<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lost N Found</title>
  
  
  <link href="https://dave0126.github.io/atom.xml" rel="self"/>
  
  <link href="https://dave0126.github.io/"/>
  <updated>2022-09-04T08:33:42.589Z</updated>
  <id>https://dave0126.github.io/</id>
  
  <author>
    <name>Guohao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>关于ObjectMonitor的底层源码分析</title>
    <link href="https://dave0126.github.io/2022/09/02/%E5%85%B3%E4%BA%8EObjectMonitor%E7%9A%84%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://dave0126.github.io/2022/09/02/%E5%85%B3%E4%BA%8EObjectMonitor%E7%9A%84%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2022-09-02T19:22:43.000Z</published>
    <updated>2022-09-04T08:33:42.589Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于-ObjectMonitor-的底层源码分析"><a href="#关于-ObjectMonitor-的底层源码分析" class="headerlink" title="关于 ObjectMonitor 的底层源码分析"></a>关于 <code>ObjectMonitor</code> 的底层源码分析</h1><p>写在前面：</p><p>本人在学习 <a href="https://dave0126.github.io/2022/03/23/JUC-Java多线程-1/#3-4-Monitor">Java 并发编程</a>时，对于 <code>synchronized</code> 关键字最底层的重量级锁 <code>Monitor</code> 的实现过程兴趣颇高，所以写下这篇文章记录学习过程。但碍于学识浅薄，文章中难免会出现错误，恳请各位读者加以指正。</p><p>文章末尾有本人根据源码分析得出的获取 <code>Monitor</code> 流程图，<a href="https://dave0126.github.io/2022/09/02/关于ObjectMonitor的底层源码分析/#附录">点击此处跳转</a>。</p><p>主要参考资料：</p><ol><li><a href="https://github.com/JetBrains/jdk8u_hotspot/blob/master/src/share/vm/runtime/objectMonitor.hpp"><code>ObjectMonitor</code> 头文件：<code>jdk8.runtime.objectMonitor.hpp</code></a></li><li><a href="https://github.com/JetBrains/jdk8u_hotspot/blob/master/src/share/vm/runtime/objectMonitor.cpp"><code>ObjectMonitor</code> 源文件：<code>jdk8.runtime.objectMonitor.cpp</code></a></li><li><a href="https://zhuanlan.zhihu.com/p/440994983?utm_id=0">知乎：深入底层源码 - 深度理解 <code>synchronized</code> 原理</a></li><li><a href="https://blog.csdn.net/sky_ccy/article/details/124124662">Java多线程-对象内置锁（<code>ObjectMonitor</code>）</a></li></ol><span id="more"></span><h3 id="Java-的对象头结构"><a href="#Java-的对象头结构" class="headerlink" title="Java 的对象头结构"></a>Java 的对象头结构</h3><p>首先我们先回顾一下关于 Java 的对象头结构。</p><p>在一个 <code>32 bits</code> 的机器中，普通对象的 Java 对象头由 <code>Mark Word</code> 和 <code>Klass Word</code> 组成，一共 <code>64 bits</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|---------------------------------------------------------|</span><br><span class="line">|               Object Header (64 bits)                   |</span><br><span class="line">|---------------------------------------------------------|</span><br><span class="line">|   Mark Word (32 bits)     |    Klass Word (32 bits)     |</span><br><span class="line">|---------------------------------------------------------|</span><br></pre></td></tr></table></figure><p>其中的 <code>Mark Word</code>（标记字）主要用来表示对象的线程锁状态，另外还可以用来配合 GC、存放该对象的<code>hashCode</code>。对于一个重量级锁，它的 <code>Mark Word</code> 是</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|---------------------------------------------------------|</span><br><span class="line">|                    Mark Word (32 bits)                  |</span><br><span class="line">|---------------------------------------------------------|</span><br><span class="line">|       ptr_to_heavyweight_monitor(30 bits)     |   1 0   |</span><br><span class="line">|---------------------------------------------------------|</span><br></pre></td></tr></table></figure><p>这个“重量级锁”指的是底层的 <code>ObjectMonitor</code> 对象，其包含着对 <code>synchronized</code> 实现”加锁“的底层操作，是整个 <code>synchronized</code> 的核心。与此同时，<code>ObjectMonitor</code> 也是 Java 基础对象 <code>Object</code> 的 <code>wait(), notify()</code> 方法的底层支持实现。</p><h3 id="ObjectMonitor-对象"><a href="#ObjectMonitor-对象" class="headerlink" title="ObjectMonitor 对象"></a><code>ObjectMonitor</code> 对象</h3><p>接下来我们开始研究  <code>ObjectMonitor</code> 对象的构造器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// initialize the monitor, exception the semaphore, all other fields</span></span><br><span class="line"><span class="comment">// are simple integers or pointers</span></span><br><span class="line">  <span class="built_in">ObjectMonitor</span>() &#123;</span><br><span class="line">    _header = <span class="literal">NULL</span>;     <span class="comment">// Mark Word </span></span><br><span class="line">    _count = <span class="number">0</span>;         <span class="comment">// 等待的线程计数，|_WaitSet| + |_EntryList|</span></span><br><span class="line">                        <span class="comment">// reference count to prevent reclaimation/deflation</span></span><br><span class="line">                        <span class="comment">// at stop-the-world time.  See deflate_idle_monitors().</span></span><br><span class="line">                        <span class="comment">// _count is approximately |_WaitSet| + |_EntryList|</span></span><br><span class="line">    _waiters = <span class="number">0</span>;       <span class="comment">// 等待线程数</span></span><br><span class="line">    _recursions = <span class="number">0</span>;    <span class="comment">// 递归；线程的重入次数: void reenter(intptr_t recursions, TRAPS);</span></span><br><span class="line">    _object = <span class="literal">NULL</span>;     <span class="comment">// 对应 synchronized (object)对应里面的object</span></span><br><span class="line">    _owner = <span class="literal">NULL</span>;      <span class="comment">// 指向拥有该 monitor 的线程。</span></span><br><span class="line">    _WaitSet = <span class="literal">NULL</span>;    <span class="comment">// 因为调用object.wait()方法而被阻塞的线程会被放在该队列中</span></span><br><span class="line">    _WaitSetLock = <span class="number">0</span> ;</span><br><span class="line">    _Responsible = <span class="literal">NULL</span>;</span><br><span class="line">    _succ = <span class="literal">NULL</span>;</span><br><span class="line">    _cxq = <span class="literal">NULL</span>;        <span class="comment">// 竞争队列，所有请求锁的线程首先会被放在这个队列中</span></span><br><span class="line">    FreeNext = <span class="literal">NULL</span>;</span><br><span class="line">    _EntryList = <span class="literal">NULL</span>;  <span class="comment">// 阻塞；第二轮竞争锁仍然没有抢到的线程</span></span><br><span class="line">                        <span class="comment">// （在exit之后扔没有竞争到的线程将有可能会被同步至此）</span></span><br><span class="line">    _SpinFreq = <span class="number">0</span>;</span><br><span class="line">    _SpinClock = <span class="number">0</span>;</span><br><span class="line">    OwnerIsThread = <span class="number">0</span>;</span><br><span class="line">    _previous_owner_tid = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这里我们需要了解以下几个成员变量的含义及作用：</p><h4 id="owner"><a href="#owner" class="headerlink" title="_owner"></a><code>_owner</code></h4><p>官方文档中对于 <code>_owner</code> 的定义如下（截取）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// * A thread acquires ownership of a monitor by successfully</span></span><br><span class="line"><span class="comment">//   CAS()ing the _owner field from null to non-null.</span></span><br></pre></td></tr></table></figure><ul><li>初始时为 <code>null</code>。当有线程占有该 <code>monitor</code> 时，<code>owner</code> 标记为该线程的唯一标识。当线程释放 <code>monitor</code>时，<code>owner</code>又恢复为 <code>null</code>。<code>owner</code> 是一个临界资源，JVM 通过 <code>CAS</code> 操作来保证其线程安全的。</li></ul><h4 id="cxq"><a href="#cxq" class="headerlink" title="_cxq"></a><code>_cxq</code></h4><p>官方文档中对于 <code>_cxq</code> 的定义如下（截取）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//   Cxq points to the the set of Recently Arrived Threads attempting entry.</span></span><br><span class="line"><span class="comment">//   Because we push threads onto _cxq with CAS, the RATs must take the form of</span></span><br><span class="line"><span class="comment">//   a singly-linked LIFO.  We drain _cxq into EntryList  at unlock-time when</span></span><br><span class="line"><span class="comment">//   the unlocking thread notices that EntryList is null but _cxq is != null.</span></span><br><span class="line"><span class="comment">// * Contending threads &quot;push&quot; themselves onto the cxq with CAS</span></span><br><span class="line"><span class="comment">//   and then spin/park.</span></span><br></pre></td></tr></table></figure><ul><li>我们可以看出，线程刚到达时，想请求锁但都没有获得锁，那么这些线程被放在 <code>_cxq</code> 队列中<strong><em><u>竞争</u></em></strong>。所以这是一个<strong><em><u>临界资源</u></em></strong>。</li><li><code>_cxq</code> 是一个后进先出 <code>LIFO</code> 的单向链表（栈），所有请求锁的最新到达线程 <code>RATs</code> 首先会被放在这个队列中，<code>_cxq</code> 是一个临界资源，JVM 通过 <code>CAS</code> 原子指令来将 <code>ObjectWaiter</code> 写入队列的头部。</li></ul><h4 id="EntryList"><a href="#EntryList" class="headerlink" title="_EntryList"></a><code>_EntryList</code></h4><p>同样的，我们截取官方文档中对于 <code>_EntryList</code> 的定义如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//   Threads blocked on entry or reentry.</span></span><br><span class="line"><span class="comment">//   The EntryList is ordered by the prevailing queue discipline and</span></span><br><span class="line"><span class="comment">//   can be organized in any convenient fashion, such as a doubly-linked list or</span></span><br><span class="line"><span class="comment">//   a circular doubly-linked list.  Critically, we want insert and delete operations</span></span><br><span class="line"><span class="comment">//   to operate in constant-time.  If we need a priority queue then something akin</span></span><br><span class="line"><span class="comment">//   to Solaris&#x27; sleepq would work nicely.  Viz.,</span></span><br><span class="line"><span class="comment">//   http://agg.eng/ws/on10_nightly/source/usr/src/uts/common/os/sleepq.c.</span></span><br><span class="line"><span class="comment">//   Queue discipline is enforced at ::exit() time, when the unlocking thread</span></span><br><span class="line"><span class="comment">//   drains the cxq into the EntryList, and orders or reorders the threads on the</span></span><br><span class="line"><span class="comment">//   EntryList accordingly.</span></span><br></pre></td></tr></table></figure><ul><li>当 <code>Monitor</code> 锁已经被一个线程获得时，其他想要获取 <code>Monitor</code> 锁的线程就需要进入 <code>EntryList</code> 阻塞等待。</li><li><p><code>EntryList</code> 中的线程对象来自 <code>_cxq</code> 和 <code>_WaitSet</code>，它们都要在 <code>EntryList</code> 中排队。这是统一获得锁的入口。</p></li><li><p><code>_EntryList</code> 是一个双向链表，当 <code>_cxq</code> 队列不为空时，<code>owener</code> 会在 <code>unlock</code> 时根据不同的策略（<code>QMode</code>），将 <code>_cxq</code> 中的数据移动到 <code>_entryList</code> 中，获取 <code>_entryList</code> 列表头部的第一个线程通过<br><code>ObjectMonitor::ExitEpilog</code> 方法唤醒该节点封装的线程，唤醒操作最终由 <code>unpark</code> 完成。</p></li></ul><blockquote><p>附 <code>QMode</code> 策略官方解释：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//   QMode:</span></span><br><span class="line"><span class="comment">//   QMode == 1 : drain cxq to EntryList, reversing order</span></span><br><span class="line"><span class="comment">//   QMode == 2 : cxq has precedence over EntryList.</span></span><br><span class="line"><span class="comment">//   QMode == 3 : Aggressively drain cxq into EntryList at the first opportunity.</span></span><br><span class="line"><span class="comment">//                This policy ensure that recently-run threads live at the head of</span></span><br><span class="line"><span class="comment">//                EntryList.</span></span><br><span class="line"><span class="comment">//   QMode == 4 : Aggressively drain cxq into EntryList at the first opportunity.</span></span><br><span class="line"><span class="comment">//                This policy ensure that recently-run threads live at the head of </span></span><br><span class="line"><span class="comment">//                EntryList.</span></span><br><span class="line"><span class="comment">//                Aggressively drain cxq into EntryList at the first opportunity.</span></span><br><span class="line"><span class="comment">//                This policy ensure that recently-run threads live at the head of</span></span><br><span class="line"><span class="comment">//                EntryList.</span></span><br></pre></td></tr></table></figure></blockquote><h4 id="WaitSet"><a href="#WaitSet" class="headerlink" title="_WaitSet"></a><code>_WaitSet</code></h4><ul><li>在得到 <code>Monitor</code> 锁后因为调用 <code>wait()</code> 方法而被挂起的线程会被放在该队列中。</li><li><code>等待时间</code>到期后唤醒或者被其他线程唤醒。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// * Waiting threads reside on the WaitSet list -- wait() puts</span></span><br><span class="line"><span class="comment">//   the caller onto the WaitSet.</span></span><br><span class="line"><span class="comment">// * notify() or notifyAll() simply transfers threads from the WaitSet to</span></span><br><span class="line"><span class="comment">//   either the EntryList or cxq.  Subsequent exit() operations will</span></span><br><span class="line"><span class="comment">//   unpark the notifyee. </span></span><br></pre></td></tr></table></figure><h3 id="ObjectWaiter-对象"><a href="#ObjectWaiter-对象" class="headerlink" title="ObjectWaiter 对象"></a><code>ObjectWaiter</code> 对象</h3><p>我们之前说过，在 <code>_cxq</code> 队列中竞争 <code>Monitor</code> 锁的线程会被封装成 <code>ObjectWaiter</code> 对象，存入 <code>EntryList</code> 等待队列中。下面是 <code>ObjectWaiter</code> 对象的构成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ObjectWaiter</span> : <span class="keyword">public</span> StackObj &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">enum</span> <span class="title class_">TStates</span> &#123; TS_UNDEF, TS_READY, TS_RUN, TS_WAIT, TS_ENTER, TS_CXQ &#125; ;</span><br><span class="line">  <span class="keyword">enum</span> <span class="title class_">Sorted</span>  &#123; PREPEND, APPEND, SORTED &#125; ;</span><br><span class="line">  ObjectWaiter * <span class="keyword">volatile</span> _next;    <span class="comment">// 指向后一个 ObjectWaiter 对象</span></span><br><span class="line">  ObjectWaiter * <span class="keyword">volatile</span> _prev;    <span class="comment">// 指向前一个</span></span><br><span class="line">  Thread*       _thread;            <span class="comment">// 当前线程</span></span><br><span class="line">  jlong         _notifier_tid;</span><br><span class="line">  ParkEvent *   _event;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">int</span>  _notified ;</span><br><span class="line">  <span class="keyword">volatile</span> TStates TState ;</span><br><span class="line">  Sorted        _Sorted ;           <span class="comment">// List placement disposition</span></span><br><span class="line">  <span class="type">bool</span>          _active ;           <span class="comment">// Contention monitoring is enabled</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由此我们可见，<code>ObjectWaiter</code> 对象是双向链表结构，保存了<code>_thread</code>（当前线程）以及当前的状态 <code>TStates</code> 等数据， 每个等待锁的线程都会被封装成 <code>ObjectWaiter</code> 对象。</p><p>下面我们介绍 <code>ObjectWaiter</code> 对象的几个核心方法：</p><h4 id="TryLock-Thread-self"><a href="#TryLock-Thread-self" class="headerlink" title="TryLock(Thread* self)"></a><code>TryLock(Thread* self)</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">ObjectMonitor::TryLock</span> <span class="params">(Thread * Self)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      <span class="type">void</span> * own = _owner ;</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 如果已经有人得到锁了, 直接返回</span></span><br><span class="line">      <span class="keyword">if</span> (own != <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span> ;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 获得锁成功</span></span><br><span class="line">      <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span> (Self, &amp;_owner, <span class="literal">NULL</span>) == <span class="literal">NULL</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 要么保证 _recursions == 0, 要么设置 _recursions = 0。</span></span><br><span class="line">         <span class="built_in">assert</span> (_recursions == <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">         <span class="built_in">assert</span> (_owner == Self, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">         <span class="keyword">return</span> <span class="number">1</span> ;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// The lock had been free momentarily, but we lost the race to the lock.</span></span><br><span class="line">      <span class="comment">// Interference -- the CAS failed.</span></span><br><span class="line">      <span class="comment">// We can either return -1 or retry.</span></span><br><span class="line">      <span class="comment">// Retry doesn&#x27;t make as much sense because the lock was just acquired.</span></span><br><span class="line">      <span class="keyword">if</span> (<span class="literal">true</span>) <span class="keyword">return</span> <span class="number">-1</span> ;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的源码我们可以分析出 <code>TryLock()</code> 方法的逻辑：</p><ul><li>首先判断当前 <code>Monitor</code> 对象是否有线程拥有 (<code>own</code>)，即 <code>owner == NULL</code>？<ul><li>如果非空，说明已经有线程拥有了该 <code>Monitor</code> 对象，则直接返回 <code>0</code>，结束；</li><li>如果为空，则当前线程尝试将 <code>_owner</code> 设置成为自己 (<code>Self</code>)，若成功直接返回 <code>1</code>，结束。</li></ul></li></ul><p>我们可以看出，对于锁的尝试获得只执行了一次，并不会多次尝试。</p><h4 id="try-enter-Thread-THREAD"><a href="#try-enter-Thread-THREAD" class="headerlink" title="try_enter(Thread* THREAD)"></a><code>try_enter(Thread* THREAD)</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">ObjectMonitor::try_enter</span><span class="params">(Thread* THREAD)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断当前线程是不是已经拥有了该 Monitor</span></span><br><span class="line">    <span class="keyword">if</span> (THREAD != _owner) &#123;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 若不是，则设置当前线程为 Monitor 的拥有者</span></span><br><span class="line">        <span class="keyword">if</span> (THREAD-&gt;<span class="built_in">is_lock_owned</span> ((address)_owner)) &#123;</span><br><span class="line">            <span class="built_in">assert</span>(_recursions == <span class="number">0</span>, <span class="string">&quot;internal state error&quot;</span>);</span><br><span class="line">            _owner = THREAD ;</span><br><span class="line">            _recursions = <span class="number">1</span> ;</span><br><span class="line">            OwnerIsThread = <span class="number">1</span> ;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查是否成功获得锁，若失败，返回false</span></span><br><span class="line">        <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span> (THREAD, &amp;_owner, <span class="literal">NULL</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      </span><br><span class="line">        <span class="comment">// 若线程已经拥有了该 Monitor，锁重入，计数 +1</span></span><br><span class="line">        _recursions++;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过上述逻辑我们可以看到：当前的线程是否已经持有了这个 <code>Monitor</code> 锁？<ul><li>如果持有，说明<strong><em><u>锁重入</u></em></strong>了，直接返回；</li><li>如果没有，则尝试持有（设置当前线程为 <code>Monitor</code> 的拥有者，在检查设置是否成功了，无论成功与否都会返回）。</li></ul></li></ul><p>我们可以看出，整个过程是只做一次尝试，不论成功失败都只执行一次。与之前的 <code>TryLock()</code> 的区别在于</p><ul><li><code>TryLock()</code> 是该 <code>Monitor</code> 对象没有 <code>_owner</code> 时尝试获得锁；</li><li><code>try_enter()</code> 是该 <code>Monitor</code> 对象已经有线程获得了，此时再次尝试获得锁。</li></ul><h3 id="enter-TRAPS"><a href="#enter-TRAPS" class="headerlink" title="enter(TRAPS)"></a><code>enter(TRAPS)</code></h3><p><code>enter()</code>方法是整个获取到锁逻辑的核心实现，核心的思想是<u>在整个链路中尽一切可能的获取到锁，如果实在获取不到情况进入等待队列进行等待</u>。整体思路如下：</p><ol><li>尝试获取获取获取锁，获取到成功直接返回。这个时刻整个等待成不是最低的;</li><li>判断自己是否已经拿到锁了，如果前面当前线程已经获取到锁了，也就直接返回。从这这里看<code>ObjectMonitor</code> 是可以重入的;</li><li>通过自旋多次尝试获取到锁的信息，如果获取到直接返回。满满的求生生欲望，避免自己加入到等待;</li><li>通过自旋转调用 <code>EnterI</code> 方法让自己加入到 <code>_cxq</code> 等待队列。一旦调用成功了整个线程就 <code>park()</code> 了，交出了执行状态等待唤醒了;</li><li>整个获取到锁之后就调用 <code>exit()</code>退出了。</li></ol><p><code>ATTR ObjectMonitor::enter(TRAPS)</code> 方法的主要源码如下（删减了一些用于断言的 <code>assert</code> 语句和对于整体运行框架联系不是十分紧密的代码）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> ATTR <span class="title">ObjectMonitor::enter</span><span class="params">(TRAPS)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 定义当前线程变量</span></span><br><span class="line">  Thread * <span class="type">const</span> Self = THREAD ;</span><br><span class="line">  <span class="type">void</span> * cur ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 1. 如果没有线程持有这个 Monitor，则将当前线程设置为持有者</span></span><br><span class="line">  cur = Atomic::<span class="built_in">cmpxchg_ptr</span> (Self, &amp;_owner, <span class="literal">NULL</span>) ;</span><br><span class="line">  <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.1 如果当前线程已经持有，则锁重入，_recursions+1</span></span><br><span class="line">  <span class="keyword">if</span> (cur == Self) &#123;</span><br><span class="line">     _recursions ++ ;</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.2 判断当前线程是否是 Monitor 的持有者</span></span><br><span class="line">  <span class="keyword">if</span> (Self-&gt;<span class="built_in">is_lock_owned</span> ((address)cur)) &#123;</span><br><span class="line">    _recursions = <span class="number">1</span> ;</span><br><span class="line">    _owner = Self ;</span><br><span class="line">    OwnerIsThread = <span class="number">1</span> ;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Self-&gt;_Stalled = <span class="built_in">intptr_t</span>(<span class="keyword">this</span>) ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.1 如果允许自旋，那么通过自旋来获取锁的信息</span></span><br><span class="line">  <span class="keyword">if</span> (Knob_SpinEarly &amp;&amp; <span class="built_in">TrySpin</span> (Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="built_in">assert</span> (((oop)(<span class="built_in">object</span>()))-&gt;<span class="built_in">mark</span>() == markOopDesc::<span class="built_in">encode</span>(<span class="keyword">this</span>), <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     Self-&gt;_Stalled = <span class="number">0</span> ;</span><br><span class="line">     <span class="keyword">return</span> ;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.2 如果前面的尝试都失败了，那么就开始正式进入等待队列 EntrtList 了</span></span><br><span class="line">  JavaThread * jt = (JavaThread *) Self ;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3.3 增加等待的线程计数 _count+1</span></span><br><span class="line">  Atomic::<span class="built_in">inc_ptr</span>(&amp;_count);</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">// 4.1 自旋进入到等待队列中</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">      jt-&gt;<span class="built_in">set_suspend_equivalent</span>();</span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 4.2 【重点】加入到等待队列</span></span><br><span class="line">      <span class="built_in">EnterI</span> (THREAD) ;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="built_in">ExitSuspendEquivalent</span>(jt)) <span class="keyword">break</span> ;</span><br><span class="line">      _recursions = <span class="number">0</span> ;</span><br><span class="line">      _succ = <span class="literal">NULL</span> ;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 5.1 退出机制</span></span><br><span class="line">      <span class="built_in">exit</span> (<span class="literal">false</span>, Self) ;</span><br><span class="line">      jt-&gt;<span class="built_in">java_suspend_self</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    Self-&gt;<span class="built_in">set_current_pending_monitor</span>(<span class="literal">NULL</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 5.2 减少等待计数 _count-1</span></span><br><span class="line">  Atomic::<span class="built_in">dec_ptr</span>(&amp;_count);</span><br><span class="line">  <span class="built_in">assert</span> (_count &gt;= <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  Self-&gt;_Stalled = <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="EnterI-TRAPS"><a href="#EnterI-TRAPS" class="headerlink" title="EnterI(TRAPS)"></a><code>EnterI(TRAPS)</code></h3><p><code>EnterI</code> 是整个进入等待队列的核心实现，核心的思想是<u>在尽最后可能的获取到锁，如果实在不行加入到 <code>_cxq</code> 的等待队列，加入队列成功后将当前线程挂起</u>。</p><p>整体思路如下：</p><ol><li>尝试通过 <code>TryLock</code>() 尝试获取下锁对象。</li><li>尝试通过自旋锁 <code>TrySpin()</code> 来获取锁的信息，这也是最后一次尝试了。实在不行就只能等待了。</li><li>构造等待节点对象，开始进行等待。</li><li>将当前线程的等待对象加入到能对队列. <code>_cxq</code> 排队队列中来</li><li>每个执行的循环周期都会经历尝试获取锁，获取不到将自己挂起 <code>park()</code> 的过程。中间有个小插曲尝试将自己设置成整个对象的维护线程（<code>_Responsiblew</code>），是防止获取锁的所有线程都进入了等待队列，没有人能通知其他线程进行拿锁的操作。</li></ol><p><code>ATTR ObjectMonitor::EnterI(TRAPS)</code> 方法的主要源码如下（删减了一些用于断言的 <code>assert</code> 语句和对于整体运行框架联系不是十分紧密的代码）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> ATTR <span class="title">ObjectMonitor::EnterI</span> <span class="params">(TRAPS)</span> </span>&#123;</span><br><span class="line">    Thread * Self = THREAD ;</span><br><span class="line">    <span class="comment">// 1 尝试获取当前的锁对象</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">TryLock</span> (Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">DeferredInitialize</span> () ;</span><br><span class="line">    <span class="comment">// 2 尝试通过自旋获取到锁的信息</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">TrySpin</span> (Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">     <span class="comment">// 3 构造一个 ObjectWaiter对象 也就是等待对象</span></span><br><span class="line">    <span class="function">ObjectWaiter <span class="title">node</span><span class="params">(Self)</span> </span>;</span><br><span class="line">    Self-&gt;_ParkEvent-&gt;<span class="built_in">reset</span>() ;</span><br><span class="line">    node._prev   = (ObjectWaiter *) <span class="number">0xBAD</span> ;</span><br><span class="line">    node.TState  = ObjectWaiter::TS_CXQ ;</span><br><span class="line">  </span><br><span class="line">    <span class="comment">// 4.1 加入到能对队列_cxq中来</span></span><br><span class="line">    ObjectWaiter * nxt ;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        node._next = nxt = _cxq ;</span><br><span class="line">        <span class="comment">// 4.2 添加完成直接返回</span></span><br><span class="line">        <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span> (&amp;node, &amp;_cxq, nxt) == nxt) <span class="keyword">break</span> ;</span><br><span class="line">        <span class="comment">// 4.3 顺便捎带加入下锁 看看是否成功</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">TryLock</span> (Self) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4.4 如果没有其他线程 将当前线程设置成负责线程 以方便后面对象回收</span></span><br><span class="line">    <span class="keyword">if</span> ((SyncFlags &amp; <span class="number">16</span>) == <span class="number">0</span> &amp;&amp; nxt == <span class="literal">NULL</span> &amp;&amp; _EntryList == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        Atomic::<span class="built_in">cmpxchg_ptr</span> (Self, &amp;_Responsible, <span class="literal">NULL</span>) ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> nWakeups = <span class="number">0</span> ;</span><br><span class="line">    <span class="type">int</span> RecheckInterval = <span class="number">1</span> ;</span><br><span class="line">    <span class="comment">// 5.1 循环进入等待和唤醒的情况，这个代码需要仔细研读</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 5.2 尝试加个锁看看是否有运气</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">TryLock</span> (Self) &gt; <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">        <span class="keyword">if</span> ((SyncFlags &amp; <span class="number">2</span>) &amp;&amp; _Responsible == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            Atomic::<span class="built_in">cmpxchg_ptr</span> (Self, &amp;_Responsible, <span class="literal">NULL</span>) ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.3 防止所有的线程都进入死等的情况，这样就会出现线程死锁</span></span><br><span class="line">        <span class="keyword">if</span> (_Responsible == Self || (SyncFlags &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">            <span class="comment">// 5.4 过一段时间就起来看看 </span></span><br><span class="line">            Self-&gt;_ParkEvent-&gt;<span class="built_in">park</span> ((jlong) RecheckInterval) ;</span><br><span class="line">            RecheckInterval *= <span class="number">8</span> ;</span><br><span class="line">            <span class="keyword">if</span> (RecheckInterval &gt; <span class="number">1000</span>) RecheckInterval = <span class="number">1000</span> ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Self-&gt;_ParkEvent-&gt;<span class="built_in">park</span>() ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 5.5 尝试加个锁看看是否有运气</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">TryLock</span>(Self) &gt; <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">        ++ nWakeups ;</span><br><span class="line">        <span class="comment">// 5.6 自旋试下 是否成功</span></span><br><span class="line">        <span class="keyword">if</span> ((Knob_SpinAfterFutile &amp; <span class="number">1</span>) &amp;&amp; <span class="built_in">TrySpin</span> (Self) &gt; <span class="number">0</span>) <span class="keyword">break</span> ;</span><br><span class="line">        <span class="keyword">if</span> ((Knob_ResetEvent &amp; <span class="number">1</span>) &amp;&amp; Self-&gt;_ParkEvent-&gt;<span class="built_in">fired</span>()) &#123;</span><br><span class="line">            Self-&gt;_ParkEvent-&gt;<span class="built_in">reset</span>() ;</span><br><span class="line">            OrderAccess::<span class="built_in">fence</span>() ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (_succ == Self) _succ = <span class="literal">NULL</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 6 已经获取到了锁，讲当前节点从等待队列中解除</span></span><br><span class="line">    <span class="built_in">UnlinkAfterAcquire</span> (Self, &amp;node) ;</span><br><span class="line">    <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="exit-bool-not-suspended-TRAPS"><a href="#exit-bool-not-suspended-TRAPS" class="headerlink" title="exit(bool not_suspended, TRAPS)"></a><code>exit(bool not_suspended, TRAPS)</code></h3><p>线程执行同步方法或代码块结束之后，会调用 <code>exit()</code> 方法将当前线程从锁对象中移除，并尝试唤醒启动的线程来获取锁的过程。核心要点有两个，</p><ul><li>一个是将当前线程释放，这个很好理解就把  <code>_owner</code> 字段中线程值设为空就好了。</li><li>另一个是唤醒其他线程，这个就涉及到相关的策略，因为前面他有一个排队队列 <code>_cxq</code>，还有一个 <code>_EntryList</code>，到底从哪里优先去取。提供了四种策略：</li></ul><div class="table-container"><table><thead><tr><th><code>QMode</code></th><th>文字说明</th></tr></thead><tbody><tr><td><code>QMode == 1</code></td><td>先反转 <code>_cxq</code> 队列，再唤醒栈顶（原栈底）元素唤醒，忽略 <code>_EntryList</code> 中的数据</td></tr><tr><td><code>QMode == 2</code></td><td>优先从 <code>_cxq</code> 栈顶唤醒，忽略 <code>_EntryList</code> 中的数据</td></tr><tr><td><code>QMode == 3</code></td><td><code>_cxq</code> 中的数据加入到 <code>_EntryList</code>【尾部】中来 然后从 <code>_EntryList</code> 开始获取</td></tr><tr><td><code>QMode == 4</code></td><td><code>_cxq</code> 中的数据加入到<code>_EntryList</code>【首部】来 然后从 <code>_EntryList</code> 开始获取</td></tr></tbody></table></div><p><code>ATTR ObjectMonitor::exit(bool not_suspended, TRAPS)</code> 方法的主要源码如下（删减了一些用于断言的 <code>assert</code> 语句和对于整体运行框架联系不是十分紧密的代码）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> ATTR <span class="title">ObjectMonitor::exit</span><span class="params">(<span class="type">bool</span> not_suspended, TRAPS)</span> </span>&#123;</span><br><span class="line">   Thread * Self = THREAD ;</span><br><span class="line">   <span class="comment">//1判断当前线程是否是锁的线程</span></span><br><span class="line">   <span class="keyword">if</span> (THREAD != _owner) &#123;</span><br><span class="line">        <span class="keyword">if</span> (THREAD-&gt;<span class="built_in">is_lock_owned</span>((address) _owner)) &#123;</span><br><span class="line">            _owner = THREAD ;</span><br><span class="line">            _recursions = <span class="number">0</span> ;</span><br><span class="line">            OwnerIsThread = <span class="number">1</span> ;</span><br><span class="line">        &#125; </span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">//重入锁的次数减1</span></span><br><span class="line">   <span class="keyword">if</span> (_recursions != <span class="number">0</span>) &#123;</span><br><span class="line">        _recursions--;        <span class="comment">// this is simple recursive enter</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// Invariant: after setting Responsible=null an thread must execute</span></span><br><span class="line">   <span class="comment">// a MEMBAR or other serializing instruction before fetching EntryList|cxq.</span></span><br><span class="line">   <span class="keyword">if</span> ((SyncFlags &amp; <span class="number">4</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        _Responsible = <span class="literal">NULL</span> ;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (Knob_ExitPolicy == <span class="number">0</span>) &#123;</span><br><span class="line">            OrderAccess::<span class="built_in">release_store_ptr</span> (&amp;_owner, <span class="literal">NULL</span>) ;   <span class="comment">// drop the lock</span></span><br><span class="line">            OrderAccess::<span class="built_in">storeload</span>() ;  </span><br><span class="line">            <span class="comment">//没有人需要获取锁了直接返回</span></span><br><span class="line">            <span class="keyword">if</span> ((<span class="built_in">intptr_t</span>(_EntryList)|<span class="built_in">intptr_t</span>(_cxq)) == <span class="number">0</span> || _succ != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//当锁已经被其他线程抢占了 直接推出就好了</span></span><br><span class="line">            <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span> (THREAD, &amp;_owner, <span class="literal">NULL</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> ;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((<span class="built_in">intptr_t</span>(_EntryList)|<span class="built_in">intptr_t</span>(_cxq)) == <span class="number">0</span> || _succ != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                OrderAccess::<span class="built_in">release_store_ptr</span> (&amp;_owner, <span class="literal">NULL</span>) ;   <span class="comment">// drop the lock</span></span><br><span class="line">                OrderAccess::<span class="built_in">storeload</span>() ;</span><br><span class="line">                <span class="keyword">if</span> (_cxq == <span class="literal">NULL</span> || _succ != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (Atomic::<span class="built_in">cmpxchg_ptr</span> (THREAD, &amp;_owner, <span class="literal">NULL</span>) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">     </span><br><span class="line">     ObjectWaiter * w = <span class="literal">NULL</span> ;</span><br><span class="line">     <span class="type">int</span> QMode = Knob_QMode ;</span><br><span class="line">    </span><br><span class="line">     <span class="comment">//当QMode=2的时候 优先从_cxq唤醒</span></span><br><span class="line">     <span class="keyword">if</span> (QMode == <span class="number">2</span> &amp;&amp; _cxq != <span class="literal">NULL</span>) &#123;</span><br><span class="line">         w = _cxq ;</span><br><span class="line">         <span class="built_in">assert</span> (w != <span class="literal">NULL</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">         <span class="built_in">assert</span> (w-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">         <span class="built_in">ExitEpilog</span> (Self, w) ;</span><br><span class="line">         <span class="keyword">return</span> ;</span><br><span class="line">     &#125;</span><br><span class="line">       <span class="comment">//当QMode=3的时候 讲_cxq中的数据加入到_EntryList尾部中来 然后从_EntryList开始获取</span></span><br><span class="line">     <span class="keyword">if</span> (QMode == <span class="number">3</span> &amp;&amp; _cxq != <span class="literal">NULL</span>) &#123;</span><br><span class="line">         w = _cxq ;</span><br><span class="line">         <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            ObjectWaiter * u = (ObjectWaiter *) Atomic::<span class="built_in">cmpxchg_ptr</span> (<span class="literal">NULL</span>, &amp;_cxq, w) ;</span><br><span class="line">            <span class="keyword">if</span> (u == w) <span class="keyword">break</span> ;</span><br><span class="line">            w = u ;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="built_in">assert</span> (w != <span class="literal">NULL</span>              , <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">    </span><br><span class="line">         ObjectWaiter * q = <span class="literal">NULL</span> ;</span><br><span class="line">         ObjectWaiter * p ;</span><br><span class="line">         <span class="keyword">for</span> (p = w ; p != <span class="literal">NULL</span> ; p = p-&gt;_next) &#123;</span><br><span class="line">             <span class="built_in">guarantee</span> (p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">             p-&gt;TState = ObjectWaiter::TS_ENTER ;</span><br><span class="line">             p-&gt;_prev = q ;</span><br><span class="line">             q = p ;</span><br><span class="line">         &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="comment">//讲_cxq数据加入到_EntryList的队列中来</span></span><br><span class="line">         ObjectWaiter * Tail ;</span><br><span class="line">         <span class="keyword">for</span> (Tail = _EntryList ; Tail != <span class="literal">NULL</span> &amp;&amp; Tail-&gt;_next != <span class="literal">NULL</span> ; Tail = Tail-&gt;_next) ;</span><br><span class="line">         <span class="keyword">if</span> (Tail == <span class="literal">NULL</span>) &#123;</span><br><span class="line">             _EntryList = w ;</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             Tail-&gt;_next = w ;</span><br><span class="line">             w-&gt;_prev = Tail ;</span><br><span class="line">         &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当QMode=4的时候 讲_cxq中的数据加入到_EntryList前面来 然后从_EntryList开始获取</span></span><br><span class="line">        <span class="keyword">if</span> (QMode == <span class="number">4</span> &amp;&amp; _cxq != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            w = _cxq ;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">               <span class="built_in">assert</span> (w != <span class="literal">NULL</span>, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">               ObjectWaiter * u = (ObjectWaiter *) Atomic::<span class="built_in">cmpxchg_ptr</span> (<span class="literal">NULL</span>, &amp;_cxq, w) ;</span><br><span class="line">               <span class="keyword">if</span> (u == w) <span class="keyword">break</span> ;</span><br><span class="line">               w = u ;</span><br><span class="line">            &#125;</span><br><span class="line">       </span><br><span class="line">            <span class="comment">//批量修改状态标志改成TS_ENTER</span></span><br><span class="line">            ObjectWaiter * q = <span class="literal">NULL</span> ;</span><br><span class="line">            ObjectWaiter * p ;</span><br><span class="line">            <span class="keyword">for</span> (p = w ; p != <span class="literal">NULL</span> ; p = p-&gt;_next) &#123;</span><br><span class="line">                p-&gt;TState = ObjectWaiter::TS_ENTER ;</span><br><span class="line">                p-&gt;_prev = q ;</span><br><span class="line">                q = p ;</span><br><span class="line">            &#125;</span><br><span class="line">       </span><br><span class="line">            <span class="comment">//插到原有的_EntryList前面 从员_EntryList中获取</span></span><br><span class="line">            <span class="keyword">if</span> (_EntryList != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                q-&gt;_next = _EntryList ;</span><br><span class="line">                _EntryList-&gt;_prev = q ;</span><br><span class="line">            &#125;</span><br><span class="line">            _EntryList = w ;</span><br><span class="line">       </span><br><span class="line">            <span class="comment">// Fall thru into code that tries to wake a successor from EntryList</span></span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        w = _EntryList  ;</span><br><span class="line">        <span class="keyword">if</span> (w != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">assert</span> (w-&gt;TState == ObjectWaiter::TS_ENTER, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">            <span class="built_in">ExitEpilog</span> (Self, w) ;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">// If we find that both _cxq and EntryList are null then just</span></span><br><span class="line">        <span class="comment">// re-run the exit protocol from the top.</span></span><br><span class="line">        w = _cxq ;</span><br><span class="line">        <span class="keyword">if</span> (w == <span class="literal">NULL</span>) <span class="keyword">continue</span> ;</span><br><span class="line">       </span><br><span class="line">        <span class="comment">//默认的策略</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="built_in">assert</span> (w != <span class="literal">NULL</span>, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">            ObjectWaiter * u = (ObjectWaiter *) Atomic::<span class="built_in">cmpxchg_ptr</span> (<span class="literal">NULL</span>, &amp;_cxq, w) ;</span><br><span class="line">            <span class="keyword">if</span> (u == w) <span class="keyword">break</span> ;</span><br><span class="line">            w = u ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将cxq排队队列进行翻转。</span></span><br><span class="line">        <span class="keyword">if</span> (QMode == <span class="number">1</span>) &#123;</span><br><span class="line">           <span class="comment">// QMode == 1 : drain cxq to EntryList, reversing order</span></span><br><span class="line">           <span class="comment">// We also reverse the order of the list.</span></span><br><span class="line">           ObjectWaiter * s = <span class="literal">NULL</span> ;</span><br><span class="line">           ObjectWaiter * t = w ;</span><br><span class="line">           ObjectWaiter * u = <span class="literal">NULL</span> ;</span><br><span class="line">           <span class="keyword">while</span> (t != <span class="literal">NULL</span>) &#123;</span><br><span class="line">               <span class="built_in">guarantee</span> (t-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">               t-&gt;TState = ObjectWaiter::TS_ENTER ;</span><br><span class="line">               u = t-&gt;_next ;</span><br><span class="line">               t-&gt;_prev = u ;</span><br><span class="line">               t-&gt;_next = s ;</span><br><span class="line">               s = t;</span><br><span class="line">               t = u ;</span><br><span class="line">           &#125;</span><br><span class="line">           _EntryList  = s ;</span><br><span class="line">           <span class="built_in">assert</span> (s != <span class="literal">NULL</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// QMode == 0 or QMode == 2</span></span><br><span class="line">           _EntryList = w ;</span><br><span class="line">           ObjectWaiter * q = <span class="literal">NULL</span> ;</span><br><span class="line">           ObjectWaiter * p ;</span><br><span class="line">           <span class="keyword">for</span> (p = w ; p != <span class="literal">NULL</span> ; p = p-&gt;_next) &#123;</span><br><span class="line">               <span class="built_in">guarantee</span> (p-&gt;TState == ObjectWaiter::TS_CXQ, <span class="string">&quot;Invariant&quot;</span>) ;</span><br><span class="line">               p-&gt;TState = ObjectWaiter::TS_ENTER ;</span><br><span class="line">               p-&gt;_prev = q ;</span><br><span class="line">               q = p ;</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (_succ != <span class="literal">NULL</span>) <span class="keyword">continue</span>;</span><br><span class="line">       </span><br><span class="line">        w = _EntryList  ;</span><br><span class="line">        <span class="keyword">if</span> (w != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="built_in">guarantee</span> (w-&gt;TState == ObjectWaiter::TS_ENTER, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">            <span class="built_in">ExitEpilog</span> (Self, w) ;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​     </p><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><h4 id="enter-、EnterI-与-exit-流程图示"><a href="#enter-、EnterI-与-exit-流程图示" class="headerlink" title="enter()、EnterI() 与 exit() 流程图示"></a><code>enter()</code>、<code>EnterI()</code> 与 <code>exit()</code> 流程图示</h4><p><img src="/2022/09/02/%E5%85%B3%E4%BA%8EObjectMonitor%E7%9A%84%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/objectmonitor_1.png" alt="objectmonitor_1"></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;关于-ObjectMonitor-的底层源码分析&quot;&gt;&lt;a href=&quot;#关于-ObjectMonitor-的底层源码分析&quot; class=&quot;headerlink&quot; title=&quot;关于 ObjectMonitor 的底层源码分析&quot;&gt;&lt;/a&gt;关于 &lt;code&gt;ObjectMonitor&lt;/code&gt; 的底层源码分析&lt;/h1&gt;&lt;p&gt;写在前面：&lt;/p&gt;
&lt;p&gt;本人在学习 &lt;a href=&quot;https://dave0126.github.io/2022/03/23/JUC-Java多线程-1/#3-4-Monitor&quot;&gt;Java 并发编程&lt;/a&gt;时，对于 &lt;code&gt;synchronized&lt;/code&gt; 关键字最底层的重量级锁 &lt;code&gt;Monitor&lt;/code&gt; 的实现过程兴趣颇高，所以写下这篇文章记录学习过程。但碍于学识浅薄，文章中难免会出现错误，恳请各位读者加以指正。&lt;/p&gt;
&lt;p&gt;文章末尾有本人根据源码分析得出的获取 &lt;code&gt;Monitor&lt;/code&gt; 流程图，&lt;a href=&quot;https://dave0126.github.io/2022/09/02/关于ObjectMonitor的底层源码分析/#附录&quot;&gt;点击此处跳转&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;主要参考资料：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/JetBrains/jdk8u_hotspot/blob/master/src/share/vm/runtime/objectMonitor.hpp&quot;&gt;&lt;code&gt;ObjectMonitor&lt;/code&gt; 头文件：&lt;code&gt;jdk8.runtime.objectMonitor.hpp&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://github.com/JetBrains/jdk8u_hotspot/blob/master/src/share/vm/runtime/objectMonitor.cpp&quot;&gt;&lt;code&gt;ObjectMonitor&lt;/code&gt; 源文件：&lt;code&gt;jdk8.runtime.objectMonitor.cpp&lt;/code&gt;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/440994983?utm_id=0&quot;&gt;知乎：深入底层源码 - 深度理解 &lt;code&gt;synchronized&lt;/code&gt; 原理&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/sky_ccy/article/details/124124662&quot;&gt;Java多线程-对象内置锁（&lt;code&gt;ObjectMonitor&lt;/code&gt;）&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Java" scheme="https://dave0126.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://dave0126.github.io/tags/Java/"/>
    
    <category term="JUC" scheme="https://dave0126.github.io/tags/JUC/"/>
    
    <category term="sychronized" scheme="https://dave0126.github.io/tags/sychronized/"/>
    
  </entry>
  
  <entry>
    <title>JMM - Java 内存模型</title>
    <link href="https://dave0126.github.io/2022/08/26/JMM-Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>https://dave0126.github.io/2022/08/26/JMM-Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</id>
    <published>2022-08-26T08:28:21.000Z</published>
    <updated>2022-08-26T16:59:49.064Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JMM-Java-内存模型"><a href="#JMM-Java-内存模型" class="headerlink" title="JMM - Java 内存模型"></a>JMM - Java 内存模型</h1><p>首先，我们应该区分【JVM 内存结构】和【JMM 内存模型】的区别。我们常说的 【JVM 内存结构】指的是JVM 的内存分区；而 【JMM 内存模型】是一种虚拟机规范。</p><p>简单的说，JMM 定义了一套在<strong><em><u>多线程</u></em></strong>读写共享数据时（成员变量、数组）时，对数据的可见性、有序性和原子性的规则和保障。</p><span id="more"></span><h3 id="0-Java-内存模型"><a href="#0-Java-内存模型" class="headerlink" title="0 Java 内存模型"></a>0 Java 内存模型</h3><p>Java 虚拟机规范中定义了 Java 内存模型（Java Memory Model，JMM），用于屏蔽掉各种硬件和操作系统的内存访问差异，以实现让 Java程序在各种平台下都能达到一致的<strong><em><u>并发</u></em></strong>效果，JMM 规范了 Java 虚拟机与计算机内存是如何协同工作的：规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。</p><p>JMM 体现在以下几个方面</p><ul><li><a href="#1-原子性">原子性</a> - 保证指令不会受到线程上下文切换的影响</li><li><a href="#2-可见性">可见性</a> - 保证指令不会受 CPU 缓存的影响</li><li>有序性 - 保证指令不会受 CPU 指令并行优化的影响</li></ul><h3 id="1-原子性"><a href="#1-原子性" class="headerlink" title="1 原子性"></a>1 原子性</h3><blockquote><p>【问题】</p><p>两个线程对初始值为 0 的静态变量一个做自增，一个做自减，各做 5000 次，结果是 0 吗？</p></blockquote><p>以上的结果可能是正数、负数、零。为什么呢？</p><p>因为 Java 中对静态变量的自增，自减并不是原子操作。例如对于 <code>i++</code> 而言 （i为静态变量），实际会产生如下的 JVM 字节码指令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getstatic// 获取静态变量i的值</span><br><span class="line">iconst 1// 准备常量1</span><br><span class="line">iadd// 自增</span><br><span class="line">putstatic// 将修改后的值存入静态变量i</span><br></pre></td></tr></table></figure><p>而对应 <code>i--</code> 也是类似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">getstatic// 获取静态变量i的值</span><br><span class="line">iconst 1// 准备常量1</span><br><span class="line">isub// 自减</span><br><span class="line">putstatic// 将修改后的值存入静态变量i</span><br></pre></td></tr></table></figure><p>而 Java 的内存模型如下，完成静态变量的自增、自减都需要在<u>主存</u>和<u>线程内存</u>中进行数据交换</p><p><img src="/2022/08/26/JMM-Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20220826105509541.png" alt="image-20220826105509541" style="zoom:50%;"></p><p>在并发的环境下，自增和自减的字节码指令可能会交错运行，无法保证自增和自减操作的原子性。所以可能无法得到我们想要的正确结果。</p><h3 id="2-可见性"><a href="#2-可见性" class="headerlink" title="2 可见性"></a>2 可见性</h3><p>先来看一个现象，<code>main</code> 线程对 <code>run</code> 变量的修改对于 <code>thread</code> 线程不可见，导致了 <code>thread</code>线程无法停止</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.Thread.sleep;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoJMM1</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">run</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span>(run)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;thread STOPPED&quot;</span>);</span><br><span class="line">        run = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【分析】</p><ol><li><p>初始状态， <code>thread</code> 线程刚开始从主存中读取到了 <code>run</code> 的值到工作内存。</p><p><img src="/2022/08/26/JMM-Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20220826112040399.png" alt="image-20220826112040399" style="zoom:50%;"></p></li><li><p>因为 <code>thread</code> 线程要频繁的从主存读取 <code>run</code> 的值，JIT 编译器会对这种”热点代码”做出优化（<a href="https://dave0126.github.io/2022/03/22/JVM-1/#6-1-即时编译">详见 JVM 篇</a>），会将 <code>run</code> 的值缓存到自己线程内存的栈中，减少对主存中 <code>run</code> 的访问，提高效率。</p><p><img src="/2022/08/26/JMM-Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20220826113253480.png" alt="image-20220826113253480" style="zoom:50%;"></p></li><li><p>1 秒之后，<code>main</code> 线程修改了 <code>run</code> 的值，并同步至主存，而 <code>thread</code> 是从自己工作内存中的高速缓存中读取这个变量的值，结果永远是旧值。</p><p><img src="/2022/08/26/JMM-Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20220826113629008.png" alt="image-20220826113629008" style="zoom:50%;"></p></li></ol><p>那么如何解决呢？</p><ul><li>我们可以在共享的变量前添加一个修饰符 <code>volatile</code>，被它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。遇到这个关键字声明的变量，<u>编译器对访问该变量的代码就不再进行优化，对主存直接操作</u>，从而可以提供对特殊地址的稳定访问。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">run</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure><ul><li>我们也可以使用 <code>synchronized</code> 锁对象实现。因为<u>在 <code>synchronized</code> 对对象加锁时，会先清空工作内存，再从主存中拷贝共享变量的最新副本到工作内存；执行完代码后，会讲修改后的共享变量的值更新到主存中，最后释放锁。</u></li></ul><p>所以，修饰符 <code>volatile</code> 和 <code>synchronized</code> 都可以保证共享变量的可见性。但是 <code>synchronized</code> 更重。</p><h4 id="可见性-vs-原子性"><a href="#可见性-vs-原子性" class="headerlink" title="可见性 vs 原子性"></a>可见性 vs 原子性</h4><p>前面例子体现的实际就是可见性，它保证的是在多个线程之间，一个线程对 <code>volatile</code> 变量的修改对另一个线程可见，不能保证原子性，仅用在一个写线程，多个读线程的情况。例如，<code>flag</code> 标记等 </p><p>原子性的核心是保证代码的顺序执行且不可拆分，而可见性保证的是共享变量在不同线程的可见性（最新值）。</p><p>而 <code>synchronized</code> 既可以保证代码块的完整性，也可以保证代码块内部共享变量的可见性。但是该操作更加重量级，性能相对更低。</p><h4 id="终止模式：两阶段终止模式"><a href="#终止模式：两阶段终止模式" class="headerlink" title="终止模式：两阶段终止模式"></a>终止模式：两阶段终止模式</h4><p>在一个线程 <code>t1</code> 中如何 “优雅” 终止线程 <code>t2</code>？ 这里的【优雅】指的是给 T2一个“料理后事”（中断处理等）的机会。</p><h5 id="错误思路"><a href="#错误思路" class="headerlink" title="错误思路"></a>错误思路</h5><ul><li>使用线程对象的 <code>stop()</code> 方法停止线程<ul><li><code>stop()</code> 方法会真正杀死线程，如果这时线程锁住了共享资源，那么当它被杀死后就再也没有机会释放锁，其它线程将永远无法获取锁</li></ul></li><li>使用 <code>System.exit(int)</code> 方法停止线程<ul><li>目的仅是停止一个线程，但这种做法会让整个程序都停止。</li></ul></li></ul><h5 id="使用-interrupt-方法："><a href="#使用-interrupt-方法：" class="headerlink" title="使用 interrupt() 方法："></a>使用 <code>interrupt()</code> 方法：</h5><pre class="mermaid">graph TDA["while(true)"]B{是否被打断?}C[料理后事]D[睡眠2s]E(结束循环)F[执行监控记录]G[设置打断标记]A --> BB --yes--> CB --no--> DC --> ED --无异常--> FD --有异常--> GF --> AG --> A</pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  两阶段终止模式（Two Phase Termination）：在进程T1中终止进程T2</span></span><br><span class="line"><span class="comment">    在终止进程T2之前让T2释放锁和临界资源</span></span><br><span class="line"><span class="comment">    不用stop() 和 System.exit()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TwoPhaseTermination</span> &#123;</span><br><span class="line">    <span class="comment">// 监控线程</span></span><br><span class="line">    privite Thread monitor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动监控线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        monitor = <span class="keyword">new</span> <span class="title class_">Thread</span> (() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                <span class="keyword">if</span> (current.isInterrupted()) &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    TODO 释放锁和临界资源</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;释放锁和临界资源&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>); <span class="comment">// 情况1</span></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                        TODO 正常功能的代码块</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="comment">// 情况2</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="comment">// 若sleep时被打断，会捕获错误e，此时的isInterrupted标记为false，程序会重复执行。所以有以下操作</span></span><br><span class="line">                    current.interrupt(); <span class="comment">// 重新设置isInterrupted打断标记, true -&gt; false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        monitor.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止监控线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        monitor.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="使用-volatile-标记代替-interrupted"><a href="#使用-volatile-标记代替-interrupted" class="headerlink" title="使用 volatile 标记代替 interrupted()"></a>使用 <code>volatile</code> 标记代替 <code>interrupted()</code></h5><pre class="mermaid">graph TDA["while(true)"]B{"if(STOP)"}C[料理后事]D[睡眠2s]E(结束循环)F[执行监控记录]G[设置打断标记]A --> BB --yes--> CB --no--> DC --> ED --无异常--> FD --有异常--> GF --> AG --> A</pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">TwoPhaseTermination_Volatile</span> &#123;</span><br><span class="line">    <span class="comment">// 监控线程</span></span><br><span class="line">    privite Thread monitor;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="type">boolean</span> STOP;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动监控线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        monitor = <span class="keyword">new</span> <span class="title class_">Thread</span> (() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                <span class="keyword">if</span> (STOP) &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    TODO 释放锁和临界资源</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;释放锁和临界资源&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>); <span class="comment">// 只能等待 sleep 结束 </span></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                        TODO 正常功能的代码块</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    current.interrupt(); </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        monitor.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止监控线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        STOP = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="终止模式：Balking-犹豫模式"><a href="#终止模式：Balking-犹豫模式" class="headerlink" title="终止模式：Balking 犹豫模式"></a>终止模式：Balking 犹豫模式</h4><p>在上述的例子中，我们使用监控线程，来监控内存的使用等信息，但是这样的监控线程只需要一个就够了。但是在上面的例子里并没有对于监控线程数量的限制。我们可以继续对其改造。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoJMMBalking</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="type">Balking</span> <span class="variable">balking</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Balking</span>();</span><br><span class="line">     balking.start();</span><br><span class="line">     balking.start();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Balking</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Thread monitor;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">boolean</span> <span class="variable">STARTING</span> <span class="operator">=</span> <span class="literal">false</span>; <span class="comment">// 检查是否执行的标记</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (STARTING) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    STARTING = <span class="literal">true</span>;</span><br><span class="line">    monitor = <span class="keyword">new</span> <span class="title class_">Tread</span>(() -&gt;&#123;</span><br><span class="line">      <span class="comment">// TODO</span></span><br><span class="line">    &#125;);</span><br><span class="line">    monitor.start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在并发的情况下，该程序并不能保证正确运行。因为不能保证其的原子性，因此需要加锁。也可以使用“双标志检查法”。</p><h3 id="3-有序性"><a href="#3-有序性" class="headerlink" title="3 有序性"></a>3 有序性</h3><p>JVM 会在不影响程序正确性的前提下，调整语句的执行顺序。思考以下代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> i;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> j;</span><br><span class="line">i = <span class="number">0</span>;</span><br><span class="line">j = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>我们可以看到，先执行 <code>i</code> 还是 <code>j</code> 并不影响程序的结果。所以在上述代码执行的过程中，既可以</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">j = <span class="number">1</span>;</span><br><span class="line">i = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>也可以是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span>;</span><br><span class="line">j = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>这种特性我们称之为<strong><em><u>指令重排</u></em></strong>，但是在<u>多线程环境</u>下指令重排会<u>影响程序的正确性</u>。</p><p>如何理解这种优化呢？</p><h4 id="指令重排列优化"><a href="#指令重排列优化" class="headerlink" title="指令重排列优化"></a>指令重排列优化</h4><p>我们从 CPU 的角度理解这个问题。事实上，CPU 在会一个时钟周期 T 内执行一条指令。我们可以把一条指令再划分为五个更小的阶段：</p><p><em>取指令 (<strong>I</strong>nstruction <strong>F</strong>etch) - 指令译码 (<strong>I</strong>nstruction <strong>D</strong>ecode) - 执行指令 (<strong>EX</strong>ecute) - 内存访问 (<strong>MEM</strong>ory access) - 数据写回 (register <strong>W</strong>rite <strong>B</strong>ack)</em> </p><p><img src="/2022/08/26/JMM-Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20220826143700494.png" alt="image-20220826143700494" style="zoom:50%;"></p><p>我们可以在<u>不改变结果的前提</u>下，将这些指令的各个阶段通过<u>重排序</u>和<u>组合</u>来实现<u>指令级并行</u>。</p><p><img src="/2022/08/26/JMM-Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/image-20220826144401033.png" alt="image-20220826144401033" style="zoom:45%;"></p><p>这种<strong><em><u>多级指令流水线</u></em></strong>，可以在一个时钟周期内，同时运行多条指令的不同阶段（相当于一条执行时间最长的复杂指令），本质上，流水线技术<u>并不能缩短单条指令的执行时间</u>，但它变相地<u>提高了指令地吞吐率</u>。</p><p>但是以这种方式执行时，一条指令的执行次序就会有所调整。</p><blockquote><p>重排序分为以下几种：</p><ul><li>编译器优化的重排序。编译器在不改变单线程程序语义的前提下，可以重新安排语句的执行顺序。</li><li>指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。</li><li>内存系统的重排序。由于处理器使用缓存和读／写缓冲区，这使得加载和存储操作看上去可能是在乱序执行</li></ul></blockquote><h3 id="4-volatile-原理"><a href="#4-volatile-原理" class="headerlink" title="4 volatile 原理"></a>4 <code>volatile</code> 原理</h3><p> <code>volatile</code> 的底层实现原理是内存屏障，Memory Barrier (Memory Fence)。</p><ul><li>对 <code>volatile</code> 变量的<strong><em><u>写指令后</u></em></strong>会加入<strong><em><u>写屏障</u></em></strong></li><li>对 <code>volatile</code> 变量的<strong><em><u>读指令前</u></em></strong>会加入<strong><em><u>读屏障</u></em></strong></li></ul><h4 id="如何保证可见性"><a href="#如何保证可见性" class="headerlink" title="如何保证可见性"></a>如何保证可见性</h4><ul><li>写屏障 (sfence) 保证：<u>在该屏障之前的对于共享变量的改动，都同步到主存中</u></li><li>读屏障 (lfence) 保证：<u>在该屏障之后的对于共享变量的改动，加载的是主存中的最新数据</u></li></ul><pre class="mermaid">sequenceDiagram    participant t1 as thread 1    participant n as num=0    participant v as volatile ready=false    participant t2 as thread 2    t1 -->> t1 :num=2    t1 ->> v : ready = true    Note over t1,v :写屏障    Note over t2,n :读屏障    t2 ->> n :读取num，等于2    t2 ->> v : 读取ready，等于true</pre><h4 id="如何保证有序性（本线程内）"><a href="#如何保证有序性（本线程内）" class="headerlink" title="如何保证有序性（本线程内）"></a>如何保证有序性（本线程内）</h4><ul><li>写屏障 (sfence) 保证：<u>指令重排时，不会将<strong><em>写屏障之前</em></strong>的代码排在写屏障之后</u></li><li>读屏障 (lfence) 保证：<u>指令重排时，不会将<strong><em>读屏障之后</em></strong>的代码排在读屏障之前</u></li></ul><pre class="mermaid">sequenceDiagram    participant t1 as thread 1    participant n as num=0    participant v as volatile ready=false    participant t2 as thread 2    t1 -->> t1 :num=2    t1 ->> v : ready = true    Note over t1,v :写屏障    Note over t2,n :读屏障    t2 ->> n :读取num，等于2    t2 ->> v : 读取ready，等于true</pre><p>【总结】</p><ul><li><code>volatile</code> 只能保证<strong><em><u>可见性</u></em></strong>和<strong><em><u>有序性</u></em></strong>，并不能保证原子性</li><li><code>synchronized</code> 可以保证以上三种性质。</li></ul><h4 id="double-checked-locking-问题"><a href="#double-checked-locking-问题" class="headerlink" title="double-checked locking 问题"></a><code>double-checked locking</code> 问题</h4><p>以我们在<a href="https://dave0126.github.io/2022/06/16/Java的23种设计模式/#单例模式">设计模式篇</a>中提到的单例模式为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">      INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，由于 <code>synchronized</code> 是重量级锁，每次调用 <code>getInstance()</code> 方法获得实例对象时都会执行同步代码块、加锁、释放锁……这样效率不高。但是单例模式在创建时，只有第一次应该保护如下的代码块</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line"> <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123;</span><br><span class="line">   INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line"> &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其余时间可以直接返回单例对象。我们思考能不能将保护的作用范围缩小，只有在第一次创建单例对象的时候使用 <code>synchronized</code> 保护。在此情景下，提出了<code>double-checked locking</code> 思想：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123; <span class="comment">// Frist check: 适用于单例对象创建之后的判断</span></span><br><span class="line">      <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123; <span class="comment">// Second check：适用于第一次单例对象创建的判断，上锁</span></span><br><span class="line">          INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上的实现特点是：</p><ul><li>懒惰的实例化</li><li>首次使用 <code>getInstance()</code> 才使用 <code>synchronized</code> 加锁，后续使用时无需加锁</li><li>但是很关键的一点：第一个 <code>if</code> 使用了 <code>INSTANCE</code> 变量，是<u>在同步块之外</u>，<strong><em><u>不能保证有序性</u></em></strong></li></ul><p>下面，我们就来研究其中的问题。我门考虑以下重点代码 <code>Singleton.getInstance()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123; <span class="comment">// Frist check: 适用于单例对象创建之后的判断</span></span><br><span class="line">    <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">      <span class="keyword">if</span> (INSTANCE == <span class="literal">null</span>) &#123; <span class="comment">// Second check：适用于第一次单例对象创建的判断，上锁</span></span><br><span class="line">        INSTANCE = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其对应的字节码为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> JMM.Singleton <span class="title function_">getInstance</span><span class="params">()</span>;</span><br><span class="line">    descriptor: ()LJMM/Singleton;</span><br><span class="line">    flags: (<span class="number">0x0009</span>) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">2</span>, args_size=<span class="number">0</span></span><br><span class="line">         <span class="number">0</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field INSTANCE:LJMM/Singleton;</span></span><br><span class="line">         <span class="number">3</span>: ifnonnull     <span class="number">37</span></span><br><span class="line">         <span class="number">6</span>: ldc           #<span class="number">3</span>                  <span class="comment">// class JMM/Singleton</span></span><br><span class="line">         <span class="number">8</span>: dup<span class="comment">// 复制Singleton引用对象，解锁时用</span></span><br><span class="line">         <span class="number">9</span>: astore_0<span class="comment">// 存入slot0</span></span><br><span class="line">        <span class="number">10</span>: monitorenter<span class="comment">// 加锁</span></span><br><span class="line">        <span class="number">11</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field INSTANCE:LJMM/Singleton;</span></span><br><span class="line">        <span class="number">14</span>: ifnonnull     <span class="number">27</span></span><br><span class="line">        <span class="number">17</span>: <span class="keyword">new</span>           #<span class="number">3</span>                  <span class="comment">// * class JMM/Singleton</span></span><br><span class="line">        <span class="number">20</span>: dup<span class="comment">// *</span></span><br><span class="line">        <span class="number">21</span>: invokespecial #<span class="number">4</span>                  <span class="comment">// * Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">        <span class="number">24</span>: putstatic     #<span class="number">2</span>                  <span class="comment">// * Field INSTANCE:LJMM/Singleton;</span></span><br><span class="line">        <span class="number">27</span>: aload_0</span><br><span class="line">        <span class="number">28</span>: monitorexit</span><br><span class="line">        <span class="number">29</span>: goto          <span class="number">37</span></span><br><span class="line">        <span class="number">32</span>: astore_1</span><br><span class="line">        <span class="number">33</span>: aload_0</span><br><span class="line">        <span class="number">34</span>: monitorexit</span><br><span class="line">        <span class="number">35</span>: aload_1</span><br><span class="line">        <span class="number">36</span>: athrow</span><br><span class="line">        <span class="number">37</span>: getstatic     #<span class="number">2</span>                  <span class="comment">// Field INSTANCE:LJMM/Singleton;</span></span><br><span class="line">        <span class="number">40</span>: areturn</span><br></pre></td></tr></table></figure><p>其中</p><ul><li><code>17:</code> 表示创建对象，将对象引用入栈 <code>// new Singleton</code></li><li><code>20:</code> 表示复制一份对象引用 <code>// 引用地址</code></li><li><code>21:</code> 表示利用一个对象引用，调用构造方法 <code>//根据引用地址调用</code></li><li><code>24:</code> 表示利用一个对象引用，赋值给 <code>static INSTANCE</code></li></ul><p>我们得到了如上的字节码。在 CPU 的执行期间，有可能由于指令级并行的重排序，我们会得到如下执行序列（先执行 24，再执行 21）</p><pre class="mermaid">sequenceDiagram    participant t1 as thread 1    participant i as INSTANCE    participant t2 as thread 2    t1 -->> t1 :17: new    t1 -->> t1 :20: dup    t1 ->> i : 24: putstatic, 给INSTANCE赋值   t2 ->> i : 0: getstatic, 获取INSTANCE引用   t2 -->> t2 : 3: ifnotnull 37   t2 -->> t2 : 37: getstatic, 获取INSTANCE引用   t2 -->> t2 : 40: areturn   t2 -->> t2 : 使用对象   t1 -->> t1 : 21: invokespecial #4, 调用构造方法</pre><p>此时，如果我们给 <code>INSTANCE</code> 加上 <code>volatile</code> 修饰符，此问题就可以解决。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br></pre></td></tr></table></figure><p>其对对应的字节码并没有区别，所以我们从【读/写屏障】的角度分析：</p><blockquote><ul><li>写屏障 (sfence) 保证：<u>指令重排时，不会将<strong><em>写屏障之前</em></strong>的代码排在写屏障之后</u></li><li>读屏障 (lfence) 保证：<u>指令重排时，不会将<strong><em>读屏障之后</em></strong>的代码排在读屏障之前</u></li></ul></blockquote><pre class="mermaid">sequenceDiagram    participant t1 as thread 1    participant i as INSTANCE    participant t2 as thread 2    t1 -->> t1 :17: new    t1 -->> t1 :20: dup    t1 -->> t1 : 21: invokespecial #4, 调用构造方法    t1 ->> i : 24: putstatic, 给INSTANCE赋值    Note over t1,i :写屏障   Note over t2,i :读屏障   t2 ->> i : 0: getstatic, 获取INSTANCE引用   t2 -->> t2 : 3: ifnotnull 37   t2 -->> t2 : 37: getstatic, 获取INSTANCE引用   t2 -->> t2 : 40: areturn   t2 -->> t2 : 使用对象</pre><h4 id="heppens-before-规则"><a href="#heppens-before-规则" class="headerlink" title="heppens-before 规则"></a>heppens-before 规则</h4><p>happens-before 规定了对共享变量的写操作对其它线程的读操作可见，它是可见性与有序性的一套规则总结，抛开以下 happens-before 规则，JMM 并不能保证一个线程对共享变量的写，对于其它线程对该共享变量的读可见</p><ul><li>线程解锁 <code>m</code> 之前对变量的写，对于接下来对 <code>m</code> 加锁的其它线程对该变量的读可见</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">static</span> <span class="type">Object</span> <span class="variable">m</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span> ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; &#123;</span><br><span class="line">  <span class="keyword">synchronized</span>(m) &#123;</span><br><span class="line">    x = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>).start ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="number">0</span>)-&gt; &#123;</span><br><span class="line">  <span class="keyword">synchronized</span>(m) &#123;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="string">&quot;t2&quot;</span>). start();</span><br></pre></td></tr></table></figure><ul><li>线程对 <code>volatile</code> 变量的写，对接下来其它线程对该变量的读可见</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; &#123;</span><br><span class="line">  x = <span class="number">10</span>;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>).start ();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="number">0</span>)-&gt; &#123;</span><br><span class="line">  System.out.println(x);</span><br><span class="line">&#125;, <span class="string">&quot;t2&quot;</span>). start();</span><br></pre></td></tr></table></figure><ul><li>线程 <code>start()</code> 之前对变量的写，对该线程开始后对该变量的读可见</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="number">0</span>)-&gt; &#123;</span><br><span class="line">  System.out.println(x);</span><br><span class="line">&#125;, <span class="string">&quot;t2&quot;</span>). start();</span><br></pre></td></tr></table></figure><ul><li>线程结束前对变量的写，对其它线程得知它结束后的读可见（比如其它线程调用 <code>t1.isAlive()</code> 或 <code>t1.join()</code> 等待它结束）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="number">0</span>)-&gt;&#123;</span><br><span class="line">  x = <span class="number">10</span>;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line"></span><br><span class="line">t1. join();</span><br><span class="line">System.out.println(x);</span><br></pre></td></tr></table></figure><ul><li>线程 <code>t1</code> 打断 <code>t2</code>  (interrupt) 前对变量的写，对于其他线程得知 <code>t2</code> 被打断后对变量的读可见（通过<br><code>t2.interrupted</code> 或 <code>t2.isInterrupted</code>)</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(Thread.currentThread).isInterrupted))&#123;</span><br><span class="line">        System.out.println(x);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="string">&quot;t2&quot;</span>) ;</span><br><span class="line">  t2. start();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="number">0</span>)-&gt;&#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    x = <span class="number">10</span>;</span><br><span class="line">    t2. interrupt();</span><br><span class="line">  &#125;, <span class="string">&quot;t1&quot;</span>). start();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">while</span>(!t2.isInterrupted())&#123;</span><br><span class="line">    Thread.yield();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  system.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对变量默认值（<code>0，false， null</code>）的写，对其它线程对该变量的读可见</li><li>具有传递性，如果 <code>x hb -&gt; y</code> 并且 <code>y hb -&gt; z</code> 那么有 <code>x hb -&gt; z</code>，配合 <code>volatile</code> 的防指令重排，有下面的例子</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">static</span> <span class="type">int</span> x;</span><br><span class="line"><span class="keyword">static</span> <span class="type">int</span> y;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="number">0</span>)-&gt; &#123;</span><br><span class="line">  y = <span class="number">10</span>;</span><br><span class="line">  x = <span class="number">20</span>;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>). start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="number">0</span>)-&gt; &#123;</span><br><span class="line">  System.out.println(x);</span><br><span class="line">&#125;, <span class="string">&quot;t2&quot;</span>). start();</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;JMM-Java-内存模型&quot;&gt;&lt;a href=&quot;#JMM-Java-内存模型&quot; class=&quot;headerlink&quot; title=&quot;JMM - Java 内存模型&quot;&gt;&lt;/a&gt;JMM - Java 内存模型&lt;/h1&gt;&lt;p&gt;首先，我们应该区分【JVM 内存结构】和【JMM 内存模型】的区别。我们常说的 【JVM 内存结构】指的是JVM 的内存分区；而 【JMM 内存模型】是一种虚拟机规范。&lt;/p&gt;
&lt;p&gt;简单的说，JMM 定义了一套在&lt;strong&gt;&lt;em&gt;&lt;u&gt;多线程&lt;/u&gt;&lt;/em&gt;&lt;/strong&gt;读写共享数据时（成员变量、数组）时，对数据的可见性、有序性和原子性的规则和保障。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://dave0126.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://dave0126.github.io/tags/Java/"/>
    
    <category term="JMM" scheme="https://dave0126.github.io/tags/JMM/"/>
    
  </entry>
  
  <entry>
    <title>Java的23种设计模式</title>
    <link href="https://dave0126.github.io/2022/06/16/Java%E7%9A%8423%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>https://dave0126.github.io/2022/06/16/Java%E7%9A%8423%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-06-16T11:07:34.000Z</published>
    <updated>2022-07-19T12:06:51.777Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-的-23种设计模式"><a href="#Java-的-23种设计模式" class="headerlink" title="Java 的 23种设计模式"></a>Java 的 23种设计模式</h1><p>设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的，是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p><p>设计模式分为三种类型，共23种：</p><ul><li><strong>创建型模式</strong>：<a href="https://dave0126.github.io/2022/06/16/Java的23种设计模式/#单例模式">单例模式</a>、<a href="https://dave0126.github.io/2022/06/16/Java的23种设计模式/#抽象工厂模式">抽象工厂模式</a>、<a href>建造者模式</a>、<a href="https://dave0126.github.io/2022/06/16/Java的23种设计模式/#工厂模式">工厂模式</a>、<a href>原型模式</a>。</li><li><strong>结构型模式</strong>：<a href>适配器模式</a>、<a href>桥接模式</a>、<a href="https://dave0126.github.io/2022/06/16/Java的23种设计模式/#装饰模式">装饰模式</a>、<a href>组合模式</a>、<a href>外观模式</a>、<a href>享元模式</a>、<a href="https://dave0126.github.io/2022/06/16/Java的23种设计模式/#代理模式">代理模式</a>。</li><li><strong>行为型模式</strong>：<a href>模版方法模式</a>、<a href>命令模式</a>、<a href>迭代器模式</a>、<a href>观察者模式</a>、<a href>中介者模式</a>、<a href>备忘录模式</a>、<a href>解释器模式</a>、<a href>状态模式</a>、<a href>策略模式</a>、<a href>责任链模式</a>、<a href>访问者模式</a>。</li></ul><span id="more"></span><h2 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h2><p>创建型模式的主要关注点是“<u>怎样创建对象</u>”，它的主要特点是“<u>将对象的创建与使用分离</u>”。</p><p>这样可以<strong>降低系统的耦合度</strong>，使用者不需要关注对象的创建细节。</p><p>创建型模式分为：</p><ul><li><a href="#单例模式">单例模式</a></li><li><a href="#工厂方法模式">工厂方法模式</a></li><li><a href="#抽象工厂模式">抽象工厂模式</a></li><li>原型模式</li><li>建造者模式</li></ul><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>所谓类的单例设计模式，就是采取一定的方法保证在整个软件系统中，对于<u>某个类只能存在一个实例</u>，该类负责创建自己的实例，并且该类只提供一个取得其实例的方法（静态方法）。</p><h4 id="单例设计模式的实现方法"><a href="#单例设计模式的实现方法" class="headerlink" title="单例设计模式的实现方法"></a>单例设计模式的实现方法</h4><h5 id="1-饿汉式"><a href="#1-饿汉式" class="headerlink" title="1. 饿汉式"></a>1. 饿汉式</h5><h6 id="方法1-静态常量"><a href="#方法1-静态常量" class="headerlink" title="方法1: 静态常量"></a>方法1: 静态常量</h6><p>步骤如下：</p><ol><li><p>将构造器私有化（防止通过 <code>new</code> 创建一个实例）</p></li><li><p>在类的内部创建一个实例</p></li><li><p>对外暴露一个静态的公共方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getInstance</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure></li></ol><p>【实例】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  <span class="comment">// 1.将构造器私有化</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2.在类的内部创建一个实例</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3.对外提供一个静态的公共方法，返回实例对象</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> singletonTest&#123;</span><br><span class="line">  <span class="type">Singleton</span> <span class="variable">instance1</span> <span class="operator">=</span> Singleton.getnstance();</span><br><span class="line">  <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.getnstance();</span><br><span class="line">  <span class="keyword">assert</span> (instance1==instance2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【优缺点】</p><ul><li>优点：写法简单、避免线程同步问题（装载类的时候就完成了实例化）</li><li>缺点：没有达到懒加载的要求（如果始终没有用到这个实例，那么内存空间就被浪费了）</li></ul><h6 id="方法2-静态代码块"><a href="#方法2-静态代码块" class="headerlink" title="方法2: 静态代码块"></a>方法2: 静态代码块</h6><p>参考上述【静态常量方法】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">  <span class="comment">// 1.将构造器私有化</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2.在类的内部创建一个实例</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">  <span class="keyword">static</span> &#123; <span class="comment">// 在静态代码块中创建实例</span></span><br><span class="line">    instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>()</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3.对外提供一个静态的公共方法，返回实例对象</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【静态常量方法】与【静态代码块方法】本质上是一样的。</p><h5 id="2-懒汉式"><a href="#2-懒汉式" class="headerlink" title="2. 懒汉式"></a>2. 懒汉式</h5><h6 id="方法1-线程不安全"><a href="#方法1-线程不安全" class="headerlink" title="方法1: 线程不安全"></a>方法1: 线程不安全</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 提供一个静态的公共方法，当调用该方法时，才去创建 instance。即懒汉式</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">      instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> singletonTest&#123;</span><br><span class="line">  <span class="type">Singleton</span> <span class="variable">instance1</span> <span class="operator">=</span> Singleton.getnstance();</span><br><span class="line">  <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> Singleton.getnstance();</span><br><span class="line">  <span class="keyword">assert</span> (instance1==instance2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【优缺点】</p><ul><li>优点：在饿汉式的基础上达到懒加载的要求。</li><li>缺点：在【多线程】下，由于 <code>if(instance == null)&#123;&#125;</code> 代码块不是原子性的，会存在【线程冲突】（不是单例模式）</li></ul><h6 id="方法2-线程安全"><a href="#方法2-线程安全" class="headerlink" title="方法2: 线程安全"></a>方法2: 线程安全</h6><p>由上述我们可知，在【多线程】情况下，不同线程可能会满足 <code>if(instance == null)&#123;&#125;</code> 代码块，从而存在线程冲突。所以我们决定在其基础上加入同步代码 <code>synchronized</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 提供一个静态的公共方法并加入同步代码，解决了线程安全问题</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123;</span><br><span class="line">      instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【优缺点】</p><ul><li>优点：达到懒加载的要求并解决了多线程下线程安全问题</li><li>缺点：因为使用了 <code>synchronized</code>，效率低</li></ul><h6 id="方法3-双重检查-Double-Check"><a href="#方法3-双重检查-Double-Check" class="headerlink" title="方法3: 双重检查 (Double Check)"></a>方法3: 双重检查 (Double Check)</h6><p>为了解决懒汉式中因为使用了 <code>synchronized</code>从而效率低的问题，我们使用如下方法：</p><ol><li>使用 <code>volatile</code> <u>防止重排序</u>以及在<u>线程之间共享变量的内存可见性</u>：<code>new</code> 创建对象 的过程分为三步，(1) 分配内存空间；(2) 初始化对象；(3) 指向对象的内存地址。而 (2) 和 (3) 可能被编译器自动重排，导致 <code>if</code> 判断为非空从而返回一个未经初始化的对象。</li><li>双重检查单例是否为空。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span>&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 提供一个静态的公共方法并加入同步代码，解决了线程安全问题</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123; <span class="comment">// a、b</span></span><br><span class="line">      <span class="keyword">synchronized</span> (Singleton.class) &#123; <span class="comment">// a先进入同步代码块，完成初始化。b在进入时再检查，非空</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="literal">null</span>)&#123; <span class="comment">// 不会重复执行同步代码，保证了效率</span></span><br><span class="line">          instance = <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Double-Check概念是多线程开发中常使用到的，如代码中所示，我们进行了两次 <code>if (singleton== null)</code> 检查，这样就可以保证线程安全了。</li><li>这样，实例化代码只用执行一次，后面再次访问时，判断 <code>if (singleton == null)</code>，直接 <code>return</code> 实例化对象，也避免的反复进行方法同步</li><li>线程安全、延迟加载、效率较高。</li></ul><p>在实际开发中，推荐使用这种单例设计模式</p><h6 id="方法4-静态内部类"><a href="#方法4-静态内部类" class="headerlink" title="方法4: 静态内部类"></a>方法4: 静态内部类</h6><ul><li>当外部类 (<code>Singleton</code>) 装载时静态内部类 (<code>SingletonInstance</code>) 不会被装载</li><li>当访问静态内部类中的属性或方法时，静态内部类才会被装载</li><li>静态内部类是线程安全的（<code>JVM</code> 底层机制）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 静态内部类，该类中有一个静态的属性</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonInstance</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这种方式采用了类装载的机制来保证初始化实例时只有一个线程</li><li>静态内部类方式在 <code>Singleton</code>类被装载时并不会立即实例化，而是在需要实例化时，调用 <code>getlnstance</code>方法，才会装载 <code>SingletonInstance</code>类，从而完成 <code>Singleton</code> 的实例化。</li><li>类的静态属性只会在第一次加载类的时候初始化，所以在这里，<code>JVM</code> 帮助我们保证了线程的安全性，在类进行初始化时，别的线程是无法进入的。</li><li>优点：避免了线程不安全，利用静态内部类特点实现延迟加载，效率高，推荐使用。</li></ul><h5 id="3-枚举"><a href="#3-枚举" class="headerlink" title="3. 枚举"></a>3. 枚举</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Singleton</span>&#123;</span><br><span class="line">  INSTANCE;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// 方法</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>借助 <code>JDK1.5</code> 中添加的枚举来实现单例模式。不仅能避免多线程同步问题，而且还能防止反序列化重新创建新的对象。</li></ul><h4 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h4><h5 id="如何破坏单例模式？"><a href="#如何破坏单例模式？" class="headerlink" title="如何破坏单例模式？"></a>如何破坏单例模式？</h5><p>除了【枚举】方法外，我们可以使上述的单例类创建多个实例对象（即破坏单例）。</p><p>有两种方法，分别是【序列化】和【反射】。</p><h5 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeObjectToFile</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">  <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filename));</span><br><span class="line">  oos.writeObject(instance);</span><br><span class="line">  oos.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">readObjectFromFile</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">ObjectIntputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filename));</span><br><span class="line">  <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> (Singleton) oos.readObject();</span><br><span class="line">  ois.close();</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">singletonSerializationTest</span><span class="params">()</span> &#123;</span><br><span class="line">  writeObjectToFile();</span><br><span class="line">  <span class="type">Singleton</span> <span class="variable">instance1</span> <span class="operator">=</span> readObjectFromFile();</span><br><span class="line">  <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> readObjectFromFile();</span><br><span class="line">  <span class="keyword">assert</span> (instance1 != instance2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">singletonReflexTest</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="comment">// 1.获取Singleton的字节码对象</span></span><br><span class="line">  Class&lt;Singleton&gt; clazz = Singleton.class;</span><br><span class="line">  <span class="comment">// 2.获取无参构造方法的对象</span></span><br><span class="line">  <span class="type">Constructor</span> <span class="variable">cons</span> <span class="operator">=</span> clazz.getDeclaredConstructor();</span><br><span class="line">  <span class="comment">// 3.因为Singleton是private的，所以我们需要“暴力反射”</span></span><br><span class="line">  cons.setAccessible(<span class="literal">true</span>);</span><br><span class="line">  <span class="comment">// 4.创建Singleton对象</span></span><br><span class="line">  <span class="type">Singleton</span> <span class="variable">instance1</span> <span class="operator">=</span> (Singleton) cons.newInstance();</span><br><span class="line">  <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> (Singleton) cons.newInstance();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">assert</span> (instance1 != instance2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解决上述问题"><a href="#解决上述问题" class="headerlink" title="解决上述问题"></a>解决上述问题</h4><h5 id="“序列化与反序列化”破坏单例的解决方案"><a href="#“序列化与反序列化”破坏单例的解决方案" class="headerlink" title="“序列化与反序列化”破坏单例的解决方案"></a>“序列化与反序列化”破坏单例的解决方案</h5><p>在 <code>Singleton</code> 类中添加 <code>readResolve()</code>方法，在反序列化时被反射调用，如果定义了这个方法，就返回这个方法的值，如果没有定义，则返回新 <code>new</code> 出来的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  <span class="comment">// 1.将构造器私有化</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2.静态内部类，该类中有一个静态的属性</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonInstance</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3.对外提供一个静态的公共方法，返回实例对象</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 当进行反序列化时，会自动调用该方法</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">writeObjectToFile</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">  <span class="type">ObjectOutputStream</span> <span class="variable">oos</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectOutputStream</span>(<span class="keyword">new</span> <span class="title class_">FileOutputStream</span>(filename));</span><br><span class="line">  oos.writeObject(instance);</span><br><span class="line">  oos.close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">readObjectFromFile</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">ObjectIntputStream</span> <span class="variable">ois</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ObjectInputStream</span>(<span class="keyword">new</span> <span class="title class_">FileInputStream</span>(filename));</span><br><span class="line">  <span class="type">Singleton</span> <span class="variable">instance</span> <span class="operator">=</span> (Singleton) oos.readObject();</span><br><span class="line">  ois.close();</span><br><span class="line">  <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">singletonSerializationTest</span><span class="params">()</span> &#123;</span><br><span class="line">  writeObjectToFile();</span><br><span class="line">  <span class="type">Singleton</span> <span class="variable">instance1</span> <span class="operator">=</span> readObjectFromFile();</span><br><span class="line">  <span class="type">Singleton</span> <span class="variable">instance2</span> <span class="operator">=</span> readObjectFromFile();</span><br><span class="line">  <span class="keyword">assert</span> (instance1 == instance2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="“反射”破坏单例的解决方案"><a href="#“反射”破坏单例的解决方案" class="headerlink" title="“反射”破坏单例的解决方案"></a>“反射”破坏单例的解决方案</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">flag</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 1.将构造器私有化</span></span><br><span class="line">  <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (Singleton.class) &#123;</span><br><span class="line">      <span class="comment">// 判断flag是否为真，若是，则说明不是第一次访问，则抛出异常；若不是，则初始化对象</span></span><br><span class="line">      <span class="keyword">if</span>(flag) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;不能创建多个对象&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      flag = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2.静态内部类，该类中有一个静态的属性</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SingletonInstance</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">INSTANCE</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3.对外提供一个静态的公共方法，返回实例对象</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 当进行反序列化时，会自动调用该方法</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">readResolve</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ol><li>单例模式保证了 系统内存中该类只存在一个对象，节省了系统资源，对于一些需要频繁创建销毁的对象，使用单例模式可以提高系统性能</li><li>当想实例化一个单例类的时候，必须要记住使用<u>相应的获取对象的方法</u>，而不是使用 <code>new</code></li><li>单例模式使用的场景：<ul><li>需要频繁的进行创建和销毁的对象</li><li>创建对象时耗时过多或耗费资源过多(即：重量级对象)，但又经常用到的对象</li><li>工具类对象</li><li>频繁访问数据库或文件的对象(比如数据源、session工厂等）</li></ul></li></ol><h3 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h3><h5 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h5><p>需求：设计一个咖啡店点餐系统。</p><p>设计一个咖啡类（Coffee），并定义其两个子类（美式咖啡 Americano和意式浓缩咖啡 Espresso）；再设计一个咖啡店类（Cafe），咖啡店具有点咖啡的功能。</p><p>设计如下：</p><p><img src="/2022/06/16/Java%E7%9A%8423%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20220706101024505.png" alt="image-20220706101024505" style="zoom:50%;"></p><p><code>Coffee</code> 咖啡类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSugar</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Add sugar...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addMilk</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Add milk...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Americano</span> <span class="keyword">extends</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Americano&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Espresso</span> <span class="keyword">extends</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Espresso&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Cafe</code> 咖啡店类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cafe</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> Coffee <span class="title function_">orderCoffee</span><span class="params">(String type)</span>&#123;</span><br><span class="line">    <span class="comment">// 声明Coffee类型的变量，根据不同的类型创建不同的Coffee子类对象</span></span><br><span class="line">    <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(type.equals(<span class="string">&quot;Americano&quot;</span>))&#123;</span><br><span class="line">      coffee = <span class="keyword">new</span> <span class="title class_">Americano</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">&quot;Espresso&quot;</span>))&#123;</span><br><span class="line">      coffee = <span class="keyword">new</span> <span class="title class_">Espresso</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;ERROR: Unknown coffee type&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加配料</span></span><br><span class="line">    coffee.addMilk();</span><br><span class="line">    coffee.addSugar();</span><br><span class="line">    <span class="keyword">return</span> coffee;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上我们可见，如果我们想加入另一种 <code>Caffee</code> 类型，我们需要修改很多代码，耦合度高，这显然违背了软件设计的开闭原则。</p><p>如果我们使用工厂来生产对象，我们就只和工厂打交道就可以了，彻底和对象解耦，如果要更换对象，直接在工厂里更换该对象即可，达到了与对象解耦的目的；所以说，工厂模式最大的优点就是：<strong>解耦</strong>。</p><p>在本教程中会介绍三种工厂的使用</p><ul><li>简单工厂模式（不属于GOF的23种经典设计模式）</li><li>工厂方法模式</li><li>抽象工厂模式</li></ul><h4 id="简单工厂-静态工厂模式"><a href="#简单工厂-静态工厂模式" class="headerlink" title="简单工厂/静态工厂模式"></a>简单工厂/静态工厂模式</h4><p>简单工厂/静态工厂<u>不是</u>一种设计模式，反而像是一种编程习惯。</p><h5 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h5><p>简单工厂/静态工厂包含如下角色：</p><ul><li>抽象产品 ：定义了产品的规范，描述了产品的主要特性和功能。</li><li>具体产品 ：实现或者继承抽象产品的子类</li><li>具体工厂 ：提供了创建产品的方法，调用者通过该方法来获取产品。</li></ul><h5 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h5><p>现在使用简单工厂对上面案例进行改进，类图如下：</p><p><img src="/2022/06/16/Java%E7%9A%8423%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20220706104353075.png" alt="image-20220706104353075" style="zoom:50%;"></p><p><code>Coffee</code> 咖啡类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSugar</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Add sugar...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addMilk</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Add milk...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Americano</span> <span class="keyword">extends</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Americano&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Espresso</span> <span class="keyword">extends</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Espresso&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SimpleCoffeeFactory</code> 简单咖啡工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">SimpleCoffeeFactory</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">(String type)</span> &#123;</span><br><span class="line">    <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">if</span>(type.equals(<span class="string">&quot;Americano&quot;</span>))&#123;</span><br><span class="line">      coffee = <span class="keyword">new</span> <span class="title class_">Americano</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(type.equals(<span class="string">&quot;Espresso&quot;</span>))&#123;</span><br><span class="line">      coffee = <span class="keyword">new</span> <span class="title class_">Espresso</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;ERROR: Unknown coffee type&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> coffee;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Cafe</code> 咖啡店类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cafe</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> Coffee <span class="title function_">orderCoffee</span><span class="params">(String type)</span> &#123;</span><br><span class="line">    <span class="comment">// SimpleCoffeeFactory factory = new SimpleCoffeeFactory();</span></span><br><span class="line">    <span class="comment">// Coffee coffee = factory.createCoffee(type);</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 静态工厂</span></span><br><span class="line">    <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> SimpleCoffeeFactory.createCoffee(type);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 添加配料</span></span><br><span class="line">    coffee.addMilk();</span><br><span class="line">    coffee.addSugar();</span><br><span class="line">    <span class="keyword">return</span> coffee;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂（<code>factory</code>）处理创建对象的细节，一旦有了 <code>SimpleCoffeeFactory</code>，<code>Cafe</code> 类中的 <code>orderCoffee()</code> 就变成此对象的客户，后期如果需要 <code>Coffee</code> 对象直接从工厂中获取即可。</p><p>这样也就解除了<u>和 <code>Coffee</code> 实现类的耦合</u>，同时又产生了新的耦合，<u><code>Cafe</code> 对象和 <code>SimpleCoffeeFactory</code> 工厂对象的耦合</u>，工厂对象和商品对象的耦合。</p><p>后期如果再加新品种的咖啡，我们势必要需求修改 <code>SimpleCoffeeFactory</code> 的代码，违反了开闭原则（对修改关闭，对扩展开放）。工厂类的客户端可能有很多，比如创建美团外卖等，这样只需要修改工厂类的代码，省去其他的修改操作。</p><p><strong>【优点】</strong></p><p>封装了创建对象的过程，可以通过参数直接获取对象。把对象的创建和业务逻辑层分开，这样以后就避免了修改客户代码，如果要实现新产品直接修改工厂类，而不需要在原代码中修改，这样就降低了客户代码修改的可能性，更加容易扩展。</p><p><strong>【缺点】</strong></p><p>增加新产品时还是需要修改工厂类的代码，违背了“开闭原则”。</p><h4 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h4><p>针对上例中的缺点，使用工厂方法模式就可以完美的解决，完全遵循开闭原则。</p><h5 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h5><p>定义一个用于创建对象的接口，让子类决定实例化哪个产品类对象。工厂方法使一个产品类的实例化延迟到其工厂的子类。</p><h5 id="结构-1"><a href="#结构-1" class="headerlink" title="结构"></a>结构</h5><p>工厂方法模式的主要角色：</p><ul><li>抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法来创建产品。</li><li>具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。</li><li>抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。</li><li>具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。</li></ul><h5 id="实现-1"><a href="#实现-1" class="headerlink" title="实现"></a>实现</h5><p>使用工厂方法模式对上例进行改进，类图如下：</p><p><img src="/2022/06/16/Java%E7%9A%8423%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20220706110450907.png" alt="image-20220706110450907" style="zoom:50%;"></p><p><code>Coffee</code> 咖啡类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSugar</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Add sugar...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addMilk</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Add milk...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Americano</span> <span class="keyword">extends</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Americano&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Espresso</span> <span class="keyword">extends</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Espresso&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>CoffeeFactory</code> 咖啡工厂接口类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line">  Coffee <span class="title function_">createCoffee</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体的咖啡工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmericanoFactory</span> <span class="keyword">implements</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Coffee createCoffee &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Americano</span>(); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">EspressoFactory</span> <span class="keyword">implements</span> <span class="title class_">CoffeeFactory</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> Coffee createCoffee &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Espresso</span>(); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Cafe</code> 咖啡店类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Cafe</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> CoffeeFactory factory;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setFactory</span><span class="params">(CoffeeFactory factory)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.factory = factory;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Coffee <span class="title function_">orderCoffee</span><span class="params">(String type)</span> &#123;</span><br><span class="line">    <span class="type">Coffee</span> <span class="variable">coffee</span> <span class="operator">=</span> factory.createCoffee();</span><br><span class="line">    <span class="comment">// 添加配料</span></span><br><span class="line">    coffee.addMilk();</span><br><span class="line">    coffee.addsugar();</span><br><span class="line">    <span class="keyword">return</span> coffee;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上的编写的代码可以看到，要增加产品类时也要相应地增加工厂类，不需要修改工厂类的代码了，这样就解决了简单工厂模式的缺点。</p><p>工厂方法模式是简单工厂模式的进一步抽象。由于使用了多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。</p><p><strong>【优点】</strong></p><ul><li>用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；</li><li>在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；</li></ul><p><strong>【缺点】</strong></p><ul><li>每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。</li></ul><h4 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h4><p>前面介绍的工厂方法模式中考虑的是一类产品的生产，这些工厂只生产同种类产品，同种类产品称为同等级产品，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。</p><p>本节要介绍的抽象工厂模式将考虑多等级产品的生产，将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，下图所示</p><p><img src="/2022/06/16/Java%E7%9A%8423%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20220706114743401.png" alt="image-20220706114743401" style="zoom:50%;"></p><ul><li>横轴是产品等级，也就是同一类产品；</li><li>纵轴是产品族，也就是同一品牌的产品，同一品牌的产品产自同一个工厂。</li></ul><h5 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h5><p>是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。</p><p>抽象工厂模式是工厂方法模式的升级版本，工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。</p><h5 id="结构-2"><a href="#结构-2" class="headerlink" title="结构"></a>结构</h5><p>抽象工厂模式的主要角色如下：</p><ul><li>抽象工厂（<code>Abstract Factory</code>）：提供了创建产品的接口，它<u>包含多个创建产品的方法</u>，可以<u>创建多个不同等级的产品</u>。</li><li>具体工厂（<code>Concrete Factory</code>）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。</li><li>抽象产品（<code>Product</code>）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。</li><li>具体产品（<code>ConcreteProduct</code>）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间是多对一的关系。</li></ul><h5 id="实现-2"><a href="#实现-2" class="headerlink" title="实现"></a>实现</h5><p>现咖啡店业务发生改变，不仅要生产咖啡还要生产甜点，如提拉米苏 <code>Tiramisu</code>、抹茶慕斯 <code>MatchaMousse</code> 等，要是按照工厂方法模式，需要定义提拉米苏类、抹茶慕斯类、提拉米苏工厂、抹茶慕斯工厂、甜点工厂类，很容易发生【类爆炸】情况。其中，</p><ul><li><p>意式浓缩咖啡、美式咖啡是一个产品等级，都是咖啡；提拉米苏、抹茶慕斯也是一个产品等级；</p></li><li><p>意式浓缩咖啡和提拉米苏是同一产品族（也就是都属于意大利风味），美式咖啡和抹茶慕斯是同一产品族（也就是都属于美式风味）；</p></li></ul><p>所以这个案例可以使用抽象工厂模式实现。类图如下：</p><p><img src="/2022/06/16/Java%E7%9A%8423%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20220719134607944.png" alt="image-20220719134607944"></p><p>代码如下：</p><p>抽象工厂</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">  Coffee <span class="title function_">createCoffee</span><span class="params">()</span>;</span><br><span class="line">  Dessert <span class="title function_">createDessert</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AmericanFlavorFactory</span> <span class="keyword">implements</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Americano</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Dessert <span class="title function_">createDessert</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">MatchaMousse</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ItalyFlavorFactory</span> <span class="keyword">implements</span> <span class="title class_">Factory</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> Coffee <span class="title function_">createCoffee</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Espresso</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Dessert <span class="title function_">createDessert</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Tiramisu</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Coffee</code> 咖啡类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> String <span class="title function_">getName</span><span class="params">()</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addSugar</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Add sugar...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addMilk</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Add milk...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Americano</span> <span class="keyword">extends</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Americano&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Espresso</span> <span class="keyword">extends</span> <span class="title class_">Coffee</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Espresso&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>甜品类 <code>Dessert</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Dessert</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Tiramisu</span> <span class="keyword">extends</span> <span class="title class_">Dessert</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Tiramisu&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MatchaMousse</span> <span class="keyword">extends</span> <span class="title class_">Dessert</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;MatchaMousse&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">createTiramisuTest</span><span class="params">()</span>&#123;</span><br><span class="line">  <span class="type">ItalyDessertFactory</span> <span class="variable">factory</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ItalyDessertFactory</span>();</span><br><span class="line">  <span class="type">Dessert</span> <span class="variable">tiramisu</span> <span class="operator">=</span> factory.createDessert();</span><br><span class="line">  tiramisu.show();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要加同一个产品族的话，只需要再加一个对应的工厂类即可，不需要修改其他的类。</p><p>【优缺点】</p><ul><li>当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。</li><li>当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。</li></ul><p>【使用场景】</p><ul><li>当需要创建的对象是一系列相互关联或相互依赖的产品族时，如电器工厂中的电视机、洗衣机、空调等。</li><li>系统中有多个产品族，但每次只使用其中的某一族产品。如有人只喜欢穿某一个品牌的衣服和鞋。</li><li>系统中提供了产品的类库，且所有产品的接口相同，客户端不依赖产品实例的创建细节和内部结构。</li></ul><h2 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h2><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p><strong>意图：</strong>为其他对象提供一种代理，以控制对这个对象的访问。代理对象在其中充当中介的作用。</p><p><strong>主要解决：</strong>在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。</p><blockquote><p>例如，我们有一个 A类，我们想调用 C类的方法以完成某项功能，但是 C类不允许 A类调用。此时，我们可以在 A类 和 C类 之间创建一个 B代理类，让 A类 访问 B代理类 完成功能。</p><p><img src="/2022/06/16/Java%E7%9A%8423%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20220705163306183.png" alt="image-20220705163306183" style="zoom:50%;"></p></blockquote><p>被代理的对象可以是<u>远程对象</u>、<u>创建开销大的对象</u>或<u>需要安全控制的对象</u></p><p><strong>使用代理模式的作用</strong>：</p><ol><li>功能增强：在原有的功能上，增加了额外的功能。新增加的功能，就叫做功能增强。</li><li>控制访问：不允许之间访问被代理类</li></ol><p><strong>实现代理的方式</strong>：</p><ol><li>静态代理：<ul><li>代理类是我们手动实现的，自己创建一个Java类表示代理类</li><li>同时所要代理的类是确定的</li><li>特点：实现简单；容易理解</li></ul></li><li>动态代理：</li></ol><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>静态代理在使用时，需要定义<u>接口</u>或者<u>父类</u>，被代理对象（即目标对象）与代理对象一起实现相同的接口或继承相同的父类</p><p>【实例】</p><p><img src="/2022/06/16/Java%E7%9A%8423%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20220705164019880.png" alt="image-20220705164019880" style="zoom:50%;"></p><ul><li><p>定义一个接口：<code>Teacher</code></p></li><li><p>目标对象 <code>TeacherImpl</code> 实现接口 <code>Teacher</code></p></li><li><p>使用静态代理方式，就需要在代理对象 <code>TeacherImplProxy</code> 中也实现接口 <code>Teacher</code></p></li><li><p>调用时，通过调用代理对象，来实现调用目标对象</p><p>⚠️ 目标对象和代理对象要实现相同的接口。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherImpl</span> <span class="keyword">implements</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;teaching...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherImplProxy</span> <span class="keyword">implements</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> Teacher teacher; <span class="comment">// 目标对象，通过接口聚合</span></span><br><span class="line">  <span class="comment">// 构造器</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">TeacherImplProxy</span> <span class="params">(Teacher teacher)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.teacher = teacher;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;代理开始&quot;</span>);</span><br><span class="line">    target.teach();</span><br><span class="line">    System.out.println(<span class="string">&quot;代理结束&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建目标对象（被代理对象）</span></span><br><span class="line">    <span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TeacherImpl</span>();</span><br><span class="line">    <span class="comment">// 创建代理对象，同时将被代理对象传递给代理对象</span></span><br><span class="line">    <span class="type">TeacherImplProxy</span> <span class="variable">teacherProxy</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TeacherImplProxy</span>(teacher);</span><br><span class="line">    <span class="comment">// 通过代理对象，调用被代理对象的方法</span></span><br><span class="line">    <span class="comment">// 即：执行的是代理对象的方法，代理对象再去调用被代理对象的方法</span></span><br><span class="line">    teacherProxy.teach();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果对接口进行改动，那么目标对象和代理对象都要改动。此时我们考虑动态代理。</p><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p><strong>动态代理的基本介绍：</strong></p><ul><li><p>代理对象不需要实现接口，但是目标对象需要实现接口，否则不能使用动态代理</p></li><li><p>代理对象的生成，是利用 JDK 提供的 API 实现的。动态的在内存中构建代理对象</p><ul><li><p>代理类所在包：<code>java.lang.reflect.Proxy</code>（基于反射）</p></li><li><p>JDK 实现代理只需要调用 <code>newProxyInstance()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Object <span class="title function_">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span><br><span class="line"><span class="params">                              Class&lt;?&gt;[] interfaces, // 传入目标对象</span></span><br><span class="line"><span class="params">                              InvocationHandler handler)</span>;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>动态代理也叫做 JDK 代理、接口代理</p></li></ul><p>【实例】（参考静态代理）</p><p><img src="/2022/06/16/Java%E7%9A%8423%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20220705164425482.png" alt="image-20220705164425482" style="zoom:50%;"></p><ul><li><p>定义一个接口：<code>Teacher</code></p></li><li><p>目标对象 <code>TeacherImpl</code> 实现接口 <code>Teacher</code></p></li><li><p>使用静态代理方式，就需要在代理对象 <code>TeacherImplProxy</code> 中也实现接口 <code>Teacher</code></p></li><li><p>调用时，通过调用代理对象，来实现调用目标对象</p><p>⚠️ 目标对象和代理对象要实现相同的接口。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String name)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TeacherImpl</span> <span class="keyword">implements</span> <span class="title class_">Teacher</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">teach</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;teaching...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sayHello</span><span class="params">(String name)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello, &quot;</span> + name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ProxyFactory</span> &#123;</span><br><span class="line">  <span class="comment">// 维护目标对象</span></span><br><span class="line">  <span class="keyword">private</span> Object target; <span class="comment">// 目标对象，通过接口聚合</span></span><br><span class="line">  <span class="comment">// 构造器，对target进行初始化</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ProxyFactory</span> <span class="params">(Object target)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.target = target;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 生成一个目标函数的代理对象</span></span><br><span class="line">  <span class="comment">// 1. ClassLoader loader : 指定当前目标对象使用的类加载器 Specifies the class loader used by the current target object</span></span><br><span class="line">  <span class="comment">// 2. Class&lt;?&gt;[] interface : 目标对象实现的接口类型，使用泛型方法确认类型 The interface type implemented by the target object, use the generic method to confirm the type</span></span><br><span class="line">  <span class="comment">// 3. InvocationHandler handler : 事件处理，执行目标对象的方法时，会触发事件处理器方法 Event processing, when the method of the target object is executed, the event handler method will be triggered</span></span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">getProxyInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Proxy.newProxyInstance(target.getClass().getClassLoader(),</span><br><span class="line">                                 target.getClass().getInterfaces(),</span><br><span class="line">                                 <span class="keyword">new</span> <span class="title class_">InvocationHandler</span>()&#123;</span><br><span class="line">                                   <span class="meta">@Override</span></span><br><span class="line">                                   <span class="keyword">public</span> Object <span class="title function_">invoke</span><span class="params">(Object proxy, </span></span><br><span class="line"><span class="params">                                                        Method method, </span></span><br><span class="line"><span class="params">                                                        Object[] args)</span>&#123;</span><br><span class="line">                                     System.out.println(<span class="string">&quot;代理开始&quot;</span>);</span><br><span class="line">                                     <span class="type">Object</span> <span class="variable">returnVal</span> <span class="operator">=</span> method.invoke(target,args);</span><br><span class="line">                                     System.out.println(<span class="string">&quot;代理结束&quot;</span>);</span><br><span class="line">                                     <span class="keyword">return</span> returnVal;</span><br><span class="line">                                   &#125;</span><br><span class="line">                                 &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">// 创建目标对象（被代理对象）</span></span><br><span class="line">    <span class="type">Teacher</span> <span class="variable">teacher</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TeacherImpl</span>();</span><br><span class="line">    <span class="comment">// 创建代理对象，内存中动态生成了代理对象</span></span><br><span class="line">    <span class="type">Teacher</span> <span class="variable">teacherProxy</span> <span class="operator">=</span> (Teacher) <span class="keyword">new</span> <span class="title class_">ProxyFactory</span>(teacher).getProxyInstance();</span><br><span class="line">    System.out.println();</span><br><span class="line">    <span class="comment">// 通过代理对象，调用被代理对象的方法</span></span><br><span class="line">    <span class="comment">// 即：执行的是代理对象的方法，代理对象再去调用被代理对象的方法</span></span><br><span class="line">    teacherProxy.teach();</span><br><span class="line">    teacherProxy.sayHello(<span class="string">&quot;gdai&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">代理开始</span><br><span class="line">teaching...</span><br><span class="line">代理结束</span><br><span class="line">代理开始</span><br><span class="line">Hello, gdai</span><br><span class="line">代理结束</span><br></pre></td></tr></table></figure><h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><h4 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h4><p>在不改变原有对象的基础上，将其他功能附加到对象上。</p><p>【优点】</p><ol><li>不改变原有对象的情况下给一个对象拓展功能</li><li>使用不同的组合可以实现不同的效果</li><li>体现开闭原则</li><li>低耦合</li></ol><blockquote><p>例如我们想开发一个【拍照功能】，我们已经写好了一个基础的【拍照功能】，现在我们想在这个基础功能上添加【滤镜功能】。我们不能直接对原有的【拍照功能】进行更改，因为这样有可能会破坏原有功能，所以我们使用装饰器模式来增强原有功能</p></blockquote><h4 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h4><p><img src="/2022/06/16/Java%E7%9A%8423%E7%A7%8D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20220617141948195.png" alt="image-20220617141948195" style="zoom:50%;"></p><h4 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcerteComponent</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;拍照...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Decorator</span> <span class="keyword">implements</span> <span class="title class_">Component</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> Component compontent;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Decorator</span><span class="params">(Component compontent)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.component = compontent;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ConcreteDecorator_Filter</span> <span class="keyword">extends</span> <span class="title class_">Decorator</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ConcreteDecorator_Filter</span><span class="params">(Component compontent)</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>.compontent;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">operation</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;添加滤镜...&quot;</span>);</span><br><span class="line">    compontent.operation(); <span class="comment">// 原有的功能</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DecoratorTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">Component</span> <span class="variable">component</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ConcreteDecorator_Filter</span>(<span class="keyword">new</span> <span class="title class_">ConcreteComponent</span>());</span><br><span class="line">    component.operation();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">添加滤镜...</span><br><span class="line">拍照...</span><br></pre></td></tr></table></figure><h4 id="Python-中的装饰器"><a href="#Python-中的装饰器" class="headerlink" title="Python 中的装饰器"></a><code>Python</code> 中的装饰器</h4><p>我们有如下两个函数 <code>func1()</code> 和 <code>func_muilt(*args,**kwargs)</code>，我们需要在这个在这两个函数的前后分别加入登入<code>login(func)</code> 和登出<code>logout(func)</code> 两个功能。我们就可以使用到装饰器 <code>Decorator</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># @login 为调用装饰器login</span></span><br><span class="line"><span class="meta">@login</span></span><br><span class="line"><span class="meta">@logout</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func1</span>(): <span class="comment"># 无参函数</span></span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;this is func1&#x27;</span>)</span><br><span class="line">  </span><br><span class="line">func1()</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">login...</span><br><span class="line">this is func1</span><br><span class="line">logout...</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以下就是python中装饰器的标准形式</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">func</span>):</span><br><span class="line">  <span class="comment"># *args为可变参数，可以适配多个传入参数</span></span><br><span class="line">  <span class="comment"># **kwargs为可变关键字参数，可以适配多个关键字参数</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;login...&#x27;</span>)</span><br><span class="line">    func(*args, **kwargs)</span><br><span class="line">  <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">logout</span>(<span class="params">func</span>):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    func(*args, **kwargs)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;logout...&#x27;</span>)</span><br><span class="line">  <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 带参</span></span><br><span class="line"><span class="meta">@login</span></span><br><span class="line"><span class="meta">@logout</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func_muilt</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">  <span class="built_in">print</span>(<span class="string">&#x27;this is func_muilt&#x27;</span>, *args)</span><br><span class="line">  <span class="built_in">print</span>(**kwargs)</span><br><span class="line">  </span><br><span class="line">func_muilt(<span class="string">&#x27;python&#x27;</span>, y1=<span class="string">&#x27;ok&#x27;</span>, y2=<span class="string">&#x27;oui&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">login...</span><br><span class="line">this is func_muilt python</span><br><span class="line">&#123;&#x27;y1&#x27;:&#x27;ok&#x27;, &#x27;b2&#x27;:&#x27;oui&#x27;&#125;</span><br><span class="line">logout...</span><br></pre></td></tr></table></figure><h4 id><a href="#" class="headerlink" title=" "></a> </h4><h2 id="行为型模式"><a href="#行为型模式" class="headerlink" title="行为型模式"></a>行为型模式</h2>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Java-的-23种设计模式&quot;&gt;&lt;a href=&quot;#Java-的-23种设计模式&quot; class=&quot;headerlink&quot; title=&quot;Java 的 23种设计模式&quot;&gt;&lt;/a&gt;Java 的 23种设计模式&lt;/h1&gt;&lt;p&gt;设计模式（Design pattern）是一套被反复使用、多数人知晓的、经过分类编目的，是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。&lt;/p&gt;
&lt;p&gt;设计模式分为三种类型，共23种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;创建型模式&lt;/strong&gt;：&lt;a href=&quot;https://dave0126.github.io/2022/06/16/Java的23种设计模式/#单例模式&quot;&gt;单例模式&lt;/a&gt;、&lt;a href=&quot;https://dave0126.github.io/2022/06/16/Java的23种设计模式/#抽象工厂模式&quot;&gt;抽象工厂模式&lt;/a&gt;、&lt;a href&gt;建造者模式&lt;/a&gt;、&lt;a href=&quot;https://dave0126.github.io/2022/06/16/Java的23种设计模式/#工厂模式&quot;&gt;工厂模式&lt;/a&gt;、&lt;a href&gt;原型模式&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;结构型模式&lt;/strong&gt;：&lt;a href&gt;适配器模式&lt;/a&gt;、&lt;a href&gt;桥接模式&lt;/a&gt;、&lt;a href=&quot;https://dave0126.github.io/2022/06/16/Java的23种设计模式/#装饰模式&quot;&gt;装饰模式&lt;/a&gt;、&lt;a href&gt;组合模式&lt;/a&gt;、&lt;a href&gt;外观模式&lt;/a&gt;、&lt;a href&gt;享元模式&lt;/a&gt;、&lt;a href=&quot;https://dave0126.github.io/2022/06/16/Java的23种设计模式/#代理模式&quot;&gt;代理模式&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;行为型模式&lt;/strong&gt;：&lt;a href&gt;模版方法模式&lt;/a&gt;、&lt;a href&gt;命令模式&lt;/a&gt;、&lt;a href&gt;迭代器模式&lt;/a&gt;、&lt;a href&gt;观察者模式&lt;/a&gt;、&lt;a href&gt;中介者模式&lt;/a&gt;、&lt;a href&gt;备忘录模式&lt;/a&gt;、&lt;a href&gt;解释器模式&lt;/a&gt;、&lt;a href&gt;状态模式&lt;/a&gt;、&lt;a href&gt;策略模式&lt;/a&gt;、&lt;a href&gt;责任链模式&lt;/a&gt;、&lt;a href&gt;访问者模式&lt;/a&gt;。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Java" scheme="https://dave0126.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://dave0126.github.io/tags/Java/"/>
    
    <category term="设计模式" scheme="https://dave0126.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Spring框架</title>
    <link href="https://dave0126.github.io/2022/06/15/Spring%E6%A1%86%E6%9E%B6/"/>
    <id>https://dave0126.github.io/2022/06/15/Spring%E6%A1%86%E6%9E%B6/</id>
    <published>2022-06-15T20:12:54.000Z</published>
    <updated>2022-06-24T19:08:51.276Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Spring-简介"><a href="#Spring-简介" class="headerlink" title="Spring 简介"></a>Spring 简介</h3><p>Spring 是<u>分层的</u> Java SE/EE 应用轻量级全栈开源框架，以 <u>IoC</u>（反转控制）和<u>AOP</u>（面向切面编程）为内核。</p><p>提供了<u>展现层</u> Spring MVC和<u>持久层</u> Spring JDBCTemplate 以及<u>业务层</u>事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE 企业应用开源框架。</p><span id="more"></span><h4 id="Spring-的优势"><a href="#Spring-的优势" class="headerlink" title="Spring 的优势"></a>Spring 的优势</h4><ol><li><p>方便解耦，简化开发；</p><p>通过 Spring 框架提供的Bean IoC容器，可以将对象间的依赖关系交由Spring控制，从而降低耦合度。</p></li><li><p>AOP思想的支持；</p></li><li><p>声明式事务的支持；</p><p>传统的编程式事务处理繁琐、事务管理代码冗杂，spring通过声明式配置多种事务的管理，提高效率</p></li><li><p>方便程序的测试</p></li><li><p>方便集成其他优秀框架</p></li></ol><h4 id="Spring-结构"><a href="#Spring-结构" class="headerlink" title="Spring 结构"></a>Spring 结构</h4><p><img src="/2022/06/15/Spring%E6%A1%86%E6%9E%B6/image-20220616104824734.png" alt="image-20220616104824734" style="zoom:50%;"></p><ol><li><p><code>Core Container</code> : 核心容器 </p><p>控制反转 (Inversion of Control)</p><p>依赖注入 (Dependency Injection)</p></li><li><p><code>Data Access / Data Integration</code> : 数据访问与数据集成</p><p>与数据库的操作有关</p></li><li><p><code>Aspect Oriental Program (AOP)</code> : 面向切面编程思想</p><p><code>AspectsJ</code> : AOP思想的实现</p></li><li><p><code>Web</code> : Web 开发相关</p></li><li><p><code>Test</code> : 测试相关</p></li></ol><h3 id="Spring-快速入门"><a href="#Spring-快速入门" class="headerlink" title="Spring 快速入门"></a>Spring 快速入门</h3><h4 id="Spring-开发步骤"><a href="#Spring-开发步骤" class="headerlink" title="Spring 开发步骤"></a>Spring 开发步骤</h4><p><img src="/2022/06/15/Spring%E6%A1%86%E6%9E%B6/image-20220623155611723.png" alt="image-20220623155611723" style="zoom:50%;"></p><ol><li><p>导入 Spring 开发的基本包坐标 (Maven)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写 Dao 接口和实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Interface;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> impl;</span><br><span class="line"><span class="keyword">import</span> Interface.UserDao;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">UserDao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;save running...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建 Spring 核心配置文件 (xml)</p></li><li><p>在Spring 配置文件中配置 UserDaolmpl</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;impl.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>使用 Spring 的 API获得 Bean 实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserDaoTest</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">context</span> <span class="operator">=</span> </span><br><span class="line">          <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">UserDao</span> <span class="variable">userDao</span> <span class="operator">=</span> (UserDao) context.getBean(<span class="string">&quot;userDao&quot;</span>);</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h4 id="Spring-配置文件"><a href="#Spring-配置文件" class="headerlink" title="Spring 配置文件"></a>Spring 配置文件</h4><h5 id="lt-Bean-gt-标签的基本配置"><a href="#lt-Bean-gt-标签的基本配置" class="headerlink" title="&lt;Bean&gt;标签的基本配置"></a><code>&lt;Bean&gt;</code>标签的基本配置</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;唯一性标识符&quot;</span> <span class="attr">class</span>=<span class="string">&quot;全类名(包名+类名)&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="lt-Bean-gt-标签的范围配置"><a href="#lt-Bean-gt-标签的范围配置" class="headerlink" title="&lt;Bean&gt;标签的范围配置"></a><code>&lt;Bean&gt;</code>标签的范围配置</h5><ol><li><code>singleton</code>：<u>单例</u>，默认值<ul><li>Bean的实例化个数：1个</li><li>Bean的实例化时机：当Spring核心文件被加载时，实例化配置的Bean实例</li><li>Bean的生命周期：<ul><li>对象创建：当应用加载，创建容器时，对象就被创建了</li><li>对象运行：只要容器在，对象一直活着</li><li>对象销毀：当应用卸载，销毁容器时，对象就被销毁了</li></ul></li></ul></li><li><code>prototype</code>：<u>多例</u><ul><li>Bean的实例化个数：多个</li><li>Bean的实例化时机：当调用getBean0方法时实例化Bean</li><li>Bean的生命周期：<ul><li>对象创建：当使用对象时，创建新的对象实例</li><li>对象运行：只要对象在使用中，就一直活着</li><li>对象销毁：当对象长时间不用时，被Java 的垃圾回收器回收</li></ul></li></ul></li><li><code>request</code>：WEB 项目中，Spring创建一个Bean对象，将其放入request域中</li><li><code>session</code>：WEB 项目中，Spring创建一个Bean对象，将其放入session域中</li><li><code>global session</code>：WEB 项目中，Spring创建一个Bean对象，将其放入global session域中</li></ol><h5 id="Bean生命周期配置"><a href="#Bean生命周期配置" class="headerlink" title="Bean生命周期配置"></a>Bean生命周期配置</h5><ul><li><code>init-method</code>：指定类中的初始化方法</li><li><code>destroy-method</code>：指定类中的销毁方法</li></ul><h5 id="Bean实例化的三种方式"><a href="#Bean实例化的三种方式" class="headerlink" title="Bean实例化的三种方式"></a>Bean实例化的三种方式</h5><ul><li><p><u>无参构造</u>方法实例化</p></li><li><p><u>工厂静态</u>方法实例化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StaticFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> UserDao <span class="title function_">getUserDao</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用静态工厂返回Bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDaoStaticFactory&quot;</span> </span></span><br><span class="line"><span class="tag">          <span class="attr">class</span>=<span class="string">&quot;factory.StaticFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getUserDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><u>工厂实例</u>方法实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DynamicFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> UserDao <span class="title function_">getUserDao</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">UserDaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用动态工厂返回Bean --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 1. 先创建一个动态工厂 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;DynamicFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;factory.DynamicFactory&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 2. 再通过动态工厂获得一个userDao对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDaoDynamicFactory&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;DynamicFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getUserDao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="Bean的依赖注入"><a href="#Bean的依赖注入" class="headerlink" title="Bean的依赖注入"></a>Bean的依赖注入</h5><p>因为 <code>UserService</code> 和 <code>UserDao</code> 都在Spring容器中，而最終程序直接使用的是 <code>UserService</code>，所以可以在<br>Spring容器中，将 <code>UserDao</code> 设置到 <code>UserService</code> 内部 (依赖注入)</p><pre class="mermaid">graph LRsubgraph "IoC容器"Sercive --依赖--> Daoend</pre><p>在编写程序时，通过控制反转，把对象的创建交给了 Spring，但是代码中不可能出现没有依赖的情况。</p><p>IoC解耦只是降低他们的依赖关系，但不会消除。例如：业务层仍会调用持久层的方法</p><p>那这种业务层和持久层的依赖关系，在使用 Spring 之后，就让Spring 来维护了。简单的说，就是让框架把持久层对象传入业务层，而不用我们自己去获取。</p><h6 id="怎么将-UserDao-怎样注入到-UserService-内部呢？"><a href="#怎么将-UserDao-怎样注入到-UserService-内部呢？" class="headerlink" title="怎么将 UserDao 怎样注入到 UserService 内部呢？"></a>怎么将 <code>UserDao</code> 怎样注入到 <code>UserService</code> 内部呢？</h6><ul><li><p>有参构造方法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;impl.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span>--&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userServiceByConstructor&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入依赖关系 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">UserServiceImpl</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>setXxx()</code>方法</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userDao1&quot;</span> <span class="attr">class</span>=<span class="string">&quot;impl.UserDaoImpl&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;userService&quot;</span> <span class="attr">class</span>=<span class="string">&quot;service.impl.UserServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入依赖关系 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;userDao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;userDao1&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">UserService</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> UserDao userDao;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setUserDao</span><span class="params">(UserDao userDao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.userDao = userDao;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        userDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="Bean的依赖注入的数据类型"><a href="#Bean的依赖注入的数据类型" class="headerlink" title="Bean的依赖注入的数据类型"></a>Bean的依赖注入的数据类型</h5><p>上面的操作，都是注入的引用Bean，除了对象的引用可以注入，普通数据类型，集合等都可以在容器中进行注入。</p><p>注入数据的三种数据类型：</p><ul><li>普通数据类型</li><li>引用数据类型</li><li>集合数据类</li></ul><h5 id="引入其他配置文件（分模块开发）"><a href="#引入其他配置文件（分模块开发）" class="headerlink" title="引入其他配置文件（分模块开发）"></a>引入其他配置文件（分模块开发）</h5><p>实际开发中，Spring的配置内容非常多，这就导致Spring配置很繁杂且体积很大，所以，可以将部分配置拆解到其他配置文件中，而在Spring主配置文件通过impor标签进行加载<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">import</span> <span class="attr">resource</span>=<span class="string">&quot;applicationContext-xxx.xml&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></p><h5 id="Spring的重点配置"><a href="#Spring的重点配置" class="headerlink" title="Spring的重点配置"></a>Spring的重点配置</h5><p><code>&lt;bean&gt;</code>标签</p><ul><li><code>id</code>属性：在容器中Bean实例的唯一标识，不允许重复</li><li><code>Class</code>属性：要实例化的Bean的全类名</li><li><code>scope</code>属性：Bean的作用范国，常用是singleton （默大认）和prototype</li><li><code>&lt;property&gt;</code>标签：厲性注入<ul><li><code>name</code>属性：厲性名称</li><li><code>value</code>属性：注入的普通属性值</li><li><code>ref</code>属性：注入的对象引用值</li><li><code>&lt;list&gt;</code>标签</li><li><code>&lt;map&gt;</code>标签</li><li><code>&lt;properties&gt;</code>标签</li><li><code>&lt;constructor-arg&gt;</code>标签</li></ul></li></ul><p><code>&lt;import&gt;</code>标签：导入其他的spring的分文件</p><h3 id="Spring-核心容器"><a href="#Spring-核心容器" class="headerlink" title="Spring 核心容器"></a>Spring 核心容器</h3><h4 id="IoC-Inversion-of-Control"><a href="#IoC-Inversion-of-Control" class="headerlink" title="IoC (Inversion of Control)"></a>IoC (Inversion of Control)</h4><p>为了使业务与数据<u>解耦合</u>，即使用对象时，在程序中不要主动使用 <code>new</code> 产生对象，而是由<u>外部</u>提供对象。将对象的创建由程序转移到外部，这种思想称为IoC 控制反转。</p><ul><li>Spring 提供了一个容器，称为 IoC容器，用来充当 IoC思想中的“外部”。</li><li>IoC容器负责对象的创建、初始化等一系列工作，被创建或被管理的对象在IoC容器中统称为Bean</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">BookService</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> BookDao bookDao;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">    bookDao.save();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BookDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">BookDao</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;bookDao save ...&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre class="mermaid">graph LRsubgraph "IoC容器"Sercive --依赖--> Daoend</pre><h5 id="DI-Dependency-Injection"><a href="#DI-Dependency-Injection" class="headerlink" title="DI (Dependency Injection)"></a>DI (Dependency Injection)</h5><p>在IoC容器中建立 Bean 与 Bean 之间的依赖关系的过程，被称为依赖注入 (DI)</p><h5 id="控制反转和依赖注入的关系"><a href="#控制反转和依赖注入的关系" class="headerlink" title="控制反转和依赖注入的关系"></a>控制反转和依赖注入的关系</h5><p>我们已经分别解释了控制反转和依赖注入的概念。有些人会把控制反转和依赖注入等同，但实际上它们有着本质上的不同。</p><ul><li><strong>控制反转</strong>是一种思想</li><li><strong>依赖注入</strong>是一种设计模式</li></ul><h4 id="Spring中IoC实现的简单描述"><a href="#Spring中IoC实现的简单描述" class="headerlink" title="Spring中IoC实现的简单描述"></a>Spring中IoC实现的简单描述</h4><p>IoC的主要实现是得益于一个可以动态生成对象的工厂<code>BeanFactory</code>，它通过读取配置文件中的对象的配置信息，通过反射 (reflexion) 机制返回一个实体对象。</p><ol><li><p>首先定义一个外部的配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">UserDao</span>=<span class="string">fr.spring.gdai.impl.UserDaoImpl</span></span><br></pre></td></tr></table></figure></li><li><p>Java程序读取这个配置文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BeanFactory</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Properties properties;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String,Object&gt; cache = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    properties = <span class="keyword">new</span> <span class="title class_">Properties</span>();</span><br><span class="line">properties.load(BeanFactory.class.getClassLoader().</span><br><span class="line">                    getResourceAsStream(<span class="string">&quot;factory.properties&quot;</span>))</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 多例 prototype</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getUserDaoPrototype</span><span class="params">(String property)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> properties.getProperty(property);</span><br><span class="line">    <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(value);</span><br><span class="line">    <span class="type">Object</span> <span class="variable">userDao</span> <span class="operator">=</span> clazz.getConstructor(<span class="literal">null</span>).newInstance(<span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">return</span> userDao;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 单例 singleton，spring默认</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title function_">getUserDaoSingleton</span><span class="params">(String property)</span> &#123;</span><br><span class="line">    <span class="comment">// 先判断缓存中是否存在该对象</span></span><br><span class="line">    <span class="keyword">if</span>(!cache.containsKey(property))&#123;</span><br><span class="line">      <span class="comment">// 在多线程下确保一致性，加锁</span></span><br><span class="line">      <span class="keyword">synchronized</span> (BeanFactory.class)&#123;</span><br><span class="line">        <span class="comment">// 双重检测缓存中是否存在该对象</span></span><br><span class="line">        <span class="keyword">if</span>(!cache.containsKey(property))&#123;</span><br><span class="line">          <span class="comment">// 反射机制创建对象</span></span><br><span class="line">          <span class="type">String</span> <span class="variable">value</span> <span class="operator">=</span> properties.getProperty(property);</span><br><span class="line">          <span class="type">Class</span> <span class="variable">clazz</span> <span class="operator">=</span> Class.forName(value);</span><br><span class="line">          <span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> clazz.getConstructor(<span class="literal">null</span>).newInstance(<span class="literal">null</span>);</span><br><span class="line">          <span class="comment">// 将对象存入缓存</span></span><br><span class="line">          cache.put(property,object);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cache.get(property);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>测试 <code>Object getUserDao(String property)</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userDaoPrototypeTest</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">UserDao</span> <span class="variable">userDao1</span> <span class="operator">=</span> (UserDao) BeanFactory.getUserDaoPrototype(<span class="string">&quot;UserDao&quot;</span>);</span><br><span class="line">  <span class="type">UserDao</span> <span class="variable">userDao2</span> <span class="operator">=</span> (UserDao) BeanFactory.getUserDaoPrototype(<span class="string">&quot;UserDao&quot;</span>);</span><br><span class="line">  System.out.println(userDao1);</span><br><span class="line">  System.out.println(userDao2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">fr.spring.gdai.impl.UserDaoImpl2@3f8d7a8c</span></span><br><span class="line"><span class="comment">fr.spring.gdai.impl.UserDaoImpl2@1d3a1b2c</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">userDaoSingletonTest</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">UserDao</span> <span class="variable">userDao1</span> <span class="operator">=</span> (UserDao) BeanFactory.getUserDaoSingleton(<span class="string">&quot;UserDao&quot;</span>);</span><br><span class="line">  <span class="type">UserDao</span> <span class="variable">userDao2</span> <span class="operator">=</span> (UserDao) BeanFactory.getUserDaoSingleton(<span class="string">&quot;UserDao&quot;</span>);</span><br><span class="line">  System.out.println(userDao1);</span><br><span class="line">  System.out.println(userDao2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">fr.spring.gdai.impl.UserDaoImpl2@3f8d7a8c</span></span><br><span class="line"><span class="comment">fr.spring.gdai.impl.UserDaoImpl2@3f8d7a8c</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="AOP-Aspect-Oriented-Program"><a href="#AOP-Aspect-Oriented-Program" class="headerlink" title="AOP (Aspect Oriented Program)"></a>AOP (Aspect Oriented Program)</h4><p>AOP，即面向切面编程。它是一种抽象化的面向对象编程 (OOP)，将切面抽象为对象。使用<u>动态代理</u>机制实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Calculate</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sub</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">multi</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">div</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculateImpl</span> <span class="keyword">implements</span> <span class="title class_">Calculate</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Func_add : &quot;</span> + num1 + <span class="string">&quot; + &quot;</span> + num2);    <span class="comment">// 日志打印</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> num1 + num2;                                   <span class="comment">// 业务代码</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Result : &quot;</span> + result);                   <span class="comment">// 日志打印（下同）</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure><p>我们可以看到，”日志打印”和”业务代码”紧密的耦合在一起。那么我们是否能将”日志打印”和”业务代码”分离开呢？ </p><p>AOP 要做的就是将日志代码全部抽象出去统一进行处理，计算器方法中只保留核心的业务代码。做到核心业务和非业务代码的解耦合。</p><p><img src="/2022/06/15/Spring%E6%A1%86%E6%9E%B6/image-20220624131911703.png" alt="image-20220624131911703" style="zoom:40%;"></p><p><img src="/2022/06/15/Spring%E6%A1%86%E6%9E%B6/image-20220624132501714.png" alt="image-20220624132501714" style="zoom:40%;"></p><ol><li><p>创建切面类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">LogAspect</span> &#123;</span><br><span class="line">    <span class="meta">@Before(&quot;execution(public int CalculateImpl.sub(..))&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint joinpoint)</span>&#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> joinpoint.getSignature().getName();</span><br><span class="line">        System.out.println(<span class="string">&quot;Func_&quot;</span> + name + <span class="string">&quot; : &quot;</span> + joinpoint.getArgs().toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 因为切面无法直接获取函数的内部的数据，所以我们需要添加一个映射</span></span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;execution(public int CalculateImpl.sub(..))&quot;, returning = &quot;result&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(JoinPoint joinPoint, Object result)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Result : &quot;</span> + result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>实现类添加 <code>@Component</code> 注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CalculateImpl</span> <span class="keyword">implements</span> <span class="title class_">Calculate</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> &#123;</span><br><span class="line">        <span class="comment">//System.out.println(&quot;Func_add : &quot; + num1 + &quot; + &quot; + num2);    // 日志打印</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> num1 + num2;                                   <span class="comment">// 业务代码</span></span><br><span class="line">        <span class="comment">//System.out.println(&quot;Result : &quot; + result);                   // 日志打印</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></li><li><p>配置配置文件：自动扫包 + 开启自动生成代理</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 自动扫包(寻找@注解) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;fr.spring_aop.gdai&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启自动生成代理 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">aop:aspectj-autoproxy</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:aspectj-autoproxy</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>TODO</code></p></li></ol><h3 id="Spring注解开发"><a href="#Spring注解开发" class="headerlink" title="Spring注解开发"></a>Spring注解开发</h3><p>Spring是<u>轻代码而重配置</u>的框架，配置比较繁重，影响开发效率，所以注解开发是一种趋势，注解代替xml配置文件可以简化配置，提高开发效率。</p><div class="table-container"><table><thead><tr><th style="text-align:center">注解</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center"><code>@Component</code></td><td style="text-align:center">使用在类上用于实例化Bean</td></tr><tr><td style="text-align:center"><code>@Controller</code></td><td style="text-align:center">使用在web层类上用于实例化Bean</td></tr><tr><td style="text-align:center"><code>@Service</code></td><td style="text-align:center">使用在service层类上用于实例化Bean</td></tr><tr><td style="text-align:center"><code>@Repository</code></td><td style="text-align:center">使用在dao层类上用于实例化Bean</td></tr><tr><td style="text-align:center"><code>@Autowired</code></td><td style="text-align:center">使用在字段上用于根据【类型】依赖注入</td></tr><tr><td style="text-align:center"><code>@Qualifier</code></td><td style="text-align:center">结合<code>@Autowired</code>一起使用用于根据【名称】进行依赖注入</td></tr><tr><td style="text-align:center"><code>@Resource</code></td><td style="text-align:center">相当于<code>@Autowired + @Qualifier</code>，按照【名称】进行注入</td></tr><tr><td style="text-align:center"><code>@Value</code></td><td style="text-align:center">注入普通属性</td></tr><tr><td style="text-align:center"><code>@Scope</code></td><td style="text-align:center">标注Bean的作用范围</td></tr><tr><td style="text-align:center"><code>@PostConstruct</code></td><td style="text-align:center">使用在方法上标注该方法是Bean的初始化方法</td></tr><tr><td style="text-align:center"><code>@PreDestroy</code></td><td style="text-align:center">使用在方法上标注该方法是Bean的销毁方法</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"></td></tr></tbody></table></div>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Spring-简介&quot;&gt;&lt;a href=&quot;#Spring-简介&quot; class=&quot;headerlink&quot; title=&quot;Spring 简介&quot;&gt;&lt;/a&gt;Spring 简介&lt;/h3&gt;&lt;p&gt;Spring 是&lt;u&gt;分层的&lt;/u&gt; Java SE/EE 应用轻量级全栈开源框架，以 &lt;u&gt;IoC&lt;/u&gt;（反转控制）和&lt;u&gt;AOP&lt;/u&gt;（面向切面编程）为内核。&lt;/p&gt;
&lt;p&gt;提供了&lt;u&gt;展现层&lt;/u&gt; Spring MVC和&lt;u&gt;持久层&lt;/u&gt; Spring JDBCTemplate 以及&lt;u&gt;业务层&lt;/u&gt;事务管理等众多的企业级应用技术，还能整合开源世界众多著名的第三方框架和类库，逐渐成为使用最多的Java EE 企业应用开源框架。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://dave0126.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://dave0126.github.io/tags/Java/"/>
    
    <category term="Spring" scheme="https://dave0126.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>计算复杂性理论</title>
    <link href="https://dave0126.github.io/2022/06/14/%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E6%80%A7%E7%90%86%E8%AE%BA/"/>
    <id>https://dave0126.github.io/2022/06/14/%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E6%80%A7%E7%90%86%E8%AE%BA/</id>
    <published>2022-06-14T18:49:07.000Z</published>
    <updated>2022-06-27T11:09:43.231Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Calculabilite-et-Complexite-计算复杂性理论"><a href="#Calculabilite-et-Complexite-计算复杂性理论" class="headerlink" title="Calculabilité et Complexité (计算复杂性理论)"></a>Calculabilité et Complexité (计算复杂性理论)</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>本文章是根据法国国立高等电力技术、电子学、计算机、水力学与电信学校 (E.N.S.E.E.I.H.T.) 第八学期课程“Calculabilité et Complexité”总结而来的课程笔记。碍于本人学识有限，部分叙述难免存在纰漏，请读者注意甄别。</p><p>参考：</p><ul><li>《计算复杂性理论》- 陈健二教授（广州大学）</li></ul><span id="more"></span><hr><p>我们在研究一个问题的复杂度之前，首先需要研究这个问题能否使用计算机解决（可计算性）。</p><p>什么是问题？</p><ul><li>函数问题：给定一个字符串 $\Sigma_<em>$ 作为输入，经过 $f$ 后输出另一个字符串 $\Sigma_</em>$ </li></ul><script type="math/tex; mode=display">f: \Sigma_* \to \Sigma_*</script><ul><li>决策问题：给定一个字符串 $\Sigma_*$ 作为输入，输出为 $\{_{yes} = 1,\quad _{no} = 0\}$ </li></ul><script type="math/tex; mode=display">f: \Sigma_* \to \{_{yes} = 1,\quad _{no} = 0\}</script><p>实际上可以将字符串集合 $\Sigma_*$ 分成两部分：“yes”的集合和“no”的集合</p><h3 id="图灵机"><a href="#图灵机" class="headerlink" title="图灵机"></a>图灵机</h3><p>图灵机是一个虚拟的机器，由数学家阿兰·图灵1936年提出来的，尽管这个机器很简单，但它可以模拟计算机的任何算法，无论这个算法有多复杂。</p><p>图灵机实际上是解决一个具体问题的程序（算法）</p><p><img src="/2022/06/14/%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E6%80%A7%E7%90%86%E8%AE%BA/image-20220614215904021.png" alt="image-20220614215904021" style="zoom:45%;"></p><p>上面是一个图灵机的简单示意图。</p><ul><li>有限控制器：所谓有限是指该，控制器不随输入的长度变化而变化。对应计算机的CPU</li><li>无穷的纸带：纸带就像一个计算机的存储器一样。纸带上面的每个格子是空白的，但是可以读写数据</li><li>读写头：可以向纸带读取或写入数据的指针</li></ul><p>可以用如下六元组定义该图灵机</p><script type="math/tex; mode=display">\mathcal{M} = ⟨Q,\Sigma,\delta,q_s,q_{accept},q_{reject}⟩</script><ul><li><p>$Q$ 表示所有状态的集合</p></li><li><p>$\Sigma$ 表示字符集，即纸带上只允许出现的字符。例如现代二进制计算机中 $\Sigma = \{0,1\}$ </p></li><li><p>$\delta$  是函数，表示该图灵机的每一步该怎么做</p><script type="math/tex; mode=display">\delta : Q \times \Sigma \to Q \times \Sigma \times \{L,R,-\}</script><ul><li>输入：当时的状态 $Q$ 、指针所指的字符 $\Sigma$ </li><li>输出：函数变化后的状态 $Q$ 和字符 $\Sigma$ 、指针运动的方向（L左，R右，-不动）</li></ul></li><li><p>$q_s \in Q$，表示初始状态</p></li><li><p>$q_{accept} \in Q$，表示停机状态为接受状态，判断为真</p></li><li><p>$q_{reject} \in Q$，表示停机状态为拒绝状态，判断为假</p></li></ul><blockquote><p>【例】</p><p>创建一个图灵机以满足</p><p>输入：X # Y $: X,Y \in \{二进制数\}$</p><p>输出：当 $X = Y$ 时 accept</p><p><img src="/2022/06/14/%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E6%80%A7%E7%90%86%E8%AE%BA/image-20220614222852897.png" alt="image-20220614222852897" style="zoom:45%;"></p><ul><li>$\mathcal{M} = ⟨Q,\Sigma,\delta,q_s,q_{accept},q_{reject}⟩$</li><li>$Q = \{ q_s, q_0, q_1, q_2, q_3, q_4, q_{accept}, q_{reject}\}$</li><li>$\Sigma =$ {0, 1, #, $, _}</li><li>$\delta (Q, \Sigma) = (Q, \Sigma, \{L,R,-\})$ </li></ul><p><img src="/2022/06/14/%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E6%80%A7%E7%90%86%E8%AE%BA/image-20220614230542405.png" alt="image-20220614230542405" style="zoom:50%;"></p></blockquote><h4 id="多纸带图灵机"><a href="#多纸带图灵机" class="headerlink" title="多纸带图灵机"></a>多纸带图灵机</h4><p><img src="/2022/06/14/%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E6%80%A7%E7%90%86%E8%AE%BA/image-20220614232343042.png" alt="image-20220614232343042" style="zoom:45%;"></p><p>也可以用如下六元组定义该图灵机</p><script type="math/tex; mode=display">\mathcal{M} = ⟨Q,\Sigma^k,\delta,q_s,q_{accept},q_{reject}⟩</script><ul><li><p>$Q$ 表示所有状态的集合</p></li><li><p>$\Sigma$ 表示字符集，即每个纸带上只允许出现的字符。</p></li><li><p>$\delta$  是函数，表示该图灵机的每一步该怎么做</p><script type="math/tex; mode=display">\delta : Q \times \Sigma^k \to Q \times \Sigma^k \times \{L,R,-\}^k</script></li><li><p>$q_s \in Q$，表示初始状态</p></li><li>$q_{accept} \in Q$，表示停机状态为接受状态，判断为真</li><li>$q_{reject} \in Q$，表示停机状态为拒绝状态，判断为假</li></ul><p>上述的多纸带图灵机可以组合成如下的单纸带图灵机</p><p><img src="/2022/06/14/%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E6%80%A7%E7%90%86%E8%AE%BA/image-20220614233213216.png" alt="image-20220614233213216" style="zoom:50%;"></p><p>可以引入符号 $\underline{x}$ 来表示在原来多纸带图灵机中每个指针指向当前字符的位置。</p><ol><li>遍历整个纸带。$O(t(n))$</li><li>找到符号 $\underline{x}$ 进行操作。$O(t(n)) \times O(t(n))$</li></ol><h4 id="Church-公理"><a href="#Church-公理" class="headerlink" title="Church 公理"></a>Church 公理</h4><blockquote><p>Everything we can compute on a physical computer can be comptued on a Turing Machine.</p></blockquote><p>所有的计算模型能做的事情都是一样的，没有任何一个模型能力比图灵机强，只是时间快慢不同。</p><script type="math/tex; mode=display">图灵机 = 任何计算机上的程序 = 算法</script><h3 id="可计算性理论"><a href="#可计算性理论" class="headerlink" title="可计算性理论"></a>可计算性理论</h3><p>根据 Church 公理，我们想要研究一个问题是否是可计算的，我们只需要研究在图灵机上的可计算性。</p><p>一个语言 $\mathcal{L}$ 是可以被图灵机所枚举（enumerate）的，如果存在一个图灵机 $\mathcal{M}$，使得输入是 $\mathcal{L}$ 中的串时， $\mathcal{M}$ 输出“接受”；而对非 $\mathcal{L}$ 中的串， $\mathcal{M}$ 输出“拒绝”或<strong>不停机</strong>。</p><p>而一个语言 $\mathcal{L’}$ 是可以被图灵机所决定（decide）的，如果存在一个图灵机 $\mathcal{M’}$，使得输入是 $\mathcal{L}$ 中的串时， $\mathcal{M}$ 输出“接受”；而对非 $\mathcal{L}$ 中的串， $\mathcal{M}$ 输出“拒绝”。注意这里的区别在于，对于图灵机决定的语言，我们需要在所有输出上，该图灵机都要停机。</p><blockquote><p><strong>Definition</strong></p><p>An algorithm (or a program or a Turing Machine) $\mathcal{A}$ solves a (desicion) problem $Q$ if on every input $x$, the algorithm $\mathcal{A}(x)$ halts (with an answer yes/no) </p><p>一个算法 $\mathcal{A}$ 解决了一个（判断性）问题 $Q$，对于任何一个输入，算法都可以停机（给出一个结果 yes/no）</p></blockquote><p>一个问题 $Q$ 是可解的 (solvable/computable/recursive)当且仅当该问题可以被一个算法 $\mathcal{A}$ 解决。</p><h4 id="停机问题-Halting-Problem"><a href="#停机问题-Halting-Problem" class="headerlink" title="停机问题 (Halting Problem)"></a>停机问题 (Halting Problem)</h4><p>停机问题就是判断任意一个程序是否会在有限的时间之内结束运行的问题。</p><p>该问题等价于如下的判定问题：给定一个算法 $\mathcal{A}$ 和输入 $w$，算法 $\mathcal{A}$ 在输入 $w$ 下是否能够最终停止。</p><blockquote><p>该问题不是可解的 (not solvable)，即不存在一个算法 $\mathcal{A}$ 可以判断“另一算法 $\mathcal{A’}$ 是否可以停机”，且算法 $\mathcal{A}$ 也可以停机。</p></blockquote><h5 id="证明1"><a href="#证明1" class="headerlink" title="证明1"></a>证明1</h5><p><strong>对角化(Diagonalization)</strong></p><p><img src="/2022/06/14/%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E6%80%A7%E7%90%86%E8%AE%BA/image-20220624215224140.png" alt="image-20220624215224140" style="zoom:50%;"></p><p>在上图中，所有的图灵机集合 $\mathcal{TMs}$ 是可数集合（可以列在上图中）；同样的，无穷多的输入集合 $inputs$ 也是可数集合。每个方格意为图灵机 $\mathcal{M}_i$ 在输入为 $x_j$ 的情况下是否可以停机。虽然我们无法确定其是否可以停机，但是否停机一定有一个明确的答案。</p><p>我们假设存在一个图灵机 $\mathcal{M}$ 可以判断“另一个图灵机 $\mathcal{M’}$ 在是输入为 $x_i$ 时是否可以停机”，则对于图灵机 $\mathcal{M}$，我们考虑上图中的对角线元素 $\mathcal{M}(\mathcal{M’}_i, \; x_i)$：</p><p>⚠️ 请注意区分图灵机 $\mathcal{M}$ 和图灵机 $\mathcal{M’}$ 的区别</p><ul><li>输入：另一个图灵机 $\mathcal{M’}_i$ 及其输入 $x_i$ ，</li><li><p>我们假设一个图灵机 $\mathcal{M}^*$ ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if M*(M_i,x_i) == &quot;yes&quot;</span><br><span class="line">then dead_looping; // M不停机</span><br><span class="line">else return &quot;yes&quot;; // M停机</span><br><span class="line">halts;</span><br><span class="line">// 即图灵机M*与M_i的结果相反</span><br></pre></td></tr></table></figure></li></ul><p>因为图灵机 $\mathcal{M}^{*}$ 至少与每一个图灵机 $\mathcal{M}_{i}$ 至少存在一个结果是不同的，</p><p>所以图灵机 $\mathcal{M}^{*}$ 不在图灵机集合 $\mathcal{TMs}$ 中，与假设相悖。</p><h5 id="证明2"><a href="#证明2" class="headerlink" title="证明2"></a>证明2</h5><p>我们仍然假设存在一个图灵机 $\mathcal{M}$ 可以判断“另一个图灵机 $\mathcal{M’}$ 在是输入为 $x$ 时是否可以停机”，则对于图灵机 $\mathcal{M}$：</p><script type="math/tex; mode=display">\mathcal{M}(\mathcal{M'},x) = \begin{cases}accept \quad \text{if } \mathcal{M'} \text{ halts on } x \\reject \quad \text{otherwise}\end{cases}</script><p>我们考虑如下自我停机问题：</p><script type="math/tex; mode=display">\mathcal{M}(\mathcal{M},x)</script><p>后略。</p><blockquote><p><strong>Definition</strong></p><p>令 $Q_1$ 和 $Q_2$ 是两个决策性问题，我们说 $Q_1$ 是规约 (reducible) 到 $Q_2$ 的，$Q_1 \le Q_2$，即 $Q_1$ 不比 $Q_2$ 难。如果我们可以找到一个永远可以停机的算法 $\mathcal{A}$ 当输入为 $x$ 时算法输出 $\mathcal{A}(x)$ 是 $Q_1$ 的 “yes”，则 $\mathcal{A}(x)$ 也是 $Q_2$ 的 “yes”。</p><p><strong>Lemma</strong></p><ul><li>如果 $Q_2$ 是可解的，则 $Q_1$ 也是可解的</li><li>如果 $Q_1$ 是不可解的，则 $Q_2$ 也是不可解的</li></ul></blockquote><h4 id="全接受问题-Accept-All-Problem"><a href="#全接受问题-Accept-All-Problem" class="headerlink" title="全接受问题 (Accept-All Problem)"></a>全接受问题 (Accept-All Problem)</h4><ul><li>输入：图灵机 $\mathcal{M}$ </li><li>问题：图灵机 $\mathcal{M}$ 是否能接受 (accept) 所有 $inputs$ ？</li></ul><script type="math/tex; mode=display">Q_{Halting} \le Q_{Accpet-All}</script><p>所以全接受问题也是不可解的</p><h4 id="等价程序问题-Program-Equivalence-Problem"><a href="#等价程序问题-Program-Equivalence-Problem" class="headerlink" title="等价程序问题 (Program-Equivalence Problem)"></a>等价程序问题 (Program-Equivalence Problem)</h4><ul><li>输入：两个图灵机 $\mathcal{M}_1$ 和 $\mathcal{M}_2$ </li><li>问题： $\mathcal{M}_1$ 和 $\mathcal{M}_2$ 是否做相同的事情 (function)</li></ul><p>我们已知停机问题是不可解的，全接受问题也是不可解的。</p><p>我们假设一种特殊情况，即图灵机 $\mathcal{M}_0$ 接受所有输入 $inputs$，有：</p><script type="math/tex; mode=display">Q_{Accpet-All}(\mathcal{M}) \le Q_{Prog-Equ}(\mathcal{M}, \mathcal{M_0})</script><ul><li>如果图灵机 $\mathcal{M}$ 处理全接受问题，则 $\mathcal{M}$ 和 $\mathcal{M}_0$ 是等价程序</li><li>如果图灵机 $\mathcal{M}$ 不是处理全接受问题的，则 $\mathcal{M}$ 和 $\mathcal{M}_0$ 不是等价的</li></ul><p>而全接受问题是不可解的，所以等价程序问题也是不可解的。</p><h3 id="复杂度理论"><a href="#复杂度理论" class="headerlink" title="复杂度理论"></a>复杂度理论</h3><h4 id="推广Church-公理"><a href="#推广Church-公理" class="headerlink" title="推广Church 公理"></a>推广Church 公理</h4><blockquote><p>Everything we can compute <u>in time $t(n)$</u> (<em>in space $O(s(n))$</em>) on a physical computer can be comptued on a 1-tape Turing Machine <u>in time $t^{O(1)}(n)$</u> <em>(in space $O(s(n))$)</em>.</p></blockquote><p>如果在计算机上做某一件事所花费的时间是 $t(n)$、所占空间是 $O(s(n))$，那么在单纸带图灵机上所花费的时间是多项式时间 $t^{O(1)}(n)$、所占空间是 $O(s(n))$，并不会相差太多。</p><h4 id="时空间复杂性"><a href="#时空间复杂性" class="headerlink" title="时空间复杂性"></a>时空间复杂性</h4><p>复杂性理论所研究的资源中最常见的是时间（要通过多少步演算才能解决问题）和空间（在解决问题时需要多少内存）。</p><h4 id="时间复杂度-TIME-t-n-："><a href="#时间复杂度-TIME-t-n-：" class="headerlink" title="时间复杂度 $TIME(t(n))$ ："></a>时间复杂度 $TIME(t(n))$ ：</h4><p>是指在计算机科学与工程领域完成一个算法所需要的时间，是衡量一个算法优劣的重要参数。时间复杂度越小，说明该算法效率越高，则该算法越有价值。</p><h6 id="确定的时间复杂度-DT-IME"><a href="#确定的时间复杂度-DT-IME" class="headerlink" title="确定的时间复杂度 $DT_{IME}$"></a>确定的时间复杂度 $DT_{IME}$</h6><p>对于一个【确定性】的图灵机，我们可以给出其常见的几种 【(确定的)时间复杂度 $DT_{IME}$】：</p><ul><li>$\mathcal{P}$ 问题类的 (确定的) 时间复杂度 $DT_{IME}$：</li></ul><blockquote><p><strong>Definition</strong></p><script type="math/tex; mode=display">\mathcal{P} \triangleq \bigcup_{k \in \mathbb{N}} DT_{IME}(n^k)</script><p>即 $\mathcal{P}$ 问题的时间复杂度是<u>【确定性】图灵机</u>的<u>多项式时间复杂度</u>，$\mathcal{P}$ 问题可在多项式时间解决（在很快的时间内解决），$\mathcal{P}$ 问题是易解 (feasible) 问题</p></blockquote><ul><li>$\mathsf{ETIME}$ 指数时间</li></ul><script type="math/tex; mode=display">\mathsf{ETIME} \triangleq \bigcup_{k \in \mathbb{N}} DT_{IME}(2^{kn})</script><ul><li>$\mathsf{EXPTIME}$ 指数时间</li></ul><script type="math/tex; mode=display">\mathsf{EXPTIME} \triangleq \bigcup_{k \in \mathbb{N}} DT_{IME}(2^{n^k})</script><blockquote><p><strong>结论</strong></p><script type="math/tex; mode=display">\mathcal{P} \subsetneq \mathsf{ETIME} \subsetneq \mathsf{EXPTIME}</script><ul><li>$\mathcal{P}$ <u>包含在但不等于</u> $ET_{IME}$ <u>包含在但不等于</u> $\mathsf{EXPTIME}$</li></ul></blockquote><h6 id="非确定的时间复杂度-NT-IME"><a href="#非确定的时间复杂度-NT-IME" class="headerlink" title="非确定的时间复杂度 $NT_{IME}$"></a>非确定的时间复杂度 $NT_{IME}$</h6><p>将在 <a href="####非确定性 (Non-determinism">非确定性</a>) 章节讨论。</p><p>对于一个决策性问题 $\mathcal{L}$，我们有如下要求：</p><blockquote><ol><li>写一个可以解决问题 $\mathcal{L}$ 的程序</li><li>证明这个程序是最优的（目前学界并没有数学上严格的证明）</li></ol></blockquote><p>为了尽量满足<u>要求 2</u>，我们做出了如下妥协措施：</p><ul><li>我们引入了【规约 (reductions) 】来比较问题的难度</li><li>我们依照【完整性 (completeness) 】来找出难问题</li></ul><h4 id="非确定性-Non-determinism"><a href="#非确定性-Non-determinism" class="headerlink" title="非确定性 (Non-determinism)"></a>非确定性 (Non-determinism)</h4><p>之前我们讲到的图灵机，实际上是在模拟人类的思考方式。</p><p>对于一个图灵机 $\mathcal{M} = ⟨Q,\Sigma,\delta,q_s,q_{accept},q_{reject}⟩$，我们在每一个给定的状态下都有<u>唯一一个确定的 $\delta$</u> 将当前状态转变为下一状态：$\delta (q_0, a_0) = (q_1, a_1, \{L,R,-\})$ 。</p><p>但是人类的思考具有不确定性（所谓“突发灵感”），但是图灵机无法模拟这种不确定性行为。</p><p>我们希望计算机也有这种特性，即每当计算机面临选择时，我们将不同的选择列出，而让计算机选择一种“最好”的方式执行。</p><p>譬如当我们在下棋时，我们经常没办法具体解释落子的原因，我们希望计算机可以选择一种“最好”的方式执行。</p><p>回顾 <em>带权图的最短路径问题</em>：</p><blockquote><p>给定一个带权图 $G$，两个顶点 $s$ 和 $t$，以及一个数 $k$，问：我们是否能在图中找到一条路径，使得 $s-t$ 的权值之和 $\le k$？</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 我们假设计算机每次可以找到一条最优路径，其权重为h</span></span><br><span class="line">v_0 = s;</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">1</span>; i&lt;=h; i++)</span><br><span class="line"><span class="comment">// 假设计算机可以&quot;神奇地&quot;找到一个最优的顶点v_i</span></span><br><span class="line">  <span class="keyword">for</span> (j=<span class="number">1</span>; j&lt;=h; j++) &#123;ok1 = check [v[i<span class="number">-1</span>], v[i]] is an edge&#125;</span><br><span class="line">  ok2 = check (v_h == t);</span><br><span class="line">  ok3 = check (sum(weight(v[i], v[i+<span class="number">1</span>])) &lt;= k);</span><br><span class="line">  ok =  (ok1 &amp;&amp; ok2 &amp;&amp; ok3)</span><br><span class="line">  <span class="keyword">if</span> (ok)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;no&#x27;</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">&#x27;yes&#x27;</span></span><br><span class="line"><span class="comment">// ok, ok1, ok2, ok3 是四个决策性问题，它们很容易解决且是确定的，而不借助&quot;神奇的能力&quot;</span></span><br></pre></td></tr></table></figure><p>那么计算机如何”神奇地”找到一个最优的顶点 $v_i$ 呢？</p><p><img src="/2022/06/14/%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E6%80%A7%E7%90%86%E8%AE%BA/image-20220624235014413.png" alt="image-20220624235014413" style="zoom:50%;"></p><p>或用二叉树表示（非确定性图灵机面临的选择不超过两个）：</p><p><img src="/2022/06/14/%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E6%80%A7%E7%90%86%E8%AE%BA/image-20220625002222487.png" alt="image-20220625002222487" style="zoom:50%;"></p><p>⚠️注意：这里并不是“计算机遍历所有分支然后选择一条最优路径”而是“我们的计算机有一种特殊的能力，可以直接选择一个最优路径”。</p><p>对于一个【确定性】的图灵机：</p><script type="math/tex; mode=display">\begin{aligned}& \delta (q_0, a_0) = (q_1, a_1, V_1) \\& \text{(是唯一且确定的)}\end{aligned}</script><p>对于一个【非确定性】的图灵机：</p><script type="math/tex; mode=display">\begin{aligned}& \delta (q_0, a_0) = (q_1, a_1, V_1) \\& \delta (q_0, a_0) = (q_2, a_2, V_2)\\& ... \\& \delta (q_i, a_i) = (q_i, a_i, V_i), i \in C\\& \text{(不是唯一且确定的)}\end{aligned}</script><blockquote><p><strong>Theorem.</strong></p><p>在不考虑时间因素的前提下（有效时间*），一个“有神秘能力的”计算机能做的事也<u>可以</u>在一个“没有神秘能力的”计算机上解决。</p><p>而在考虑时间因素下（有效时间*），一个“有神秘能力的”计算机能做的事 <u>有时可以</u> 在一个“没有神秘能力的”计算机上解决 (UNKNOWN)。</p></blockquote><p>【*有效时间】是多项式时间，即算法的运行时间是 $O(n^c)$，其中 $c$ 是常数。</p><h5 id="非确定的时间复杂度-NT-IME-1"><a href="#非确定的时间复杂度-NT-IME-1" class="headerlink" title="非确定的时间复杂度 $NT_{IME}$"></a>非确定的时间复杂度 $NT_{IME}$</h5><ul><li>$\mathcal{NP}$ 问题类时间复杂度</li></ul><script type="math/tex; mode=display">\mathcal{NP} \triangleq \bigcup_{k \in \mathbb{N}} NT_{IME}(n^k)</script><blockquote><p>即 $\mathcal{NP}$ 问题的时间复杂度是<u>【非确定性】图灵机</u>的<u>多项式时间复杂度</u>。</p></blockquote><ul><li>$\mathsf{NEXPTIME}$ 指数时间</li></ul><script type="math/tex; mode=display">\mathsf{NEXPTIME} \triangleq \bigcup_{k \in \mathbb{N}} NT_{IME}(2^{kn})</script><blockquote><p><strong>结论</strong></p><ul><li><script type="math/tex; mode=display">\mathcal{P} \; \subseteq \; \mathcal{NP} \; \subseteq \; \mathsf{EXPTIME} \; \subseteq \; \mathsf{NEXPTIME}</script></li><li><script type="math/tex; mode=display">\mathcal{P} \; \subsetneq \; \mathsf{EXPTIME} \qquad \mathcal{NP} \; \subsetneq \; \mathsf{NEXPTIME}</script></li><li><script type="math/tex; mode=display">\mathcal{P} \overset{\underset{\mathrm{?}}{}}{=} \mathcal{NP}</script></li><li><script type="math/tex; mode=display">\mathcal{NP} \overset{\underset{\mathrm{?}}{}}{=} \mathsf{EXPTIME}</script></li><li><script type="math/tex; mode=display">EXPT_{IME} \overset{\underset{\mathrm{?}}{}}{=} \mathsf{NEXPTIME}</script></li></ul></blockquote><h4 id="mathcal-P-overset-underset-mathrm-mathcal-NP-问题"><a href="#mathcal-P-overset-underset-mathrm-mathcal-NP-问题" class="headerlink" title="$\mathcal{P} \overset{\underset{\mathrm{?}}{}}{=} \mathcal{NP}$ 问题"></a>$\mathcal{P} \overset{\underset{\mathrm{?}}{}}{=} \mathcal{NP}$ 问题</h4><blockquote><p>在有效时间下，一个“有神秘能力的”计算机能做的事是否可以在一个“没有神秘能力的”计算机上解决？</p></blockquote><p><em>等价于</em></p><blockquote><p>一个（判断性）问题如果在【非确定性图灵机】上有效时间内可解，该问题是否可以在一个【确定性图灵机】上有效时间内可解？</p></blockquote><p><em>等价于</em></p><blockquote><script type="math/tex; mode=display">\mathcal{P} \overset{\underset{\mathrm{?}}{}}{=} \mathcal{NP}</script></blockquote><ul><li>$P$：Polynomial Time 可解</li><li>$NP$：Non-determinism Polynomial</li></ul><h5 id="mathcal-P-问题与-mathcal-NP-问题"><a href="#mathcal-P-问题与-mathcal-NP-问题" class="headerlink" title="$\mathcal{P}$ 问题与 $\mathcal{NP}$ 问题"></a>$\mathcal{P}$ 问题与 $\mathcal{NP}$ 问题</h5><blockquote><ul><li><p>$\mathcal{P}$ 问题类（判断性问题）可在【确定性图灵机】上【多项式时间】内解决（在很快的时间内解决），$\mathcal{P}$ 问题是易解 (feasible) 问题</p><p><code>the class of (decision) problems that can be solved by polynomial-time [nondeterministic] algorithms(Turing Machines)</code></p></li></ul><ul><li><p>$\mathcal{NP}$ 问题类（判断性问题）可在【非确定性图灵机】上【多项式时间】内解决</p><p><code>the class of (decision) problems that can be solved by polynomial-time [deterministic] algorithms(Turing Machines)</code></p></li></ul></blockquote><p>以下<strong>推论</strong>都是等价的</p><ul><li><p>一个“没有神秘能力的”计算机能做的事可以在一个“有神秘能力的”计算机上解决</p></li><li><p>在【非确定性图灵机】上可以做【确定性图灵机】能做的事</p></li><li><p>【确定性图灵机】不会比【非确定性图灵机】更强</p></li><li><p>所有属于 $\mathcal{P}$ 的问题都是属于 $\mathcal{NP}$ 的</p></li><li><script type="math/tex; mode=display">\mathcal{P} \subseteq \mathcal{NP} \qquad \text{①}</script></li></ul><p>反言之，如果：</p><ul><li><p>一个“有神秘能力的”计算机能做的事可以在一个“没有神秘能力的”计算机上解决</p></li><li><p>在【确定性图灵机】上可以做【非确定性图灵机】能做的事</p></li><li><p>所有属于 $\mathcal{NP}$ 的问题都是属于 $\mathcal{P}$ 的</p></li><li><script type="math/tex; mode=display">\mathcal{NP} \subseteq \mathcal{P} \qquad \text{②}</script></li></ul><p>如果满足以上两点，我们可以推出：</p><script type="math/tex; mode=display">{① + ②} \quad \Rightarrow \quad \mathcal{P} = \mathcal{NP} \quad \text{无人可知是否成立}</script><h6 id="如果-mathcal-P-mathcal-NP-成立"><a href="#如果-mathcal-P-mathcal-NP-成立" class="headerlink" title="如果 $\mathcal{P} = \mathcal{NP}$ 成立"></a>如果 $\mathcal{P} = \mathcal{NP}$ 成立</h6><ul><li>优点：很多工程上很重要的优化问题都可以用计算机解决</li><li>缺点：所有的密码系统都会被破解</li></ul><h5 id="货郎搬运-Traveling-Salesman-问题"><a href="#货郎搬运-Traveling-Salesman-问题" class="headerlink" title="货郎搬运 (Traveling Salesman)问题"></a>货郎搬运 (Traveling Salesman)问题</h5><p>在有权图 $G$ 中找到一条路径，每个点只经过一次，要求权值之和为最小 ($\le k$)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n; i++)</span><br><span class="line">  <span class="comment">// 假设计算机可以&quot;神奇地&quot;找到一个最优的顶点v[i];</span></span><br><span class="line"><span class="number">2.</span> check that all vertices picked in step1 are different;</span><br><span class="line"><span class="number">3.</span> <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=n<span class="number">-1</span>; i++)&#123;</span><br><span class="line">  check [v[i], v[i+<span class="number">1</span>]] is an edge;&#125;</span><br><span class="line"><span class="number">4.</span> check (sum(weight(v[i], v[i+<span class="number">1</span>])) &lt;= k);</span><br><span class="line"><span class="number">5.</span> <span class="keyword">if</span> (any test in steps <span class="number">2</span><span class="number">-4</span> fails)</span><br><span class="line">  then <span class="title function_">return</span> <span class="params">(<span class="string">&#x27;no&#x27;</span>)</span></span><br><span class="line">  <span class="keyword">else</span> <span class="title function_">return</span> <span class="params">(<span class="string">&#x27;yes&#x27;</span>)</span></span><br></pre></td></tr></table></figure><h5 id="可满足性-SAT-问题"><a href="#可满足性-SAT-问题" class="headerlink" title="可满足性 (SAT) 问题"></a>可满足性 (SAT) 问题</h5><p>给定一个<a href="https://zh.m.wikipedia.org/zh-hans/合取范式">合取范式</a> $F$，问 $F$是否可满足 ($F = 1$)？</p><p>即找到一组 $X={x_1,x_2,x_3,…,x_n}$ 的取值，使得 $F = 1$。</p><script type="math/tex; mode=display">\begin{aligned}F = & \quad (\neg x_1 \lor x_2 \lor x_5 \lor \neg x_4)\\  & \land (x_1 \lor x_6 \lor x_5 \lor  x_4)\\  & \land (\neg x_5 \lor x_4 \lor \neg x_2)\\ & \land (x_3 \lor \neg x_4)\\ & \land (x_1 \lor \neg x_3 \lor x_6)\\ \end{aligned}</script><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">for</span> (each variable x_i in F)</span><br><span class="line">  <span class="comment">// 假设计算机每次都可以&quot;神奇地、正确地&quot;判断出x_i的值是0还是1;</span></span><br><span class="line"><span class="number">2.</span> <span class="keyword">if</span> (the assignment constructed in step1 makes F=<span class="number">1</span>)</span><br><span class="line">  then <span class="title function_">return</span> <span class="params">(<span class="string">&#x27;yes&#x27;</span>)</span></span><br><span class="line">    <span class="keyword">else</span> <span class="title function_">return</span> <span class="params">(<span class="string">&#x27;no&#x27;</span>)</span></span><br></pre></td></tr></table></figure><h5 id="调度问题-Scheduling"><a href="#调度问题-Scheduling" class="headerlink" title="调度问题 (Scheduling)"></a>调度问题 (Scheduling)</h5><p>我们假设有两个机器 $M_1, M_2$，给定一组 $n$ 个工作，其中完成每个工作需要的时间 $T$ 分别是 $t_1, t_2, t_3, …, t_n$。我们该如何调度这两台机器，使得完成这  $n$ 个工作所有时间最短？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">for</span> (each job t_i)</span><br><span class="line">  <span class="comment">// 假设计算机每次都可以&quot;神奇地、正确地&quot;选择出工作t_i可以交给M1或M2机器处理;</span></span><br><span class="line"><span class="number">2.</span> <span class="keyword">if</span> (according by step1, both machines M1 and M2 can finish no later than time T)</span><br><span class="line">  then <span class="title function_">return</span> <span class="params">(<span class="string">&#x27;yes&#x27;</span>)</span></span><br><span class="line"><span class="keyword">else</span> <span class="title function_">return</span> <span class="params">(<span class="string">&#x27;no&#x27;</span>)</span></span><br></pre></td></tr></table></figure><h5 id="独立集问题-Independent-Set"><a href="#独立集问题-Independent-Set" class="headerlink" title="独立集问题 (Independent Set)"></a>独立集问题 (Independent Set)</h5><p>给定一个图 $G$，确定图 $G$ 的独立集中至少包含 $k$ 个顶点。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;=k; i++)&#123;</span><br><span class="line">  <span class="comment">// 假设计算机可以&quot;神奇地&quot;找到一个符合的顶点v[i];</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="number">2.</span> check (all the vertices picked in step1 are different)</span><br><span class="line"><span class="number">3.</span> check (no two vertices picked in step1 are adjacent 邻接的)</span><br><span class="line"><span class="number">4.</span> <span class="keyword">if</span> (any check in step2 and step3 fails)</span><br><span class="line">  then <span class="title function_">return</span> <span class="params">(<span class="string">&#x27;no&#x27;</span>)</span></span><br><span class="line">  <span class="keyword">else</span> <span class="title function_">return</span> <span class="params">(<span class="string">&#x27;yes&#x27;</span>)</span></span><br></pre></td></tr></table></figure><h5 id="【转换】SAT-问题-Leftrightarrow-独立集问题"><a href="#【转换】SAT-问题-Leftrightarrow-独立集问题" class="headerlink" title="【转换】SAT 问题 $\Leftrightarrow$ 独立集问题"></a>【转换】SAT 问题 $\Leftrightarrow$ 独立集问题</h5><h6 id="可满足性-SAT-问题-1"><a href="#可满足性-SAT-问题-1" class="headerlink" title="可满足性 (SAT) 问题"></a>可满足性 (SAT) 问题</h6><p>给定一个<a href="https://zh.m.wikipedia.org/zh-hans/合取范式">合取范式</a> $F$，问 $F$是否可满足 ($F = 1$)？</p><script type="math/tex; mode=display">\begin{aligned}F = & \quad (\neg x_1 \lor x_2 \lor x_5 \lor \neg x_4)\\  & \land (x_1 \lor x_6 \lor x_5 \lor  x_4)\\  & \land (\neg x_5 \lor x_4 \lor \neg x_2)\\ & \land (x_3 \lor \neg x_4)\\ & \land (x_1 \lor \neg x_3 \lor x_6)\\ \end{aligned}</script><h6 id="独立集问题-Independent-Set-1"><a href="#独立集问题-Independent-Set-1" class="headerlink" title="独立集问题 (Independent Set)"></a>独立集问题 (Independent Set)</h6><p>给定一个图 $G$，确定图 $G$ 的独立集中至少包含 $k$ 个顶点。</p><h6 id="转换过程"><a href="#转换过程" class="headerlink" title="转换过程"></a>转换过程</h6><p><img src="/2022/06/14/%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E6%80%A7%E7%90%86%E8%AE%BA/image-20220625144629790.png" alt="image-20220625144629790" style="zoom:50%;"></p><ol><li><p>在 SAT 问题中，对于每一个合取的每一个子句（即每一行括号内的元素），我们都可以用一个【完全图】来表示。</p></li><li><p>不同子句之间的相通元素若互为“非”的关系，则我们将其连接起来。</p><p>例如第一个子句中的 $\neg x_1$ 与第二个子句中的 $x_1$若互为“非”的关系，我们需要将他们连接起来</p></li><li><p>$k = 子句的个数$ 。</p></li><li><p>如果我们可以在图 $G$ 中找到 $k$ 个相互独立的顶点，则“独立集问题”的结果为【yes】</p><p>等价于</p><p>存在一组 $X={x_1,x_2,x_3,…,x_n}$ 的取值，使得 $F = 1$，即可满足性 (SAT) 问题的结果为【yes】。</p></li><li><p>至此，我们就将“可满足性 (SAT) 问题”转化成了“独立集问题”</p></li></ol><p>因此，如果一个独立集问题属于 $\mathcal{P}$ 问题类，那么它也是SAT问题。</p><h4 id="NP-完全-complete-问题"><a href="#NP-完全-complete-问题" class="headerlink" title="NP-完全 (complete) 问题"></a>NP-完全 (complete) 问题</h4><h5 id="多项式时间规约-Polynomial-time-Reduction"><a href="#多项式时间规约-Polynomial-time-Reduction" class="headerlink" title="多项式时间规约 (Polynomial-time Reduction)"></a>多项式时间规约 (Polynomial-time Reduction)</h5><blockquote><p><strong>Definition</strong></p><p>我们有两个决策性问题 $Q_1$ 和 $Q_2$，如果存在一个确定性 (det.) 的多项式时间 (poly-time) 算法 $\mathcal{R}$，使得任何一个问题 $Q_1$ 的实例 $x_1$ 都可以转换成问题 $Q_2$ 的实例 $x_2$ ，以至于 $x_1$ 是问题 $Q_1$ 的“yes”实例，当且仅当 $x_2$ 是问题 $Q_2$ 的“yes”实例。那么我们称，</p><p>一个决策性问题 $Q_1$ 【多项式时间规约】到另一个决策性问题 $Q_2$，记作 $Q_1 \le^{p}_{m} Q_2$，即 $Q_1$ 不比 $Q_2$ 难，$Q_2$ 不比 $Q_1$ 容易。</p><script type="math/tex; mode=display">x_1:Q_1的实例 \quad \xrightarrow[poly-time]{\mathcal{R}} \quad x_2:Q_2的实例</script><p>⚠️注意：这里的“实例 $x$”可以理解为关于问题 $Q$ 的一组“解”。 </p></blockquote><p><img src="/2022/06/14/%E8%AE%A1%E7%AE%97%E5%A4%8D%E6%9D%82%E6%80%A7%E7%90%86%E8%AE%BA/image-20220626084222978.png" alt="image-20220626084222978" style="zoom:45%;"></p><p><strong>性质</strong></p><ul><li>如果 $Q_1 \le^{p}_{m} Q_2$，且 $Q_2$ 属于 $\mathcal{P}$ 问题类，那么 $Q_1$ 也属于 $\mathcal{P}$ 问题类。</li><li>如果 $Q_1 \le^{p}_{m} Q_2$，且 $Q_2$ <u>不</u>属于 $\mathcal{P}$ 问题类，那么 $Q_1$ 也<u>不</u>属于 $\mathcal{P}$ 问题类。</li><li>规约具有传递性： $Q_1 \le^{p}_{m} Q_2$， $Q_2 \le^{p}_{m} Q_3$，则 $Q_1 \le^{p}_{m} Q_3$，</li></ul><h5 id="mathcal-NP-hard"><a href="#mathcal-NP-hard" class="headerlink" title="$\mathcal{NP}-hard$"></a>$\mathcal{NP}-hard$</h5><blockquote><p>对于所有属于 $\mathcal{NP}$ 问题类的问题 $Q’$，如果存在一个问题 $Q$ 满足 $Q’ \le^{p}_{m} Q$，那么问题 $Q$ 不比所有的 $\mathcal{NP}$ 问题简单。我们将问题 $Q$ 称作 $\mathcal{NP}-hard$ 问题类。</p></blockquote><h5 id="mathcal-NP-完全-complete"><a href="#mathcal-NP-完全-complete" class="headerlink" title="$\mathcal{NP}-完全\;complete$"></a>$\mathcal{NP}-完全\;complete$</h5><blockquote><p>如果问题 $Q$ 也属于 $\mathcal{NP}$ 问题类，且满足 $Q’ \le^{p}_{m} Q$，那么问题 $Q$ 就是最难的 $\mathcal{NP}$ 问题。我们将问题 $Q$ 称作 $\mathcal{NP}-完全$ 问题类。即满足以下两个条件：</p><ol><li>问题 $Q$ 属于 $\mathcal{NP}$ 问题类</li><li>$所有\mathcal{NP}问题 \le^{p}_{m} Q$，即 $Q$ 是 $\mathcal{NP}-hard$ 问题</li></ol></blockquote><h6 id="推论"><a href="#推论" class="headerlink" title="推论"></a>推论</h6><blockquote><ul><li>如果任意一个 $\mathcal{NP}-hard$ 问题都属于 $\mathcal{P}$ 问题，那么 $\mathcal{P} = \mathcal{NP}$ </li><li>如果 $\mathcal{P} \ne \mathcal{NP}$，那么没有一个 $\mathcal{NP}-hard$ 问题可以被【确定的多项式时间算法】解决（学界普遍相信）</li><li>如果 $Q_1 \le^{p}_{m} Q_2$ 且 $Q_1$ 是 $\mathcal{NP}-hard$ 问题，那么 $Q_2$ 也是 $\mathcal{NP}-hard$ 问题</li></ul></blockquote><p>例，给出一个“天然的” $\mathcal{NP}-完全$ 问题：</p><blockquote><p><strong>Cook Theorem.</strong></p><p>SAT (可满足) 问题是 $\mathcal{NP}-完全$ 问题。</p><p>证明思路：</p><ol><li>证明问题 $Q$ 是 $\mathcal{NP}-hard$ 问题<ul><li>找到一个已知的 $\mathcal{NP}-完全$ 问题 $Q_1$</li><li>证明 $Q_1 \le^{p}_{m} Q$ </li></ul></li><li>证明问题 $Q$ 属于 $\mathcal{NP}$ 问题</li></ol></blockquote><p><u>可满足问题</u> (SAT)、<u>独立集问题</u> (Independent Set)、<u>顶点覆盖问题</u> (Vertex-Cover)、<u>子集求和问题</u> (Subset Sum)、<u>分区问题</u> (Partition) 都是 $\mathcal{NP}-完全$ 问题。</p><h4 id="空间复杂度-SPACE-s-n-："><a href="#空间复杂度-SPACE-s-n-：" class="headerlink" title="空间复杂度 $SPACE(s(n))$ ："></a>空间复杂度 $SPACE(s(n))$ ：</h4><p>是指计算机科学领域完成一个算法所需要占用的存储空间，一般是输入参数的函数。它是算法优劣的重要度量指标，一般来说，空间复杂度越小，算法越好。我们假设有一个图灵机来解决某一类语言的某一问题，设有 $x$ 个字（word）属于这个问题，把X放入这个图灵机的输入端，这个图灵机为解决此问题所需要的工作带格子数总和称为空间。</p><h5 id="确定的空间复杂度-DS-PACE"><a href="#确定的空间复杂度-DS-PACE" class="headerlink" title="确定的空间复杂度 $DS_{PACE}$"></a>确定的空间复杂度 $DS_{PACE}$</h5><p>类比于时间复杂度，如果存在一台【确定性图灵机】能够在输入为 $x$ 时在 $O(s(n))$ 的空间内判定一个问题 $Q$，那么这个问题属于 $DS_{PACE}(s(n))$ 类。</p><p>对于一个【确定性】的图灵机，我们可以给出其常见的几种 【(确定的)空间复杂度 $DS_{PACE}$】：</p><ul><li>$\mathsf{1SPACE}$：指可以在【常数】空间里就可以被【确定性】图灵机解决的决策性问题（例如自增操作）</li></ul><script type="math/tex; mode=display">\mathsf{1SPACE} \triangleq DS_{PACE}(1)</script><ul><li>$\mathsf{LSPACE}$：指可以在【对数】空间里就可以被【确定性】图灵机解决的决策性问题（例如比较两数）</li></ul><script type="math/tex; mode=display">\mathsf{LSPACE} \triangleq DS_{PACE}(\log(n))</script><ul><li>$\mathsf{PSPACE}$：指可以在【多项式】空间里就可以被【确定性】图灵机解决的决策性问题</li></ul><script type="math/tex; mode=display">\mathsf{PSPACE} \triangleq \bigcup_{k \in \mathbb{N}} DS_{PACE}(n^k)</script><ul><li>$\mathsf{EXPSPACE}$：指可以在【指数】空间里就可以被【确定性】图灵机解决的决策性问题</li></ul><script type="math/tex; mode=display">\mathsf{EXPSPACE} \triangleq \bigcup_{k \in \mathbb{N}} DS_{PACE}(2^{n^k})</script><h5 id="非确定的空间复杂度-NS-PACE"><a href="#非确定的空间复杂度-NS-PACE" class="headerlink" title="非确定的空间复杂度 $NS_{PACE}$"></a>非确定的空间复杂度 $NS_{PACE}$</h5><p>相同的，如果存在一台【非确定性图灵机】能够在输入为 $x$ 时在 $O(s(n))$ 的空间内判定一个问题 $Q$，那么这个问题属于 $NS_{PACE}(s(n))$ 类。</p><script type="math/tex; mode=display">NS_{PACE}(s(n)) \subseteq DS_{PACE}(s(n)^2)</script><ul><li>$\mathsf{NLSPACE}$：指可以在【对数】空间里就可以被【非确定性】图灵机解决的决策性问题（$st-联通度 \text{ CONN}$ 是 $\mathsf{NLSPACE}-\text{complete}$问题 ）</li></ul><script type="math/tex; mode=display">\mathsf{NLSPACE} \triangleq NS_{PACE}(\log(n))</script><ul><li>$\mathsf{NPSPACE}$：指可以在【多项式】空间里就可以被【非确定性】图灵机解决的决策性问题</li></ul><script type="math/tex; mode=display">\mathsf{NPSPACE} \triangleq \bigcup_{k \in \mathbb{N}} NS_{PACE}(n^k) = \mathsf{PSPACE}</script><ul><li>$\mathsf{NEXPSPACE}$：指可以在【指数】空间里就可以被【非确定性】图灵机解决的决策性问题</li></ul><script type="math/tex; mode=display">\mathsf{NEXPSPACE} \triangleq \bigcup_{k \in \mathbb{N}} NS_{PACE}(2^{n^k}) = \mathsf{EXPSPACE}</script>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Calculabilite-et-Complexite-计算复杂性理论&quot;&gt;&lt;a href=&quot;#Calculabilite-et-Complexite-计算复杂性理论&quot; class=&quot;headerlink&quot; title=&quot;Calculabilité et Complexité (计算复杂性理论)&quot;&gt;&lt;/a&gt;Calculabilité et Complexité (计算复杂性理论)&lt;/h2&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;本文章是根据法国国立高等电力技术、电子学、计算机、水力学与电信学校 (E.N.S.E.E.I.H.T.) 第八学期课程“Calculabilité et Complexité”总结而来的课程笔记。碍于本人学识有限，部分叙述难免存在纰漏，请读者注意甄别。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;《计算复杂性理论》- 陈健二教授（广州大学）&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="课程笔记" scheme="https://dave0126.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="课程笔记" scheme="https://dave0126.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>DataBase</title>
    <link href="https://dave0126.github.io/2022/05/23/DataBase-review/"/>
    <id>https://dave0126.github.io/2022/05/23/DataBase-review/</id>
    <published>2022-05-23T19:35:10.000Z</published>
    <updated>2022-06-02T20:25:52.836Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文章是根据法国国立高等电力技术、电子学、计算机、水力学与电信学校 (E.N.S.E.E.I.H.T.) 第八学期课程<em>“Base de Donnees”</em> 总结而来的【部分课程笔记】。碍于本人学识有限，部分叙述难免存在纰漏，请读者注意甄别。</p><span id="more"></span><h3 id="数据库设计的步骤"><a href="#数据库设计的步骤" class="headerlink" title="数据库设计的步骤"></a>数据库设计的步骤</h3><ol><li><p>需求分析</p><p>调查机构情况与熟悉业务活动，明确用户的需求，确定系统边界，生成用户字典和用户需求规格说明书</p></li><li><p>概念结构设计</p><p>将需求分析得到的用户需求抽象为概念模型，绘制E-R图</p></li><li><p>逻辑结构设计</p><p>将E-R图转换为与DBMS相符合的逻辑结构（包括数据库模式和外模式），例如E-R图向关系模型的转换，再根据规范化理论对数据模型进行优化，设计用户子模式。</p></li><li><p>物理结构设计</p><p>通常关系数据库物理设计的内容包括关系模式选择存取方法，以及设计关系、索引等数据库文件的物理存储结构</p></li><li><p>数据库实施</p><p>建立实际数据库结构、载入数据</p></li><li><p>数据库运行与维护</p></li></ol><h3 id="数据库系统的标准结构"><a href="#数据库系统的标准结构" class="headerlink" title="数据库系统的标准结构"></a>数据库系统的标准结构</h3><p>三级模式和两层映像</p><h4 id="DBMS-管理数据的三个层次"><a href="#DBMS-管理数据的三个层次" class="headerlink" title="DBMS 管理数据的三个层次"></a>DBMS 管理数据的三个层次</h4><ol><li><code>External Level</code> 或 <code>User Level</code>：某一用可以看到与处理的数据，全区数据中的某一部分</li><li><code>Conceptual Level</code> 或 <code>Logic Level</code>：从全局的角度理解和管理的数据，含相应的关联约束</li><li><code>Internal Level</code> 或 <code>Physical Level</code>：存储在物理介质上的数据</li></ol><h4 id="视图（View）与模式（Schema）"><a href="#视图（View）与模式（Schema）" class="headerlink" title="视图（View）与模式（Schema）"></a>视图（View）与模式（Schema）</h4><p>模式（Schema）：对数据库中的数据所进行的一种<u>结构性的描述</u></p><p>视图（View）：某一种表现形式下表现出来的数据库中的<u>数据</u></p><h4 id="三个层次下的视图与模式"><a href="#三个层次下的视图与模式" class="headerlink" title="三个层次下的视图与模式"></a>三个层次下的视图与模式</h4><ol><li><code>External Schema</code> 与 <code>External View</code>：某一用户可以看到与处理的结构描述，及数据</li><li><code>Conceptual Schema</code> 与 <code>Conceptual View</code>：从全局的角度理解和管理的数据的结构描述，含相应的关联约束。<u>体现在数据之间的内在本质联系</u>。</li><li><code>Internal Schema</code> 与 <code>Internal View</code>：存储在物理介质上的数据的结构描述，含存储路径、存储方式、索引方式等</li></ol><p>若只提到模式，则是指 <code>Conceptual Schema</code>；只提到视图时，则通常是指 <code>External View</code>。</p><h4 id="两层映像"><a href="#两层映像" class="headerlink" title="两层映像"></a>两层映像</h4><p>何为映像？将一种模式转化为另一种模式的过程称之为映像。</p><ul><li><code>E-C Mapping</code> 将数据结构从 <code>Conceptual Schema</code> 转换到 <code>External Schema</code> 的映像，以便<u>用户的观察和使用</u></li><li><code>C-I Mapping</code> 将数据结构从 <code>Internal Schema</code> 转换到 <code>Conceptual Schema</code> 的映像，以便<u>计算机存储和处理数据</u></li></ul><h4 id="两个独立性"><a href="#两个独立性" class="headerlink" title="两个独立性"></a>两个独立性</h4><ul><li>逻辑数据独立性：当 <code>Conceptual Schema</code> 变化时，可以不改变 <code>External Schema</code>，只需改变 <code>E-C Mapping</code>，从而无需改变应用程序。</li><li>物理数据独立性：当 <code>Internal Schema</code> 变化时，可以不改变 <code>Conceptual Schema</code>，只需改变 <code>E-C Mapping</code>，从而不改变 <code>External Schema</code>。</li></ul><h4 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h4><p>前面我们提到了数据（视图）和模式，即模式是对数据本身的抽象。</p><p>而数据模型是对模式结构的抽象。</p><pre class="mermaid">graph LR数据模型 --"(结构的抽象)"--> 模式 模式 --"(结构的抽象)"--> 数据</pre><p>比如，关系模型：所有模式都可以抽象成表(Table)的形式，而每一个具体的模式都是<u>具有不同列名的具体的表</u>。</p><h5 id="三大经典数据模型"><a href="#三大经典数据模型" class="headerlink" title="三大经典数据模型"></a>三大经典数据模型</h5><ul><li><u>关系</u>模型 $\quad \to \quad$ <u>表</u>的形式组织数据</li><li><u>层次</u>模型 $\quad \to \quad$ <u>树</u>的形式组织数据</li><li><u>网状</u>模型 $\quad \to \quad$ <u>图</u>的形式组织数据</li></ul><h3 id="数据库的关系模型"><a href="#数据库的关系模型" class="headerlink" title="数据库的关系模型"></a>数据库的关系模型</h3><p>形象地说，一个<u>关系</u>就是一个<u>表</u>（但并不完全是），关系模型就是处理表的，通常由三部分组成：</p><ol><li>描述表的基本结构形式 (Relation/Table)</li><li>描述表于表之间的各种关系运算 (<code>union, difference, product, selecet, project, intersect, join, division</code>)</li><li>描述这些操作间应遵循的完整性约束条件 (实体完整性、参照完整性、用户自定义完整性)</li></ol><h4 id="什么是关系"><a href="#什么是关系" class="headerlink" title="什么是关系"></a>什么是关系</h4><ol><li><p>首先定义“列”的取值范围【域 (Domain)】</p><p>$D = \{d_1, d_2, … ,d_n\}$</p></li><li><p>在定义“元组”及所有可能组成的 n元组 (来自不同域的值的排列组合)：笛卡尔积 (Cartesian Product)</p><p>$D_1 \times D_2 \times … \times D_n = \{ (d_1, d_2, …, d_n) \;| \; d_i \in D_i,i=1,2,…n\}$</p><ul><li>在元组 $\{ (d_1, d_2, …, d_n)\}$ 的每一个值 $d_i$ 叫做一个分量 (Conponent)</li></ul></li><li><p>关系：在笛卡尔积中所有的元组中一个“<u>有意义</u>”的子集</p><ul><li><p>$\mathcal{R}(A_1:D_1,\; A_2:D_2,\; …,\; A_n:D_n) \subset \{D_1 \times D_2 \times … \times D_n\}$ 简写为 $\mathcal{R}(A_1,\; A_2,\; …,\; A_n) $ </p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator">/</span><span class="operator">/</span> 关系模式</span><br><span class="line">Student(id <span class="type">char</span>(<span class="number">8</span>), name <span class="type">char</span>(<span class="number">10</span>), sex <span class="type">char</span>(<span class="number">2</span>), age <span class="type">integer</span>, class <span class="type">char</span>(<span class="number">6</span>))</span><br><span class="line"><span class="operator">/</span><span class="operator">/</span> 关系值</span><br><span class="line">Student(<span class="number">12345678</span>, 张三, 男, <span class="number">20</span>, 三班)</span><br></pre></td></tr></table></figure></li></ul></li></ol><h4 id="关系的特性"><a href="#关系的特性" class="headerlink" title="关系的特性"></a>关系的特性</h4><ul><li>列是同质的：即每一个列中的分量来自同一个域，是同一个类型的数据；</li><li>不同的列可以来自同一个域，称其中的每一列为一个【属性】，不同属性要给予不同的属性名；</li><li>行/列位置可以互换</li><li>关系中任意两个元组不能相同，但在实际运用中，表中的记录可以重复</li><li>满足【第一范式】：<u>属性不可再分</u></li></ul><h4 id="关系的一些重要概念"><a href="#关系的一些重要概念" class="headerlink" title="关系的一些重要概念"></a>关系的一些重要概念</h4><h5 id="候选码-Candidate-Key"><a href="#候选码-Candidate-Key" class="headerlink" title="候选码 (Candidate Key)"></a>候选码 (Candidate Key)</h5><p>关系中的一个<u>属性组</u>，其值能<u>唯一标识一个元组</u>，若从该属性组中去掉任何一个属性，他就不具有这种性质了，这样的<u>属性组</u>称作候选码。</p><blockquote><p>在以下的关系模式中，</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Student(id, name, sex, age, class)</span><br></pre></td></tr></table></figure><p>只有 <code>id</code> 是可以唯一确定一个元组的，其他的属性组合都不能唯一确定一个元组。所有属性 <code>id</code> 是 <code>student</code> 关系的一个候选码</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ChoiceClasses(studentId, classId, studentName, className, grade)</span><br></pre></td></tr></table></figure><p>属性组 <code>(studentId, classId)</code> 可以唯一确定一个元组，所以该候选组是一个候选码</p></blockquote><ul><li>超码：能表示出所有属性的集合，候选码是最小的超码</li><li>主码：当出现多个候选码时，可以选定一个作为【主码 (Primary Key)】</li><li>主属性 (Prime Attribute)：包含在任何一个候选码中的属性是【主属性】，而其他属性是【非主属性】；</li><li>当候选码为全体属性时，我们称其为【全码 (All Key)】</li></ul><h5 id="外码-Foreign-Key"><a href="#外码-Foreign-Key" class="headerlink" title="外码 (Foreign Key)"></a>外码 (Foreign Key)</h5><p>关系 $\mathcal{R_1}$ 中一个非主属性组，在另一个关系 $\mathcal{R_2}$ 的主属性组中，则称这个属性组为关系 $\mathcal{R_1}$ 的【外码 (Foreign Key)】</p><ul><li>两个关系 $\mathcal{R_1}$ 和 $\mathcal{R_2}$ 通常是<u>靠外码连接起来的</u>。</li></ul><h4 id="关系模型的完整性"><a href="#关系模型的完整性" class="headerlink" title="关系模型的完整性"></a>关系模型的完整性</h4><h5 id="1-实体完整性"><a href="#1-实体完整性" class="headerlink" title="1. 实体完整性"></a>1. 实体完整性</h5><p>关系的主码的值不能为空（未知或无意义的值）</p><blockquote><p>因为主码可以唯一确定一个元组，如果值为空（未知或无意义），我们就无法确定一个元组</p></blockquote><h5 id="2-参照完整型"><a href="#2-参照完整型" class="headerlink" title="2. 参照完整型"></a>2. 参照完整型</h5><p>如果关系 $\mathcal{R_1}$ 的外码 $K_F$ 与关系 $\mathcal{R_2}$ 的主码 $K_P$ 相对应，则关系 $\mathcal{R_1}$ 中的每一个元组的 $K_F$ 值等于关系 $\mathcal{R_2}$ 中每个元组的主码 $K_P$ 值，或空值。</p><h5 id="3-用户自定义完整性"><a href="#3-用户自定义完整性" class="headerlink" title="3. 用户自定义完整性"></a>3. 用户自定义完整性</h5><p>用户针对具体的应用环境定义的完整性约束条件</p><blockquote><p>添加关于年龄的约束 $[0,200]$</p></blockquote><h4 id="关系代数运算"><a href="#关系代数运算" class="headerlink" title="关系代数运算"></a>关系代数运算</h4><p>基于集合，提供了一系列的关系代数操作：<code>union, difference, product, selecet, project, intersect, join, division</code> 等操作。以若干个关系为输入 $\to$ 结果是一个新关系。</p><h5 id="并相容性"><a href="#并相容性" class="headerlink" title="并相容性"></a>并相容性</h5><p>两个关系 $\mathcal{R_1}$ 和 $\mathcal{R_2}$ 存在相容性，当且仅当：</p><p>（1）关系 $\mathcal{R_1}$ 和 关系 $\mathcal{R_2}$ 的<u>属性数目必须相同</u>；</p><p>（2）对于任意 $i$，<u>关系 $\mathcal{R_1}$ 的第 $i$ 个属性的域必须和关系 $\mathcal{R_2}$ 的第 $i$ 个属性的域相同</u></p><p>满足并相容性的两个关系可以进行并、交、差运算</p><h5 id="并运算-Union"><a href="#并运算-Union" class="headerlink" title="并运算 (Union)"></a>并运算 (Union)</h5><script type="math/tex; mode=display">\mathcal{R_1} \cup \mathcal{R_2} = \{ t \; |\;  t \in \mathcal{R_1} \lor t \in \mathcal{R_2}\}</script><p>其中，$t$ 是元组。</p><h5 id="差运算-Difference"><a href="#差运算-Difference" class="headerlink" title="差运算 (Difference)"></a>差运算 (Difference)</h5><h5 id><a href="#" class="headerlink" title=" "></a> </h5><script type="math/tex; mode=display">\mathcal{R_1} - \mathcal{R_2} = \{ t \; |\;  t \in \mathcal{R_1} \land t \notin \mathcal{R_2}\}</script><p>其中，$t$ 是元组。</p><ul><li>$\mathcal{R_1} - \mathcal{R_2} \; 与 \; \mathcal{R_2} - \mathcal{R_1}$ 是不同的</li></ul><h5 id="广义笛卡尔积-Cartesian-Product"><a href="#广义笛卡尔积-Cartesian-Product" class="headerlink" title="广义笛卡尔积 (Cartesian Product)"></a>广义笛卡尔积 (Cartesian Product)</h5><p>关系 $\mathcal{R_1} (\langle a_1, a_2, … ,a_n\rangle)$，关系 $\mathcal{R_2} (\langle b_1, b_2, … ,b_n\rangle)$，有</p><script type="math/tex; mode=display">\mathcal{R_1} \times \mathcal{R_2} = \{ \langle a_1, a_2, ... ,a_n, b_1, b_2,...,b_n\rangle \; | \; \langle a_1, a_2, ... ,a_n\rangle \in \mathcal{R_1} \land \langle b_1, b_2, ... ,b_n\rangle \in \mathcal{R_2}\}</script><ul><li>$\mathcal{R_1} \times \mathcal{R_2} = \mathcal{R_2} \times \mathcal{R_1}$</li></ul><h5 id="选择操作-Select"><a href="#选择操作-Select" class="headerlink" title="选择操作 (Select)"></a>选择操作 (Select)</h5><script type="math/tex; mode=display">\sigma _{con}(\mathcal{R}) = \{ t \; | \; t \in \mathcal{R} \land con(t) = 'true'\}</script><ul><li>设 $\mathcal{R_1}(A_1, A_2, …,A_n)$，$t$ 是 $\mathcal{R_1}$ 的元组，$t$ 的分量记为 $t[A_i]$ 或简写为  $A_i$ </li><li>条件 con 由逻辑运算符连接几个比较表达式组成</li><li>逻辑表达式：$\land ,\lor, \neg$</li><li>比较表达式：$X \; \theta \; Y,\theta \in \{&gt;,\ge, &lt;, \le, =, \neq \}$</li><li>对于行操作（元组）</li></ul><h5 id="投影操作-Project"><a href="#投影操作-Project" class="headerlink" title="投影操作 (Project)"></a>投影操作 (Project)</h5><script type="math/tex; mode=display">\Pi _{A_{i1}, A_{i2}, ..., A_{ik}}(\mathcal{R}) = \{\langle t[A_{i1}], \; t[A_{i2}],\; ...,\; t[A_{ik}] \; | \; t \in \mathcal{R} \}</script><ul><li>设 $\mathcal{R_1}(A_1, A_2, …,A_n)$，投影操作实际上就是从原有属性组中选出几个属性作为新的属性组</li><li>$\{A_{i1}, A_{i2}, …, A_{ik}\} \subseteq \{A_{1}, A_{2}, …, A_{n}\}$</li><li>对于列操作（属性）</li></ul><h5 id="交操作-Intersection"><a href="#交操作-Intersection" class="headerlink" title="交操作 (Intersection)"></a>交操作 (Intersection)</h5><script type="math/tex; mode=display">\mathcal{R_1} \cap \mathcal{R_2} = \{t \; | \; t \in \mathcal{R_1} \land t \in \mathcal{R_2} \}</script><ul><li>$\mathcal{R_1} \cap \mathcal{R_2} = \mathcal{R_2} \cap \mathcal{R_1}$</li><li>交运算可以通过差运算来实现：$\mathcal{R_1} \cap \mathcal{R_2} = \mathcal{R_1} - (\mathcal{R_1} -\mathcal{R_2}) = \mathcal{R_2} - (\mathcal{R_2} -\mathcal{R_1})$</li></ul><h5 id="theta-连接操作-theta-Join"><a href="#theta-连接操作-theta-Join" class="headerlink" title="$\theta$ - 连接操作 ($\theta$ - Join)"></a>$\theta$ - 连接操作 ($\theta$ - Join)</h5><script type="math/tex; mode=display">\mathcal{R_1} \bowtie \mathcal{R_2}\; _{(A \; \theta \; B)} = \sigma _{(t_{[A]} \; \theta \; s_{[B]})}(\mathcal{R_1} \times \mathcal{R_2})</script><ul><li>$A$ 是 $\mathcal{R_1}$ 的一个属性，设 $\mathcal{R_1}(A_1, A_2, …,A_n), \; A \in \{A_1, A_2, …,A_n\}$</li><li>$B$ 是 $\mathcal{R_2}$ 的一个属性，设 $\mathcal{R_2}(B_1, B_2, …,B_n), \; B \in \{B_1, B_2, …,B_n\}$</li><li>$\theta$ 是比较表达式：$X \; \theta \; Y,\theta \in \{&gt;,\ge, &lt;, \le, =, \neq \}$</li><li>即在不同的表中先求笛卡尔积，再在新表上进行 $\theta$ 操作</li></ul><h5 id="自然连接操作-Join"><a href="#自然连接操作-Join" class="headerlink" title="自然连接操作 (Join)"></a>自然连接操作 (Join)</h5><script type="math/tex; mode=display">\mathcal{R_1} \bowtie \mathcal{R_2} = \sigma _{(t_{[B]} = s_{[B]})}(\mathcal{R_1} \times \mathcal{R_2})</script><ul><li>关系 $\mathcal{R_1}$ 和 关系 $\mathcal{R_2}$ 必须有<u>相同的属性组B</u></li></ul><h5 id="外连接-Outer-Join"><a href="#外连接-Outer-Join" class="headerlink" title="外连接 (Outer Join)"></a>外连接 (Outer Join)</h5><script type="math/tex; mode=display">\mathcal{R_1}\; ⟕\; \mathcal{R_2} \quad 左外连接 \\\mathcal{R_1}\; ⟖\; \mathcal{R_2} \quad 右外连接 \\\mathcal{R_1}\; ⟗\; \mathcal{R_2} \quad 全外连接 \\</script><ul><li>外连接 = 自然连接（$\theta$ - 连接）+ 失配的元组（与全空元组形成的连接）</li></ul><h5 id="除操作-Division"><a href="#除操作-Division" class="headerlink" title="除操作 (Division)"></a>除操作 (Division)</h5><script type="math/tex; mode=display">\mathcal{R_1} \div \mathcal{R_2} = \{ t \; | \; t \in \Pi _{\mathcal{R_1}-\mathcal{R_2}}(\mathcal{R_1}) \land \forall u \in \mathcal{R_2}(tu \in \mathcal{R_1})\}</script><ul><li>常用越求解“查询全部”的问题</li></ul><h4 id="函数依赖"><a href="#函数依赖" class="headerlink" title="函数依赖"></a>函数依赖</h4><p>（1）非平凡的函数依赖：$X \to Y, Y \nsubseteq X$</p><blockquote><p>无特殊说明下，均讨论非平凡的函数依赖。</p><p>意为 $X$ 可以推导出 $Y$，且 $Y$ 不是 $X$ 的子集。</p></blockquote><p>（2）平凡的函数依赖：$X \to Y, Y \subseteq X$</p><p>（3）完全函数依赖：$X \to Y$，并且对于 $X$ 的任意真子集 $X’$，都有 $X’ \nrightarrow Y$。则称 $Y$ 完全范数依赖于 $X$，记作 $X\stackrel{F}{\longrightarrow}Y$</p><blockquote><p>意为： $X$ 可以推导出 $Y$，且任意一个子集 $X’$ 都不能推导出 $Y$，那么我们称 $Y$ 完全范数依赖于 $X$</p></blockquote><p>（4）部分函数依赖： $Y$ 不完全范数依赖于 $X$，记作 $X\stackrel{P}{\longrightarrow}Y$。</p><blockquote><p>例如 $A \to C$ 且 $AB \to C$，我们可以看到，因为 $A$ 已经可以推导出 $C$ 了，对于 $AB \to C$ 来说，$B$ 就是冗余的。</p></blockquote><p>（5）传递函数依赖： $Y$ 范数依赖于 $X$， $Z$ 范数依赖于 $Y$，所以 $Z$ 范数依赖于 $X$。$X \to Y, \; Y \to Z \quad \Rightarrow \quad X \to Z$</p><h4 id="范式"><a href="#范式" class="headerlink" title="范式"></a>范式</h4><script type="math/tex; mode=display">5NF \subset 4NF \subset BCNF \subset 3NF \subset 2NF \subset 1NF \\ \\1NF \xrightarrow{消除【部分依赖】}2NF \xrightarrow{消除【非主属性】的【传递依赖】} 3NF \xrightarrow{满足【箭头左侧搜包含候选码】}BCNF</script><h5 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h5><p>【第一范式】：要求所有属性都是<u>不可分割的数据项</u>（根据实际业务规定何为“不可分割”）。</p><p>第一范式的目标是确保每列（属性）的原子性</p><blockquote><p>例如在具体的业务中，我们想记录用户的住址，但我们并不想对住址的省市加以区分。对于我们而言，地址就已经是一个“原子性的”数据项了。所以我们的第一范式就是：</p><div class="table-container"><table><thead><tr><th>id</th><th>姓名</th><th>地址</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div><p>而不是：</p><div class="table-container"><table><thead><tr><th>id</th><th>姓名</th><th>省</th><th>市</th><th>区</th><th>详细地址</th></tr></thead><tbody><tr><td></td></tr></tbody></table></div></blockquote><p>第一范式可能存在的问题：由于模式中一些<u>不正确的数据依赖关系</u>所引起，可以<u>分解关系</u>来解决</p><ol><li>数据冗余</li><li>更新异常</li><li>插入异常</li><li>删除异常</li></ol><h5 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h5><p>【第二范式】：在满足1NF的前提下，不包含非主属性对于候选码的部分函数依赖。即<u>每个非主属性</u>都是<u>完全函数依赖</u>于<u>候选码</u>的。</p><p>第二范式要求每个表只描述一类信息。</p><blockquote><p>例如，在关系R中，候选码为【学生编号】和【教师编号】，非主属性是 [学生姓名]，[教师姓名]。因为通过【学生编号】就可以唯一确定 [学生姓名] 了，并不需要【教师编号】。所以，我们可以将1NF转化成2NF，即拆分成三个表：</p><ul><li>学生表(【学生编号】, 学生姓名)</li><li>教师表(【教师编号】, 教师姓名)</li><li>学生教师关系表(学生编号 , 教师编号)</li></ul></blockquote><h5 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h5><p>【第三范式】：在满足2NF的前提下，不包含<u>非主属性</u>对于候选码的函数依赖。即候选码应该<u>直接决定</u>非主属性，不能间接决定 ($A \to B, \; B \to C$ )</p><blockquote><p>例如在关系R中，候选码为【客户姓名】，非主属性是 [订单编号] 和 [订单负责人]。则我们可以通过【客户姓名】决定 [订单编号]，再通过 [订单编号] 决定 [订单负责人]。所以，我们可以将其成3NF，即拆分成两个表：</p><ul><li>客户表(【客户姓名】, 订单编号)</li><li>订单表(订单编号, 订单负责人)</li></ul></blockquote><h5 id="BCNF"><a href="#BCNF" class="headerlink" title="BCNF"></a>BCNF</h5><p>【BC范式】：在满足3NF的前提下，如果对于每个函数依赖 $X \to Y$，若 $Y$ 不属于 $X$，则 $X$ 必<u>含有候选码</u>，则该关系满足 $BCNF$。</p><h3 id="SQL-语句"><a href="#SQL-语句" class="headerlink" title="SQL 语句"></a>SQL 语句</h3><h4 id="DDL-数据定义语句-Schema"><a href="#DDL-数据定义语句-Schema" class="headerlink" title="DDL 数据定义语句 (Schema)"></a><code>DDL</code> 数据定义语句 (Schema)</h4><h5 id="CREATE-创建"><a href="#CREATE-创建" class="headerlink" title="CREATE 创建"></a><code>CREATE</code> 创建</h5><p>关系名（表名）、属性名（列名）、属性的数据类型、完整性约束</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">&#x27;表名&#x27;</span> (</span><br><span class="line"><span class="string">&#x27;列名&#x27;</span> 数据类型 列的完整性约束 ,</span><br><span class="line"><span class="string">&#x27;列名&#x27;</span> 数据类型 列的完整性约束 ,</span><br><span class="line">  ... ,</span><br><span class="line">) 表的的完整性约束;</span><br></pre></td></tr></table></figure><h5 id="ALTER-修改"><a href="#ALTER-修改" class="headerlink" title="ALTER 修改"></a><code>ALTER</code> 修改</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> <span class="string">&#x27;表名&#x27;</span> (</span><br><span class="line"><span class="keyword">ADD</span> <span class="keyword">COLUMN</span> <span class="string">&#x27;新列名&#x27;</span> 数据类型 列的完整性约束 ,</span><br><span class="line">  <span class="keyword">ADD</span> 完整性约束 ,</span><br><span class="line">  MODIFY <span class="string">&#x27;列名&#x27;</span> 数据类型 ,</span><br><span class="line">  <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> <span class="string">&#x27;列名&#x27;</span> ,</span><br><span class="line">  <span class="keyword">DROP</span> 完整性约束 ,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h5 id="DROP-删除"><a href="#DROP-删除" class="headerlink" title="DROP 删除"></a><code>DROP</code> 删除</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="string">&#x27;表名&#x27;</span>;</span><br></pre></td></tr></table></figure><h4 id="DQL-数据查询语言"><a href="#DQL-数据查询语言" class="headerlink" title="DQL 数据查询语言"></a><code>DQL</code> 数据查询语言</h4><h5 id="SELECT-查询语句"><a href="#SELECT-查询语句" class="headerlink" title="SELECT 查询语句"></a><code>SELECT</code> 查询语句</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 当满足_condition的条件下，从表T中查询列A</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> A <span class="keyword">as</span> <span class="string">&#x27;列A的别名&#x27;</span> <span class="comment">-- DISTINCT 显示查询结果无重复</span></span><br><span class="line"><span class="keyword">FROM</span> T</span><br><span class="line"><span class="keyword">WHERE</span> _condition</span><br></pre></td></tr></table></figure><p>子句：</p><ul><li><p><code>WHERE</code> ：条件子句，可以用 <code>AND / OR</code> 连接多个条件</p><ul><li>比较大小：<code>=, &gt;, &lt;, &gt;=, &lt;=, &lt;&gt;, !&lt;, !&gt;, NOT</code></li><li>确定范围 (包含)：<code>[NOT] BETWEEN ... AND...</code> </li><li>指定集合：<code>列名 [NOT] IN (Val1, Val2, Val3)</code>，意为在查询结果中筛选列名的值为 <code>Val1, Val2, Val3</code> 的记录</li><li>字符串匹配：<code>列名 [NOT] LIKE &#39;匹配目标串&#39; [ESCAPE &#39;转义字符&#39;]</code><ul><li><code>%</code> 通配符：代表任意长度的字符串。 <code>a%b</code> 表示以a开始，b结束的任意长度的字符串</li><li><code>_</code> 通配符：代表单个字符。<code>a_b</code> 表示a开始，b结束的长度为3的字符串</li></ul></li><li>涉及空值：<code>IS [NOT] NULL</code></li></ul></li><li><p><code>GROUP BY</code>：对查询结果分组，</p><p>分组方法：按指定的一列或多列值分组，值相等的为一组。</p><ul><li><code>HAVING</code>：功能类似于 <code>WHERE</code>，但是作用域是分组后的数据</li></ul></li><li><p><code>ORDER BY</code>：对查询结果进行排序</p><ul><li><code>列名1,列名2 ASD</code>：升序（缺省）</li><li><code>列名1,列名2 DESC</code>：降序</li></ul></li><li><p>常用集函数：</p><ul><li><code>COUNT (列名)</code>：统计记录的个数（行数）</li><li><code>SUM (列名)</code>：计算列总和</li><li><code>AVG (列名)</code>：计算列平均值</li><li><code>MAX (列名)</code>：计算列最大值</li><li><code>MIN (列名)</code>：计算列最小值</li></ul></li></ul><h5 id="SELECT-多表查询"><a href="#SELECT-多表查询" class="headerlink" title="SELECT 多表查询"></a><code>SELECT</code> 多表查询</h5><p>同时涉及多个表的查询称为多表查询。</p><ol><li><p>交叉连接（广义笛卡尔积）：不常用</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1.<span class="operator">*</span>,col2.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> col1,col2</span><br><span class="line"><span class="comment">-- 返回col1和col2的广义笛卡尔积</span></span><br></pre></td></tr></table></figure></li><li><p>等值连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1.<span class="operator">*</span>,col2.<span class="operator">*</span></span><br><span class="line"><span class="keyword">FROM</span> col1,col2</span><br><span class="line"><span class="keyword">WHERE</span> col1.id <span class="operator">=</span> col2.id</span><br><span class="line"><span class="comment">-- 在col1和col2的广义笛卡尔积中找出id对应相等的结果</span></span><br></pre></td></tr></table></figure></li></ol><h5 id="SELECT-嵌套查询"><a href="#SELECT-嵌套查询" class="headerlink" title="SELECT 嵌套查询"></a><code>SELECT</code> 嵌套查询</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> 列名</span><br><span class="line"><span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="keyword">WHERE</span> _condition <span class="keyword">IN</span>[<span class="operator">&gt;</span>,<span class="operator">&lt;</span>,<span class="operator">=</span>,...] (</span><br><span class="line"><span class="keyword">SELECT</span> 内层列名</span><br><span class="line"><span class="keyword">FROM</span> 内层表名</span><br><span class="line"><span class="keyword">WHERE</span> _condition2)</span><br></pre></td></tr></table></figure><ul><li>内层查询的结果是一个关于“内层列名”的集合</li><li>不能使用 <code>ORDER BY</code> 和 <code>GROUP BY</code>语句</li></ul><h4 id="DML-数据操作语言"><a href="#DML-数据操作语言" class="headerlink" title="DML 数据操作语言"></a><code>DML</code> 数据操作语言</h4><h5 id="INSERT-插入语句"><a href="#INSERT-插入语句" class="headerlink" title="INSERT 插入语句"></a><code>INSERT</code> 插入语句</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 将指定元组加入指定表中</span></span><br><span class="line"><span class="keyword">INSERT</span> </span><br><span class="line"><span class="keyword">INTO</span> 表名 [(列名)]</span><br><span class="line"><span class="keyword">VALUES</span> val_1,val_2,...,val_n</span><br><span class="line"><span class="comment">-- 或子查询</span></span><br></pre></td></tr></table></figure><h5 id="UPDATE-修改语句"><a href="#UPDATE-修改语句" class="headerlink" title="UPDATE 修改语句"></a><code>UPDATE</code> 修改语句</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> 表名</span><br><span class="line"><span class="keyword">SET</span> 列名 <span class="operator">=</span> 表达式</span><br><span class="line"><span class="keyword">WHERE</span> _condition</span><br></pre></td></tr></table></figure><h5 id="DELETE-删除语句"><a href="#DELETE-删除语句" class="headerlink" title="DELETE 删除语句"></a><code>DELETE</code> 删除语句</h5><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span></span><br><span class="line"><span class="keyword">FROM</span> 表名</span><br><span class="line"><span class="keyword">WHERE</span> _condition</span><br></pre></td></tr></table></figure><h3 id="解题过程"><a href="#解题过程" class="headerlink" title="解题过程"></a>解题过程</h3><ol><li><p>审题，列出所有的属性</p></li><li><p>根据题目所述，写出所有的依赖关系“$X \to Y$”</p></li><li><p>选出候选码：</p><ul><li><p>只出现在<u>左边</u>的一定是<u>候选码</u></p></li><li><p>只出现在<u>右边</u>的一定<u>不是候选码</u></p></li><li><p>左右<u>两边都出现</u>的可能是候选码</p></li><li><p>左右<u>两边都不出现</u>的一定是<u>候选码</u></p></li><li><p>再确定候选码的闭包，如果可以推出全部集合，那么当前确定的就是候选码；否则就需要把每一个可能的值加入候选码中求解闭包，判断能否推出全部集合。</p><p>【如何求闭包？】</p><p>即可以由当前属性组的所有子集推出的，包含属性组中所有属性的属性组集合</p><p>$(A,B)^+ = \{(A\to…) \cup (B\to …) \cup (AB \to …) \cup (A) \cup (B)\}$</p></li></ul></li><li><p>判断当前关系属于哪一个范式，并将其转化成BCNF</p></li></ol><h3 id="E-R-图"><a href="#E-R-图" class="headerlink" title="E-R 图"></a>E-R 图</h3><h4 id="如何画-E-R-图"><a href="#如何画-E-R-图" class="headerlink" title="如何画 E-R 图"></a>如何画 E-R 图</h4><ul><li>实体：我们用矩形框代表实体类</li><li>关系：我们用菱形框代表两个实体间的关系</li><li>属性：我们用椭圆形框代表属性。实体和关系都可以具有属性</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">attri=&gt;start: 属性</span><br><span class="line">entity1=&gt;operation: 实体</span><br><span class="line">relat=&gt;condition: 关系</span><br><span class="line">entity2=&gt;operation: 实体</span><br><span class="line"></span><br><span class="line">attri-&gt;entity1-&gt;relat-&gt;entity2</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre class="mermaid">graph LRa1[教室]a2[学生]b{上课}ca11(教室号)ca21(学号)ca22(名字)a1 ---- bb ---- a2a1 ---- ca11a2 ---- ca21a2 ---- ca22</pre><ul><li>1对1联系：</li></ul><pre class="mermaid">graph TDa[实体A]b{关系}c[实体B]a ----|1|bc ----|1|b</pre>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本文章是根据法国国立高等电力技术、电子学、计算机、水力学与电信学校 (E.N.S.E.E.I.H.T.) 第八学期课程&lt;em&gt;“Base de Donnees”&lt;/em&gt; 总结而来的【部分课程笔记】。碍于本人学识有限，部分叙述难免存在纰漏，请读者注意甄别。&lt;/p&gt;</summary>
    
    
    
    <category term="课程笔记" scheme="https://dave0126.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="课程笔记" scheme="https://dave0126.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Appli Web课程笔记</title>
    <link href="https://dave0126.github.io/2022/05/03/Appli-Web%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    <id>https://dave0126.github.io/2022/05/03/Appli-Web%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/</id>
    <published>2022-05-03T10:51:05.000Z</published>
    <updated>2022-08-22T14:42:30.398Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文章是根据法国国立高等电力技术、电子学、计算机、水力学与电信学校 (E.N.S.E.E.I.H.T.) 第八学期课程<em>“Application Web”</em> 总结而来的【部分课程笔记】。碍于本人学识有限，部分叙述难免存在纰漏，请读者注意甄别。</p><span id="more"></span><h3 id="第一部分：Introduction"><a href="#第一部分：Introduction" class="headerlink" title="第一部分：Introduction"></a>第一部分：Introduction</h3><p>Web 基于 <code>客户端-服务器</code> 模型， 这里客户端是浏览器，服务器是 Web 服务器（如 Apache）。<br>主要包括三个方面：</p><h4 id="1-带有-URI-URN-URL-的文件的指定和位置"><a href="#1-带有-URI-URN-URL-的文件的指定和位置" class="headerlink" title="1. 带有 URI/URN/URL 的文件的指定和位置"></a>1. 带有 URI/URN/URL 的文件的指定和位置</h4><ul><li>URI (Uniform Resource Identifier)：统一资源标识符，就是在某一规则下能把一个资源独一无二地标识出来。$URI = URL \; \cup \; URN$</li><li>URL (Uniform Resource Locator)：统一资源定位符。标识一个互联网资源，并指定对其进行操作或获取该资源的方法。</li><li>URN (Uniform Resource Name)：统一资源名称。用于标识唯一书目的 ISBN系统是一个典型的 URN 使用范例</li></ul><h4 id="2-使用-HTML-和-CSS-语言对文档进行编码"><a href="#2-使用-HTML-和-CSS-语言对文档进行编码" class="headerlink" title="2. 使用 HTML 和 CSS 语言对文档进行编码"></a>2. 使用 HTML 和 CSS 语言对文档进行编码</h4><h5 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h5><p>HTML (HyperText Markup Language) 语言由<strong>包含内容的标签 (composé de balises)</strong>组成</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span><span class="comment">&lt;!-- 标记 HTML文档 --&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span><span class="comment">&lt;!-- 标记 HTML头部元素 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span><span class="comment">&lt;!-- 标记 HTML元数据 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span><span class="comment">&lt;!-- 标记 HTML的标题 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="comment">&lt;!-- 标记 HTML文档的主体 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="comment">&lt;!-- 标记 标题 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>&gt;</span><span class="comment">&lt;!-- 标记 水平线 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span> <span class="comment">&lt;!-- 标记 一个段落 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">br</span>&gt;</span> <span class="comment">&lt;!-- 标记 换行 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">em</span>&gt;</span><span class="tag">&lt;/<span class="name">em</span>&gt;</span><span class="comment">&lt;!-- 标记 着重元素(加粗) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="comment">&lt;!-- 内容划分元素 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span>&gt;</span><span class="comment">&lt;!-- 表格 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="comment">&lt;!-- table data cell表格中的一个单元格 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">th</span>&gt;</span><span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="comment">&lt;!-- table header cell表格中的表头 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span><span class="comment">&lt;!-- table row表格中的一行 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span><span class="comment">&lt;!-- List Item列表项目 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">nl</span>&gt;</span><span class="tag">&lt;/<span class="name">nl</span>&gt;</span><span class="comment">&lt;!-- navigation lists导航列表 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span><span class="tag">&lt;/<span class="name">ol</span>&gt;</span><span class="comment">&lt;!-- Ordered List排序列表 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span><span class="comment">&lt;!-- Unordered List不排序列表 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span>&gt;</span><span class="tag">&lt;/<span class="name">form</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 表示文档中的一个区域，此区域包含交互控件，用于向 Web 服务器提交信息 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;https://www.google.com&quot;</span>&gt;</span>这是一个链接<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 标签&lt;a&gt;: 设置超文本链接 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;/images/logo.png&quot;</span> <span class="attr">width</span>=<span class="string">&quot;258&quot;</span> <span class="attr">height</span>=<span class="string">&quot;39&quot;</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 标签&lt;img&gt;: 设置图片 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="CSS"><a href="#CSS" class="headerlink" title="CSS"></a>CSS</h5><p><strong>层叠样式表</strong>（<strong>C</strong>ascading <strong>S</strong>tyle <strong>S</strong>heets) 是一种用来为结构化文档（如HTML文档或XML应用）添加样式（字体、间距和颜色等）的计算机语言</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>:<span class="number">#d0e4fe</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">h1</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>:orange;</span><br><span class="line">    <span class="attribute">text-align</span>:center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">p</span> &#123;</span><br><span class="line">    <span class="attribute">font-family</span>:<span class="string">&quot;Times New Roman&quot;</span>;</span><br><span class="line">    <span class="attribute">font-size</span>:<span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* Exemple: &lt;h2 id=&quot;boldFond&quot;&gt;加粗文本&lt;/h2&gt;*/</span></span><br><span class="line"><span class="selector-class">.boldFond</span> &#123;</span><br><span class="line">  font_weight: bold;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>如何在 <code>HTTP</code> 文件里使用 <code>CSS</code>文件</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">herf</span>=<span class="string">&quot;/style.css&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="3-浏览器和-Web-服务器之间的通信协议-HTTP"><a href="#3-浏览器和-Web-服务器之间的通信协议-HTTP" class="headerlink" title="3. 浏览器和 Web 服务器之间的通信协议 (HTTP)"></a>3. 浏览器和 Web 服务器之间的通信协议 (HTTP)</h4><p>HTTP协议是Hyper Text Transfer Protocol（超文本传输协议）的缩写,是用于从万维网服务器传输超文本到本地浏览器的传送协议，<strong>基于TCP/IP通信协议</strong>来传递数据（HTML 文件, 图片文件, 查询结果等）。面向连接，安全。</p><p>HTTP协议工作于 <code>C/S</code> 架构为上。浏览器作为HTTP客户端通过URL向HTTP服务端即WEB服务器发送所有请求。<u>Web服务器根据接收到的请求后，向客户端发送响应信息</u>：</p><pre class="mermaid">graph LRClient --Request--> ServerServer --Reponse--> Client</pre><p>HTTP使用URL来传输数据和建立连接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://127.0.0.1:8080/enseeiht/index.html?name=dai&amp;age=18#detail</span><br><span class="line">协议IP地址或DNS端口虚拟目录文件名参数部分锚</span><br></pre></td></tr></table></figure><h5 id="HTTP-请求数据格式"><a href="#HTTP-请求数据格式" class="headerlink" title="HTTP 请求数据格式"></a>HTTP 请求数据格式</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 请求行 --&gt;</span></span><br><span class="line">POST /example/index.html HTTP/1.1</span><br><span class="line"><span class="comment">&lt;!-- 请求方法 | 请求资源路径 | 协议及版本 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 请求头 key: value --&gt;</span></span><br><span class="line">Host: www.google.com<span class="comment">&lt;!-- 请求主机名 --&gt;</span></span><br><span class="line">User_Agent: Chrome<span class="comment">&lt;!-- 请求的浏览器信息 --&gt;</span></span><br><span class="line">Accept: xxx/xxx<span class="comment">&lt;!-- 浏览器能接收的资源类型，如text/*、image/* --&gt;</span></span><br><span class="line">Cookie: NAME=VALUE <span class="comment">&lt;!-- 上报 Cookie --&gt;</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 请求体  --&gt;</span></span><br><span class="line">username=xxx&amp;password=123456</span><br></pre></td></tr></table></figure><p>或 <code>json</code> 格式的 HTTP 请求数据</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">POST http<span class="punctuation">:</span><span class="comment">//www.example.com HTTP/1.1 </span></span><br><span class="line">Content-Type<span class="punctuation">:</span> application/json;charset=utf<span class="number">-8</span></span><br><span class="line"></span><br><span class="line"><span class="punctuation">&#123;</span><span class="attr">&quot;username&quot;</span><span class="punctuation">:</span><span class="string">&quot;xxx&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;password&quot;</span><span class="punctuation">:</span><span class="string">&quot;123456&quot;</span><span class="punctuation">,</span> <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span> <span class="number">24</span><span class="punctuation">,</span> <span class="attr">&quot;hobby&quot;</span><span class="punctuation">:</span><span class="punctuation">[</span><span class="string">&quot;x&quot;</span><span class="punctuation">,</span><span class="string">&quot;xx&quot;</span><span class="punctuation">,</span><span class="string">&quot;xxx&quot;</span><span class="punctuation">]</span><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure><p>或 <code>xml</code> 格式的 HTTP 请求数据</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">POST http://www.example.com HTTP/1.1 </span><br><span class="line">Content-Type: text/xml</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="meta">&lt;REQ&gt;</span></span><br><span class="line"><span class="meta">&lt;username&gt;xxx&lt;/username&gt;</span></span><br><span class="line"><span class="meta">&lt;passowrd&gt;123456&lt;/password&gt;</span></span><br><span class="line"><span class="meta">&lt;/REQ&gt;</span></span><br></pre></td></tr></table></figure><h6 id="HTTP-的请求方法"><a href="#HTTP-的请求方法" class="headerlink" title="HTTP 的请求方法"></a>HTTP 的请求方法</h6><ul><li><p><code>GET</code>：请求指定的页面信息，并返回实体主体。 </p><p><u>在<strong>请求行</strong>中请求 (<code>/example/index.html?username=xxx&amp;password=123456</code>)，<strong>有长度限制</strong></u>。</p></li><li><code>HEAD</code>：类似于 <code>GET</code> 请求，只不过返回的响应中没有具体的内容，用于获取报头 </li><li><code>POST</code>：向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。<code>POST</code> 请求可能会导致新的资源的建立和/或已有资源的修改。<u>在<strong>请求体</strong>中请求，<strong>没有长度限制</strong></u>。</li><li><code>PUT</code>：从客户端向服务器传送的数据取代指定的文档的内容。</li><li><code>DELETE</code>：请求服务器删除指定的页面。 </li><li><code>CONNECT</code>：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。 </li><li><code>OPTIONS</code>：允许客户端查看服务器的性能。 </li><li><code>TRACE</code>：回显服务器收到的请求，主要用于测试或诊断。</li></ul><h5 id="HTTP-响应数据格式"><a href="#HTTP-响应数据格式" class="headerlink" title="HTTP 响应数据格式"></a>HTTP 响应数据格式</h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 响应行 --&gt;</span></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line"><span class="comment">&lt;!-- 协议及版本 响应状态 状态码描述 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 响应头 key: value --&gt;</span></span><br><span class="line">Server: www.google.com<span class="comment">&lt;!-- 响应主机名 --&gt;</span></span><br><span class="line">Content-Type: text/html<span class="comment">&lt;!-- 该响应的内容类型，text/html、image/jpg --&gt;</span></span><br><span class="line">Content-Length:<span class="comment">&lt;!-- 该响应的内容长度(字节数) --&gt;</span></span><br><span class="line">Content-Encoding:<span class="comment">&lt;!-- 该响应的编码 --&gt;</span></span><br><span class="line">Cache-Control：<span class="comment">&lt;!-- 客户端如何缓存该响应 --&gt;</span></span><br><span class="line">Set-Cookie: NAME=VALUE, expires=过期时间戳, ... <span class="comment">&lt;!-- 下放 Cookie --&gt;</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 响应体  --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">http</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">http</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="HTTP-状态码"><a href="#HTTP-状态码" class="headerlink" title="HTTP 状态码"></a>HTTP 状态码</h6><p>状态代码有三位数字组成，第一个数字定义了响应的类别，共分五种类别:</p><ul><li><code>1xx</code>：指示信息。表示请求已接收，继续处理 </li><li><code>2xx</code>：成功。表示请求已被成功接收、理解、接受 </li><li><code>3xx</code>：重定向。要完成请求必须进行更进一步的操作 </li><li><code>4xx</code>：客户端错误。请求有语法错误或请求无法实现 </li><li><code>5xx</code>：服务器端错误。服务器未能实现合法的请求</li></ul><p>常见状态码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">200 OK                        //客户端请求成功</span><br><span class="line">302 Found//资源已移动到Location响应头指定的URL，浏览器自动重新跳转</span><br><span class="line">400 Bad Request               //客户端请求有语法错误，不能被服务器所理解</span><br><span class="line">401 Unauthorized              //请求未经授权</span><br><span class="line">403 Forbidden                 //服务器收到请求，但是拒绝提供服务</span><br><span class="line">404 Not Found                 //请求资源不存在，eg：输入了错误的URL</span><br><span class="line">500 Internal Server Error     //服务器发生不可预期的错误</span><br><span class="line">503 Server Unavailable        //服务器当前不能处理客户端的请求，一段时间后可能恢复正常</span><br></pre></td></tr></table></figure><h4 id="4-HTTP-表单-formulaire"><a href="#4-HTTP-表单-formulaire" class="headerlink" title="4. HTTP 表单 (formulaire)"></a>4. HTTP 表单 (formulaire)</h4><p>网站怎样与用户进行交互？答案是使用HTML表单(form)。表单是可以把浏览者输入的数据传送到服务器端，这样服务器端程序就可以处理表单传过来的数据。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;url&quot;</span> <span class="attr">method</span>=<span class="string">&quot;method&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--action: 规定当提交表单时向何处发送表单数据 </span></span><br><span class="line"><span class="comment">method: 规定用于发送 form-data 的 HTTP 方法(GET/POST)--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="get与-post的差别"><a href="#get与-post的差别" class="headerlink" title="get与 post的差别"></a><code>get</code>与 <code>post</code>的差别</h5><p>本质上的区别是语义的区别，根据HTTP规范，<code>POST</code> 的语义是根据请求负荷（报文主体）对指定的资源做出处理。<code>POST</code> 方法是安全、不可缓存的。<code>GET</code> 的语义是请求获取指定的资源，具体的处理方式视资源类型而不同。<code>GET</code> 不安全，可缓存。具体差别如下：</p><ul><li>get在后退刷新时是无害的，post会重新提交请求；</li><li>get参数通过URL传递，post放在Request body中；</li><li>get请求参数保留在浏览器历史记录中，post参数不会保留；</li><li>get产生的URL地址可以被存为书签，而post不可以；</li><li>对参数的数据类型，get只接受ASCII字符，而post没有限制；</li><li>get比post更不安全，因为发送的数据显示在URL上，在发送密码或其他敏感信息时绝不要使用get;</li><li>get请求只能进行url编码，而post支持多种编码方式。</li></ul><h5 id="表单元素：input"><a href="#表单元素：input" class="headerlink" title="表单元素：input"></a>表单元素：<code>input</code></h5><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;type&quot;</span> <span class="attr">name</span>=<span class="string">&quot;input&quot;</span> <span class="attr">size</span>=<span class="string">&quot;10pd&quot;</span> <span class="attr">value</span>=<span class="string">&quot;value&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h6 id="常见的-input-标签"><a href="#常见的-input-标签" class="headerlink" title="常见的 input 标签:"></a>常见的 <code>input</code> 标签:</h6><ul><li><p><code>submit</code> 用于数据提交</p></li><li><p><code>text</code> 可输入文本</p></li><li><p><code>password</code> 用于输入密码，输入内容会呈现为小圆点，进行隐藏</p></li><li><p><code>checkbox</code> 多选框</p></li><li><p><code>radio</code> 多选框</p></li><li><p><code>select</code> 下拉选择 并和 <code>option</code> 标签一起使用</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">&quot;choice&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;value1&quot;</span>&gt;</span>选择1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;value2&quot;</span>&gt;</span>选择2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;value3&quot;</span>&gt;</span>选择3<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p><code>file</code> 上传文件</p></li><li><p><code>hidden</code> 隐藏组件</p></li><li><p><code>bottom</code> 按钮</p></li><li><p><code>reset</code> 重置表单</p></li><li><p><code>textarea</code> 文本区域</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;teatarea&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;4&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;4&quot;</span>&gt;</span></span><br><span class="line">这是文本区域，可以键入</span><br><span class="line"><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="5-CGI的工作原理"><a href="#5-CGI的工作原理" class="headerlink" title="5. CGI的工作原理"></a>5. CGI的工作原理</h4><p>CGI（Common Gateway Interface）公共网关接口，根据CGI标准，编写外部扩展应用程序，可以对客户端浏览器输入的数据进行处理，完成客户端与服务器的交互操作。CGI规范定义了Web服务器如何向扩展应用程序发送消息，在收到扩展应用程序的信息后又如何进行处理等内容。</p><p>CGI 应用程序能与浏览器进行交互，还可通过数据API与数据库服务器等外部数据源进行通信，从数据库服务器中获取数据。格式化为HTML文档后，发送给浏览器，也可以将从浏览器获得的数据放到数据库中。</p><pre class="mermaid">graph RLsubgraph "C/S"浏览器 --"get/post"--> Web服务器Web服务器 --"generated.html"--> 浏览器endWeb服务器 --stdin--> CGIWeb服务器 --$QUERY_STRING--> CGICGI --stdout--> Web服务器subgraph "动态网页"CGI --传入数据--> 程序程序 --产生数据--> CGIend</pre><p><code>&lt;form&gt;</code>标签的 <code>METHOD</code> 属性来决定具体使用哪一种方法。</p><ul><li>在 <code>METHOD=GET</code> 时，向 CGI 传递表单编码信息的是通过命令来进行的。表单编码信息大多数是通过环境变量 <code>QUERY_STRING</code> 来传递的。</li><li>若 <code>METHOD=POST</code>，表单信息通过标准输入 <code>stdin</code> 来读取。</li></ul><h4 id="6-HTTP-Cookies"><a href="#6-HTTP-Cookies" class="headerlink" title="6. HTTP Cookies"></a>6. HTTP Cookies</h4><p><code>Cookie</code> 是一个<strong>保存在客户机</strong>中的简单的文本文件, 这个文件与特定的 Web 文档关联在一起, <u>保存了该客户机访问这个Web 文档时的信息, 当客户机再次访问这个 Web 文档时这些信息可供该文档使用</u>。</p><p><strong>由服务器创建，保存在客户端中</strong></p><h5 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h5><p>Cookie是一段不超过4KB的小型文本数据，由一个名称（Name）、一个值（Value）和其它几个用于控制Cookie有效期、安全性、使用范围的可选属性组成。其中：</p><ol><li><code>Name/Value</code>：设置Cookie的名称及相对应的值，对于认证Cookie，<code>Value</code>值包括Web服务器所提供的访问令牌。</li><li><code>Expires</code>属性：设置Cookie的生存期。有两种存储类型的Cookie：会话性与持久性。Expires属性缺省时，为会话性Cookie，仅保存在客户端内存中，并在用户关闭浏览器时失效；持久性Cookie会保存在用户的硬盘中，直至生存期到或用户直接在网页中单击“注销”等按钮结束会话时才会失效 [3] 。</li><li><code>Path</code> 属性：定义了Web站点上可以访问该Cookie的目录。</li><li><code>Domain</code> 属性：指定了可以访问该 Cookie 的 Web 站点或域。Cookie 机制并未遵循严格的同源策略，允许一个子域可以设置或获取其父域的 Cookie。当需要实现单点登录方案时，Cookie 的上述特性非常有用，然而也增加了 Cookie受攻击的危险，比如攻击者可以借此发动会话定置攻击。因而，浏览器禁止在 <code>Domain</code> 属性中设置<code>.org</code>、<code>.com</code> 等通用顶级域名、以及在国家及地区顶级域下注册的二级域名，以减小攻击发生的范围</li><li><code>Secure</code> 属性：指定是否使用 <code>HTTPS</code> 安全协议发送Cookie。使用HTTPS安全协议，可以保护Cookie在浏览器和Web服务器间的传输过程中不被窃取和篡改。该方法也可用于Web站点的身份鉴别，即在HTTPS的连接建立阶段，浏览器会检查Web网站的SSL证书的有效性。但是基于兼容性的原因（比如有些网站使用自签署的证书）在检测到SSL证书无效时，浏览器并不会立即终止用户的连接请求，而是显示安全风险信息，用户仍可以选择继续访问该站点。由于许多用户缺乏安全意识，因而仍可能连接到Pharming攻击所伪造的网站</li><li><code>HTTPOnly</code> 属性 ：用于防止客户端脚本通过document.cookie属性访问Cookie，有助于保护Cookie不被跨站脚本攻击窃取或篡改。但是，HTTPOnly的应用仍存在局限性，一些浏览器可以阻止客户端脚本对Cookie的读操作，但允许写操作；此外大多数浏览器仍允许通过 <code>XMLHTTP</code> 对象读取 <code>HTTP</code> 响应中的Set-Cookie头 。</li></ol><h3 id="第二部分：动态网页"><a href="#第二部分：动态网页" class="headerlink" title="第二部分：动态网页"></a>第二部分：动态网页</h3><h4 id="2-1-Servlet"><a href="#2-1-Servlet" class="headerlink" title="2.1 Servlet"></a>2.1 Servlet</h4><p>Servlet是 Java 提供的一门<strong>动态web</strong>资源开发技术。是JavaEE 的规范之一，其实就是一个<u>接口</u>，我们需要定义 <code>Servlet</code> 的类实现 <code>Servlet</code>接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">Servlet</span>&#123;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ServletConfig config)</span> <span class="keyword">throws</span> ServletException;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">destory</span><span class="params">()</span> <span class="keyword">throws</span> ServletException;</span><br><span class="line">  ServletConfig <span class="title function_">getServletConfig</span><span class="params">()</span> <span class="keyword">throws</span> ServletException;</span><br><span class="line">  String <span class="title function_">getServletInfo</span><span class="params">()</span> <span class="keyword">throws</span> ServletException;</span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是在上述 <code>Servlet</code> 接口中只有 <code>void service(ServletRequest req, ServletResponse res)</code> 方法最为常用，我们将 <code>Servlet</code> 接口封装为 <code>HttpServlet</code> 抽象类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">HttpServlet</span> <span class="keyword">extends</span> <span class="title class_">GenericServlet</span> &#123;</span><br><span class="line"><span class="comment">/* Provides an abstract class to be subclassed to create an HTTP servlet suitable for a Web site. A subclass of HttpServlet must override at least one method, usually one of these:*/</span></span><br><span class="line">  HttpServletRequest req;</span><br><span class="line">HttpServletResponse res;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// if the servlet supports HTTP GET requests</span></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// for HTTP POST requests</span></span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Request-和-Response"><a href="#Request-和-Response" class="headerlink" title="Request 和 Response"></a>Request 和 Response</h5><p><img src="/2022/05/03/Appli-Web%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/2022-05-06 11.28.18.png" alt="2022-05-06 11.28.18" style="zoom:40%;"></p><h6 id="Request-获取请求数据"><a href="#Request-获取请求数据" class="headerlink" title="Request 获取请求数据"></a>Request 获取请求数据</h6><p>请求数据分为3部分：</p><ol><li>请求行：<code>GET /request-demo/req1?username=xxx HTTP/1.1</code><ul><li><code>String getMethod()</code>：获取请求方式：<code>GET/POST</code></li><li><code>String getContextPath()</code>：获取虛拟目录(项目访问路径)：<code>/request-demo</code></li><li><code>String Buffer getRequestURL()</code>：获取URL（统一资源定位符）：<code>http://localhost:8080/request-demo/req1</code></li><li><code>String getRequestURI()</code>：获取URI（统一资源标识符）：<code>/request-demo/req1</code></li><li><code>String getQueryString()</code>：获取请求参数（<code>GET</code> 方式）： <code>username=zhangsan&amp;password=1</code></li></ul></li><li>请求头：<code>User-Agent: Mozilla/5.0 Chrome/91.0.4472.106</code><ul><li>String getHeader(String name)：根据请求头名称，获取值</li></ul></li><li>请求体 (<code>POST</code> 方式)：<code>username=xxx&amp;password=123456</code><ul><li><code>ServletlnputStream getinputStream()</code>：获取字节输入流</li><li><code>BufferedReader getReader()</code>：获取字符输入流</li></ul></li></ol><p><code>getParameter()</code>：我们将 <code>GET</code> 方式中获取请求参数 <code>String getQueryString()</code> 和 <code>POST</code> 方式中获取请求参数 <code>BufferedReader getReader()</code> 同一为一种<u>通用的获取请求参数的方法：<code>getParameter(key)</code></u>。这其实是将所有的参数解析后存在在一个 <code>MAP</code> 中，通过 <code>key</code> 来获取 <code>value</code>。</p><p>【请求转发】<code>request.getRequestDispatcher(&quot;资源B的路径&quot;).forword(request,respond)</code>：如果服务器有两个资源，资源A 和资源B，资源A处理一部分后跳转 (forword) 到资源B继续处理。地址栏不变，一次请求</p><ul><li>请求转发资源间共享数据：使用 <code>Request</code> 对象<ul><li><code>void setAttribute(String name, Object o)</code>：存储数据到 <code>request</code> 域中</li><li><code>Object getAttribute (String name)</code>：根据 key，获取值</li><li><code>void removeAttribute(String name)</code>：根据 key，删除该键值对</li></ul></li></ul><h6 id="Response-设置响应数据"><a href="#Response-设置响应数据" class="headerlink" title="Response 设置响应数据"></a>Response 设置响应数据</h6><p>响应数据分为3部分：</p><ol><li>响应行：<code>HTTP/1.1 200 OK</code><ul><li><code>void setStatus(int statusCode)</code>：设置响应状态码</li></ul></li><li><p>响应头：<code>Content-Type: text/html</code></p><ul><li><code>void setHeader(String name, String value)</code>：设置响应头 键值对</li></ul></li><li><p>响应体：<code>&lt;html&gt;&lt;/html&gt;</code></p><ul><li><code>Printwriter writer =  response.getWriter()</code>：获取宇符输出流<ul><li><code>writer.write(&quot;&lt;html&gt;&quot;)</code></li></ul></li><li><code>Servletoutputstream outputStream = response.getoutputStream()</code>：获取字节输出流</li></ul></li></ol><p>【重定向 Redierct】当前资源A无法处理(<code>statusCode=302</code>)，重定向到别的资源B (<code>location</code>) 处理。地址栏变化，两次不同的请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">response.sendRedierct(<span class="string">&quot;资源B的路径&quot;</span>);</span><br><span class="line"><span class="comment">// 与以下代码等价</span></span><br><span class="line">response.setStatus(<span class="number">302</span>);</span><br><span class="line">response.setHeader(<span class="string">&quot;location&quot;</span>,<span class="string">&quot;资源B的路径&quot;</span>);</span><br></pre></td></tr></table></figure><p>例：</p><p><img src="/2022/05/03/Appli-Web%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/2022-05-03 20.48.15.png" alt="2022-05-03 20.48.15" style="zoom:50%;"></p><p><code>web_app/demo.html</code>：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Enter a person<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>= <span class="string">&quot;web_app/demo&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- action是请求的路径，规定当提交表单时向何处发送表单数据 --&gt;</span></span><br><span class="line">      firstname<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;firstname&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">      lastname<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lastname&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">      email<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;op&quot;</span> <span class="attr">value</span>=<span class="string">&quot;add&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">name</span>=<span class="string">&quot;op&quot;</span> <span class="attr">value</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><ul><li>由上述代码可见，<code>action</code> 指定的请求路径是 <code>web_app/demo</code></li><li><code>method</code> 指定的方法是 <code>post</code></li></ul><p><code>servletDemo.java</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个路径可以配置多个 urlPattern = &#123;&quot;/demo1&quot;, &quot;/demo2&quot;&#125;</span></span><br><span class="line"><span class="meta">@WebServlet(urlPattern=&quot;/web_app/demo&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Directory</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="type">PrintWriter</span> <span class="variable">out</span> <span class="operator">=</span> response.getWriter();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 对于数据库的操作</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">db_url</span> <span class="operator">=</span> <span class="string">&quot;jdbc:hsqldb:hsql://localhost/web_app&quot;</span>;</span><br><span class="line">      <span class="type">String</span> <span class="variable">db_user</span> <span class="operator">=</span> <span class="string">&quot;sa&quot;</span>;</span><br><span class="line">      Class.forName(<span class="string">&quot;org.hsqldb.jdbcDriver&quot;</span>);</span><br><span class="line">      <span class="type">Connection</span> <span class="variable">con</span> <span class="operator">=</span> DriverManager.getConnection(db_url, db_user, <span class="literal">null</span>);</span><br><span class="line">      </span><br><span class="line">      response.setContentType(<span class="string">&quot;text/html&quot;</span>);</span><br><span class="line">      out.print(<span class="string">&quot;&lt;html&gt;&lt;head&gt;&lt;title&gt;demo&lt;/title&gt;&lt;/head&gt;&quot;</span>);</span><br><span class="line">      out.print(<span class="string">&quot;&lt;body&gt;&lt;h1&gt;Enter a person&lt;/h1&gt;&quot;</span>);</span><br><span class="line">      </span><br><span class="line">      <span class="type">String</span> <span class="variable">op</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;op&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (op.equals(<span class="string">&quot;list&quot;</span>)) &#123;</span><br><span class="line">        <span class="comment">// op = list</span></span><br><span class="line">        <span class="type">Statement</span> <span class="variable">stmt</span> <span class="operator">=</span> con.createStatement();</span><br><span class="line">        <span class="type">ResultSet</span> <span class="variable">res</span> <span class="operator">=</span> stmt.executeQuery(<span class="string">&quot;SELECT * FROM demo&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">while</span>(res.next()) &#123;</span><br><span class="line">          out.print(<span class="string">&quot;&lt;p&gt;&quot;</span>+res.getString(<span class="string">&quot;firstname&quot;</span>)+<span class="string">&quot; &quot;</span>+res.getString(<span class="string">&quot;lastname&quot;</span>) +<span class="string">&quot; &quot;</span>+res.getString(<span class="string">&quot;email&quot;</span>)+<span class="string">&quot;&lt;/p&gt;&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// op = add</span></span><br><span class="line">        <span class="type">PreparedStatement</span> <span class="variable">ps</span> <span class="operator">=</span> con.prepareStatement(<span class="string">&quot;INSERT INTO demo VALUES(?,?,?)&quot;</span>);</span><br><span class="line">        ps.setString(<span class="number">1</span>, request.getParameter(<span class="string">&quot;firstname&quot;</span>));</span><br><span class="line">        ps.setString(<span class="number">2</span>, request.getParameter(<span class="string">&quot;lastname&quot;</span>));</span><br><span class="line">        ps.setString(<span class="number">3</span>, request.getParameter(<span class="string">&quot;email&quot;</span>));</span><br><span class="line">        ps.executeUpdate();</span><br><span class="line">        out.print(<span class="string">&quot;Person was added&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      out.print(<span class="string">&quot;&lt;/body&gt;&lt;/html&gt;&quot;</span>);</span><br><span class="line">      </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">      ex.printStackTrace(out);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h5><p>客户端的会话构造技术：将数据保存在客户端，每次请求都携带 Cookies 数据进行访问。</p><ul><li>Cookie 存活时间：<ul><li>默认情况下，Cookie 存储在浏览器内存中，当浏览器关闭，内存释放，则 Cookie 被销毁。</li><li><code>setMaxAge(int seconds)</code> ：设置存活时间。（+表示存入硬盘，到期删除；-表示默认情况；0表示删除对应Cookie）</li></ul></li></ul><p><img src="/2022/05/03/Appli-Web%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/2022-05-04 09.21.41.png" alt="2022-05-04 09.21.41" style="zoom:50%;"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1.创建Cookie对象，设置数据</span></span><br><span class="line"><span class="type">Cookie</span> <span class="variable">cookie</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cookie</span>(String name, String value);</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setValue</span><span class="params">(String newValue)</span>;</span><br><span class="line">String <span class="title function_">getValue</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setDomain</span><span class="params">(String pattern)</span>;</span><br><span class="line">String <span class="title function_">getDomain</span><span class="params">()</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setMxaAge</span><span class="params">(<span class="type">int</span> expiry)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">getMaxAge</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.发送Cookie到客户端：使用response对象</span></span><br><span class="line">HttpServletRequest.addCookie(cookie);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.获取客户端携带的所有Cookie</span></span><br><span class="line">Cookie[] cookies = HttpServletRequest.getCookie();</span><br><span class="line"><span class="comment">// 遍历所有cookies数组，获取每一个Cookie对象</span></span><br><span class="line"><span class="keyword">for</span> (Cookie c:cookies)&#123;</span><br><span class="line">  <span class="comment">// 得到键 key</span></span><br><span class="line">  c.getName();</span><br><span class="line">  <span class="comment">// 得到值 value</span></span><br><span class="line">  c.getValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h5><p>服务器端的会话跟踪技术：将数据保存在服务端。Session的是现实基于Cookies的。</p><p><img src="/2022/05/03/Appli-Web%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/2022-05-04 09.38.52.png" alt="2022-05-04 09.38.52" style="zoom:50%;"></p><p>JavaEE 提供了 <code>HttpSession</code> 接口，来实现<u>一次回话的多次请求间的<strong>数据共享功能</strong></u></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 获取 Session 对象</span></span><br><span class="line"><span class="type">HttpSession</span> <span class="variable">session</span> <span class="operator">=</span> HttpServletRequest.getSession;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. Session 中的功能</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">setAttribute</span><span class="params">(String name, Object o)</span>; <span class="comment">// 将数据存储到 Session 中</span></span><br><span class="line">Object <span class="title function_">getAttritube</span><span class="params">(String name)</span>; <span class="comment">// 根据 key 获得 value</span></span><br><span class="line"><span class="keyword">void</span> <span class="title function_">removeAttritude</span><span class="params">(String name)</span>; <span class="comment">// 根据 key 删除该键值对</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><h4 id="2-2-JSP"><a href="#2-2-JSP" class="headerlink" title="2.2 JSP"></a>2.2 JSP</h4><p>Java Server Page，即Java服务端页面。是一种动态网页技术，既可以定义 HTML、JS、CSS 等静态内容，还可以定义 Java 代码的动态内容。<code>JSP = HRTML + Java</code></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt; &lt;!-- html 代码 --&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;h1&gt;JSP, Hello world.&lt;/h1&gt;</span><br><span class="line">    &lt;% <span class="comment">// JSP 脚本：Java 代码</span></span><br><span class="line">    System.out.println(<span class="string">&quot;hello.jsp&quot;</span>);<span class="comment">// console 输出</span></span><br><span class="line">    %&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h5 id="JSP-原理"><a href="#JSP-原理" class="headerlink" title="JSP 原理"></a>JSP 原理</h5><p>JSP 本质上是一个 Servlet。JSP 在被访问时，由 JSP 容器（Tomcat）将其转换为 Java 文件（Servlet），再由 JSP 容器将其编译，最终对外提供服务的就是这个字节码文件：</p><p><img src="/2022/05/03/Appli-Web%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/2022-05-04 10.05.07.png" alt="2022-05-04 10.05.07" style="zoom:40%;"></p><h5 id="JSP-脚本-Scriptlet"><a href="#JSP-脚本-Scriptlet" class="headerlink" title="JSP 脚本 (Scriptlet)"></a>JSP 脚本 (Scriptlet)</h5><p>JSP 脚本用于在 JSP 页面内定义 Java 代码。</p><p>JSP 脚本的分类：</p><ul><li><code>&lt;% ... %&gt;</code>：Java 脚本。内容会直接放到 <code>_jspService()</code> 方法之中；</li><li><code>&lt;%= ... %&gt;</code>：表达式。内容会直接放到 <code>out.print()</code> 方法之中，作为 <code>out.print()</code> 的参数；</li><li><code>&lt;%! ... %&gt;</code>：声明。内容会放到 <code>_jspService()</code> 方法之外，被类直接包含。定义成员变量、方法等</li></ul><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;html&gt;</span><br><span class="line">&lt;% System.out.println(<span class="string">&quot;Hello, JSP&quot;</span>); %&gt;</span><br><span class="line">&lt;%= <span class="string">&quot;hello&quot;</span> %&gt;</span><br><span class="line">&lt;%! <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="number">123</span>; %&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">hello_jsp</span> <span class="keyword">extends</span> <span class="title class_">HttpJspBase</span> <span class="keyword">implements</span> <span class="title class_">JspSourceDependent</span> &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> <span class="number">123</span>;<span class="comment">// 成员变量或方法</span></span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">_jspService</span><span class="params">(req, res)</span> &#123;</span><br><span class="line">    out.write(<span class="string">&quot;&lt;html&gt;&quot;</span>);</span><br><span class="line">    System.out.println(<span class="string">&quot;Hello, JSP&quot;</span>);</span><br><span class="line">    out.print(<span class="string">&quot;hello&quot;</span>);<span class="comment">// 显示输出在页面上</span></span><br><span class="line">    out.write(<span class="string">&quot;&lt;\html&gt;&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="JSP-的指令标签"><a href="#JSP-的指令标签" class="headerlink" title="JSP 的指令标签"></a>JSP 的指令标签</h5><p>JSP指令用来设置整个JSP页面相关的属性，如网页的编码方式和脚本语言。</p><p>语法格式如下：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ directive attribute=<span class="string">&quot;value&quot;</span> %&gt;</span><br></pre></td></tr></table></figure><p>指令可以有很多个属性，它们以键值对的形式存在，并用逗号隔开。</p><p>JSP中的三种指令标签：</p><h6 id="lt-page-gt"><a href="#lt-page-gt" class="headerlink" title="&lt;%@ page ... %&gt;"></a><code>&lt;%@ page ... %&gt;</code></h6><p>Page指令为容器提供当前页面的使用说明。一个JSP页面可以包含多个page指令。</p><p>Page指令的语法格式：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page attribute=<span class="string">&quot;value&quot;</span> %&gt;</span><br></pre></td></tr></table></figure><p>等价的XML格式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">jsp:directive.page</span> <span class="attr">attribute</span>=<span class="string">&quot;value&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>属性</strong></th><th style="text-align:left"><strong>描述</strong></th></tr></thead><tbody><tr><td style="text-align:left"><code>buffer</code></td><td style="text-align:left">指定out对象使用缓冲区的大小</td></tr><tr><td style="text-align:left"><code>autoFlush</code></td><td style="text-align:left">控制out对象的 缓存区</td></tr><tr><td style="text-align:left"><code>contentType</code></td><td style="text-align:left">指定当前JSP页面的MIME类型和字符编码</td></tr><tr><td style="text-align:left"><code>errorPage</code></td><td style="text-align:left">指定当JSP页面发生异常时需要转向的错误处理页面</td></tr><tr><td style="text-align:left"><code>isErrorPage</code></td><td style="text-align:left">指定当前页面是否可以作为另一个JSP页面的错误处理页面</td></tr><tr><td style="text-align:left"><code>extends</code></td><td style="text-align:left">指定servlet从哪一个类继承</td></tr><tr><td style="text-align:left"><code>import</code></td><td style="text-align:left">导入要使用的Java类</td></tr><tr><td style="text-align:left"><code>info</code></td><td style="text-align:left">定义JSP页面的描述信息</td></tr><tr><td style="text-align:left"><code>isThreadSafe</code></td><td style="text-align:left">指定对JSP页面的访问是否为线程安全</td></tr><tr><td style="text-align:left"><code>language</code></td><td style="text-align:left">定义JSP页面所用的脚本语言，默认是Java</td></tr><tr><td style="text-align:left"><code>session</code></td><td style="text-align:left">指定JSP页面是否使用session</td></tr><tr><td style="text-align:left"><code>isELIgnored</code></td><td style="text-align:left">指定是否执行EL表达式</td></tr><tr><td style="text-align:left"><code>isScriptingEnabled</code></td><td style="text-align:left">确定脚本元素能否被使用</td></tr></tbody></table></div><h6 id="包含：-lt-include-gt"><a href="#包含：-lt-include-gt" class="headerlink" title="包含：&lt;%@ include ... %&gt;"></a>包含：<code>&lt;%@ include ... %&gt;</code></h6><p>使用包含操作，可以将一些重复的代码包含进来继续使用，从正常的页面组成来看，有时可能分为几个区域。而其中的一些区域可能是一直不需要改变的，改变的就其中的一个具体内容区域。现在有两种方法可以实现上述功能。</p><ul><li>方法一：在每个JSP 页面 （HTML）都包含工具栏、头部信息、尾部信息、具体内容</li><li>方法二：将工具栏、头部信息、尾部信息都分成各个独立的文件，使用的时候直接导入</li></ul><p>很明显，第二种方法比第一种更好，第一种会存在很多重复的代码，并旦修改很不方便，在JSP 中如果要想实现包含的操作，有两种做法：<strong>静态包含</strong>、<strong>动态包含</strong>，静态包含使用 <code>include</code> 指令即可，动态包含则需要使用 <code>include</code> 动作标签。</p><ul><li><p>静态包含：<code>&lt;%@ include file=&quot;要包含文件的相对路径&quot; %&gt;</code></p></li><li><p>动态包含：<code>&lt;jsp:include file=&quot;要包含文件的相对路径&quot;&gt; &lt;/jsp:include&gt;</code></p></li></ul><h6 id="Taglib指令"><a href="#Taglib指令" class="headerlink" title="Taglib指令"></a>Taglib指令</h6><p>JSP API允许用户自定义标签，一个自定义标签库就是自定义标签的集合。Taglib指令引入一个自定义标签集合的定义，包括库路径、自定义标签。</p><p>Taglib指令的语法：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ taglib uri=<span class="string">&quot;uri&quot;</span> prefix=<span class="string">&quot;prefixOfTag&quot;</span> %&gt;</span><br></pre></td></tr></table></figure><h4 id="2-3-MVN-模式"><a href="#2-3-MVN-模式" class="headerlink" title="2.3 MVN 模式"></a>2.3 MVN 模式</h4><p>MVC 是一种分层开发的模式，其中：</p><ul><li>M：Model，业务模型，处理业务</li><li>V：View，视图，界面展示</li><li>C：Controller，控制器，处理请求，调用模型和视图，也可以在一个控制器中调用另一个控制器</li></ul><p><img src="/2022/05/03/Appli-Web%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/2022-05-04 11.29.09.png" alt="2022-05-04 11.29.09" style="zoom:40%;"></p><h5 id="三层架构：软件设计架构"><a href="#三层架构：软件设计架构" class="headerlink" title="三层架构：软件设计架构"></a>三层架构：软件设计架构</h5><p><img src="/2022/05/03/Appli-Web%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/2022-05-04 11.46.01.png" alt="2022-05-04 11.46.01" style="zoom:50%;"></p><ul><li>数据访问层：对数据库的CRUD基本操作</li><li>业务逻辑层：对业务逻辑进行封装，组合数据访问层层中基本功能，形成复杂的业务逻辑功能</li><li>表现层：接收请求，封装数据，调用业务逻辑层，响应数据</li></ul><h4 id="2-4-案例"><a href="#2-4-案例" class="headerlink" title="2.4 案例"></a>2.4 案例</h4><p><img src="/2022/05/03/Appli-Web%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/2022-05-04 12.59.01.png" alt="2022-05-04 12.59.01" style="zoom:50%;"></p><p><img src="/2022/05/03/Appli-Web%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/2022-05-04 12.59.29.png" alt="2022-05-04 12.59.29" style="zoom:50%;"></p><p><img src="/2022/05/03/Appli-Web%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/2022-05-04 12.59.46.png" alt="2022-05-04 12.59.46" style="zoom:50%;"></p><p><img src="/2022/05/03/Appli-Web%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/2022-05-04 13.00.04.png" alt="2022-05-04 13.00.04" style="zoom:50%;"></p><p>我们使用一个简单的例子实现上述 MVC + 三层结构，其中我们不需要连接数据库，所以我们把 “数据访问层”和“数据库”用一个类 <code>Compte</code> 取代：</p><p><code>Compte.java</code> (DATA)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Compte</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line">  <span class="keyword">private</span> String nom;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> solde;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Compte</span><span class="params">()</span> &#123;&#125; <span class="comment">// 空构造函数</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Compte</span><span class="params">(<span class="type">int</span> num, String nom, <span class="type">int</span> solde)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.num = num;</span><br><span class="line">    <span class="built_in">this</span>.nom = nom;</span><br><span class="line">    <span class="built_in">this</span>.solde = solde;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.num = num;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getNom</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.nom;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNom</span><span class="params">(String nom)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.nom = nom;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSolde</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.solde;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSolde</span><span class="params">(<span class="type">int</span> solde)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.solde = solde;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    rerturn <span class="string">&quot;Compte [num=&quot;</span> + num + <span class="string">&quot;,nom=&quot;</span> + nom + <span class="string">&quot;,solde=&quot;</span> + solde + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Facade.java</code> (Service)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Facade</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Facade</span><span class="params">()</span> &#123;</span><br><span class="line">    addCompte(<span class="keyword">new</span> <span class="title class_">Compte</span>(<span class="number">1</span>, <span class="string">&quot;dan&quot;</span>, <span class="number">2000</span>));</span><br><span class="line">    addCompte(<span class="keyword">new</span> <span class="title class_">Compte</span>(<span class="number">2</span>, <span class="string">&quot;alain&quot;</span>, <span class="number">4000</span>));</span><br><span class="line">    addCompte(<span class="keyword">new</span> <span class="title class_">Compte</span>(<span class="number">3</span>, <span class="string">&quot;luc&quot;</span>, <span class="number">6000</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> Map&lt;Integer, Compte&gt; comptes = <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;Integer, Compte&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCompte</span><span class="params">(Compte c)</span>&#123;</span><br><span class="line">    comptes.put(c.getNum(), c);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Collection&lt;Compte&gt; <span class="title function_">consulterComptes</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> comptes.values();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Compte <span class="title function_">consulterCompte</span><span class="params">(<span class="type">int</span> num)</span> <span class="keyword">throws</span> RuntimeException &#123;</span><br><span class="line">    <span class="type">Compte</span> <span class="variable">c</span> <span class="operator">=</span> comptes.get(num);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">null</span>)</span><br><span class="line">      <span class="keyword">throws</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Compte introuvable&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debit</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> montant)</span> <span class="keyword">throws</span> RuntimeException &#123;</span><br><span class="line">    <span class="type">Compte</span> <span class="variable">c</span> <span class="operator">=</span> consulterCompte(num);</span><br><span class="line">    <span class="keyword">if</span> (c.getSolde() &lt; montant)</span><br><span class="line">      <span class="keyword">throws</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Solde insuffisant&quot;</span>);</span><br><span class="line">    c.setSolde(c.getSolde - montant);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">credit</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> montant)</span> <span class="keyword">throws</span> RuntimeException &#123;</span><br><span class="line">    <span class="type">Compte</span> <span class="variable">c</span> <span class="operator">=</span> consulterCompte(num);</span><br><span class="line">    c.setSolde(c.getSolde + montant);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Controller.java</code> (servlet)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/Controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Controller</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="type">Facade</span> <span class="variable">facade</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Facade</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">action</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;action&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (action.equals(<span class="string">&quot;consulter&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(request.getParameter(<span class="string">&quot;num&quot;</span>));</span><br><span class="line">        request.setAttribute(<span class="string">&quot;num&quot;</span>, num);</span><br><span class="line">        request.setAttribute(<span class="string">&quot;compte&quot;</span>, facade.consulterCompte(num));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (action.equals(<span class="string">&quot;consulterTous&quot;</span>))&#123;</span><br><span class="line">         request.setAttribute(<span class="string">&quot;comptes&quot;</span>, facade.consulterComptes());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (action.equals(<span class="string">&quot;debit&quot;</span>) || action.equals(<span class="string">&quot;credit&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(request.getParameter(<span class="string">&quot;num&quot;</span>));</span><br><span class="line">        <span class="type">int</span> <span class="variable">montant</span> <span class="operator">=</span> Integer.parseInt(request.getParameter(<span class="string">&quot;montant&quot;</span>));</span><br><span class="line">        request.setAttribute(<span class="string">&quot;num&quot;</span>, num);</span><br><span class="line">        <span class="keyword">if</span> (action.equals(<span class="string">&quot;debit&quot;</span>)) &#123;</span><br><span class="line">          facade.debit(num, montant);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          facade.crebit(num, montant);</span><br><span class="line">        &#125;</span><br><span class="line">        request.setAttribute(<span class="string">&quot;num&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      request.setAttribute(<span class="string">&quot;exception: &quot;</span>, e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    request.getRequestDispatcher(<span class="string">&quot;Banque.jsp&quot;</span>).forward(request, response);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Banque.jsp</code> (View)</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">&quot;java&quot;</span> <span class="keyword">import</span>=<span class="string">&quot;java.util.*&quot;</span> contentType=<span class="string">&quot;text/html; charset=UTF-8&quot;</span> pageEncoding=<span class="string">&quot;UTF-8&quot;</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span></span><br><span class="line"><span class="string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">&quot;Content-Type&quot;</span> content=<span class="string">&quot;text/html; charset=UTF-8&quot;</span>&gt;</span><br><span class="line">&lt;title&gt;Insert title here&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">  </span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=<span class="string">&quot;Controller&quot;</span> method=<span class="string">&quot;get&quot;</span>&gt;</span><br><span class="line">&lt;table&gt;</span><br><span class="line"> &lt;tr&gt;</span><br><span class="line"> &lt;td&gt; Code :&lt;/td&gt;</span><br><span class="line"> &lt;td&gt;&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;num&quot;</span> value=<span class="string">&quot;$&#123;num&#125;&quot;</span>&gt;&lt;/td&gt; </span><br><span class="line">          &lt;!-- $&#123;num&#125; EL表达式 = request.getAttribute(<span class="string">&quot;num&quot;</span>); --&gt;</span><br><span class="line"> &lt;td&gt;&lt;input type=<span class="string">&quot;submit&quot;</span> name=<span class="string">&quot;action&quot;</span> value=<span class="string">&quot;consulter&quot;</span>&gt;&lt;/td&gt;</span><br><span class="line"> &lt;td&gt;&lt;input type=<span class="string">&quot;submit&quot;</span> name=<span class="string">&quot;action&quot;</span> value=<span class="string">&quot;consultertous&quot;</span>&gt;&lt;/td&gt;</span><br><span class="line"> &lt;/tr&gt;</span><br><span class="line"> &lt;/table&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;% <span class="keyword">if</span> (request.getAttribute(<span class="string">&quot;compte&quot;</span>) != <span class="literal">null</span>) &#123; %&gt;</span><br><span class="line"></span><br><span class="line"> &lt;table&gt;</span><br><span class="line"> &lt;tr&gt;&lt;td&gt; Num :&lt;/td&gt;&lt;td&gt;$&#123;compte.num&#125;&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line"> &lt;tr&gt;&lt;td&gt; Nom :&lt;/td&gt;&lt;td&gt;$&#123;compte.nom&#125;&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line"> &lt;tr&gt;&lt;td&gt; Solde :&lt;/td&gt;&lt;td&gt;$&#123;compte.solde&#125;&lt;/td&gt;&lt;/tr&gt;</span><br><span class="line"> &lt;/table&gt;</span><br><span class="line"></span><br><span class="line"> &lt;form action=<span class="string">&quot;Controller&quot;</span> method=<span class="string">&quot;get&quot;</span>&gt;</span><br><span class="line"> &lt;table&gt;</span><br><span class="line"> &lt;tr&gt;</span><br><span class="line"> &lt;td&gt;&lt;input type=<span class="string">&quot;hidden&quot;</span> name=<span class="string">&quot;num&quot;</span> value=<span class="string">&quot;$&#123;num&#125;&quot;</span>&gt;&lt;/td&gt;</span><br><span class="line"> &lt;td&gt;&lt;input type=<span class="string">&quot;text&quot;</span> name=<span class="string">&quot;montant&quot;</span>&gt;&lt;/td&gt;</span><br><span class="line"> &lt;td&gt;&lt;input type=<span class="string">&quot;submit&quot;</span> name=<span class="string">&quot;action&quot;</span> value=<span class="string">&quot;debit&quot;</span>&gt;&lt;/td&gt;</span><br><span class="line"> &lt;td&gt;&lt;input type=<span class="string">&quot;submit&quot;</span> name=<span class="string">&quot;action&quot;</span> value=<span class="string">&quot;credit&quot;</span>&gt;&lt;/td&gt;</span><br><span class="line"> &lt;/tr&gt;</span><br><span class="line"> &lt;/table&gt;</span><br><span class="line"> &lt;/form&gt;</span><br><span class="line"></span><br><span class="line">&lt;% &#125; %&gt;</span><br><span class="line">  &lt;% Collection&lt;Compte&gt; l = (Collection&lt;Compte&gt;)request.getAttribute(<span class="string">&quot;comptes&quot;</span>);</span><br><span class="line"> <span class="keyword">if</span> (l != <span class="literal">null</span>) &#123;</span><br><span class="line">%&gt;</span><br><span class="line">    </span><br><span class="line">&lt;table border=<span class="string">&quot;1&quot;</span> width=<span class="string">&quot;80%&quot;</span>&gt;</span><br><span class="line">&lt;tr&gt; &lt;th&gt;Num&lt;/th&gt;&lt;th&gt;Nom&lt;/th&gt;&lt;th&gt;Solde&lt;/th&gt;&lt;/tr&gt;</span><br><span class="line">&lt;% <span class="keyword">for</span> (Compte c : l) &#123; %&gt;</span><br><span class="line">&lt;tr&gt;</span><br><span class="line">        &lt;td&gt;&lt;%=c.getNum() %&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;&lt;%=c.getNom() %&gt;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;&lt;%=c.getSolde() %&gt;&lt;/td&gt;</span><br><span class="line">      &lt;/tr&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line">&lt;% &#125; %&gt;</span><br><span class="line">    </span><br><span class="line">$&#123;exception&#125;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="第三部分：EJB"><a href="#第三部分：EJB" class="headerlink" title="第三部分：EJB"></a>第三部分：EJB</h3><p>EBJ (Enterprise JavaBean) 运行在容器 (Container) 中。EJB 实际上就是一个封装了业务逻辑的 Java 类。</p><ul><li>EJB 支持分布式。分布式对象之间实现分布透明性，即在客户端代码中无需指定分布式对象的位置；</li><li>EJB 支持分布式对象之间的事物（RMI 不支持）</li><li>支持不同类型的客户端</li></ul><p><img src="/2022/05/03/Appli-Web%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/2022-05-04 14.40.38.png" alt="2022-05-04 14.40.38" style="zoom:50%;"></p><h4 id="Session-Bean"><a href="#Session-Bean" class="headerlink" title="Session Bean"></a>Session Bean</h4><p>Session Bean 可以<strong>执行业务逻辑操作</strong>，比如注册用户、订单登记等。在上级部分所讲的“三层结构”中位于<strong>业务逻辑层</strong>。</p><p>何为 Session？</p><p>从客户端获得 EJB 对象开始，多次调用 EJB 对象的方法，直到客户端生命周期结束，或客户端释放了 EJB 队象为止，称为一次会话 (Session)。与返回的 EJB 对象有关，如果不是同一个对象（内存地址不同），则不是同一个会话。</p><pre class="mermaid">sequenceDiagram    participant c as Client    participant ec as EJB容器    participant eo as EJB对象    c ->> ec :1. JNDI 查找 EJB对象    ec ->> c :2. 返回 EJB对象1    c ->> eo :3. 调用 EJB对象1 的方法    c ->> eo :4. 调用 EJB对象1 的方法    c ->> eo :5. 调用 EJB对象1 的方法    Note over eo :以上操作均在一个 Session1 中    Note over c :客户端生命周期结束    c ->> ec :6. JNDI 查找 EJB对象    ec ->> c :7. 返回 EJB对象2    c ->> eo :8. 调用 EJB对象2 的方法    c ->> eo :9. 调用 EJB对象2 的方法    c ->> eo :10. 调用 EJB对象2 的方法    Note over eo :以上操作均在一个 Session2 中</pre><h5 id="Session-Bean-的状态"><a href="#Session-Bean-的状态" class="headerlink" title="Session Bean 的状态"></a>Session Bean 的状态</h5><p>何为对象的状态？</p><p>对象的状态是由其实例变量（即成员变量）的值组成。</p><ul><li>实例变量：在不同的实例中，变量的值可以是不同的。非静态变量。</li><li>类变量：这个类的所有实例都一个值。<code>static</code> 变量</li></ul><h6 id="Stateful-Session-Bean-有状态的-Session-Bean"><a href="#Stateful-Session-Bean-有状态的-Session-Bean" class="headerlink" title="Stateful Session Bean (有状态的 Session Bean)"></a>Stateful Session Bean (有状态的 Session Bean)</h6><p>EJB 能够为同一个客户端在多次请求（方法调用）之间保持与其对应的状态信息</p><blockquote><p>从 HTTP Session 类比 Stateful Session Bean：</p></blockquote><div class="table-container"><table><thead><tr><th>客户动作</th><th>服务器响应</th></tr></thead><tbody><tr><td>1、打开浏览器</td><td></td></tr><tr><td>2、访问购物网站</td><td>3、创建 HTTP Session 对象</td></tr><tr><td></td><td>4、返回 jsessionid</td></tr><tr><td>5、将 jsessionid 写入 cookie</td><td></td></tr><tr><td>6、往购物车内添加商品</td><td></td></tr><tr><td>7、向系统提交商品信息，以及 jsessionid 的值</td><td>8、服务器根据 jsessionid 找到对应的 HTTP Session对象，同时，创建购物车对象，与 Session 绑定</td></tr><tr><td>9、 继续添加商品，或删除商品</td><td></td></tr><tr><td>10、每次向服务器提交数据的时候，都会带着一个 jsessionid 的信息</td><td>11、服务器通过 jsessionid 来辨认不同的客户端，以及维护这些客户端的状态信息</td></tr></tbody></table></div><p>EJB 实例池通过 Token 令牌区分不同的客户端，从而实现 Stateful Session Bean：</p><p><img src="/2022/05/03/Appli-Web%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/2022-05-04 15.01.19.png" alt="2022-05-04 15.01.19" style="zoom:45%;"></p><h6 id="Stateless-Session-Bean-无状态的-Session-Bean"><a href="#Stateless-Session-Bean-无状态的-Session-Bean" class="headerlink" title="Stateless Session Bean (无状态的 Session Bean)"></a>Stateless Session Bean (无状态的 Session Bean)</h6><p>是指 EJB 容器不会对 EJB 的状态进行管理。容器会使用实例池的方式，甚至单例 (Singleton) 的方式来实现无状态的 Session Bean。</p><blockquote><p>是否可以理解成：在有状态的 Session Bean 中，实例池不再根据 Token 区分不同的客户端？</p></blockquote><h6 id="Singleton-Session-Bean-单例的-Session-Bean"><a href="#Singleton-Session-Bean-单例的-Session-Bean" class="headerlink" title="Singleton Session Bean (单例的 Session Bean)"></a>Singleton Session Bean (单例的 Session Bean)</h6><p>实例池中只有一个 EJB对象，不再对客户端的状态进行区别管理，而统一使用一个 EJB 对象</p><h4 id="客户端访问接口"><a href="#客户端访问接口" class="headerlink" title="客户端访问接口"></a>客户端访问接口</h4><h5 id="Remote-远程客户端接口"><a href="#Remote-远程客户端接口" class="headerlink" title="@Remote 远程客户端接口"></a><code>@Remote</code> 远程客户端接口</h5><ul><li>客户端与其调用的 EJB 对象不在同一个 JVM 进程中；</li><li>可以是 web组件、应用客户端、或是其他的 EJB；</li><li>对于远程客户端来说，EJB 的位置是透明的；</li><li>为了创建一个可以被远程客户端访问的 EJB，需要用 <code>@Remote</code> 注解来定义这些 EJB</li></ul><h5 id="Local-本地客户端接口"><a href="#Local-本地客户端接口" class="headerlink" title="@Local 本地客户端接口"></a><code>@Local</code> 本地客户端接口</h5><ul><li>客户端与其调用的 EJB 对象在同一个 JVM 进程中；</li><li>可以是 web组件、或是其他的 EJB；</li><li>为了创建一个可以被本地访问的 EJB，需要用 <code>@Local</code> 注解来定义这些 EJB</li><li>一个 EJB 可以同时被定义为 <code>@Remote</code> 和 <code>@Local</code></li></ul><h5 id="webMethod-客户端接口"><a href="#webMethod-客户端接口" class="headerlink" title="@webMethod 客户端接口"></a><code>@webMethod</code> 客户端接口</h5><p>Web Service 客户端可以访问<strong>无状态 Session Bean</strong> 的接口，只有在业务逻辑方法被标识为 <code>@WebMethod</code> 的时候，Web Service 客户端才可以访问到。</p><h4 id="客户端访问方式"><a href="#客户端访问方式" class="headerlink" title="客户端访问方式"></a>客户端访问方式</h4><h5 id="远程访问方式-Remote-Access"><a href="#远程访问方式-Remote-Access" class="headerlink" title="远程访问方式 (Remote Access)"></a>远程访问方式 (Remote Access)</h5><p>在进程间通行的时候需要将参数序列化和反序列化，传值。</p><pre class="mermaid">sequenceDiagram    participant c as Client    participant est as EJB Stub 客户端代理    participant esk as EJB Skeleton 服务器代理    participant j as JNDI 服务    participant eo as EJB对象    c ->> +j :1. JNDI lookup(查找) EJB对象    j ->> -est :2. 创建    est ->> c :3. 给客户端返回 stub 对象    c ->> +est :4. 调用方法（参数）    est ->> est :5. 将参数序列化    est ->> -esk :6. 底层网络通信    esk ->> esk :7. 将参数反序列化    esk ->> eo :8. 调用相应的方法（参数）</pre><h5 id="本地访问方式-Local-Access"><a href="#本地访问方式-Local-Access" class="headerlink" title="本地访问方式 (Local Access)"></a>本地访问方式 (Local Access)</h5><p>与远程访问方式相比，本地服务方式没有将参数序列化和反序列化的内容。可以直接访问地址（传址）</p><pre class="mermaid">sequenceDiagram    participant c as Client    participant est as EJB Stub 客户端代理    participant esk as EJB Skeleton 服务器代理    participant j as JNDI 服务    participant eo as EJB对象    c ->> +j :1. JNDI lookup(查找) EJB对象    j ->> -est :2. 创建    est ->> c :3. 给客户端返回 stub 对象    c ->> +est :4. 调用方法（参数）    est ->> -esk :5. 底层网络通信    esk ->> eo :6. 调用相应的方法（参数）</pre><h5 id="客户端访问接口类型与访问方式"><a href="#客户端访问接口类型与访问方式" class="headerlink" title="客户端访问接口类型与访问方式"></a>客户端访问接口类型与访问方式</h5><pre class="mermaid">graph LRsubgraph "客户端接口"远程客户端接口本地客户端接口WebService客户端接口endsubgraph "访问方式"Remote方式Local方式WebMethod方式end远程客户端接口 --- Remote方式本地客户端接口 --- Remote方式本地客户端接口 --- Local方式WebService客户端接口 --- WebMethod方式</pre><h5 id="方法的参数和访问方式"><a href="#方法的参数和访问方式" class="headerlink" title="方法的参数和访问方式"></a>方法的参数和访问方式</h5><p>不同的访问方式 (Remote、Local、Web Service) 会影响到 EJB 方法的参数及其返回值。</p><h6 id="独立性"><a href="#独立性" class="headerlink" title="独立性"></a>独立性</h6><ul><li>如果是远程调用，客户端操纵的 EJB 的参数，其实是一份<strong>参数值的拷贝</strong>。因此，对参数的修改，不会影响到EJB，</li><li>但是对于本地调用来说，客户端操纵的 EJB 的参数，就是一个直接引用，它对参数的修改，将会<strong>影响到  EJB</strong>。</li><li>所以，不管在哪种情况下，<strong>请避免修改参数的值</strong>！</li></ul><h6 id="粗粒度的数据访问"><a href="#粗粒度的数据访问" class="headerlink" title="粗粒度的数据访问"></a>粗粒度的数据访问</h6><p>因为远程调用的速度比较慢，所以在设计的时候，请尽量使用粗粒度的接口设计。即尽量减少方法的调用，并尽可能在一次方法调用中传输完毕所需要的数据！</p><h4 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h4><p>我们依旧沿用上一个部分的案例。</p><p><code>Compte.java</code> ( 实体类 )</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Compte</span> <span class="keyword">extends</span> <span class="title class_">Serializable</span> &#123;<span class="comment">// 需要将其序列化</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line">  <span class="keyword">private</span> String nom;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> solde;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Compte</span><span class="params">()</span> &#123;&#125; <span class="comment">// 空构造函数</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Compte</span><span class="params">(<span class="type">int</span> num, String nom, <span class="type">int</span> solde)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.num = num;</span><br><span class="line">    <span class="built_in">this</span>.nom = nom;</span><br><span class="line">    <span class="built_in">this</span>.solde = solde;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.num = num;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getNom</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.nom;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNom</span><span class="params">(String nom)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.nom = nom;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSolde</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.solde;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSolde</span><span class="params">(<span class="type">int</span> solde)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.solde = solde;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    rerturn <span class="string">&quot;Compte [num=&quot;</span> + num + <span class="string">&quot;,nom=&quot;</span> + nom + <span class="string">&quot;,solde=&quot;</span> + solde + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Remote-远程客户端访问-和-Local-本地客户端访问"><a href="#Remote-远程客户端访问-和-Local-本地客户端访问" class="headerlink" title="@Remote 远程客户端访问 和 @Local 本地客户端访问"></a><code>@Remote</code> 远程客户端访问 和 <code>@Local</code> 本地客户端访问</h5><p><code>&lt;interface&gt;: BankLocal</code> (本地访问接口)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Local</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BankLocal</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCompte</span><span class="params">(Compte c)</span>;</span><br><span class="line">  <span class="keyword">public</span> Collection&lt;Compte&gt; <span class="title function_">consulterComptes</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">public</span> Compte <span class="title function_">consulterCompte</span><span class="params">(<span class="type">int</span> num)</span> <span class="keyword">throws</span> RuntimeException;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debit</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> montant)</span> <span class="keyword">throws</span> RuntimeException;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">credit</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> montant)</span> <span class="keyword">throws</span> RuntimeException ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&lt;interface&gt;: BankRemote</code> (远程访问接口)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Remote</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BankRemote</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCompte</span><span class="params">(Compte c)</span>;</span><br><span class="line">  <span class="keyword">public</span> Collection&lt;Compte&gt; <span class="title function_">consulterComptes</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">public</span> Compte <span class="title function_">consulterCompte</span><span class="params">(<span class="type">int</span> num)</span> <span class="keyword">throws</span> RuntimeException;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debit</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> montant)</span> <span class="keyword">throws</span> RuntimeException;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">credit</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> montant)</span> <span class="keyword">throws</span> RuntimeException ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BankImpl.java</code> ( Facade/Service)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Singleton</span> <span class="comment">// Or @Stateful, or @Stateless</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bankimpl</span> <span class="keyword">implements</span> <span class="title class_">BankLocal</span>, BankRemote &#123;</span><br><span class="line">  <span class="meta">@PostConstruct</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    addCompte(<span class="keyword">new</span> <span class="title class_">Compte</span>(<span class="number">1</span>, <span class="string">&quot;dan&quot;</span>, <span class="number">2000</span>));</span><br><span class="line">    addCompte(<span class="keyword">new</span> <span class="title class_">Compte</span>(<span class="number">2</span>, <span class="string">&quot;alain&quot;</span>, <span class="number">4000</span>));</span><br><span class="line">    addCompte(<span class="keyword">new</span> <span class="title class_">Compte</span>(<span class="number">3</span>, <span class="string">&quot;luc&quot;</span>, <span class="number">6000</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> Map&lt;Integer, Compte&gt; comptes = <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;Integer, Compte&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCompte</span><span class="params">(Compte c)</span>&#123;</span><br><span class="line">    comptes.put(c.getNum(), c);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Collection&lt;Compte&gt; <span class="title function_">consulterComptes</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> comptes.values();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Compte <span class="title function_">consulterCompte</span><span class="params">(<span class="type">int</span> num)</span> <span class="keyword">throws</span> RuntimeException &#123;</span><br><span class="line">    <span class="type">Compte</span> <span class="variable">c</span> <span class="operator">=</span> comptes.get(num);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">null</span>)</span><br><span class="line">      <span class="keyword">throws</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Compte introuvable&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debit</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> montant)</span> <span class="keyword">throws</span> RuntimeException &#123;</span><br><span class="line">    <span class="type">Compte</span> <span class="variable">c</span> <span class="operator">=</span> consulterCompte(num);</span><br><span class="line">    <span class="keyword">if</span> (c.getSolde() &lt; montant)</span><br><span class="line">      <span class="keyword">throws</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Solde insuffisant&quot;</span>);</span><br><span class="line">    c.setSolde(c.getSolde - montant);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">credit</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> montant)</span> <span class="keyword">throws</span> RuntimeException &#123;</span><br><span class="line">    <span class="type">Compte</span> <span class="variable">c</span> <span class="operator">=</span> consulterCompte(num);</span><br><span class="line">    c.setSolde(c.getSolde + montant);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>RemoteClientEJB.java</code> (远程客户端app)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">RemoteClientEJB</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">appName</span> <span class="operator">=</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">      <span class="type">String</span> <span class="variable">moduleName</span> <span class="operator">=</span> <span class="string">&quot;jbbk&quot;</span>; <span class="comment">// project name</span></span><br><span class="line">      <span class="type">String</span> <span class="variable">distinctName</span> <span class="operator">=</span> <span class="string">&quot;BankImpl&quot;</span>;</span><br><span class="line">      <span class="type">String</span> <span class="variable">viewClassName</span> <span class="operator">=</span> BankRemote.class.getName();</span><br><span class="line">      <span class="type">Context</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InitialContext</span>();</span><br><span class="line">      <span class="type">String</span> <span class="variable">jndiName</span> <span class="operator">=</span> <span class="string">&quot;ejb:&quot;</span> + appName + <span class="string">&quot;/&quot;</span> + mouduleName + <span class="string">&quot;/&quot;</span> + distinctName + <span class="string">&quot;!&quot;</span></span><br><span class="line">        + viewClassName;</span><br><span class="line">      System.out.println(jndiName);<span class="comment">// ejb:/jbbk/BankImpl!bk.BankRemote</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">// 远程获取 BankRemote 的代理</span></span><br><span class="line">      <span class="type">BankRemote</span> <span class="variable">bankStub</span> <span class="operator">=</span> (BankRemote) ctx.lookup(jndiName);</span><br><span class="line">      </span><br><span class="line">      Collection&lt;Compte&gt; comptes = bankStub.consulterComptes();</span><br><span class="line">      System.out.println(<span class="string">&quot;Print all the accounts(comptes).&quot;</span>);</span><br><span class="line">      <span class="keyword">for</span> (Compte c:comptes) &#123;</span><br><span class="line">        System.out.println(c.toString);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Execption e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>jboss-ejb-client.properties</code> ( 为了客户端可以远程访问，配置 <code>JNDI</code> )</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">endpoint.name</span> = <span class="string">client-endpoint</span></span><br><span class="line"><span class="attr">remote.connectionprovider.create.org.xnio.Options.SSL_ENABLED</span> = <span class="string">false</span></span><br><span class="line"><span class="attr">remote.connections</span> = <span class="string">default</span></span><br><span class="line"><span class="attr">remote.connections.default.host</span> = <span class="string">localhost</span></span><br><span class="line"><span class="attr">remote.connections.default.port</span> = <span class="string">8080</span></span><br></pre></td></tr></table></figure><h5 id="WebMethod-客户端访问：Servlet"><a href="#WebMethod-客户端访问：Servlet" class="headerlink" title="@WebMethod 客户端访问：Servlet"></a><code>@WebMethod</code> 客户端访问：Servlet</h5><p><code>Controller.java</code> (以 <code>@WebServlet</code> 方式访问的客户端：Servlet)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@WebServlet(&quot;/Controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Controller</span> <span class="keyword">extends</span> <span class="title class_">HttpServlet</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">long</span> <span class="variable">serialVersionUID</span> <span class="operator">=</span> <span class="number">1L</span>;<span class="comment">// *</span></span><br><span class="line">  <span class="meta">@EJB</span><span class="comment">// * 服务器端的实现</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">BankImpl</span> <span class="variable">facade</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Facade</span>();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title function_">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">String</span> <span class="variable">action</span> <span class="operator">=</span> request.getParameter(<span class="string">&quot;action&quot;</span>);</span><br><span class="line">      <span class="keyword">if</span> (action.equals(<span class="string">&quot;consulter&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(request.getParameter(<span class="string">&quot;num&quot;</span>));</span><br><span class="line">        request.setAttribute(<span class="string">&quot;num&quot;</span>, num);</span><br><span class="line">        request.setAttribute(<span class="string">&quot;compte&quot;</span>, facade.consulterCompte(num));</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (action.equals(<span class="string">&quot;consulterTous&quot;</span>))&#123;</span><br><span class="line">         request.setAttribute(<span class="string">&quot;comptes&quot;</span>, facade.consulterComptes());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (action.equals(<span class="string">&quot;debit&quot;</span>) || action.equals(<span class="string">&quot;credit&quot;</span>)) &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">num</span> <span class="operator">=</span> Integer.parseInt(request.getParameter(<span class="string">&quot;num&quot;</span>));</span><br><span class="line">        <span class="type">int</span> <span class="variable">montant</span> <span class="operator">=</span> Integer.parseInt(request.getParameter(<span class="string">&quot;montant&quot;</span>));</span><br><span class="line">        request.setAttribute(<span class="string">&quot;num&quot;</span>, num);</span><br><span class="line">        <span class="keyword">if</span> (action.equals(<span class="string">&quot;debit&quot;</span>)) &#123;</span><br><span class="line">          facade.debit(num, montant);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          facade.crebit(num, montant);</span><br><span class="line">        &#125;</span><br><span class="line">        request.setAttribute(<span class="string">&quot;num&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      request.setAttribute(<span class="string">&quot;exception: &quot;</span>, e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    request.getRequestDispatcher(<span class="string">&quot;Banque.jsp&quot;</span>).forward(request, response);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>&lt;interface&gt;: BankRemote</code> (远程访问接口)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Remote</span></span><br><span class="line"><span class="meta">@WebService</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">BankRemote</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCompte</span><span class="params">(Compte c)</span>;</span><br><span class="line">  <span class="keyword">public</span> Collection&lt;Compte&gt; <span class="title function_">consulterComptes</span><span class="params">()</span>;</span><br><span class="line">  <span class="keyword">public</span> Compte <span class="title function_">consulterCompte</span><span class="params">(<span class="type">int</span> num)</span> <span class="keyword">throws</span> RuntimeException;</span><br><span class="line">  <span class="meta">@WebMethod</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debit</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> montant)</span> <span class="keyword">throws</span> RuntimeException;</span><br><span class="line">  <span class="meta">@WebMethod</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">credit</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> montant)</span> <span class="keyword">throws</span> RuntimeException ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BankImpl.java</code> ( Facade/Service)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Singleton</span> <span class="comment">// Or @Stateful, or @Stateless</span></span><br><span class="line"><span class="meta">@WebService(endpointInterface=&quot;bk.BankRemote&quot;, serviceName=&quot;BankWS&quot;)</span></span><br><span class="line"><span class="comment">// endpointInterface = &quot;name_of_interface.class&quot;</span></span><br><span class="line"><span class="comment">// serviceName = &quot;name_of_service_wanted&quot;</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Bankimpl</span> <span class="keyword">implements</span> <span class="title class_">BankLocal</span>, BankRemote &#123;</span><br><span class="line">  <span class="meta">@PostConstruct</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">    addCompte(<span class="keyword">new</span> <span class="title class_">Compte</span>(<span class="number">1</span>, <span class="string">&quot;dan&quot;</span>, <span class="number">2000</span>));</span><br><span class="line">    addCompte(<span class="keyword">new</span> <span class="title class_">Compte</span>(<span class="number">2</span>, <span class="string">&quot;alain&quot;</span>, <span class="number">4000</span>));</span><br><span class="line">    addCompte(<span class="keyword">new</span> <span class="title class_">Compte</span>(<span class="number">3</span>, <span class="string">&quot;luc&quot;</span>, <span class="number">6000</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> Map&lt;Integer, Compte&gt; comptes = <span class="keyword">new</span> <span class="title class_">Hashtable</span>&lt;Integer, Compte&gt;();</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addCompte</span><span class="params">(Compte c)</span>&#123;</span><br><span class="line">    comptes.put(c.getNum(), c);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Collection&lt;Compte&gt; <span class="title function_">consulterComptes</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> comptes.values();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Compte <span class="title function_">consulterCompte</span><span class="params">(<span class="type">int</span> num)</span> <span class="keyword">throws</span> RuntimeException &#123;</span><br><span class="line">    <span class="type">Compte</span> <span class="variable">c</span> <span class="operator">=</span> comptes.get(num);</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="literal">null</span>)</span><br><span class="line">      <span class="keyword">throws</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Compte introuvable&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">debit</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> montant)</span> <span class="keyword">throws</span> RuntimeException &#123;</span><br><span class="line">    <span class="type">Compte</span> <span class="variable">c</span> <span class="operator">=</span> consulterCompte(num);</span><br><span class="line">    <span class="keyword">if</span> (c.getSolde() &lt; montant)</span><br><span class="line">      <span class="keyword">throws</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Solde insuffisant&quot;</span>);</span><br><span class="line">    c.setSolde(c.getSolde - montant);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">credit</span><span class="params">(<span class="type">int</span> num, <span class="type">int</span> montant)</span> <span class="keyword">throws</span> RuntimeException &#123;</span><br><span class="line">    <span class="type">Compte</span> <span class="variable">c</span> <span class="operator">=</span> consulterCompte(num);</span><br><span class="line">    c.setSolde(c.getSolde + montant);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第四部分：JPA"><a href="#第四部分：JPA" class="headerlink" title="第四部分：JPA"></a>第四部分：JPA</h3><p>JPA，Java持久化API：持久化 Bean 与普通的 Java Bean 无异，区别在于他们要用 EJB 的 Annotation 进行标记。</p><ul><li>一个实体类将其表示为 <code>@Entity</code>；</li><li>实体类必须有主键，一般用 <code>@Id</code> 标识；</li><li>在 <code>/META-INF/</code> 目录下，有 <code>persistence.xml</code> 文件，其主要作用是定义<u>实体类映射的相关配置信息</u>，比如指定数据源、都有哪些实体类、以及跟持久化相关的其它的一些属性。</li></ul><h4 id="Entity-Bean-实体类"><a href="#Entity-Bean-实体类" class="headerlink" title="Entity Bean 实体类"></a>Entity Bean 实体类</h4><p>我们可以用 Entity Bean 实体类来记录数据，<u>每个实体类都关联一个数据库的表</u>。</p><h4 id="Entity-Bean-基本映射规则（映射到数据库表）"><a href="#Entity-Bean-基本映射规则（映射到数据库表）" class="headerlink" title="Entity Bean 基本映射规则（映射到数据库表）"></a>Entity Bean 基本映射规则（映射到数据库表）</h4><p>（默认的表名和字段名与属性名一致）</p><ol><li>实体类和表的映射关系：<ul><li><code>@Entity</code>：声明<u>实体类</u>；</li><li><code>@Table(name=&quot;数据库表的名称&quot;)</code>：配置<u>实体类和表的映射关系</u></li></ul></li><li><p>实体类中属性和数据库表中字段的映射关系：</p><ul><li><code>@Id</code>：声明主键的配置</li><li><code>@GeneratedValue(strategy)</code>：配置<u>主键的生成策略</u><ul><li><code>strategy = GenerationType.IDENTITY</code>：id主键自增</li><li><code>strategy = GenerationType.AUTO</code>：缺省，默认方式</li><li><code>strategy = GenerationType.SEQUENCE</code>：通过序列生产主键，与 <code>@SequenceGenerator</code> 配合使用</li><li><code>strategy = GenerationType.TABLE</code>：通过其他表生成主键</li></ul></li><li><code>@Column(name=&quot;数据库表中字段的名称&quot;)</code>：配置属性和数据库表中<u>字段的映射</u>关系<ul><li><code>name = &quot;数据库表中字段的名称&quot;</code> ;</li><li><code>unique = true/false</code>：是否唯一；</li><li><code>nullable = true/false</code>：是否可空；</li><li><code>length = 字段长度</code>；</li></ul></li><li><code>@Basic</code>：默认<u>缺省</u>，所有配置全部设为<u>默认</u></li><li><code>@Transient</code>：该属性<u>不需要映射为数据库表的字段</u>；</li><li><code>@Temporal(TemporalType)</code>：定义 <code>Date</code> 类型的精度<ul><li><code>TemporalType.DATE</code>：<code>年-月-日</code></li><li><code>TemporalType.TIME</code>：<code>时:分:秒</code></li><li><code>TemporalType.TIMESTAMP</code>：<code>年-月-日 时:分:秒</code></li></ul></li></ul><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Compte</span> <span class="keyword">extends</span> <span class="title class_">Serializable</span> &#123;<span class="comment">// 需要将其序列化</span></span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="meta">@GeneratetdValue(strategy=GenerationType.IDENTITY)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> num;</span><br><span class="line">  <span class="keyword">private</span> String nom;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> solde;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Compte</span><span class="params">()</span> &#123;&#125; <span class="comment">// 空构造函数</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Compte</span><span class="params">(<span class="type">int</span> num, String nom, <span class="type">int</span> solde)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.num = num;</span><br><span class="line">    <span class="built_in">this</span>.nom = nom;</span><br><span class="line">    <span class="built_in">this</span>.solde = solde;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getNum</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.num;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.num = num;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">getNom</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.nom;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setNom</span><span class="params">(String nom)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.nom = nom;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getSolde</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.solde;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSolde</span><span class="params">(<span class="type">int</span> solde)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.solde = solde;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    rerturn <span class="string">&quot;Compte [num=&quot;</span> + num + <span class="string">&quot;,nom=&quot;</span> + nom + <span class="string">&quot;,solde=&quot;</span> + solde + <span class="string">&quot;]&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></blockquote></li></ol><h4 id="EntityManager-实体类管理器"><a href="#EntityManager-实体类管理器" class="headerlink" title="EntityManager 实体类管理器"></a><code>EntityManager</code> 实体类管理器</h4><p>在 JPA 规范中，EntityManager是真正对数据库操作的对象。</p><p>实体作为普通 Java 对象，只有在调用EntityManager 将其持久化后才会变成持久化对象。EntityManager对象在一组实体类与底层数据源之间进行 O/R  映射的管理。它可以用来管理和更新 Entity Bean，根椐主键查找 Entity Bean，还可以通过 JPQL 语句查询实体。</p><h5 id="实体的状态："><a href="#实体的状态：" class="headerlink" title="实体的状态："></a>实体的状态：</h5><ul><li>新建状态：新创建的对象，<u>尚未拥有持久性主键</u>。</li><li>持久化状态：已经拥有持久性主键并<u>和持久化建立了上下文环境</u></li><li>游离状态 ：拥有持久化主键，但是<u>没有与持久化建立上下文环境</u></li><li>删除状态：拥有持久化主键，已经和持久化建立上下文环境，但是<u>从数据库中删除</u></li></ul><h5 id="EntityManager-方法"><a href="#EntityManager-方法" class="headerlink" title="EntityManager 方法"></a><code>EntityManager</code> 方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@PersistenceContext</span></span><br><span class="line"><span class="keyword">private</span> EntityManager em;</span><br></pre></td></tr></table></figure><ul><li><p><code>find()</code>：根据id查找</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> num;<span class="comment">// 主键</span></span><br><span class="line"><span class="type">Compte</span> <span class="variable">c</span> <span class="operator">=</span> em.find(Compte.class, num);</span><br></pre></td></tr></table></figure></li><li><p><code>getReference()</code>：根据id查找，先返回实体对象的代理，在使用代理对象前关闭 EntityManager 会出现懒加载异常 <code>LazyInitializationException</code>。</p></li><li><p><code>presist()</code>：保存 (<code>INSERT</code>)，使对象由临时状态变为持久化状态。如果实体类有主键，在 <code>presist()</code>会抛出异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Compte</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Compte</span>(<span class="literal">null</span>, <span class="string">&quot;tom&quot;</span>, <span class="string">&quot;200&quot;</span>);<span class="comment">// 自动分配主键</span></span><br><span class="line">em.presist(c);</span><br></pre></td></tr></table></figure></li><li><p><code>merge()</code>：更新 <code>UPDATE or INSERT</code></p><ul><li><p>如传入的是一个<u>临时对象</u>（无主键id），会先<u>创建一个新的对象</u>（有主键），把临时对象的<u>属性复制到新对象</u>中，再对这个<u>新对象 <code>INSERT</code> 数据库持久化操作</u>。所以新对象有主键，而临时对象没有主键。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Compte</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Compte</span>(<span class="literal">null</span>, <span class="string">&quot;theo&quot;</span>, <span class="string">&quot;1000&quot;</span>);<span class="comment">// 自动分配主键</span></span><br><span class="line"><span class="type">Compte</span> <span class="variable">c_temp</span> <span class="operator">=</span> em.merge(c);</span><br><span class="line"><span class="comment">// c.getNum(); -&gt; nullc_temp.getNum(); -&gt; JPA 按照策略分配的 #Id 的值</span></span><br></pre></td></tr></table></figure></li><li><p>如果传入的是一个<u>游离对象</u>（有主键id），若 <u>EntityManager 缓存中<strong>没有</strong>该对象</u>、且<u>数据库中也<strong>没有</strong>相应的记录</u>，JPA 则会先<u>创建一个新的对象</u>，把游离对象的<u>属性复制到新对象</u>中，再对这个<u>新对象 <code>INSERT</code> 数据库持久化操作</u>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Compte</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Compte</span>(<span class="number">100</span>, <span class="string">&quot;enzo&quot;</span>, <span class="string">&quot;1000&quot;</span>);<span class="comment">// 自动分配主键</span></span><br><span class="line"><span class="type">Compte</span> <span class="variable">c_temp</span> <span class="operator">=</span> em.merge(c);</span><br><span class="line"><span class="comment">// c.getNum(); -&gt; 100c_temp.getNum(); -&gt; 4</span></span><br></pre></td></tr></table></figure></li><li><p>如果传入的是一个游离对象（有主键id），若 <u>EntityManager 缓存中没有该对象</u>，但<u>数据库中有相应的记录</u>，JPA 则会<u>查询相应记录</u>后<u>返回该记录的一个对象</u>，把<u>游离对象的属性复制到查询对象</u>中，再对这个<u>查询对象 <code>UPDATE</code> 数据库持久化操作</u>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Compte</span> <span class="variable">c</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Compte</span>(<span class="literal">null</span>, <span class="string">&quot;enzo&quot;</span>, <span class="string">&quot;500&quot;</span>);<span class="comment">// 自动分配主键</span></span><br><span class="line">c.setNum(<span class="number">4</span>);</span><br><span class="line"><span class="type">Compte</span> <span class="variable">c_temp</span> <span class="operator">=</span> em.merge(c);</span><br><span class="line"><span class="comment">// c.toString(); -&gt; Compte [num=4, nom=enzo, solde=500]</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p><code>remove()</code>：删除</p></li><li><p><code>flush()</code>：同步数据表的记录和内存中对象的状态</p><ul><li><code>setFlushMode(FlushModeType.AUTO)</code>：自动同步到数据库</li><li><code>setFlushMode(FlushModeType.COMMIT)</code>：直到事物提交时才同步到数据库</li><li><code>getFlushMode</code></li></ul></li><li><p><code>transaction = em.getTransaction()</code>：获取事务对象 </p><ul><li><code>transaction.begin();</code></li><li><code>transaction.commit();</code></li><li><code>transaction.rollback();</code></li></ul></li></ul><h4 id="映射关联关系"><a href="#映射关联关系" class="headerlink" title="映射关联关系"></a>映射关联关系</h4><h5 id="ManyToOne-单向多对一关联映射"><a href="#ManyToOne-单向多对一关联映射" class="headerlink" title="@ManyToOne 单向多对一关联映射"></a><code>@ManyToOne</code> 单向多对一关联映射</h5><p>在单向多对一的关联映射里，在“多”的一端添加一个外键 (Foreign Key) 指向“一”的一端，而且可以指定字段名称。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">  <span class="meta">@GeneratedValue</span></span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Column(name=&quot;client_name&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  <span class="comment">// constructors, setters, getters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">  <span class="meta">@GeneratedValue</span></span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Column(name=&quot;account_amount&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> amount;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@ManyToOne</span><span class="comment">// @ManyToOne 多对一映射关系</span></span><br><span class="line">  <span class="meta">@JoinColumn(name=&quot;client_ID&quot;)</span><span class="comment">// 使用 @JoinColumn 来映射外键，name为新建外键列的列名</span></span><br><span class="line">  <span class="keyword">private</span> Client client;<span class="comment">// 多个账户可以对应一个客户</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/05/03/Appli-Web%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/2022-05-05 19.57.54.png" alt="2022-05-05 19.57.54" style="zoom:50%;"></p><h5 id="OneToMany-一对多关联映射"><a href="#OneToMany-一对多关联映射" class="headerlink" title="@OneToMany 一对多关联映射"></a><code>@OneToMany</code> 一对多关联映射</h5><ul><li><code>@OneToMany(fetch=FetchType.xxx)</code>：修改默认加载策略，默认懒加载 (<code>LAZY</code>)；(<code>EAGER</code>)</li><li><code>@OneToMany(cascade=CascadeType.remove)</code>：<ul><li>默认情况下，若删除“一”的一端，会先将“一”的一端中<u>关联“多”的外键置空</u>，然后删除</li><li>可以通过 <code>@OneToMany</code> 的 <code>cascade</code> 属性来修改默认的删除策略</li><li><code>CascadeType.PERSIST （级联新建）</code></li><li><code>CascadeType.REMOVE （级联删除）</code></li><li><code>CascadeType.REFRESH （级联刷新）</code></li><li><code>CascadeType.MERGE （级联更新）中选择一个或多个</code></li><li><code>还有一个选择是使用CascadeType.ALL ，表示选择全部四项</code></li></ul></li></ul><h6 id="一对多单向关联映射："><a href="#一对多单向关联映射：" class="headerlink" title="一对多单向关联映射："></a>一对多<u>单向</u>关联映射：</h6><p>一对多<u>单向</u>关联映射 有两个映射策略，即 <u>外键关联</u> 和 <u>表关联</u></p><ul><li><u>外键</u>关联：会创建一个<u>外键</u> ，用<u>外键</u>记录 <code>Client</code> 和 <code>Account</code> 之间的<u>单向关联</u>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">  <span class="meta">@Column(name=&quot;client_name&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@JoinColumn(name=&quot;client_ID&quot;)</span><span class="comment">// 使用 @JoinColumn 来映射外键，name为新建外键列的列名</span></span><br><span class="line">  <span class="meta">@OneToMany</span><span class="comment">// @OneToMany 一对多映射关系</span></span><br><span class="line">  <span class="keyword">private</span> Set&lt;Account&gt; accounts;<span class="comment">// 集合属性：一个客户可以对应多个账户</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="meta">@GenerateValue</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">  <span class="meta">@Column(name=&quot;account_amount&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> amount;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// private Client client;// 因为是单向的，所以不能 Account 类里不能有 Client 类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/05/03/Appli-Web%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/2022-05-05 19.57.54.png" alt="2022-05-05 19.57.54" style="zoom:50%;"></p><ul><li><u>表</u>关联：会创建一个<u>中间表</u> ，用<u>中间表</u>记录 <code>Client</code> 和 <code>Account</code> 之间的<u>单向关联</u>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">  <span class="meta">@Column(name=&quot;client_Name&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@JoinTable(name=&quot;t_Client_Account&quot;,</span></span><br><span class="line"><span class="meta">          joinColumn=&#123;@JoinColumn(name=&quot;client_ID&quot;,referencedColumnName=&quot;ID&quot;)&#125;,</span></span><br><span class="line"><span class="meta">          inverseJoinColumn=&#123;@JoinColumn(name=&quot;account_ID&quot;,referencedColumnName=&quot;ID&quot;)&#125;</span></span><br><span class="line"><span class="meta">  @OneToMany// @OneToMany 一对多映射关系</span></span><br><span class="line"><span class="meta">  private Set&lt;Account&gt; accounts;// 集合属性：一个客户可以对应多个账户</span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="meta">@GenerateValue</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">  <span class="meta">@Column(name=&quot;account_amount&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> amount;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// private Client client;// 因为是单向的，所以不能 Account 类里不能有 Client 类</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/05/03/Appli-Web%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/2022-05-05 20.44.11.png" alt="2022-05-05 20.44.11" style="zoom:50%;"></p><h6 id="一对多双向关联映射："><a href="#一对多双向关联映射：" class="headerlink" title="一对多双向关联映射："></a>一对多<u>双向</u>关联映射：</h6><p>一对多<u>双向</u>关联映射 = 多对一<u>双向</u>关联映射</p><p>没有中间表，但会在“多”的一端加入一个外键，两端的外键名保持一致。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Client</span> &#123;</span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="meta">@GenerateValue</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">  <span class="meta">@Column(name=&quot;client_name&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 在“一”的一端定义mappedBy，即映射规则由对方决定; 在使用这种属性时，则不能用@JoinColumn属性</span></span><br><span class="line">  <span class="meta">@OneToMany(mappedBy=client)</span></span><br><span class="line">  <span class="keyword">private</span> Set&lt;Account&gt; accounts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 多</span></span><br><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="meta">@GenerateValue</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">  <span class="meta">@Column(name=&quot;account_amount&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> amount;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@JoinColumn(name=&quot;client_ID&quot;)</span><span class="comment">// 使用 @JoinColumn 来映射外键，两端的外键名保持一致</span></span><br><span class="line">  <span class="meta">@ManyToOne</span></span><br><span class="line">  <span class="keyword">private</span> Client client;<span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/05/03/Appli-Web%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/2022-05-05 19.57.54.png" alt="2022-05-05 19.57.54" style="zoom:50%;"></p><h5 id="OneToOne-一对一双向关联映射"><a href="#OneToOne-一对一双向关联映射" class="headerlink" title="@OneToOne 一对一双向关联映射"></a><code>@OneToOne</code> 一对一双向关联映射</h5><p>有两种策略：<u><strong>主键(Primary Key)关联</strong></u> 和 <strong><u>唯一外键(Foreign Key)关联</u></strong></p><h6 id="主键关联"><a href="#主键关联" class="headerlink" title="主键关联"></a>主键关联</h6><p>一端的主键 (<code>@Id</code>) 依赖于另一端的主键 (<code>@Id</code>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> &#123;</span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="meta">@GenerateValue</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Column(name=&quot;manager_name&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> String managerName;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@OneToOne</span></span><br><span class="line">  <span class="meta">@PrimaryKeyJoinColumn</span></span><br><span class="line">  <span class="keyword">private</span> CustomerNum customerNum</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Department</span> &#123;</span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="meta">@GenerateValue</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Column(name=&quot;department_name&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> String DepartmentName;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@OneToOne(mappedBy=&quot;m_ID&quot;)</span></span><br><span class="line">  <span class="comment">// 在双键关联中只需要定义一方的映射规则，另外一方遵守已经定义一方的映射规则；</span></span><br><span class="line">  <span class="comment">// mappedBy = 对方指向我自身的 *属性名称*</span></span><br><span class="line">  <span class="keyword">private</span> Customer customer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/05/03/Appli-Web%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/2022-05-05 21.07.25.png" alt="2022-05-05 21.07.25" style="zoom:50%;"></p><h6 id="唯一外键关联"><a href="#唯一外键关联" class="headerlink" title="唯一外键关联"></a>唯一外键关联</h6><ul><li>使用 <code>@OneToOne</code> 来映射一对一关联关系；</li><li>若需要在当前表中添加外键，则需要使用 <code>@JoinColumn(unique=true)</code> 来映射 </li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Manager</span> &#123;</span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="meta">@GenerateValue</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Column(name=&quot;manager_name&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> String managerName;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 对于没有外键的一方，建议设置 mappedBy=true</span></span><br><span class="line">  <span class="meta">@OneToOne(mappedBy=&quot;manager&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> Department department</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Department</span> &#123;</span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="meta">@GenerateValue</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Column(name=&quot;department_name&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> String DepartmentName;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@OneToOne</span></span><br><span class="line">  <span class="meta">@JoinColumn(name=&quot;manager_ID&quot;, unique=true)</span></span><br><span class="line">  <span class="comment">// 在双键关联中只需要定义一方的外键映射规则，另外一方遵守已经定义一方的映射规则；</span></span><br><span class="line">  <span class="comment">// 需要使用 @JoinColumn(unique=true) 来添加外键映射 </span></span><br><span class="line">  <span class="keyword">private</span> Manager manager</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/05/03/Appli-Web%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/2022-05-05 21.07.25.png" alt="2022-05-05 21.07.25" style="zoom:50%;"></p><h5 id="ManyToMany-多对多关联映射"><a href="#ManyToMany-多对多关联映射" class="headerlink" title="@ManyToMany 多对多关联映射"></a><code>@ManyToMany</code> 多对多关联映射</h5><p>​    通过新建一个<u>中间表</u>，达到多对多的关联映射。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Item</span> &#123;</span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="meta">@GenerateValue</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Column(name=&quot;item_name&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@JoinTable(// 映射中间表</span></span><br><span class="line"><span class="meta">    name=&quot;t_Item_Category&quot;,// 中间表的名字</span></span><br><span class="line"><span class="meta">    joinColumns=&#123;// 映射当前类所在的表 在中间表中的外键</span></span><br><span class="line"><span class="meta">      @JoinColumn(name=&quot;item_ID&quot;,// 当前表在中间表中的 外键列的列名</span></span><br><span class="line"><span class="meta">                 referencedColumnName=&quot;ID&quot;)&#125;,// 指定外键关联当前表的哪一列（可缺省）</span></span><br><span class="line"><span class="meta">  inverseJoinColumns=&#123;// 映射关联的类 在 中间表 中的 外键</span></span><br><span class="line"><span class="meta">      @JoinColumn(name=&quot;category_ID&quot;,// 对方表在中间表中 外键列的列名</span></span><br><span class="line"><span class="meta">                       referenceColumnName=&quot;ID&quot;)&#125;)</span><span class="comment">// 指定外键关联对方表的哪一列（可缺省）</span></span><br><span class="line">  <span class="meta">@ManyToMany</span></span><br><span class="line">  <span class="keyword">private</span> Set&lt;Category&gt; categorys</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Category</span> &#123;</span><br><span class="line">  <span class="meta">@GeneratedValue</span></span><br><span class="line">  <span class="meta">@Id</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@Column(name=&quot;category_name&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> String name;</span><br><span class="line">  </span><br><span class="line">  <span class="meta">@ManyToMany(mappedBy=&quot;categorys&quot;)</span></span><br><span class="line">  <span class="keyword">private</span> Set&lt;Item&gt; items;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/05/03/Appli-Web%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/2022-05-05 21.22.35.png" alt="2022-05-05 21.22.35" style="zoom:50%;"></p><h4 id="JPQL"><a href="#JPQL" class="headerlink" title="JPQL"></a>JPQL</h4><p>JPQL 语言，即 Java Persistence Query Language 的简称。</p><p>JPQL 是一种和 SQL 非常类似的中间性和对象化查询语言，它查询的内容是<u>实体类和类中的属性</u>。它最终会被编译成针对不同底层数据库的 SQL查询，从而屏蔽不同数据库的差异。</p><p>JPQL 语言的语句可以是 <code>select</code> 语句，<code>update</code> 语句或 <code>delete</code>语句，它们都通过 Query 接口封装执行。调用 <code>EntityManager</code> 的 <code>createQuery()</code>、<code>createNamedQuery()</code>、<code>createNativeQuery()</code> 以获得查询对象，进而可调用 Query 接口的相关方法来执行查询操作</p><p>例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Collection&lt;Orders&gt; <span class="title function_">searchByAge</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">String</span> <span class="variable">jpql</span> <span class="operator">=</span> <span class="string">&quot;FROM Customer c WHERE c.age &gt; ?&quot;</span>; <span class="comment">// ?是参数的占位符</span></span><br><span class="line">  <span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> em.createQuery(jpql);</span><br><span class="line">  <span class="comment">// 占位符索引从1开始</span></span><br><span class="line">  <span class="comment">// query.setParameter(第几个占位符, 参数的值)</span></span><br><span class="line">  query.setParameter(<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">  Collection&lt;Customer&gt; result = (Collection&lt;Customer&gt;) query.getResultList();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><code>SELECT-FROM</code> 子句：<code>select</code> 用于指定返回的结果实体或实体的某些属性；<code>from</code> 子句声明查询源实体类，并指定标识符变量（相当于 SQL 表的别名）。如果不希望返回重复实体，可以使用关键字 <code>distinct</code>。</p><ul><li><code>FROM Orders WHERE o.id=:o_id</code> 当查询整个实体类时可省略 <code>select *</code></li></ul></li><li><p><code>WHERE</code> 子句：用于指定查询条件，</p><ul><li><code>SELECT o FROM Orders o WHERE o.id =:o_id</code></li><li><code>SELECT o FROM Orders o WHERE o.id &gt; 4</code></li></ul></li><li><p><code>GROUP BY</code> 子句：用于对查询结果分组统计，通常需要使用聚合函数，如 <code>AVG, SUM, COUNT, MAX, MIN</code>等</p><ul><li><code>SELECT MAX(o.id) FROM Orders o</code></li></ul></li><li><p><code>ORDER BY</code> 子句：用于对查询结果进行排序，<code>ASC</code> 升序，<code>DESC</code> 降序</p><ul><li><code>SELECT o FROM Orders ORDER BY o.id DESC</code></li></ul></li><li><p><code>UPDATE</code> 子句：用于执行数据的更新操作。主要针对于单个实体类的更新</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">jpql</span> <span class="operator">=</span> <span class="string">&quot;UPDATE Order o SET o.age = ? WHERE o.id = ?&quot;</span>;</span><br><span class="line"><span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> em.creatQuery(jpql);</span><br><span class="line">query.setParameter(<span class="number">1</span>,<span class="number">25</span>);</span><br><span class="line">query.setParameter(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">query.executeUpdate();</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><code>DELETE</code> 子句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">jpql</span> <span class="operator">=</span> <span class="string">&quot;DELETE Order o WHERE o.id = ?&quot;</span>;</span><br><span class="line"><span class="type">Query</span> <span class="variable">query</span> <span class="operator">=</span> em.creatQuery(jpql);</span><br><span class="line">query.setParameter(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">query.executeUpdate();</span><br></pre></td></tr></table></figure></li></ul><p>当然还有很多其他的用法，但在此我们不作深究。</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本文章是根据法国国立高等电力技术、电子学、计算机、水力学与电信学校 (E.N.S.E.E.I.H.T.) 第八学期课程&lt;em&gt;“Application Web”&lt;/em&gt; 总结而来的【部分课程笔记】。碍于本人学识有限，部分叙述难免存在纰漏，请读者注意甄别。&lt;/p&gt;</summary>
    
    
    
    <category term="课程笔记" scheme="https://dave0126.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="课程笔记" scheme="https://dave0126.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>idea常见问题</title>
    <link href="https://dave0126.github.io/2022/05/02/idea%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>https://dave0126.github.io/2022/05/02/idea%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</id>
    <published>2022-05-02T10:45:46.000Z</published>
    <updated>2022-06-24T19:11:36.444Z</updated>
    
    <content type="html"><![CDATA[<span id="more"></span><h3 id="1-修改-idea-vmoptions-后无法打开的问题"><a href="#1-修改-idea-vmoptions-后无法打开的问题" class="headerlink" title="1. 修改 idea.vmoptions 后无法打开的问题"></a>1. 修改 <code>idea.vmoptions</code> 后无法打开的问题</h3><p>本文仅适用于以下系统环境：</p><blockquote><ol><li><code>M1 Arm64bits: MacOS v12.3</code></li><li><code>IntelliJ IDEA v2021.3.3</code></li></ol></blockquote><p>在官方描述 <a href="https://intellij-support.jetbrains.com/hc/en-us/articles/206544869-Configuring-JVM-options-and-platform-properties">Configuring JVM options and platform properties</a> 中</p><blockquote><p>“Please note that custom <strong><code>.vmoptions</code> file created using ‘Edit Custom VM Options’ action has the priority over the original file in the bin directory</strong>.”</p><p>使用“Edit Custom VM Options”操作创建的自定义 <code>.vmoptions</code> 文件<u>优先于</u> bin 目录中的原始文件</p></blockquote><p>也就是说 <code>idea.vmoptions</code> 文件有两份：</p><blockquote><ol><li><code>/Applications/IntelliJ\ IDEA.app/Contents/bin/idea.vmoptions</code> </li><li><code>.vmoptions</code> 的副本。注意，config目录中的.vmoptions文件执行 <u>优先级高于</u> IDEA安装路径下bin目录中的原始文件（第1条）。</li></ol></blockquote><p>对于第一种情况，直接去对应地址下修改即可；对于我们在 IDEA 软件中通过 <code>Help -&gt; Edit Custom VM Options</code> 修改 <code>idea.vmoptions</code> 的情况，则对应第二种。</p><h4 id="关于如何查找-vmoptions副本的位置："><a href="#关于如何查找-vmoptions副本的位置：" class="headerlink" title="关于如何查找 .vmoptions副本的位置："></a>关于如何查找 <code>.vmoptions</code>副本的位置：</h4><ol><li><p>首先找到对应版本IDEA的安装目录，以本人电脑举例 <code>/Applications/IntelliJ\ IDEA.app/</code></p></li><li><p>找到文件夹 <code>/Contents/MacOS</code></p></li><li><p>使用命令行运行 <code>idea</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./idea</span><br></pre></td></tr></table></figure></li><li><p>随后命令行会打印启动加载详情及文件路径，如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">2022-05-02 12:12:33.623 idea[80627:6541003] allVms required 1.8*,1.8+</span><br><span class="line">2022-05-02 12:12:33.624 idea[80627:6541007] Current Directory: /Users/xxx</span><br><span class="line">2022-05-02 12:12:33.624 idea[80627:6541007] parseVMOptions: IDEA_VM_OPTIONS = (null)</span><br><span class="line">2022-05-02 12:12:33.624 idea[80627:6541007] fullFileName is: /Applications/IntelliJ IDEA.app/Contents/bin/idea.vmoptions</span><br><span class="line">2022-05-02 12:12:33.624 idea[80627:6541007] fullFileName exists: /Applications/IntelliJ IDEA.app/Contents/bin/idea.vmoptions</span><br><span class="line">2022-05-02 12:12:33.624 idea[80627:6541007] parseVMOptions: /Applications/IntelliJ IDEA.app/Contents/bin/idea.vmoptions</span><br><span class="line">2022-05-02 12:12:33.624 idea[80627:6541007] parseVMOptions: /Applications/IntelliJ IDEA.app.vmoptions</span><br><span class="line">2022-05-02 12:12:33.625 idea[80627:6541007] parseVMOptions: /Users/dave/Library/Application Support/JetBrains/IntelliJIdea2021.3/idea.vmoptions</span><br><span class="line">2022-05-02 12:12:33.625 idea[80627:6541007] parseVMOptions: platform=17 user=2 file=/Users/xxx/Library/Application Support/JetBrains/IntelliJIdea2021.3/idea.vmoptions</span><br><span class="line">Error opening zip file or JAR manifest missing : /Applications/IntelliJ\IDEA.app/Contents/plugins/xxx.jar</span><br><span class="line">Error occurred during initialization of VM agent library failed to init: instrument</span><br></pre></td></tr></table></figure><p>我们可以发现 <code>idea</code> 在加载并解析 <code>VMOptions</code> 时访问了如下地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/Users/xxx/Library/Application Support/JetBrains/IntelliJIdea2021.3/idea.vmoptions</span><br></pre></td></tr></table></figure></li><li><p>至此我们就找到了 <code>.vmoptions</code>副本的位置。</p></li><li><p>修改错误代码或者将其删除即可重新打开软件。</p></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;span id=&quot;more&quot;&gt;&lt;/span&gt;
&lt;h3 id=&quot;1-修改-idea-vmoptions-后无法打开的问题&quot;&gt;&lt;a href=&quot;#1-修改-idea-vmoptions-后无法打开的问题&quot; class=&quot;headerlink&quot; title=&quot;1. 修改 idea.v</summary>
      
    
    
    
    <category term="IDEA" scheme="https://dave0126.github.io/categories/IDEA/"/>
    
    
    <category term="IDEA" scheme="https://dave0126.github.io/tags/IDEA/"/>
    
  </entry>
  
  <entry>
    <title>最优化</title>
    <link href="https://dave0126.github.io/2022/04/22/%E6%9C%80%E4%BC%98%E5%8C%96/"/>
    <id>https://dave0126.github.io/2022/04/22/%E6%9C%80%E4%BC%98%E5%8C%96/</id>
    <published>2022-04-22T19:25:39.000Z</published>
    <updated>2022-05-03T10:53:28.421Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文章是根据法国国立高等电力技术、电子学、计算机、水力学与电信学校 (E.N.S.E.E.I.H.T.) 第七学期课程<em>“Optimisation”</em> 总结而来的【部分课程笔记】。碍于本人学识有限，部分叙述难免存在纰漏，请读者注意甄别。</p><span id="more"></span><h4 id="最优化问题解题步骤"><a href="#最优化问题解题步骤" class="headerlink" title="最优化问题解题步骤"></a>最优化问题解题步骤</h4><h5 id="1-建模最优化问题"><a href="#1-建模最优化问题" class="headerlink" title="1. 建模最优化问题"></a>1. 建模最优化问题</h5><p>我们首先需要根据题目的描述对于问题 $(\mathcal{P})$ 进行数学建模。包括问题中提供的任何信息。确定</p><p>(1) 我们想要最大化或最小化目标函数，并将其统一转换成最小化问题；</p><p>(2) 为目标方程中的变量依照题意添加约束，统一标准化为小于等于约束；</p><p>(3) 如果可以，结合图形更加直观。</p><h5 id="2-确定目标函数的定义域-Omega"><a href="#2-确定目标函数的定义域-Omega" class="headerlink" title="2. 确定目标函数的定义域 $\Omega$"></a>2. 确定目标函数的定义域 $\Omega$</h5><p>目标函数的定义域 $\Omega$ 的封闭性、有无界性、是否非空 和 凹凸性：必须是一个<u>封闭(closed) 的</u>、<u>有界的(bounded)</u> <u>非空 (non-empty) 凸区间 (convex interval)</u> （即两端都有端点并包含这些端点的区间，且区间中任意两点的连线上的所有点都属于这个区间）</p><h5 id="3-判断目标函数在定义域-Omega-上的极值情况"><a href="#3-判断目标函数在定义域-Omega-上的极值情况" class="headerlink" title="3. 判断目标函数在定义域 $\Omega$ 上的极值情况"></a>3. 判断目标函数在定义域 $\Omega$ 上的极值情况</h5><ul><li><p><u>存在性 (existence)</u>：一阶偏导 (梯度) $\nabla$ 检验，评估目标函数在定义域 $\Omega$ 中的一阶偏导，简单判断目标函数的极值情况。例如：</p><p>$f(x_1,x_2,x_3)\;\Rightarrow \; f(z,z,z) \; \xrightarrow{z\to \infin}\; f\to \infin \text{ 无全局最大值}$，$f(x_1,x_2,x_3)\;\Rightarrow \; f(z,z,z) \; \xrightarrow{z\to -\infin}\; f\to -\infin \text{ 无全局最小值}$</p></li><li><p><u>唯一性 (unicité)</u>：二阶偏导 (梯度) $\nabla^2$ 检验，要求：定义域 $\Omega$ 中必须只有一个极值。测试：求目标函数的二阶偏导 ，并在临界数处对其进行评估。如果该值为 $<0$，则临界数表示严格极大值 (strict maximum)。如果该值为$>0$，则临界数表示严格极小值 (strict minimum)。</0$，则临界数表示严格极大值></p></li></ul><h5 id="4-构造拉格朗日乘数法或-mathcal-KKT"><a href="#4-构造拉格朗日乘数法或-mathcal-KKT" class="headerlink" title="4. 构造拉格朗日乘数法或$\mathcal{KKT}$"></a>4. 构造拉格朗日乘数法或$\mathcal{KKT}$</h5><p>下略。</p><h4 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h4><p>是数学中的一种基本概念。 在泛函分析中，它定义在赋范线性空间中，并满足一定的条件，即 <strong>①非负性</strong>；<strong>②齐次性</strong>；<strong>③三角不等式</strong>。 它常常被用来度量<u>某个向量空间（或矩阵）中的每个向量的长度或大小</u>。</p><ul><li><p>$l_1范数$ ：</p><script type="math/tex; mode=display">\lVert x\rVert_1 = \sum_{i=1}^n |x_i|</script></li><li><p>$l_2范数$ ：</p><script type="math/tex; mode=display">\lVert x\rVert_2 = \sqrt{x^Tx} = \sqrt{\sum_{i=1}^n x_i^2}</script></li><li><p>$l_\infin范数$ ：</p><script type="math/tex; mode=display">\lVert x\rVert_{\infin} = max\{ |x_i|:i\in 1,2,...,n\}</script></li><li><p>$l_p范数$ ：</p><script type="math/tex; mode=display">\lVert x\rVert_p =(\sum_{i=1}^n |x_i|^p)^{\frac {1}{p}},p \in [1,\infin)</script></li></ul><h4 id="凸集"><a href="#凸集" class="headerlink" title="凸集"></a>凸集</h4><h5 id="凸集-Convex-set"><a href="#凸集-Convex-set" class="headerlink" title="凸集 (Convex set)"></a>凸集 (Convex set)</h5><p>给定非空集合 $F \subseteq \R^n$，如果 $\forall x,y \in F, \alpha \in [0,1]$ 都有 $\alpha x+(1-\alpha) y \in F$，那么我们就称这个 $F$ 为 $\R^n$ 中的一个凸集，即集合中的任意两点的连线仍然属于该集合。</p><h5 id="凸组合-Convex-combination"><a href="#凸组合-Convex-combination" class="headerlink" title="凸组合 (Convex combination)"></a>凸组合 (Convex combination)</h5><p>$x^1, x^2,…,x^k$ 的凸组合：</p><script type="math/tex; mode=display">\lambda_1x^1 + \lambda_2x^2 + ... +\lambda_kx^k</script><p>其中，$\lambda_1, \lambda_2,…,\lambda_k \ge 0, \sum_{i=1}^k \lambda_i = 1$</p><h4 id="黑塞矩阵-Hessain"><a href="#黑塞矩阵-Hessain" class="headerlink" title="黑塞矩阵 (Hessain)"></a>黑塞矩阵 (Hessain)</h4><p>在之前的学习中我们已经知道，一阶导数，也就是目标函数的梯度，反映了函数值随着自变量 $x$ 变化的速率情况。所谓二阶导数，就是在一阶导数的基础上再求导数，反映了一阶导数的变化情况。</p><p>例如对于二次型函数 $f(x) = x^2$，它的一阶导数就是 $\frac {df(x)}{dx} = 2x$，二阶导数为 $\frac{d^2f(x)}{dx^2} = 2$</p><p>将其推广，对于一般的多元函数 $f(x) : \R^n \to \R$， 对其求一阶偏导数 (partial)，一阶偏导为向量称作梯度 (gradient):</p><script type="math/tex; mode=display">\nabla f(x) = \begin{bmatrix}\frac{\partial f}{\partial x_1} \\\frac{\partial f}{\partial x_2} \\\vdots\\\frac{\partial f}{\partial x_n}\end{bmatrix}</script><p>我们再对一阶导数 $\frac{\part f(x)}{\part x}$ 对于 $x_i$ 求偏导，我们可以得到</p><script type="math/tex; mode=display">\nabla (\frac{\partial f}{\partial x_i}) = \nabla^2 f(x) =\begin{bmatrix}\frac{\partial}{\partial x_1}\frac{\partial f}{\partial x_1} & \frac{\partial}{\partial x_2}\frac{\partial f}{\partial x_1} & \cdots & \frac{\partial}{\partial x_n}\frac{\partial f}{\partial x_1}      \\\frac{\partial}{\partial x_1}\frac{\partial f}{\partial x_2} & \frac{\partial}{\partial x_2}\frac{\partial f}{\partial x_2} & \cdots & \frac{\partial}{\partial x_n}\frac{\partial f}{\partial x_2}      \\\vdots & \vdots & \ddots & \vdots \\\frac{\partial}{\partial x_1}\frac{\partial f}{\partial x_n} & \frac{\partial}{\partial x_2}\frac{\partial f}{\partial x_n} & \cdots & \frac{\partial}{\partial x_n}\frac{\partial f}{\partial x_n}      \\\end{bmatrix}\leftarrow Hessian \; Matrix</script><p>黑塞矩阵是对梯度再求一次偏导，所以它是 $n \times n$ 的方阵，满足对称性 $\mathcal{H}_{ij} = \mathcal{H}_{ji}$</p><blockquote><p>例：对于 $f(x,y) = 5x + 8y +xy -x^2 -2y^2$</p></blockquote><script type="math/tex; mode=display">\nabla f(x,y) = \begin{bmatrix}\frac{\partial f}{\partial x} \\\frac{\partial f}{\partial y} \end{bmatrix}= \begin{bmatrix}5-2x+y \\8+x-4y \end{bmatrix}\\\mathcal{H} (x) =\begin{bmatrix}2 & 1 \\1 & -4\\\end{bmatrix}</script><p>对于二次函数，黑塞矩阵为常数矩阵。</p><h5 id="黑塞矩阵的意义"><a href="#黑塞矩阵的意义" class="headerlink" title="黑塞矩阵的意义"></a>黑塞矩阵的意义</h5><p>如果一个函数的黑塞矩阵是<strong>正定</strong> (positive definite) 的，即特征值大于 0，也即目标函数在所有可行方向 $d$ 上的二阶导数都大于 $0$。我们就可以得出 $f(x)$ 是<u>一个严格的凸函数</u>，其<u>极值就是极小值</u>，而且也是<strong><u>全局的最小值</u></strong>。</p><h4 id="矩阵的正定"><a href="#矩阵的正定" class="headerlink" title="矩阵的正定"></a>矩阵的正定</h4><p>正定矩阵首先是一个对称阵。以下我们介绍一种判断矩阵是否正定的方法，Sylvester’s Criterion：</p><h5 id="Sylvester’s-Criterion"><a href="#Sylvester’s-Criterion" class="headerlink" title="Sylvester’s Criterion"></a>Sylvester’s Criterion</h5><p>各阶行列式（顺序主子式）都大于0 $\Rightarrow$ 矩阵正定 $\succ 0$</p><script type="math/tex; mode=display">\begin{bmatrix}2 & -1 & 0 \\-1 & 2 & -1 \\0 & -1 & 2\end{bmatrix}\quad \Rightarrow \quad \begin{vmatrix}2 \end{vmatrix} > 0\quad\begin{vmatrix}2 & -1 \\-1 & 2 \end{vmatrix} > 0\quad\begin{vmatrix}2 & -1 & 0 \\-1 & 2 & -1 \\0 & -1 & 2\end{vmatrix} > 0</script><h4 id="无约束优化问题的最优性条件"><a href="#无约束优化问题的最优性条件" class="headerlink" title="无约束优化问题的最优性条件"></a>无约束优化问题的最优性条件</h4><p>无约束优化问题： $\min f(x)$</p><p>最优解的定义：</p><ul><li><p>局部最优解：对于一个解 $\bar x$，在 $\bar x$ 的临域空间 $N_s(\bar x)$ 内 $f(\bar x)$ 的值是最大或最小的。</p><script type="math/tex; mode=display">\forall x \in N_s(\bar x), f(x) \ge f(\bar x) \;或\; f(x) \le f(\bar x)</script></li><li><p>全局最优解：对于一个解 $\bar x$，在任意n维空间 $\R^n$ 内 $f(\bar x)$ 的值是最大或最小的。</p><script type="math/tex; mode=display">\forall x \in \R^n, f(x) \ge f(\bar x) \;或\; f(x) \le f(\bar x)</script></li><li><p>严格局部最优解：对于一个解 $\bar x$，在 $\bar x$ 的临域空间 $N_s(\bar x)$ 内 $f(\bar x)$ 的值是严格最大或最小的（不包含等于情况）。</p><script type="math/tex; mode=display">\forall x \in N_s(\bar x), f(x) > f(\bar x) \;或\; f(x) < f(\bar x)</script></li><li><p>严格全局最优解：对于一个解 $\bar x$，在任意n维空间 $\R^n$ 内 $f(\bar x)$ 的值是严格最大或最小的（不包含等于情况）。</p><script type="math/tex; mode=display">\forall x \in \R^n, f(x) > f(\bar x) \;或\; f(x) < f(\bar x)</script></li></ul><h5 id="最优性条件"><a href="#最优性条件" class="headerlink" title="最优性条件"></a>最优性条件</h5><p>考虑无约束优化问题： $\min f(x)$</p><ul><li><p>必要条件：若 $x^<em>$ 是最优解，则 $x^</em>$ 有如下性质：</p><script type="math/tex; mode=display">(1)\quad \nabla f(x^*) = 0 \qquad \qquad \qquad \text{目标函数在 } x^* \text{的位置时梯度为零} \\(2)\quad \nabla^2 f(x^*) \succeq 0 \qquad \text{目标函数在 } x^* \text{的位置时黑塞矩阵是半正定的}</script></li><li><p>充分条件：</p><script type="math/tex; mode=display">若 \nabla f(x^*) = 0, \nabla^2 f(x^*) \succ 0 \quad \Rightarrow \quad 则 x^* 是严格最优的</script></li></ul><h4 id="无约束优化：线搜索-和-信赖域"><a href="#无约束优化：线搜索-和-信赖域" class="headerlink" title="无约束优化：线搜索 和 信赖域"></a>无约束优化：线搜索 和 信赖域</h4><p>考虑无约束优化问题： $\min f(x)$</p><p>迭代下降算法的描述：</p><p>给定一个初始点 $x_0$ ，我们可以判断 $x_0$ 是否是我们需要找的点，如果不是，我们要产生点列 $\{x_k\}^\infin_{k=1}$ ，并且满足 $f(x_{k+1}) &lt; f(x)$ “下一个点的函数值比当前点的函数值小”。我们有两种策略：线搜索 (Line search) 和 信赖域 (Trust region)</p><h5 id="线搜索方法"><a href="#线搜索方法" class="headerlink" title="线搜索方法"></a>线搜索方法</h5><h6 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h6><ol><li>给定初始点 $x_0$</li><li>判断 $x_0$ 是否满足【终止条件】；是，则终止</li><li>当前点为 $x_k$，首先找到【下降方向 $d_k$】（从这个点出发，有一段步长的距离，目标函数值会减小的方向）</li><li>确定【步长 $\alpha _k &gt; 0$ 】，使得 $f(x_k + \alpha_k d_k) &lt; f(x)$</li><li>我们就得到了下一个点 $x_{k+1} :=x_k + \alpha_k d_k$；转第 2 步</li></ol><ul><li>终止条件：$\lVert \nabla f(x_k) \rVert_2 \le \mathcal{E}$，其中 $\mathcal{E}$ 是一个很小的正整数，意味着当梯度趋近于 0</li><li>下降方向 $d_k$ 的选择：最速下降、共轭梯度等</li><li>步长 $\alpha _k$ 的选择：我们令 $\phi(\alpha) := f(x_k + \alpha d_k)$，步长 $\alpha_k = \min \phi (\alpha),\alpha \ge 0$</li><li>算法结束后会给我们一个点列 $\{x_k\}$，我们需要关心点列的收敛性和收敛速度</li></ul><h5 id="信赖域方法"><a href="#信赖域方法" class="headerlink" title="信赖域方法"></a>信赖域方法</h5><ol><li>当前点为 $x_k$，首先决定“活动范围 $\Delta$” $\lVert d\rVert_2 \le \Delta$</li><li>再决定“活动方向”</li></ol><h4 id="无约束优化：最速下降"><a href="#无约束优化：最速下降" class="headerlink" title="无约束优化：最速下降"></a>无约束优化：最速下降</h4><h5 id="收敛速度"><a href="#收敛速度" class="headerlink" title="收敛速度"></a>收敛速度</h5><p>设当前点列 $\{x_k\}$ 收敛到 $x^*$，若存在极限</p><script type="math/tex; mode=display">\lim_{k\to \infin} \frac{\lVert x_{k+1} - x^* \rVert_2}{\lVert x_{k} - x^* \rVert_2} = \beta</script><ul><li>当 $0 &lt; \beta &lt; 1$ 时，则称点列 $\{x_k\}$ 为<strong>线性收敛</strong></li><li>当 $\beta = 0$ 时，则称点列 $\{x_k\}$ 为<strong>超线性收敛</strong></li></ul><p>若存在某个 $p \ge 1$，有</p><script type="math/tex; mode=display">\lim_{k\to \infin} \frac{\lVert x_{k+1} - x^* \rVert_2}{\lVert x_{k} - x^* \rVert_2^p} = \beta <+\infin</script><p>则称点列 $\{x_k\}$ 为<strong>p阶收敛</strong></p><ul><li>当 $p &gt; 1$ 时，p阶收敛必为超线性收敛</li></ul><h5 id="最速下降法"><a href="#最速下降法" class="headerlink" title="最速下降法"></a>最速下降法</h5><p>也叫做梯度下降法。【基本思想】是选择 $x_k$ 处的负梯度方向作为搜素方向，即 $d_k = -\nabla f(x_k) $</p><ul><li>优点：简单直观；收敛；搜素方向只需计算 $-\nabla f(x_k) $</li><li>缺点：收敛速度慢（线性搜索）；Zigzag现象（路径是“之”字形）；不具备“在有限步内求得凸二次函数最优解”的特性</li></ul><h4 id="约束优化：-mathcal-KKT-条件"><a href="#约束优化：-mathcal-KKT-条件" class="headerlink" title="约束优化：$\mathcal{KKT}$ 条件"></a>约束优化：$\mathcal{KKT}$ 条件</h4><h5 id="一阶必要条件-最优解-to-mathcal-KKT-点"><a href="#一阶必要条件-最优解-to-mathcal-KKT-点" class="headerlink" title="一阶必要条件 : $最优解 \to \mathcal{KKT} 点$"></a>一阶必要条件 : $最优解 \to \mathcal{KKT} 点$</h5><p>假设 $x^<em>$ 是问题 $\mathcal{P}$ 的局部最优解，且 $x^</em>$ 某处的约束规范 (constraint qualification) 成立，则存在 $\lambda$，$\mu$ 使得</p><script type="math/tex; mode=display">\min_{x\in \R^2} f(x) \\s.t. \quad \forall i \in \{1,2,...,l\}:h_i(x)=0\quad 且 \quad \forall j \in \{1,2,...,m\}:g_j(x) \le 0 \\可行集 S(\mathcal{E}) = \{x| 满足 \; s.t.\} \\</script><ol><li><script type="math/tex; mode=display">\nabla f(x^*) + \sum_{i=1}^m \lambda_i \nabla g_i(x^*) + \sum_{i=1}^l \mu_i \nabla h_i(x^*)= 0</script></li><li><p>$\forall i \in \{1,2,…,m\}:\lambda_i \ge 0$</p></li><li><p>$\forall i \in \{1,2,…,m\}:g_i(x^*) \le 0$</p></li><li><p>$\forall i \in \{1,2,…,m\}:h_i(x^*) = 0$</p></li><li><p>$\forall i \in \{1,2,…,m\}:\lambda_i g_i(x^*) = 0$</p></li></ol><h5 id="二阶充分条件-mathcal-KKT-点-to-最优解"><a href="#二阶充分条件-mathcal-KKT-点-to-最优解" class="headerlink" title="二阶充分条件 : $\mathcal{KKT}点 \to 最优解$"></a>二阶充分条件 : $\mathcal{KKT}点 \to 最优解$</h5><p>假设 $x^*$ 满足上述的 $\mathcal{KKT}$ 条件，我们定义一个函数 $\mathcal{L}(x) = f(x) + \sum \mu_i h_i(x) + \sum \lambda_i g_i(x))$，可知：</p><ol><li>$\nabla_{x} \mathcal{L}(x^*) = 0 \qquad \mathcal{KKT}\text{条件中的第 1 条}$</li><li>$\mathcal{L}(x^<em>) = f(x^</em>) + \sum \mu_i h_i(x^<em>) + \sum \lambda_i g_i(x^</em>)) = f(x^<em>) + 0 + 0 \quad \Rightarrow \quad \mathcal{L}(x^</em>) = f(x^*)$</li><li>$\forall x \in S(\mathcal{E}),\;\mathcal{L}(x) \le f(x)$</li></ol><p>有以下结论：</p><ul><li>由 2, 3 可知，若 $x^<em>$ 是 $\mathcal{L} (x)$ 的最优解，则$x^</em>$ 也是 $\mathcal{P}$ 的最优解：$f(x^<em>) = \mathcal{L}(x^</em>) \le \mathcal{L}(x) \le f(x)$</li><li>若 $\nabla_{xx} \mathcal{L}(x^<em>) \succeq 0, \; \forall x \in S(\mathcal{E})$，则 $x^</em>$ 是 $\mathcal{P}$ 的<u>全局最优解</u></li><li>若 $\nabla_{xx} \mathcal{L}(x^<em>) \succeq 0, \; \forall x \in \{S(\mathcal{E})\cap _{临域}N_S(x</em>)\}$，则 $x^*$ 是 $\mathcal{P}$ 的<u>局部最优解</u></li><li>若 $\nabla_{xx} \mathcal{L}(x^<em>) \succ 0$，则 $x^</em>$ 是 $\mathcal{P}$ 的<u>严格局部最优解</u></li></ul><h4 id="约束优化：对偶理论"><a href="#约束优化：对偶理论" class="headerlink" title="约束优化：对偶理论"></a>约束优化：对偶理论</h4><p>考虑如下一般形式的约束优化问题：</p><script type="math/tex; mode=display">(\mathcal{P}):\; \min_{x\in \R^2} f(x) \\s.t. \quad \left\{\begin{aligned}& h_i(x)=0, \;\forall i \in \{1,2,...,l\} \\ & g_j(x) \le 0 , \; \forall j \in \{1,2,...,m\} \\& x \in X\end{aligned}\right.\\ \\可行集 S(\mathcal{E}) = \{ x \in X | 满足 \; s.t.\} \\</script><p>其中 $X$ 是“<strong>集合约束</strong>”，如果：</p><ol><li>$X = \R^n$ 所研究的问题 $\mathcal{P}$ 就是在 <strong>n 维实数域</strong>上的<strong>连续优化问题</strong>，就可以运用以上知识</li><li>$X = \Z^n_+$ 所研究的问题 $\mathcal{P}$ 就是在 <strong>n 维整数（或非负整数）域</strong>上的<strong>连续优化问题</strong>，就可以运用以上知识</li><li>$X = \{0,1\}^n$ 所研究的问题 $\mathcal{P}$ 就是在 <strong>n 维 0-1 集合</strong>上的<strong>离散整数优化问题</strong></li></ol><h5 id="对偶问题的意义"><a href="#对偶问题的意义" class="headerlink" title="对偶问题的意义"></a>对偶问题的意义</h5><script type="math/tex; mode=display">原问题 \; (\mathcal{P}) \quad \xrightarrow{构建} \quad 对偶问题 \; (\mathcal{D})</script><ol><li>如果原问题 $(\mathcal{P})$ 是非凸问题，我们很难求解这一类 <code>NP-hard</code> 问题，我们就可以构造一个和原问题 $(\mathcal{P})$ 的关系紧密又简单的对偶问题 $(\mathcal{D})$ 来求解；</li><li>在线性规划问题中的对偶问题；</li><li>鲁棒优化，锥优化</li></ol><h5 id="拉格朗日对偶问题"><a href="#拉格朗日对偶问题" class="headerlink" title="拉格朗日对偶问题"></a>拉格朗日对偶问题</h5><script type="math/tex; mode=display">(\mathcal{P}):\; \min_{x\in \R^2} f(x) \\s.t. \quad \left\{\begin{aligned}& h_i(x)=0, \;\forall i \in \{1,2,...,l\} \\ & g_j(x) \le 0 , \; \forall j \in \{1,2,...,m\} \\& x \in X\end{aligned}\right.\\ \\可行集 S(\mathcal{E}) = \{ x \in X | 满足 \; s.t.\} \\</script><p>我们引入拉格朗日函数：</p><script type="math/tex; mode=display">\mathcal{L}(x, \lambda, \mu) = f(x) + \sum_{i=1}^l \mu_i h_i(x) + \sum_{i=1}^m \lambda_i g_i(x))</script><p>此时我们对拉格朗日函数 $\mathcal{L}$ 求最小值，得到拉格朗日对偶函数 (dual function)：</p><script type="math/tex; mode=display">\begin{aligned}d(\lambda,\mu)& = \min _{x \in X} (\mathcal{L}(x, \lambda, \mu)) = \min _{x \in X} \{ f(x) + \sum_{i=1}^l \mu_i h_i(x) + \sum_{i=1}^m \lambda_i g_i(x)\} \\& \le \min _{x \in S(\mathcal{E})} \{ f(x) + \sum_{i=1}^l \mu_i h_i(x) + \sum_{i=1}^m \lambda_i g_i(x)\} \\& \le \min _{x \in S(\mathcal{E})} \{ f(x) \}\end{aligned}</script><ul><li>对于 $\forall (\lambda, \mu), \lambda \ge 0$ 必有 $d(\lambda,\mu) \le v (\mathcal{P})$，即 $d(\lambda, \mu)$ 是 $v (\mathcal{P})$ 的下界，所以我们要找出 $d(\lambda, \mu)$ 的【最大值】</li></ul><p>此时我们就可以给出拉格朗日问题的对偶问题 $(\mathcal{D})$ ：</p><script type="math/tex; mode=display">(\mathcal{D}):\; \max d(\lambda, \mu) \\s.t. \quad \lambda_i \ge 0,\; \forall i \in \{1,2,...,m\}</script><p>写成以下形式：</p><script type="math/tex; mode=display">(\mathcal{D}):\; \max _{\lambda \ge 0} \quad \min _{x \in X} (\mathcal{L}(x, \lambda, \mu)) \quad \xrightarrow{交换} \quad \min _{x \in X} \quad \max _{\lambda \ge 0}  (\mathcal{L}(x, \lambda, \mu))</script><p>经过推导，问题 $(\mathcal{D})$ 可转化成原问题 $(\mathcal{P})$：</p><script type="math/tex; mode=display">(\mathcal{P}):\; \min_{x\in \R^2} f(x) \\s.t. \quad \left\{\begin{aligned}& h_i(x)=0, \;\forall i \in \{1,2,...,l\} \\ & g_j(x) \le 0 , \; \forall j \in \{1,2,...,m\} \\& x \in X\end{aligned}\right.</script><h5 id="弱对偶定理"><a href="#弱对偶定理" class="headerlink" title="弱对偶定理"></a>弱对偶定理</h5><p>在之前拉格朗日对偶问题中，“对于 $\forall (\lambda, \mu), \lambda \ge 0$ 必有 $d(\lambda,\mu) \le v (\mathcal{P})$，即 $d(\lambda, \mu)$ 是 $v (\mathcal{P})$ 的下界，所以我们要找出 $d(\lambda, \mu)$ 的最大值”。我们可以推导到一般：</p><ul><li>设 $ v (\mathcal{P})$ 是原问题 $(\mathcal{P})$ 的最优值，$ v (\mathcal{D})$ 是对偶问题 $(\mathcal{D})$ 的最优值，则 $ v (\mathcal{D}) \le v (\mathcal{P})$ </li></ul><p>推论：假设 $\bar x \in S(\mathcal{E})，(\bar \lambda,\bar \mu),\bar \lambda \ge 0 \; 且 \; d(\bar \lambda,\bar \mu) = f(\bar x)$，则 $ v (\mathcal{P}) =  v (\mathcal{D}) \; 且 \; \bar x,(\bar \lambda,\bar \mu) \; 是\; v (\mathcal{P}) \; 和 \; v (\mathcal{D}) \; 的最优解$</p>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本文章是根据法国国立高等电力技术、电子学、计算机、水力学与电信学校 (E.N.S.E.E.I.H.T.) 第七学期课程&lt;em&gt;“Optimisation”&lt;/em&gt; 总结而来的【部分课程笔记】。碍于本人学识有限，部分叙述难免存在纰漏，请读者注意甄别。&lt;/p&gt;</summary>
    
    
    
    <category term="课程笔记" scheme="https://dave0126.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="课程笔记" scheme="https://dave0126.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="最优化" scheme="https://dave0126.github.io/tags/%E6%9C%80%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>拉格朗日乘数与KKT几何关联推导</title>
    <link href="https://dave0126.github.io/2022/04/21/KKT/"/>
    <id>https://dave0126.github.io/2022/04/21/KKT/</id>
    <published>2022-04-21T20:57:45.000Z</published>
    <updated>2022-09-04T08:19:33.424Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Lagrange-Multipliers-amp-mathcal-KKT-几何关联推导"><a href="#Lagrange-Multipliers-amp-mathcal-KKT-几何关联推导" class="headerlink" title="Lagrange Multipliers &amp; $\mathcal{KKT}$ 几何关联推导"></a>Lagrange Multipliers &amp; $\mathcal{KKT}$ 几何关联推导</h3><p>本文章是根据<a href="https://www.csc.kth.se/utbildning/kth/kurser/DD3364/Lectures/KKT.pdf">瑞典皇家理工学院课件</a>总结归纳而成。碍于本人学识有限，部分叙述难免存在纰漏，请读者注意甄别。</p><p>参考资料：</p><ol><li><a href="https://www.csc.kth.se/utbildning/kth/kurser/DD3364/Lectures/KKT.pdf">KTH Royal Institute of Technology : Lagrange Multipliers and the Karush-Kuhn-Tucker conditions</a></li></ol><span id="more"></span><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>我们想要找到一个满足一些约束的函数的最大值或最小值</p><h4 id="公式描述"><a href="#公式描述" class="headerlink" title="公式描述"></a>公式描述</h4><p>给定一个函数 $f$，不等式约束 $g_1, . . . , g_m$ 和等式约束 $h_1,…, h_l$ 都在在定义域 $Ω ⊂ \mathbb{R}^n$ 上的优化问题：</p><script type="math/tex; mode=display">\begin{aligned}& \min_{x∈Ω} \;f(x) \\s.t.& \left\{\begin{aligned}∀i \quad g_i(x) ≤ 0 \\∀j \quad h_j (x) = 0 \end{aligned}\right.\end{aligned}</script><h4 id="No-constraints"><a href="#No-constraints" class="headerlink" title="No constraints"></a>No constraints</h4><p><strong>Assume</strong>: Let $f$ : $Ω → \mathbb{R}$  be a continuously differentiable function. 在定义域上连续可微</p><p>【局部最小值】的【充要条件】(Necessary and sufficient conditions): </p><p>$x^{\ast}$ is a local minimum of $f(x)$ 当且仅当</p><ol><li><p>$f$ 在 $x^{\ast}$ 处是零梯度 (zero gradient)：</p><script type="math/tex; mode=display">∇_x f(x^{\ast}) = 0</script></li><li><p>$f$ 的 Hessian 矩阵在 $x^{\ast}$ 处是半正定的 (positive semi-definite)：保证$f$ 在 $x^{\ast}$ 处是“波谷”</p><script type="math/tex; mode=display">\begin{aligned}& v^t (∇^2f(x^{\ast})) v ≥ 0, ∀v ∈ \mathbb{R}^n\\\\&\nabla_{xx}^2 f(x) =\begin{bmatrix}\frac{\partial^2 f(x)}{\partial x_1 ^2} & \frac{\partial^2 f(x)}{\partial x_1 \partial x_2} & \cdots & \frac{\partial^2 f(x)}{\partial x_1 \partial x_n}      \\\frac{\partial^2 f(x)}{\partial x_2 \partial x_1} & \frac{\partial^2 f(x)}{\partial x_2 ^2} & \cdots & \frac{\partial^2 f(x)}{\partial x_2 \partial x_n}      \\\vdots & \vdots & \ddots & \vdots \\\frac{\partial^2 f(x)}{\partial x_n \partial x_1} & \frac{\partial^2 f(x)}{\partial x_n  \partial x_2} & \cdots & \frac{\partial^2 f(x)}{\partial x_n ^2}      \\\end{bmatrix}\leftarrow Hessian \; Matrix\end{aligned}</script></li></ol><p>【局部最大值】的【充要条件】(Necessary and sufficient conditions): $x^{\ast}$ is a local minimum of $f(x)$ 当且仅当</p><ol><li><p>$f$ 在 $x^{\ast}$ 处是零梯度 (zero gradient)：</p><script type="math/tex; mode=display">∇_x f(x^{\ast}) = 0</script></li><li><p>$f$ 的 Hessian 矩阵在 $x^{\ast}$ 处是半正定的 (positive semi-definite)：保证$f$ 在 $x^{\ast}$ 处是“波谷”</p><script type="math/tex; mode=display">\begin{aligned}& v^t (∇^2f(x^*)) v \le 0, ∀v ∈ \mathbb{R}^n \\\\\\& \nabla^2 f(x) =\begin{bmatrix}\frac{\partial^2 f(x)}{\partial x_1 ^2} & \frac{\partial^2 f(x)}{\partial x_1 \partial x_2} & \cdots & \frac{\partial^2 f(x)}{\partial x_1 \partial x_n}      \\\frac{\partial^2 f(x)}{\partial x_2 \partial x_1} & \frac{\partial^2 f(x)}{\partial x_2 ^2} & \cdots & \frac{\partial^2 f(x)}{\partial x_2 \partial x_n}      \\\vdots & \vdots & \ddots & \vdots \\\frac{\partial^2 f(x)}{\partial x_n \partial x_1} & \frac{\partial^2 f(x)}{\partial x_n  \partial x_2} & \cdots & \frac{\partial^2 f(x)}{\partial x_n ^2}      \\\end{bmatrix}\leftarrow Hessian \; Matrix\end{aligned}</script></li></ol><h4 id="Equality-Constrainsts"><a href="#Equality-Constrainsts" class="headerlink" title="Equality Constrainsts"></a>Equality Constrainsts</h4><p>问题提出：</p><script type="math/tex; mode=display">\begin{aligned}& \min_{x∈\mathbb{R}^2} \;f(x) \\s.t. \quad & h_i (x) = 0, \; ∀i\in \{1,2,...,l\}\end{aligned}</script><p>举例：</p><script type="math/tex; mode=display">\begin{aligned}& f(x) = x_1 + x_2 \\s.t.\quad & h(x) = x^2_1 + x^2_2 − 2\end{aligned}</script><ol><li><p>可行点 (feasible point) $x_F \in$ 可行域 (feasible region) 满足约束 $h(x) = x^2_1 + x^2_2 − 2 = 0$，图形上的表示就是在 $x^2_1 + x^2_2 − 2$ 的圆上</p></li><li><p>目标函数 $f(x) = x_1 + x_2$ 的梯度方向 $\nabla_x f(x) = [1,1]^T$，所以它的负梯度方向为 $- \nabla_x f(x) = [-1,-1]^T$</p></li><li><p>我们找到一个点 $x_i$ 满足约束：其中 $\alpha$ 为步长，$\delta x_i$ 为 $x_i$ 点的运动方向</p><ul><li>$h(x_F + \alpha \delta x_i) = 0$（确保在圆上）</li><li>$f(x_F + \alpha \delta x) &lt; f(x_F)$（确保移动后的函数值 &lt; 移动前）</li></ul><p><img src="/2022/04/21/KKT/2022-04-23 20.51.01.png" alt="2022-04-23 20.51.01" style="zoom:35%;"></p></li><li><p>一个点 $x_i$ 要沿着 $f(x)$ 的最速下降 (the steepest descent) 方向，即负梯度方向为 $- \nabla_x f(x) = [-1,-1]^T$ ；但是 $x_i$ 还要满足等式约束，所以我们要确保 $\delta x_i$ 与 负梯度方向 $- \nabla_x f(x)$ 的夹角为锐角，即内积 $\delta x_i \cdot (- \nabla_x f(x_F)) &gt; 0$</p><p><img src="/2022/04/21/KKT/2022-04-23 21.12.41.png" alt="2022-04-23 21.12.41" style="zoom:35%;"></p><ul><li>至此，我们就找到了满足约的点 $x_i$ 移动的方向，即与目标函数 $f(x)$ 负梯度方向的夹角为锐角的约束函数 $h(x)$ 的切线方向。那么，什么时候停止移动呢？</li></ul></li><li><p>从图像中我们可以看到，当目标函数 $f(x)$ 与约束函数 $h(x)$ 相切的时候，我们可以取到局部极值点 (临界点 critical point)，即 目标函数 $f(x)$ 的梯度方向与约束函数 $h(x)$ 的梯度方向共线：</p><script type="math/tex; mode=display">\nabla_x f(x_F) = \mu \nabla_x h(x_F)\quad \Rightarrow \quad\nabla_x f(x_F) + \mu \nabla_x h(x_F) = 0 \quad ①</script><p>这个条件【确保局部极值】</p><p><img src="/2022/04/21/KKT/2022-04-23 21.30.49.png" alt="2022-04-23 21.30.49" style="zoom:35%;"></p><p>而此时， $x_i$ 移动的方向 $\delta x_i$ 始终与约束函数 $g(x)$ 梯度方向 $\nabla_x h(x)$ 正交，即</p><script type="math/tex; mode=display">\delta x_i \cdot \mu \nabla_x h(x_F) = \delta x_i \cdot (- \nabla_x h(x_F))</script></li></ol><p>   我们重新构造这个优化问题 $(\mathcal{P})$，并推广到多等式约束：</p><script type="math/tex; mode=display">   \begin{aligned}   & \min_{x∈\mathbb{R}^2} \;f(x) \\   s.t. \quad & h_i (x) = 0, \; ∀i\in \{1,2,...,l\}   \end{aligned}</script><p>   我们定义拉格朗日函数 $\mathcal{L}$：</p><script type="math/tex; mode=display">   \mathcal{L} (x, \mu) = f(x) + \sum_{i=1}^l \mu_i h_i(x)</script><p>   当 $x^{\ast}$ 是局部最小值时，存在唯一的 $\mu^{\ast}$ 满足约束：</p><ul><li>$\nabla_{x} \mathcal{L} (x^{\ast},\mu^{\ast})= 0 \qquad \Leftarrow \qquad \nabla_x f(x_F) + \mu \nabla_x h(x_F) = 0 \quad ①$ </li><li>$\begin{aligned} \nabla_{\mu} \mathcal{L} (x^{\ast},\mu ^{\ast})= 0 \qquad \Leftarrow \qquad \frac {\partial \mathcal{L} (x,\mu_i)}{\partial \mu_i} = h_i(x) = 0\end{aligned} \quad \text{满足约束条件}$ </li><li>$\nabla_{xx}^2 \mathcal{L}(x^{\ast}, \mu^{\ast}) \succeq 0\qquad \Leftarrow \qquad \text{Hessain matrix 半正定：满足局部极小}$</li></ul><h4 id="Inequality-Constraints"><a href="#Inequality-Constraints" class="headerlink" title="Inequality Constraints"></a>Inequality Constraints</h4><p>问题提出：</p><script type="math/tex; mode=display">\begin{aligned}& \min_{x∈\mathbb{R}^2} \;f(x) \\s.t. \quad & g_j (x) \le 0, \; ∀j\in \{1,2,...,m\}\end{aligned}</script><h5 id="Case-1-可退化到无约束"><a href="#Case-1-可退化到无约束" class="headerlink" title="Case 1 : 可退化到无约束"></a>Case 1 : 可退化到无约束</h5><p>举例：</p><script type="math/tex; mode=display">\begin{aligned}& f(x) = x_1^2 + x_2^2 \\s.t.\quad & h(x) = x^2_1 + x^2_2 − 1\end{aligned}</script><p><img src="/2022/04/21/KKT/2022-04-23 22.33.13.png" alt="2022-04-23 22.33.13" style="zoom:40%;"></p><ol><li>可以从图像中看出，当 $f(x)$ 不加约束条件时的最优点为 $(0,0)$</li><li>可行点 (feasible point) $x_F \in$ 可行域 (feasible region) 满足约束 $h(x) = x^2_1 + x^2_2 − 1 = 0$，图形上的表示就是在 $x^2_1 + x^2_2 − 1$ 的圆上</li><li>当 $f(x)$ 加入约束条件时的最优点还是 $(0,0)$</li><li>说明有无约束条件对这个问题的求解并没有影响</li><li>此时我们就可以将这个约束优化问题退化成无约束问题：<ul><li>$f(x)$ 在 $x^{\ast}$ 处是零梯度 (zero gradient)：$∇_x f(x^∗) = 0$</li><li>$f$ 的 Hessian 矩阵在 $x^{\ast}$ 处是半正定的 (positive definite) ：$\nabla_{xx}^2 f(x^{\ast}) \succeq 0$</li></ul></li></ol><h5 id="Case-2-不等式约束"><a href="#Case-2-不等式约束" class="headerlink" title="Case 2 : 不等式约束"></a>Case 2 : 不等式约束</h5><p>我们更改上一例题的条件：</p><script type="math/tex; mode=display">\begin{aligned}& f(x) = (x_1 - 1.1)^2 + (x_2 - 1.1)^2 \\s.t.\quad & h(x) = x^2_1 + x^2_2 − 1\end{aligned}</script><p><img src="/2022/04/21/KKT/2022-04-23 22.49.34.png" alt="2022-04-23 22.49.34" style="zoom:40%;"></p><ol><li><p>可以从图像中看出，当 $f(x)$ 不加约束条件时的最优点为 $(1.1,-1.1)$</p></li><li><p>可行点 (feasible point) $x_F \in$ 可行域 (feasible region) 满足约束 $h(x) = x^2_1 + x^2_2 − 1 = 0$，图形上的表示就是在 $x^2_1 + x^2_2 − 1$ 的圆上</p></li><li><p>当 $f(x)$ 加入约束条件时的最优点并不在原来的 $(1.1,-1.1)$ 点</p></li><li><p>在这种情况下，极值在约束面上，即 $g(x^{\ast}) = 0$，此时就与<strong>等式约束条件</strong>一致了</p></li><li><p>所以参考等式约束问题，最优值出现在目标函数 $f(x)$ 的梯度方向与约束函数 $h(x)$ 的梯度方向共线：</p><script type="math/tex; mode=display">-\nabla_x f(x) = \lambda \nabla_x g(x), \lambda > 0\quad \Rightarrow \quad\nabla_x f(x) + \lambda \nabla_x g(x) = 0 \quad ②</script><p><img src="/2022/04/21/KKT/2022-04-23 22.57.55.png" alt="2022-04-23 22.57.55" style="zoom:40%;"></p></li></ol><h5 id="总结两种情况"><a href="#总结两种情况" class="headerlink" title="总结两种情况"></a>总结两种情况</h5><script type="math/tex; mode=display">\begin{aligned}& \min_{x∈\mathbb{R}^2} \;f(x) \\s.t. \quad & g_j (x) \le 0, \; ∀j\in \{1,2,...,m\}\end{aligned}</script><h6 id="Case-1-无约束时的局部极小值在可行域【中】"><a href="#Case-1-无约束时的局部极小值在可行域【中】" class="headerlink" title="Case 1 : 无约束时的局部极小值在可行域【中】"></a>Case 1 : 无约束时的局部极小值在可行域【中】</h6><ol><li>$g(x^{\ast}) &lt; 0 \qquad \Leftarrow \qquad 在可行域里$</li><li>$\nabla_x f(x^{\ast}) = \nabla_x f(x^{\ast}) + \lambda_{(=0)} \nabla_x g(x^{\ast}) = 0 \qquad \Leftarrow \qquad \mathcal{KKT} 条件1$</li><li>$\nabla_{xx}^2 f(x^{\ast}) \succeq 0 \qquad \Leftarrow \qquad Hessian 矩阵是半正定的$</li></ol><h6 id="Case-2-无约束时的局部极小值在可行域【外】"><a href="#Case-2-无约束时的局部极小值在可行域【外】" class="headerlink" title="Case 2 : 无约束时的局部极小值在可行域【外】"></a>Case 2 : 无约束时的局部极小值在可行域【外】</h6><ol><li>$g(x^{\ast}) = 0 \qquad \Leftarrow \qquad \mathcal{KKT} 条件3$</li><li>$- \nabla_x f(x^{\ast}) + \lambda \nabla_x g(x^{\ast}) = 0, \; \lambda &gt; 0 \qquad \Leftarrow \qquad \mathcal{KKT} 条件1$</li><li>$\nabla_{xx}^2 f(x^{\ast}) \succeq 0 \qquad \Leftarrow \qquad Hessian 矩阵是半正定的$</li></ol><p>$\mathcal{KKT}$ 条件4 ：$x^{\ast}$ 是可行点</p><h5 id="多等式和多不等式的-mathcal-KKT-条件"><a href="#多等式和多不等式的-mathcal-KKT-条件" class="headerlink" title="多等式和多不等式的 $\mathcal{KKT}$ 条件"></a>多等式和多不等式的 $\mathcal{KKT}$ 条件</h5><p>给定一个函数 $f$，不等式约束 $g_1, . . . , g_m$ 和等式约束 $h_1,…, h_l$ 都在在定义域 $Ω ⊂ \mathbb{R}^n$ 上的优化问题：</p><script type="math/tex; mode=display">\begin{aligned}& (\mathcal{P}):\; \min_{x\in Ω} f(x) \\s.t. \quad & \left\{\begin{aligned}& h_i(x)=0, \;\forall i \in \{1,2,...,l\} \\ & g_j(x) \le 0 , \; \forall j \in \{1,2,...,m\} \end{aligned}\right.\end{aligned}</script><p>我们定义拉格朗日函数 $\mathcal{L}$：</p><script type="math/tex; mode=display">\mathcal{L}(x, \lambda, \mu) = f(x) + \sum_{i=1}^l \mu_i h_i(x) + \sum_{j=1}^m \lambda_j g_j(x))</script><p>当 $x^{\ast}$ 是局部最小值时，存在唯一的 $\mu ^{\ast}$ 满足约束：</p><ul><li><p>$\nabla_{x} \mathcal{L} (x^{\ast},\mu ^{\ast}, \lambda^{\ast})= 0 \qquad \Leftarrow \qquad \nabla_x f(x^{\ast}) + \sum_{i=1}^l \mu_i \nabla_x h_i(x^{\ast}) + \sum_{j=1}^m \lambda_j \nabla_x g_j(x^{\ast}) = 0$ </p></li><li><p>$\lambda^{\ast}_j \ge 0 \text{ for } j=1,…,m$</p></li><li>$\lambda^{\ast}_j g_j(x^{\ast}) = 0 \text{ for } j=1,…,m$</li><li>$g_j(x^{\ast}) \le 0 \text{ for } j=1,…,m$</li><li>$g_i(x^{\ast}) = 0 \text{ for } i=1,…,l$</li><li>$\nabla_{xx}^2 \mathcal{L}(x^{\ast}, \lambda^{\ast}) \succ 0\qquad \Leftarrow \qquad \text{Hessain matrix 正定：满足局部极小}$</li></ul>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;Lagrange-Multipliers-amp-mathcal-KKT-几何关联推导&quot;&gt;&lt;a href=&quot;#Lagrange-Multipliers-amp-mathcal-KKT-几何关联推导&quot; class=&quot;headerlink&quot; title=&quot;Lagrange Multipliers &amp;amp; $\mathcal{KKT}$ 几何关联推导&quot;&gt;&lt;/a&gt;Lagrange Multipliers &amp;amp; $\mathcal{KKT}$ 几何关联推导&lt;/h3&gt;&lt;p&gt;本文章是根据&lt;a href=&quot;https://www.csc.kth.se/utbildning/kth/kurser/DD3364/Lectures/KKT.pdf&quot;&gt;瑞典皇家理工学院课件&lt;/a&gt;总结归纳而成。碍于本人学识有限，部分叙述难免存在纰漏，请读者注意甄别。&lt;/p&gt;
&lt;p&gt;参考资料：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://www.csc.kth.se/utbildning/kth/kurser/DD3364/Lectures/KKT.pdf&quot;&gt;KTH Royal Institute of Technology : Lagrange Multipliers and the Karush-Kuhn-Tucker conditions&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="课程笔记" scheme="https://dave0126.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="课程笔记" scheme="https://dave0126.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="最优化" scheme="https://dave0126.github.io/tags/%E6%9C%80%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>运筹学</title>
    <link href="https://dave0126.github.io/2022/04/19/%E8%BF%90%E7%AD%B9%E5%AD%A6/"/>
    <id>https://dave0126.github.io/2022/04/19/%E8%BF%90%E7%AD%B9%E5%AD%A6/</id>
    <published>2022-04-19T20:02:52.000Z</published>
    <updated>2022-04-27T19:41:31.396Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础运筹学"><a href="#基础运筹学" class="headerlink" title="基础运筹学"></a>基础运筹学</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><a href>本文章</a>是根据法国国立高等电力技术、电子学、计算机、水力学与电信学校 (E.N.S.E.E.I.H.T.) 第七学期课程<em>“Recherche Operation”</em> 总结而来的【部分课程笔记】。碍于本人学识有限，部分叙述难免存在纰漏，请读者注意甄别。</p><p>总而言之，运筹学就是从真实系统中<strong>建立模型</strong>，用数学的形式表示出来。</p><span id="more"></span><h3 id="附录一：KKT-和-拉格朗日乘子"><a href="#附录一：KKT-和-拉格朗日乘子" class="headerlink" title="附录一：KKT 和 拉格朗日乘子"></a>附录一：KKT 和 拉格朗日乘子</h3><h5 id="关系：-KKT-，拉格朗日乘子-和-线性规划"><a href="#关系：-KKT-，拉格朗日乘子-和-线性规划" class="headerlink" title="关系：$KKT$ ，拉格朗日乘子 和 线性规划"></a>关系：$KKT$ ，拉格朗日乘子 和 线性规划</h5><p>本科阶段，我们在高等数学中认识了拉格朗日乘子。其研究范围可以认为是</p><script type="math/tex; mode=display">拉格朗日乘子 \sim 在约束条件为强约束（即约束条件都为等式）的情况下，非线性规划的问题中求解最优值。</script><p>而 $KKT$ 研究范围可以认为是</p><script type="math/tex; mode=display">KKT \sim 在约束条件为弱约束（即约束条件有不等式）的情况下，非线性规划的问题中求解最优值。</script><p>线性规划问题的研究范围可以认为是</p><script type="math/tex; mode=display">LP(线性规划) \sim 在约束条件下，线性规划的问题中求解最优值。</script><p>所以我们可以认为 $KKT &gt; 拉格朗日乘子$，$KKT &gt; LP &gt; 整数线性规划$</p><h4 id="拉格朗日乘子"><a href="#拉格朗日乘子" class="headerlink" title="拉格朗日乘子"></a>拉格朗日乘子</h4><p>引例：我们有如下问题</p><script type="math/tex; mode=display">W = f(x,y,z) = 3x^2 + 2y^2 - 4z^2\\s.t.\left\{\begin{aligned}3x + 4y -z = 0\\6x^2 + y - z^2 = 0\end{aligned}\right.</script><p>由于对于拉格朗日乘子法的证明过程并不感兴趣，所以在此不加证明地直接给出其计算方法：</p><ol><li><p>已知我们想要求解目标函数 $W = f(x,y,z) = 3x^2 + 2y^2 - 4z^2$ 的最大值$maxW$ 或最小值$minW$​，我们有两个约束条件$g_1,g_2$： $s.t.\left\{\begin{aligned} g_1:3x + 4y -z = 0\\ g_2:6x^2 + y - z^2 = 0 \end{aligned}\right.$</p></li><li><p>我们引入拉格朗日乘子 $\lambda _i$ 辅助求解该问题。拉格朗日乘子 $\lambda _i$ 引入的数量由<strong>约束条件的数量决定</strong>。所以本引例中需要引入两个拉格朗日乘子 $\lambda_1, \lambda_2$ 。</p></li><li><p>构造一个包含拉格朗日乘子 $\lambda_1,\lambda_2$ 的新函数 $F(x,y,z,\lambda_i) = f(x,y,z) + \lambda_1g_1 + \lambda_2g_2 + …+ \lambda_ng_n$ 。所以原函数可转化为以下的拉格朗日函数：</p><script type="math/tex; mode=display">\begin{aligned}F(x,y,z,\lambda_1,\lambda_2) & =  f(x,y,z) + \lambda_1g_1 + \lambda_2g_2\\&= 3x^2 + 2y^2 - 4z^2 + \lambda_1 (3x + 4y -z) + \lambda_2(6x^2 + y - z^2)\end{aligned}</script></li><li><p>则我们就可以通过导数的方法求解此问题 $F(x,y,z,\lambda_1,\lambda_2)$ 。对 $F$ 求偏导，有几个自变量，就求几次偏导，令其都等于 0。方程 ①②③④⑤ 一定能得到不止一组的解 $(x_i,\; y_i,\; z_i,\; {\lambda_1}_i,\; {\lambda_2}_i)$ ，将解得的解 $(x_i,\; y_i,\; z_i,\; {\lambda_1}_i,\; {\lambda_2}_i)$ 代入原来的目标函数 $W=f(x,y,z)$ 中，算出的 $W_{max}$ 和 $W_{min}$。</p><script type="math/tex; mode=display">\left\{\begin{aligned}\frac {\partial F}{\partial x} =0 \qquad ①\\\frac {\partial F}{\partial y} =0 \qquad ②\\\frac {\partial F}{\partial z} =0 \qquad ③\\\frac {\partial F}{\partial {\lambda_1}} =0 \qquad ④\\\frac {\partial F}{\partial {\lambda_2}} =0 \qquad ⑤\\\end{aligned}\right.\quad \stackrel{解}{\Longrightarrow} \quad\begin{pmatrix}x_i\\y_i\\z_i\\{\lambda_1}_i\\{\lambda_2}_i\\\end{pmatrix}\quad \stackrel{代入原来的目标函数}{\Longrightarrow} \quadf(x_i,y_i,z_i)\quad \stackrel{找Min和Max}{\Longrightarrow} \quad(W_{max}, W_{min})</script></li></ol><h4 id="KKT"><a href="#KKT" class="headerlink" title="KKT"></a>KKT</h4><p>KKT 本质上是拉格朗日乘数法的推广，即推广到弱约束（即约束条件有不等式）条件。</p><p>【拉格朗日乘数法】：</p><script type="math/tex; mode=display">Z_{max}或Z_{min} = f(x,y,z,...)\\g_1 =0, \; g_2 =0,\; g_3 = 0\\①观察约束条件，有几个约束，方程就引入几个拉格朗日乘子 \lambda ,对于\lambda 无限制\\②构建F(x,y,z,\lambda_1, \lambda_2, \lambda_3) = f(x,y,z) + \lambda_1g_1 + \lambda_2g_2 + \lambda_3g_3\\③\left\{\begin{aligned}\frac {\partial F}{\partial x} =0 \quad \stackrel{本质是}{\Longrightarrow} \quad F对目标函数的自变量求偏导\\ \frac {\partial F}{\partial y} =0 \quad \stackrel{本质是}{\Longrightarrow} \quad F对目标函数的自变量求偏导\\ \frac {\partial F}{\partial z} =0 \quad \stackrel{本质是}{\Longrightarrow} \quad F对目标函数的自变量求偏导\\ \frac {\partial F}{\partial {\lambda_1}} =0 \quad {\Longrightarrow} \quad g_1= 0 \\\frac {\partial F}{\partial {\lambda_2}} =0 \quad {\Longrightarrow} \quad g_2= 0 \\\frac {\partial F}{\partial {\lambda_3}} =0 \quad {\Longrightarrow} \quad g_3= 0 \\\end{aligned}\right.\quad {\Longrightarrow} \quad 约束 g_i=0\\ \\④ 解方程组 \\⑤ 将所有解代入目标函数 f(x,y,z)，判断最大值和最小值\\⑥ 结束\\</script><p>【KKT】：</p><script type="math/tex; mode=display">Z_{max}或Z_{min} = f(x,y,z,...)\\g_1 \le 0, \; g_2 \ge 0, \; g_n = 0\\⓪化为标准型^*\\①观察约束条件，有几个约束，方程就引入几个拉格朗日乘子 \lambda^* ,\lambda^* \ge 0\\\begin{aligned}②构建\mathcal{L}(x,y,z,\lambda_1^*, \lambda_2^*, \lambda_3^*, \lambda_4^*) & = f(x,y,z) + \lambda_1^*g'_1 + \lambda_2^*g'_2 + \lambda_3^*g'_3 + \lambda_4^*g'_4\\& = f(x,y,z) + \lambda_1^*g_1 - \lambda_2^*g_2 + \lambda_3^*g_3 - \lambda_4^*g_3\end{aligned}\\③\left\{\begin{aligned}\frac {\partial \mathcal{L}}{\partial x} =0 \quad \stackrel{本质是}{\Longrightarrow} \quad F对目标函数的自变量求偏导\\ \frac {\partial \mathcal{L}}{\partial y} =0 \quad \stackrel{本质是}{\Longrightarrow} \quad F对目标函数的自变量求偏导\\ \frac {\partial \mathcal{L}}{\partial z} =0 \quad \stackrel{本质是}{\Longrightarrow} \quad F对目标函数的自变量求偏导\\ \lambda_1^*g_1 = 0 \\\lambda_2^*(-g_2) = 0 \\\lambda_3^*(g_3) = 0 \\\lambda_4^*(-g_3) = 0\end{aligned}\right.\quad {\Longrightarrow} \quad 广义乘子 \lambda_i^*\times 约束g_i = 0 \\ \\④ 解方程组 \\⑤ 将所有解代入目标函数 f(x,y,z)，判断最大值和最小值\\⑥ 结束\\</script><ol><li><p>化为【标准型】：</p><p>对于上述例子，我们可以看到【约束条件】很“混乱”，即符号不同，有$\le, \ge ,=$ ，我们需要将它们化为统一标准形式（“$代数式     \ge 0$”）。</p><ul><li>对于 $=$ ：$g_3 = 0 \Leftrightarrow g_3\le 0 且 g_3 \ge 0$ </li><li>对于 $\le$ ：$g_1 \le 0 \Leftrightarrow -g_1 \ge 0$ </li></ul><p>所以我们可以按上述规则将约束条件改写为</p><script type="math/tex; mode=display">s.t.\left\{\begin{aligned}- g_1 \ge 0\\g_2 \ge 0\\g_3 \ge 0\\-g_3 \ge 0\\\end{aligned}\right.\quad \stackrel{看作整体}{\Longrightarrow} \quads.t.\left\{\begin{aligned}g_1' = - g_1 \ge 0\\g_2' = g_2 \ge 0\\g_3' = g_3 \ge 0\\g_4' = -g_3 \ge 0\\\end{aligned}\right.</script><p>不过更建议化成 “$代数式 \le 0$” 的形式，因为可以更好的和拉格朗日乘数法结合观察：</p><script type="math/tex; mode=display">s.t.\left\{\begin{aligned}- g_1 \ge 0\\g_2 \ge 0\\g_3 \ge 0\\-g_3 \ge 0\\\end{aligned}\right.\quad \stackrel{看作整体}{\Longrightarrow} \quads.t.\left\{\begin{aligned}g_1' = g_1 \le 0\\g_2' = -g_2 \le 0\\g_3' = g_3 \le 0\\g_4' = -g_3 \le 0\\\end{aligned}\right.</script></li><li><p>观察约束条件，有几个约束，方程就引入几个广义拉格朗日乘子 $\lambda^<em>$：$\lambda_1^</em>, \lambda_2^<em>, \lambda_3^</em>, \lambda_4^*$ 。注意，在拉格朗日乘数法中，引入拉格朗日乘子 $\lambda$ 后并无任何限制，但是在 $KKT$ 中，我们要求所有的广义拉格朗日乘子</p><script type="math/tex; mode=display">\lambda^* \ge 0</script></li></ol><ol><li><p>构造一个包含广义拉格朗日乘子 $\lambda_1^<em>, \lambda_2^</em>, \lambda_3^<em>, \lambda_4^</em>$ 的新函数 $\mathcal{L} (x,y,z,\lambda_i^<em>) = f(x,y,z) + \lambda_1^</em>g_1 + \lambda_2^<em>g_2 + …+ \lambda_n^</em>g_n$ 。所以原函数可转化为以下的广义拉格朗日函数：</p><script type="math/tex; mode=display">\begin{aligned}\mathcal{L} (x,y,z,\lambda_1^*, \lambda_2^*, \lambda_3^*, \lambda_4^*) & = f(x,y,z) + \lambda_1^*g'_1 + \lambda_2^*g'_2 + \lambda_3^*g'_3 + \lambda_4^*g'_4\\& = f(x,y,z) + \lambda_1^*g_1 - \lambda_2^*g_2 + \lambda_3^*g_3 - \lambda_4^*g_3\end{aligned}\\</script></li><li><p>则我们就可以通过导数的方法求解此问题 $\mathcal{L} (x,y,z,\lambda_1^<em>, \lambda_2^</em>, \lambda_3^<em>, \lambda_4^</em>)$ 。写出如下形式的方程。方程定能得到不止一组的解 $(x_i,\; y_i,\; z_i,\; {\lambda_1^<em>}_i, {\lambda_2^</em>}_i, {\lambda_3^<em>}_i, {\lambda_4^</em>}_i$ ，将解得的解 $(x_i,\; y_i,\; z_i,\; {\lambda_1^<em>}_i, {\lambda_2^</em>}_i, {\lambda_3^<em>}_i, {\lambda_4^</em>}_i$ 代入原来的目标函数 $Z=f(x,y,z)$ 中，算出的 $Z_{max}$ 和 $Z_{min}$。</p><script type="math/tex; mode=display">\left\{\begin{aligned}\frac {\partial \mathcal{L}}{\partial x} =0 \\\frac {\partial \mathcal{L}}{\partial y} =0 \\\frac {\partial \mathcal{L}}{\partial z} =0 \\\lambda_1^*g_1 = 0 \\\lambda_2^*(-g_2) = 0 \\\lambda_3^*(g_3) = 0 \\\lambda_4^*(-g_3) = 0\end{aligned}\right.\quad \stackrel{解}{\Longrightarrow} \quad\begin{pmatrix}x_i\\y_i\\z_i\\{\lambda_1^*}_i\\{\lambda_2^*}_i\\{\lambda_3^*}_i\\{\lambda_4^*}_i\\\end{pmatrix}\quad \stackrel{代入原来的目标函数}{\Longrightarrow} \quadf(x_i,y_i,z_i)\quad \stackrel{找Min和Max}{\Longrightarrow} \quad(Z_{max}, Z_{min})</script></li></ol><h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><p>$f(x) = (x-3)^2，0 \le x \le 5，求_{min}f(x)$</p><ol><li><p>规范化（化标准型“$代数式 \le 0$”）：</p><script type="math/tex; mode=display">0 \le x \le 5 \quad \Rightarrow \quad\begin{aligned}x \ge 0\\x \le 5\end{aligned}\quad \Rightarrow \quad\begin{aligned}-x \le 0\\x-5 \le 0\end{aligned}\quad \Rightarrow \quad\begin{aligned}g_1 = -x \le 0\\g_2 = x-5 \le 0\end{aligned}</script></li><li><p>观察约束，有 2 个约束，所以引入 2 个广义拉格朗日乘子 $\lambda_1^<em>, \lambda_2^</em>$，</p><script type="math/tex; mode=display">\lambda_1^* \ge 0 \\\lambda_2^* \ge 0 \\</script></li><li><p>构建广义拉格朗日函数 $\mathcal{L} (x,\lambda_1^<em>, \lambda_2^</em>)$ :</p><script type="math/tex; mode=display">\begin{aligned}\mathcal{L} (x,\lambda_1^*, \lambda_2^*) &= f(x) +  \lambda_1^*g_1 + \lambda_2^*g_2 \\&= (x-3)^2 +  \lambda_1^*(-x) + \lambda_2^*(x-5)\end{aligned}</script></li><li><p>联立方程组：</p><script type="math/tex; mode=display">\left\{\begin{aligned}\frac {\partial F}{\partial x} = 2(x-3) - \lambda_1^* + \lambda_2^* = 0 \qquad ①\\\lambda_1^*g_1 = \lambda_1^* (-x) = 0 \qquad ② \\\lambda_2^*g_2 = \lambda_2^* (x-5) = 0 \qquad ③ \\\end{aligned}\right.</script></li><li><p>解方程组。(【注意⚠️】：一般需要详细讨论解的情况。)</p><p>【1】我们先从 ② 式开始 ：$② \Rightarrow \lambda_1^<em> x = 0 \quad \stackrel{两种情况}{\Longrightarrow} \quad \lambda_1^</em>=0 \; 或\; x=0$ </p><ol><li><p>当 $\lambda_1^<em> \ne 0$ 时，我们可以得到 $x = 0$ 。我们再结合 $③\;\lambda_2^</em> (x-5) = 0$，我们得到 $\lambda_2^<em> = 0$ 。我们再结合 $ ① \; 2(x-3) - \lambda_1^</em> + \lambda_2^<em> = 0$ ，我们可以解得 $\lambda_1^</em> = -6 &lt; 0$ 。因为我们有约束条件 $\lambda_1^* \ge 0$，所以我们要舍弃这组解。</p></li><li><p>当 $\lambda_1^* = 0$ 时，在 ② 式中 $x$ 可以是任意值，所以我们要结合 ① ③ 式：</p><script type="math/tex; mode=display">\left\{\begin{aligned}2(x-3) + \lambda_2^* = 0 \qquad ①\\\lambda_2^* (x-5) = 0 \qquad ③ \\\end{aligned}\right.\quad \stackrel{解得}{\Longrightarrow} \quad\left\{\begin{aligned}x = 3 \\\lambda_2^* = 0\\\end{aligned}\right.\quad 或 \quad\left\{\begin{aligned}x = 5 \\\lambda_2^* = -4 < 0\\\end{aligned}\right.</script><p>我们可以看出，其中存在一组解</p><script type="math/tex; mode=display">\left\{\begin{aligned}x = 3 \\\lambda_1^* = 0\\\lambda_2^* = 0\\\end{aligned}\right.</script></li></ol><p>【2】我们再回到 ③ 式重新讨论：$ ③ \;  \lambda_2^<em> (x-5) = 0 \quad \stackrel{两种情况}{\Longrightarrow} \quad \lambda_2^</em>=0 \; 或\; x=5$</p><ol><li><p>$x=5, \lambda_2^* \ne 0$ 的情况已经在 ② 式的第 2 种情况中讨论过了，所以跳过。</p></li><li><p>当 $\lambda_2^* = 0$ 时，在 ③ 式中 $x$ 可以是任意值，所以我们要结合 ① ② 式：</p><script type="math/tex; mode=display">\left\{\begin{aligned}2(x-3) - \lambda_1^* = 0 \qquad ①\\\lambda_1^* (-x) = 0 \qquad ② \\\end{aligned}\right.\quad \stackrel{解得}{\Longrightarrow} \quad\left\{\begin{aligned}x = 0 \\\lambda_1^* = -6 < 0\\\end{aligned}\right.\quad 或 \quad\left\{\begin{aligned}x = 3 \\\lambda_1^* = 0\\\end{aligned}\right.</script><p>我们可以看出，其中存在一组解</p><script type="math/tex; mode=display">\left\{\begin{aligned}x = 3 \\\lambda_1^* = 0\\\lambda_2^* = 0\\\end{aligned}\right.</script></li></ol></li><li><p>所以 $_{min}f(x) = f(3) = (3-3)^2 = 0$ 。</p></li></ol><p>【一点想法】</p><p>当我们使用 KKT 得到一个解时，若该解中某个广义拉格朗日乘子 $\lambda_i^* &gt;0$，则说明 $\lambda_i$ 所对应的约束 $g_i = 0$，即这个解所对应的点恰好落在了曲线 $g_i = 0$ 上。</p><h3 id="附录二：线性代数回顾"><a href="#附录二：线性代数回顾" class="headerlink" title="附录二：线性代数回顾"></a>附录二：线性代数回顾</h3><p>简言之，线性代数的目的就是求解线性方程组。经典的理论是与几何联系起来。</p><h5 id="方法论"><a href="#方法论" class="headerlink" title="方法论"></a>方法论</h5><pre class="mermaid">graph LR提取系统信息 --经过运算--> 判断解的情况提取系统信息 --经过运算--> 解方程</pre><script type="math/tex; mode=display">\left\{\begin{aligned}a_{1,1}x_1 + a_{1,2}x_2 + ... a_{1,n}x_n = \; b_1 \\a_{2,1}x_1 + a_{2,2}x_2 + ... a_{2,n}x_n = \; b_2 \\...    \quad ... \quad ... \quad ... \quad \\a_{i,1}x_1 + a_{i,2}x_2 + ... a_{i,n}x_n = \; b_i \\...    \quad ... \quad ... \quad ... \quad \\a_{n,1}x_1 + a_{n,2}x_2 + ... a_{n,n}x_n = \; b_n \\\end{aligned}\right.\quad \stackrel{提取系统信息}{\Longrightarrow} \quad\begin{pmatrix}a_{1,1} & a_{1,2} & \cdots & a_{1,n}\\a_{2,1} & a_{2,2} & \cdots & a_{2,n}\\\vdots & \vdots & \vdots & \vdots\\a_{n,1} & a_{n,2} & \cdots & a_{n,n}\\\end{pmatrix} \begin{pmatrix}x_1\\x_2\\\vdots\\x_n\\\end{pmatrix}=\begin{pmatrix}b_1\\b_2\\\vdots\\b_n\\\end{pmatrix}</script><p>【秩】Rank：矩阵的本质属性。如果把矩阵看成一个个行向量或者列向量，如果其中<strong>有一个向量</strong>能被另一个向量<strong>线性表示</strong>的话，那么该矩阵表示的方程组有<strong>无穷多解</strong>；如果<strong>没有任何一个</strong>向量能被另一个向量线性表示的话，那么该矩阵表示的方程组<strong>有唯一解</strong>。【秩】的本质就是矩阵中<strong>独立向量的个数</strong>。</p><p>【行列式】：行列式的本质是代表一种算法的运算符，和 $+,-,\times,\div$ 类似。用 $A_{2 \times 2}$ 举例：</p><script type="math/tex; mode=display">A_{2 \times 2} =\begin{vmatrix}x & y \\z & v\end{vmatrix}=xv-yz</script><p>【行列式的几何意义】</p><ul><li>二阶：是这 2 个向量围成的平行四边形的面积</li><li>三阶：是这 3 个向量围成的平行六面体的体积</li><li>n阶：n维超立方体的体积</li></ul><p>所以，<u>行列式一旦 $=0$</u> ，说明行列式对应的矩阵里有<u>线性相关的向量</u>。当<u>行列式 $\ne 0$</u> 时，说明行列式对应的<u>矩阵是<strong>满秩</strong></u>的。</p><h3 id="第一部分：线性规划"><a href="#第一部分：线性规划" class="headerlink" title="第一部分：线性规划"></a>第一部分：线性规划</h3><h4 id="1-1-线性规划问题及数学模型"><a href="#1-1-线性规划问题及数学模型" class="headerlink" title="1.1 线性规划问题及数学模型"></a>1.1 线性规划问题及数学模型</h4><h5 id="1-1-1-问题的提出"><a href="#1-1-1-问题的提出" class="headerlink" title="1.1.1 问题的提出"></a>1.1.1 问题的提出</h5><p>我们可以考虑以下一个简单的例子：</p><p>例1，某工厂在计划期内要安排生产甲、乙两种产品，已知生产单位产品所需的设备合时及 A、B 两种原材料的消耗如表所示。该厂每生产一件产品甲可获利2元，一件产品乙可获利3元，问该工厂如何安排生产计划使利润最大？</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">产品甲</th><th style="text-align:center">产品乙</th><th style="text-align:center">资源限量</th></tr></thead><tbody><tr><td style="text-align:center">设备</td><td style="text-align:center">1 台时/件</td><td style="text-align:center">2 台时/件</td><td style="text-align:center">8 台时</td></tr><tr><td style="text-align:center">原材料 A</td><td style="text-align:center">4 kg/件</td><td style="text-align:center">0</td><td style="text-align:center">16 kg</td></tr><tr><td style="text-align:center">原材料 B</td><td style="text-align:center">0</td><td style="text-align:center">4 kg/间</td><td style="text-align:center">12 kg</td></tr><tr><td style="text-align:center">利润</td><td style="text-align:center">2 元</td><td style="text-align:center">3 元</td></tr></tbody></table></div><p>我们可以根据以上描述建立一个数学模型：</p><script type="math/tex; mode=display">Profit_{max} = 2x+3y\\s.t.\left\{\begin{aligned}x_1 + 2x_2 \le 8 \\4x_1 \le 16 \\4x_2 \le 12 \\x_1, x_2 \ge 0\end{aligned}\right.</script><p>其中，</p><ul><li>$x_1$ 和 $x_2$ 为【决策变量】；</li><li>$Profit_{max} = 2x+3y$ 是【决策函数】，是决策者希望达到的计划目标；</li><li>$s.t.$ 为“subject to”，为【约束条件】，为决策变量取值时受到的限制。</li></ul><p>这类优化问题的共同特征：</p><ol><li>每一个问题都用一组决策变量表示某一方案，这组决策变量的值就代表一个具体方案。<strong>一般取值非负且连续</strong>。</li><li>要有建模的相关数据，如资源拥有量、消耗资源定额、创造的新价值量等并构造不矛盾的约束条件，<strong>由线性等式或不等式来表示</strong>。</li><li>都有一个要达到的目标，可用决策变量及其有关的价值系数构成的线性函数来表示，一般要求<strong>最大或最小</strong></li></ol><p>线性规划问题模型的【一般表达式形式】为：</p><script type="math/tex; mode=display">max(min)Z = c_1x_1 + c_2x_2 + c_3x_3 + ...+ c_nx_n\\s.t.\left\{\begin{aligned}a_{1,1}x_1 + a_{1,2}x_2 + ... a_{1,n}x_n \le (\ge ,=) \; b_1 \\a_{2,1}x_1 + a_{2,2}x_2 + ... a_{2,n}x_n \le (\ge ,=) \; b_2 \\...    \quad ... \quad ... \quad ... \quad \\a_{i,1}x_1 + a_{i,2}x_2 + ... a_{i,n}x_n \le (\ge ,=) \; b_i \\...    \quad ... \quad ... \quad ... \quad \\a_{n,1}x_1 + a_{n,2}x_2 + ... a_{n,n}x_n \le (\ge ,=) \; b_n \\x_1, x_2, ... x_n \ge 0\end{aligned}\right.</script><p>其中，</p><ul><li>$c_n$ 为价值系数</li><li>$a_{ij}$ 为技术系数</li><li>$b_i$ 为资源限制</li><li>$x_1, x_2, … x_n \ge 0$ 为决策变量约束</li></ul><h5 id="1-1-2-图解法"><a href="#1-1-2-图解法" class="headerlink" title="1.1.2 图解法"></a>1.1.2 图解法</h5><p>图解法求解步骤（只适用于两个决策变量的问题 - 二维）：</p><ol><li>由全部约束条件作图求出【可行域】；</li><li>作目标函数【等值线】，确定使目标函数最优的移动方向；</li><li>平移目标函数的等值线，找出【最优点】，算出最优值。</li></ol><p><img src="/2022/04/19/%E8%BF%90%E7%AD%B9%E5%AD%A6/2022-04-20 09.38.37.png" alt="2022-04-20 09.38.37" style="zoom:40%;"></p><h5 id="1-1-3-化标准型"><a href="#1-1-3-化标准型" class="headerlink" title="1.1.3 化标准型"></a>1.1.3 化标准型</h5><p>参考以上线性规划问题模型的一般表达式形式，我们发现线性规划的共同特证：</p><ol><li><p>决策变量：每个问题都用一组决策变量表示某个方案</p><p>决策变量：决策变量的取值一般都是非负且连续的</p></li><li><p>约束条件：与决策变量不矛盾的条件，用线性等式或不等式表示</p></li><li><p>目标函数：决策变量与价值系数组成，一般要求实现最大或最小</p></li></ol><p>所以我们建模的一般思路为：<strong>确定决策变量，写出目标函数，找出约束条件</strong>。</p><p>如果我们想用<strong>单纯形法</strong>求解线性规划问题，第一步是将一般表达式为以下的<strong>标准型</strong>：</p><script type="math/tex; mode=display">maxZ = c_1x_1 + c_2x_2 + c_3x_3 + ...+ c_nx_n\\s.t.\left\{\begin{aligned}a_{1,1}x_1 + a_{1,2}x_2 + ... a_{1,n}x_n = \; b_1 \\a_{2,1}x_1 + a_{2,2}x_2 + ... a_{2,n}x_n = \; b_2 \\...    \quad ... \quad ... \quad ... \quad \\a_{i,1}x_1 + a_{i,2}x_2 + ... a_{i,n}x_n = \; b_i \\...    \quad ... \quad ... \quad ... \quad \\a_{m,1}x_1 + a_{m,2}x_2 + ... a_{m,n}x_n = \; b_m \\x_1, x_2, ... x_n \ge 0\\b_1, b_2, ... b_n \ge 0\end{aligned}\right.</script><p>简言之：</p><ol><li>目标函数 $Z$ 最大；</li><li>约束条件 $a_{i,1}x_1 + a_{i,2}x_2 + … a_{i,n}x_n = \; b_i$ 为等式；</li><li>决策条件 $x_1, x_2, … x_n$ 非负</li><li>资源限量 $b_1, b_2, … b_n$ 非负</li></ol><p>上方的单纯形法的标准型可以简写成以下形式</p><script type="math/tex; mode=display">maxZ = \sum_{j=1}^n c_jx_j\\s.t.\left\{\begin{aligned}\sum_{j=1}^n a_{i,j}x_j = b_j \quad i=1,2,3,...,m\\x_j \ge 0 \quad j=1,2,3,...,n\end{aligned}\right.</script><p>或写成向量的形式</p><script type="math/tex; mode=display">maxZ = CX\\s.t.\left\{\begin{aligned}\sum_{j=1}^n P_jx_j = b \\x_j \ge 0 \quad j=1,2,3,...,n \\\end{aligned}\right.\\价值向量C = (c_1, c_2, ..., c_n)；\quad 决策变量的向量X = (x_1, x_2, ..., x_n)^T\\资源向量b = (b_1, b_2, ..., b_m)^T；\quad 约束条件的系数列向量P_j = (a_{1,j}, a_{2,j}, ..., a_{m,j})</script><p>或写成矩阵的形式</p><script type="math/tex; mode=display">maxZ = CX\\s.t.\left\{\begin{aligned}AX = b \\X \ge O\end{aligned}\right.\\其中，A =\begin{pmatrix}a_{1,1} & a_{1,2} & \cdots & a_{1,n}\\a_{2,1} & a_{2,2} & \cdots & a_{2,n}\\\vdots & \vdots & \vdots & \vdots\\a_{m,1} & a_{m,2} & \cdots & a_{m,n}\\\end{pmatrix}, \quadO =\begin{pmatrix}0\\0\\\vdots\\0\\\end{pmatrix}, \quad X =\begin{pmatrix}x_1\\x_2\\\vdots\\x_n\\\end{pmatrix}</script><h6 id="一般形式化成标准型"><a href="#一般形式化成标准型" class="headerlink" title="一般形式化成标准型"></a>一般形式化成标准型</h6><p>例2：我们需要将以下一般形式化成标准型</p><script type="math/tex; mode=display">minZ = x_1 + 2x_2 + 3x_3 \quad ① \\s.t.\left\{\begin{aligned}-2x_1 + x_2 + x_3 \le 9 \quad ②\\-3x_1 + x_2 + 2x_3 \ge 4 \quad ③\\4x_1 - 2x_2 - 3x_3 = -6 \quad ④ \\x_1 \le 0,\; x_2 \ge 0,\; x_3无约束\end{aligned}\right.</script><ol><li><p>【目标函数最大】</p><p>如果目标函数的求解是最小值问题，我们需要将其转换成<strong>最大值问题</strong>，方法为<strong>取负数</strong>：</p><script type="math/tex; mode=display">min \; Z = CX \quad \stackrel{Z'=-Z}{\Longrightarrow} \quad max\; Z' = -CX</script><p>所以在例题中：</p><script type="math/tex; mode=display">minZ = x_1 + 2x_2 + 3x_3 \quad \stackrel{Z'=-Z}{\Longrightarrow} \quad maxZ' = -x_1 - 2x_2 - 3x_3</script></li><li><p>【资源限量非负】</p><script type="math/tex; mode=display">b_i < 0 \quad \stackrel{两端同乘(-1)}{\Longrightarrow} \quad 右端项非负\\b_i = 0\;的情况日后再议</script></li></ol><p>   我们可以发现，例中的 ④ 式的资源限量为 -6，所以</p><script type="math/tex; mode=display">   ④ \quad 4x_1 - 2x_2 - 3x_3 = -6 \quad \stackrel{两端同乘(-1)}{\Longrightarrow} \quad -4x_1 + 2x_2 + 3x_3 = 6</script><ol><li><p>【约束条件化为等式】</p><script type="math/tex; mode=display">将约束条件中的 \le \quad \stackrel{【加上】松弛变量}{\Longrightarrow} \quad 变成 =    \\将约束条件中的 \ge \quad \stackrel{【减掉】剩余变量}{\Longrightarrow} \quad 变成 =</script><p>例如例中的 ② 式，我们需要将其化为等式，则</p><script type="math/tex; mode=display">② \quad -2x_1 + x_2 + x_3 \le 9 \quad \stackrel{【加上】松弛变量}{\Longrightarrow} \quad -2x_1 + x_2 + x_3 +x_4 = 9</script><p>注意⚠️：此时的 $x_4$ 实际上是无意义的，只是我们加入的使等式成立的松弛变量。</p><p>同理，对于 ③ 式，我们有</p><script type="math/tex; mode=display">③ \quad -3x_1 + x_2 + 2x_3 \ge 4 \quad \stackrel{【减掉】剩余变量}{\Longrightarrow} \quad -3x_1 + x_2 + 2x_3 - x_5 = 4</script><p><strong>松弛变量</strong>与<strong>剩余变量</strong>在实际问题中分别表示未被充分利用的资源和超出的资源，均未转化为价值和利润，所以引进模型后它们<strong>在目标函数中的系数均为 0 </strong>。</p></li><li><p>【决策变量非负】</p><script type="math/tex; mode=display">x \le 0 \quad \stackrel{x' = -x}{\Longrightarrow} \quad x' \ge 0</script><p>例如例题中的 $x_1 \le 0$，我们需要将其化为大于 0 的形式，则</p><script type="math/tex; mode=display">x_1 \le 0 \quad \stackrel{x_1' = -x_1}{\Longrightarrow} \quad {x_1}' \ge 0</script><ul><li><p>【处理无约束变量】</p><script type="math/tex; mode=display">x无约束 \quad \stackrel{x = x' -x''}{\Longrightarrow} \quad x'\ge 0,\; x'' \ge 0</script><p>意为，一个无约束的数 $x$ 可以等于两个非负数 $x’,x’’$ 的差，其结果依然无约束。但是 $x’,x’’$ 是存在约束的。</p><p>例如例题中的 $x_3 无约束$，我们将其变化为</p><script type="math/tex; mode=display">x_3无约束 \quad \stackrel{x_3 = x_3' -x_3''}{\Longrightarrow} \quad x_3'\ge 0,\; x_3'' \ge 0</script></li></ul></li><li><p>最后请注意替换后的变量代入原式时的<strong>替换问题</strong></p></li></ol><p>所以，通过以上步骤，例题中的原式可化为如下形式：</p><script type="math/tex; mode=display">maxZ = x_1' - 2x_2 - 3x_3' + 3x_3'' + 0x_4 + 0x_5 \quad ① \\s.t.\left\{\begin{aligned}2x_1' + x_2 + x_3' - x_3'' + x_4 = 9 \quad ②\\3x_1' + x_2 + 2x_3' - 2x_3'' - x_5 = 4 \quad ③\\-4x_1' + 2x_2 + 3x_3' - 3x_3'' = 6 \quad ④ \\x_1',\; x_2,\; x_3',\; x_3'',\; x_4,\; x_5 \ge 0\end{aligned}\right.</script><h5 id="1-1-4-解的概念"><a href="#1-1-4-解的概念" class="headerlink" title="1.1.4 解的概念"></a>1.1.4 解的概念</h5><h6 id="可行解-和-最优解"><a href="#可行解-和-最优解" class="headerlink" title="可行解 和 最优解"></a>可行解 和 最优解</h6><p>在以下线性规划问题的一般形式中，</p><script type="math/tex; mode=display">maxZ = \sum_{j=1}^n c_jx_j \qquad ①\\s.t.\left\{\begin{aligned}\sum_{j=1}^n a_{i,j}x_j = b_j \quad i=1,2,3,...,m \qquad ② \\x_j \ge 0 \quad j=1,2,3,...,n \qquad ③\end{aligned}\right.</script><ul><li>【可行解】：满足约束条件 ② 和 ③ 的解。<strong>全部可行解的集合称为可行域</strong></li><li>【最优解】：是目标函数 ① 最大的<strong>可行解</strong></li></ul><p><img src="/2022/04/19/%E8%BF%90%E7%AD%B9%E5%AD%A6/2022-04-20 11.46.29.png" alt="2022-04-20 11.46.29" style="zoom:50%;"></p><h6 id="基解-和-基可行解"><a href="#基解-和-基可行解" class="headerlink" title="基解 和 基可行解"></a>基解 和 基可行解</h6><script type="math/tex; mode=display">maxZ = CX\\s.t.\left\{\begin{aligned}AX = b \\X \ge O\end{aligned}\right.\\其中，C =\begin{pmatrix}c_1\\c_2\\\vdots\\c_n\\\end{pmatrix}, \quadX =\begin{pmatrix}x_1\\x_2\\\vdots\\x_n\\\end{pmatrix}, \quadA_{m<n} =\begin{pmatrix}a_{1,1} & a_{1,2} & \cdots & a_{1,n}\\a_{2,1} & a_{2,2} & \cdots & a_{2,n}\\\vdots & \vdots & \vdots & \vdots\\a_{m,1} & a_{m,2} & \cdots & a_{m,n}\\\end{pmatrix}, \quadb =\begin{pmatrix}b_1\\b_2\\\vdots\\b_n\\\end{pmatrix}, \quadO =\begin{pmatrix}0\\0\\\vdots\\0\\\end{pmatrix}</script><ul><li>【基】：设 $A$ 是约束方程组 ② 的 $m\times n$ 阶系数矩阵（<strong>设 $n&gt;m$，变量的个数大于方程的个数</strong>，即方程组一定有无穷多个解），<strong>其秩(rank) 为 $m$</strong>，$B$ 是 $A$ 中的一个 $m\times m$ 阶的满秩子矩阵（<strong>行列式 $|B| \ne 0$ 的非奇异子矩阵</strong>），称 $B$ 是线性规划问题的一个基。</li></ul><script type="math/tex; mode=display">R(A) = m \Rightarrow\begin{pmatrix}a_{1,1} & a_{1,2} & \cdots & a_{1,m}\\a_{2,1} & a_{2,2} & \cdots & a_{2,m}\\\vdots & \vdots & \vdots & \vdots\\a_{m,1} & a_{m,2} & \cdots & a_{m,m}\\\end{pmatrix}\Rightarrow\begin{pmatrix}P_{1} & P_{2} & \cdots & P_{m}\end{pmatrix},\; 其中P_i =\begin{pmatrix}a_{1,i}\\a_{2,i}\\\vdots\\a_{m,i}\\\end{pmatrix}</script><ul><li>【基向量组 $B$】（极大线性无关组）：向量组 $A$ 中有 $m$ 个线性无关的向量，且其余向量均可由这 $m$ 个向量来线性表示</li></ul><script type="math/tex; mode=display">\begin{pmatrix}a_{1,1} & a_{1,2} & \cdots & a_{1,n}\\a_{2,1} & a_{2,2} & \cdots & a_{2,n}\\\vdots & \vdots & \vdots & \vdots\\a_{m,1} & a_{m,2} & \cdots & a_{m,n}\\\end{pmatrix}\times X\Rightarrow\begin{pmatrix}a_{1,1}\\a_{2,1}\\\vdots\\a_{m,1}\\\end{pmatrix}x_1 +\begin{pmatrix}a_{1,2}\\a_{2,2}\\\vdots\\a_{m,2}\\\end{pmatrix}x_2 + ...+\begin{pmatrix}a_{1,n}\\a_{2,n}\\\vdots\\a_{m,n}\\\end{pmatrix} x_n =\begin{pmatrix}b_{1}\\b_{2}\\\vdots\\b_{m}\\\end{pmatrix}</script><p>设方程组前 $m$ 个变量的系数列向量就是它的基向量（极大线性无关组），则</p><script type="math/tex; mode=display">\begin{pmatrix}a_{1,1}\\a_{2,1}\\\vdots\\a_{m,1}\\\end{pmatrix}x_1 +\begin{pmatrix}a_{1,2}\\a_{2,2}\\\vdots\\a_{m,2}\\\end{pmatrix}x_2 + ...+\begin{pmatrix}a_{1,n}\\a_{2,n}\\\vdots\\a_{m,n}\\\end{pmatrix} x_n =\begin{pmatrix}b_{1}\\b_{2}\\\vdots\\b_{m}\\\end{pmatrix}\Rightarrow</script><script type="math/tex; mode=display">\begin{pmatrix}a_{1,1}\\a_{2,1}\\\vdots\\a_{m,1}\\\end{pmatrix}x_1 +\begin{pmatrix}a_{1,2}\\a_{2,2}\\\vdots\\a_{m,2}\\\end{pmatrix}x_2 + ...+\begin{pmatrix}a_{1,m}\\a_{2,m}\\\vdots\\a_{m,m}\\\end{pmatrix} x_m =\begin{pmatrix}b_{1}\\b_{2}\\\vdots\\b_{m}\\\end{pmatrix} - \begin{pmatrix}a_{1,m+1}\\a_{2,m+1}\\\vdots\\a_{m,m+1}\\\end{pmatrix} x_{m+1} - ... -\begin{pmatrix}a_{1,n}\\a_{2,n}\\\vdots\\a_{m,n}\\\end{pmatrix} x_n</script><p>其中，$P_1,\;P_2,\;…,\; P_m$ 被称为【基向量】，它们对应的变量 $x_1,\; x_2,\; …,\; x_m$​ 被称作【基变量】；$P_{m+1},\; …,\; P_n$ 被称为【非基向量】，它们对应的变量 $x_{m+1},\; …,\; x_n$ 被称作【非基变量】。</p><p>令所有的非基变量 $x_{m+1}=x_{m+2}= …=x_n = 0$，又因为 $|B| \ne 0$，根据克莱姆法则，可以求出一个唯一解：</p><script type="math/tex; mode=display">\begin{pmatrix}a_{1,1}\\a_{2,1}\\\vdots\\a_{m,1}\\\end{pmatrix}x_1 +\begin{pmatrix}a_{1,2}\\a_{2,2}\\\vdots\\a_{m,2}\\\end{pmatrix}x_2 + ...+\begin{pmatrix}a_{1,m}\\a_{2,m}\\\vdots\\a_{m,m}\\\end{pmatrix} x_m =\begin{pmatrix}b_{1}\\b_{2}\\\vdots\\b_{m}\\\end{pmatrix} \quad \stackrel{解得X_B}{\Longrightarrow} \quad\begin{pmatrix}x_1 \\x_2 \\\vdots \\x_m\\\end{pmatrix}</script><p>【基解】：根据基 $B$ 求得的解 $X$ 被称作基解。</p><script type="math/tex; mode=display">X = (X_B + X_N) = (x_1,\; x_2,\; ...,\; x_m,\; 0, \; 0, \; ...,\; 0)^T</script><p>其中，</p><ul><li>基解中非零分量的数目不大于 $m$（方程个数）；</li><li>有一个基，就能求得一组基解。</li></ul><p>【基可行解】：基解中所有分量<strong>都满足非负条件</strong>的解，即</p><script type="math/tex; mode=display">X = (X_B + X_N) = (x_1,\; x_2,\; ...,\; x_m,\; 0, \; 0, \; ...,\; 0)^T,\quad x_i \ge 0,i\in1,2,...,n</script><p>【可行即】：对应于<u>基可行解</u>的<u>基</u>，称为可行基。</p><h6 id="四个解的关系"><a href="#四个解的关系" class="headerlink" title="四个解的关系"></a>四个解的关系</h6><p><img src="/2022/04/19/%E8%BF%90%E7%AD%B9%E5%AD%A6/2022-04-21 12.10.57.png" alt="2022-04-21 12.10.57" style="zoom:50%;"></p><ul><li>当最优解唯一时，最优解也是基可行解；</li><li>当最优解不唯一时，最优解不一定是基可行解。</li></ul><h4 id="1-2-单纯形法"><a href="#1-2-单纯形法" class="headerlink" title="1.2 单纯形法"></a>1.2 单纯形法</h4><h5 id="单纯形法的思想"><a href="#单纯形法的思想" class="headerlink" title="单纯形法的思想"></a>单纯形法的思想</h5><p>我们继续探究例2，用基的方法求解最优解。在 1.1.3 节的末尾，我们得到了化为标准型的线性规划问题模型：</p><script type="math/tex; mode=display">maxZ = x_1' - 2x_2 - 3x_3' + 3x_3'' + 0x_4 + 0x_4 \quad ① \\s.t.\left\{\begin{aligned}2x_1' + x_2 + x_3' - x_3'' + x_4 = 9 \quad ②\\3x_1' + x_2 + 2x_3' - 2x_3'' - x_5 = 4 \quad ③\\-4x_1' + 2x_2 + 3x_3' - 3x_3'' = 6 \quad ④ \\x_1',\; x_2,\; x_3',\; x_3'',\; x_4,\; x_5 \ge 0\end{aligned}\right.</script><ol><li><p>首先，我们可以将约束条件中的系数矩阵 $A$ 写出来：</p><script type="math/tex; mode=display">A =\begin{pmatrix}2 & 1 & 1 & -1 & 1 & 0\\3 & 1 & 2 & -2 & 0 & 1\\-4 & 2 & 3 & -3 & 0 & 0\\\end{pmatrix} \Rightarrow\begin{pmatrix}P_{1} & P_{2} & P_3 & P_4 & P_5 & P_{6}\end{pmatrix}</script></li><li><p>我们可以看出，这是 $A$ 是一个 $3\times 6$ ，秩为 3 的矩阵，<u>则我们需要找到一个行列式不为 $0$ 的 $3 \times 3$ 的基矩阵 $B$</u> </p><script type="math/tex; mode=display">|B_1| = \begin{vmatrix}P_{1} & P_{2} & P_3\end{vmatrix} =\begin{vmatrix}2 & 1 & 1 \\3 & 1 & 2 \\-4 & 2 & 3 \\\end{vmatrix} = -9</script></li><li><p>因为 $P_1, P_2, P_3$ 线性无关，令 $\begin{pmatrix}P_{1} &amp; P_{2} &amp; P_3\end{pmatrix}$ 为基，则</p><script type="math/tex; mode=display">\begin{pmatrix}2 & 1 & 1 & -1 & 1 & 0\\3 & 1 & 2 & -2 & 0 & 1\\-4 & 2 & 3 & -3 & 0 & 0\\\end{pmatrix} \times\begin{pmatrix}x_1'\\x_2\\x_3'\\0\\0\\0\end{pmatrix} = \begin{pmatrix}9 \\4 \\6\end{pmatrix}\qquad \Rightarrow \qquadX^{(1)}=\begin{pmatrix}x_1'\\x_2\\x_3'\\0\\0\\0\end{pmatrix} =\begin{pmatrix}0.7778\\13.2222\\-5.77778\\0\\0\\0\end{pmatrix}</script></li><li><p>求解出的基解有元素小于 0，所以这个基解 $X^{(1)}$不是可行解。</p></li><li><p>重复第 2 步，<u>找到一个行列式不为 $0$ 的 $3 \times 3$ 的基矩阵 $B_i$，解得它的基解 $X^{(i)}$ 。若 $X^{(i)}$ 的所有元素都满足非负约束（$\ge 0$），则 $X^{(i)}$ 就是可行解。</u></p><ul><li><p>【出基】：将列向量 $P_i$ 从基里移除，即</p><script type="math/tex; mode=display">B_i = \begin{pmatrix}P_{a} & P_{i} & P_{b}\end{pmatrix} =\begin{pmatrix}a_{1,a} & a_{1,i} & a_{1,b} \\a_{2,a} & a_{2,i} & a_{2,b} \\a_{3,a} & a_{3,i} & a_{3,b} \\\end{pmatrix} \quad \stackrel{P_i出基}{\Longrightarrow} \quad\begin{pmatrix}P_{a} & P_{b}\end{pmatrix} =\begin{pmatrix}a_{1,a} & a_{1,b} \\a_{2,a} & a_{2,b} \\a_{3,a} & a_{3,b} \\\end{pmatrix}</script><p>【进基】：将列向量 $P_j$ 移进基中，即</p><script type="math/tex; mode=display">B_j = \begin{pmatrix}P_{a} & P_{b}\end{pmatrix} =\begin{pmatrix}a_{1,a} & a_{1,b} \\a_{2,a} & a_{2,b} \\a_{3,a} & a_{3,b} \\\end{pmatrix}\quad \stackrel{P_j进基}{\Longrightarrow} \quad\begin{pmatrix}P_{a} & P_{j} & P_{b}\end{pmatrix} =\begin{pmatrix}a_{1,a} & a_{1,j} & a_{1,b} \\a_{2,a} & a_{2,j} & a_{2,b} \\a_{3,a} & a_{3,j} & a_{3,b} \\\end{pmatrix}</script><p>尽量选择<strong>目标函数里对结果影响大的向量</strong>【进基】，因为我们不希望它是<strong>非基向量</strong>而<strong>使其基变量为 0</strong>；尽量选择“容量”最小的列向量【出基】</p></li></ul></li><li><p><u>解出所有的基解  $X^{(n)}$</u>，其中基解的数目 $n \le C_6^4=15$ 个。<u>找出所有基解中的可行解</u></p></li><li><p>再将<u>所有可行解代入目标函数 ① 中，结果最大的就是【最优解】</u></p></li></ol><h5 id="单纯形法的计算步骤"><a href="#单纯形法的计算步骤" class="headerlink" title="单纯形法的计算步骤"></a>单纯形法的计算步骤</h5><ul><li>为了书写规范和便于计算，对单纯形法的计算设计了【单纯形表】</li><li>每一次迭代对应一张单纯形表</li><li>含<u>初始基可行解</u>的单纯形表称为【初始单纯形表】</li><li>含<u>最优解</u>的单纯形表称为【最终单纯形表】</li></ul><h5 id="单纯形表"><a href="#单纯形表" class="headerlink" title="单纯形表"></a>单纯形表</h5><p>单纯形表解题方法：</p><ol><li>将题目给出的线性规划问题化为标准型</li><li>根据标准型填写初始单纯形表<ul><li>列数： $未知数\;x_i\;的个数+ c_B + X_B + b + \theta_i$</li><li>行数：$约束方程的个数 + c_j + \sigma_j$</li><li>$c_j$：目标函数中各个变量的系数，对应地填入表内</li><li><strong>每个变量所在列的数字</strong>根据大括号中<strong>约束方程组中该变量的系数</strong></li><li>【基】找出变量下放已填写数字构成的矩阵中的<strong>单位矩阵</strong>，依次将该单位矩阵对应的变量写在 $X_B$ 的下面</li><li>将上一步骤中找到的变量上方的数字 $c_j$ 依次对应地填入 $c_B$ 中</li><li>将大括号中约束方程组等号右边的 $b_i$ 依次填到 $b$ 下面</li></ul></li><li>找出可行解<ul><li>令 <strong>$X_B$ 所在列的变量</strong>与<strong>$b$ 所在列的数字</strong>对应相等，再令其他变量等于 0</li></ul></li><li>求出检验数 $\sigma_j = c_j -(c_{B_1}x_{j1} + c_{B_2}x_{j2} + …)$ <ul><li>$X_B$ 下面的变量对应的 $\sigma$ 的值为 0</li><li>【<strong>初始单纯形表</strong>】中 $c_j$ 的数字与 $\sigma_j$ 行的数字完全相同</li></ul></li><li>观察一下 $\sigma_j$ 这一行的数字看一下是否都 $≤0$<ul><li>若这些数字都 $≤0$，则该可行解就是最优解</li><li>若这些数字有＞0的，则该可行解不是最优解，继续进行步骤 6</li></ul></li><li>找到 $\sigma_j$ 行最大的数字 $max(\sigma_j)$ 那一列对应的变量 $x_a$【进基变量】，求出 $\theta _{i} = {b_i}/{x_{ai}}$：<ul><li>若 $\theta \ge 0$，则把 $\theta$ 的值填到表中</li><li>若 $\theta &lt; 0$，则<strong>不用</strong>把 $\theta$ 的值填到表中</li><li>若 $\theta \; 无意义$，则<strong>不用</strong>把 $\theta$ 的值填到表中</li></ul></li><li>找到表中 $\theta _i$ 最小值对应 $X_B$ 列的变量 $x_b$（出基变量），找到【 $x_a$ 的列】和 【$x_b$ 的行】交叉的数字 $m$</li><li>用 【$x_a$ 上面的数字 $c_a】$ 替代 【$x_b$ 前面的数字 $c_b$】，用 $x_a$ 替代 $x_b$，清空 $\sigma_j$ 行与 $\theta_i$ 列</li><li>对 $x_1,x_2…x_n$ 与 $b$ 列组成的矩阵进行运算，【将 $m$ 变成 $1$】（矩阵的初等行变换），同列其他元素变成 $0$，形成一个新的矩阵，将该矩阵中的数字填入表格中对应的位置形成新的单纯形表并进行步骤 3</li><li>如何检验所求的最优解是不是唯一最优解：<ul><li>找出 $X_B$ 列变量以外的变量</li><li>找出 $X_B$ 列变量以外的变量对应的 $\sigma_i$</li><li>若 $X_B$ 列变量以外的变量对应的 $\sigma_i$ 都 $＜0$，则 $X^*$ 为唯一最优解</li><li>若 $X_B$ 列变量以外的变量对应的 $\sigma_i$ 中有 $=0$ 的，则 $X^*$ 是无穷多最优解中的一个</li></ul></li></ol><p>【例】给出下列问题：</p><script type="math/tex; mode=display">max Z = 2x_1 + 3x_2 + 0x_3 + 0x_4 + 0x_5 \quad ① \\s.t.\left\{\begin{aligned}x_1 + 2x_2 + x_3 + 0x_4+ 0x_5 = 8 \quad ②\\4x_1 + 0x_2 + 0x_3 + x_4 + 0x_5 = 16 \quad ③\\0x_1 + 4x_2 + 0x_3+ 0x_4+ x_5 = 12 \quad ④ \\x_1, x_2, x_3, x_4, x_5 \ge 0\end{aligned}\right.</script><ol><li><p>该线性规划问题已化成标准形式；</p></li><li><p>根据标准型填写如下的初始单纯形表。</p><p>|   \   |   $c_j:$    |   2   |   3   |   0   |   0   |   0   |  \   | \          |<br>| :—-: | :————-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—: | ————— |<br>| $c_B$ |    $X_B$    | $x_1$ | $x_2$ | $x_3$ | $x_4$ | $x_5$ | $b$  | $\theta_i$ |<br>|   0   |    $x_3$    |   1   |   2   |   1   |   0   |   0   |  8   | 4          |<br>|   0   |    $x_4$    |   4   |   0   |   0   |   1   |   0   |  16  | ❌          |<br>|   0   |    $x_5$    |   0   |   4   |   0   |   0   |   1   |  12  | 3          |<br>|   \   | $\sigma_i:$ |   2   |   3   |   0   |   0   |   0   |  \   | \          |</p></li><li><p>找出可行解：令 <strong>$X_B$ 所在列的变量</strong>与<strong>$b$ 所在列的数字</strong>对应相等，再令其他变量等于 0。故</p><script type="math/tex; mode=display">X^{(0)} = (x_3 = 8, x_4 = 16, x_5 = 12, x_1 =0 , x_2 =0) \quad \stackrel{整理}{\Longrightarrow} \quad X^{(0)}=(0,0,8,16,12)^T</script></li><li><p>求出检验数 $\sigma_j = c_j -(c_{B_1}x_{j1} + c_{B_2}x_{j2} + …)$ :</p><ul><li>$\sigma_1 = c_1 -(c_{B_1}x_{11} + c_{B_2}x_{12} + c_{B_3}x_{13}) = 2-(0\times 1+0\times 4+0\times0) = 2$</li><li>$\sigma_2 = c_2 -(c_{B_1}x_{21} + c_{B_2}x_{22} + c_{B_3}x_{23}) = 3-(0\times 2+0\times 0+0\times4) = 3$</li><li>$\sigma_3 = c_3 -(c_{B_1}x_{31} + c_{B_2}x_{32} + c_{B_3}x_{33}) = 0-(0\times 1+0\times 0+0\times0) = 0$</li><li>$\sigma_4 = c_4 -(c_{B_1}x_{41} + c_{B_2}x_{42} + c_{B_3}x_{43}) = 0-(0\times 0+0\times 1 + 0\times0) = 0$</li><li>$\sigma_5 = c_5 -(c_{B_1}x_{51} + c_{B_2}x_{52} + c_{B_3}x_{53}) = 0-(0\times 0+0\times 0+0\times1) = 0$</li></ul></li><li><p>观察一下 $\sigma_j$ 这一行的数字看一下是否都 $≤0$ ？否，继续进行下一步。</p></li><li><p>找到 $\sigma_j$ 行最大的数字 $max(\sigma_j)$ 那一列对应的变量 $x_a$【进基变量】，求出 $\theta _{i} = {b_i}/{x_{ai}}$：</p><p> $max(\sigma_j) = 3 =\theta_2 \quad \stackrel{对应的}{\Longrightarrow} \quad 进基变量x_a = x_2$</p><ul><li>$\theta _{1} = {b_1}/{x_{21}} = 8 / 2 = 4 &gt;0$，填入表中</li><li>$\theta _{2} = {b_2}/{x_{22}} = 16 / 0 :无意义$</li><li>$\theta _{3} = {b_3}/{x_{31}} = 12 / 4 = 3 &gt;0$，填入表中</li></ul></li><li><p>找到表中 $\theta _i$ 最小值对应 $X_B$ 列的变量 $x_b$【出基变量】，找到 $x_a$ 的列和 $x_b$ 的行交叉的数字 $m$：</p><p>$min(\theta_i) = 3 = \theta_3 \quad \stackrel{对应的}{\Longrightarrow} \quad 出基变量 x_b = x_5$。$x_a = x_2$的列 与 $x_b = x_5$ 的行交叉的数字 $m = 4$</p></li><li><p>用 $x_a$ 上面的数字替代 $x_b$ 前面的数字，用 $x_a$ 替代 $x_b$，清空 $\sigma_j$ 行与 $\theta_i$ 列：</p><p>|   \   |   $c_j:$    |   2   |   3   |   0   |   0   |   0   |  \   | \          |<br>| :—-: | :————-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—: | ————— |<br>| $c_B$ |    $X_B$    | $x_1$ | $x_2$ | $x_3$ | $x_4$ | $x_5$ | $b$  | $\theta_i$ |<br>|   0   |    $x_3$    |   1   |   2   |   1   |   0   |   0   |  8   |            |<br>|   0   |    $x_4$    |   4   |   0   |   0   |   1   |   0   |  16  |            |<br>|   3   |    $x_2$    |   0   |   4   |   0   |   0   |   1   |  12  |            |<br>|   \   | $\sigma_i:$ |       |       |       |       |       |  \   | \          |</p></li><li><p>对 $x_1,x_2…x_n$ 与 $b$ 列组成的矩阵进行运算，<u>将 $m$ 变成 $1$，同列其他元素变成 $0$，形成一个新的矩阵</u>，将该矩阵中的数字填入表格中对应的位置形成新的单纯形表并进行步骤 3：</p><script type="math/tex; mode=display">M = (x_1,x_2…x_n|b) =(A|b) =\begin{pmatrix}1 & 2 & 1 & 0 & 0 & 8\\4 & 0 & 0 & 1 & 0 & 16\\0 & 4 & 0 & 0 & 1 & 12\\\end{pmatrix}\\\quad \xrightarrow[1/4 \times 第3行]{m=1的初等行变换} \quad\begin{pmatrix}1 & 2 & 1 & 0 & 0 & 8\\4 & 0 & 0 & 1 & 0 & 16\\0 & 1 & 0 & 0 & 1/4 & 3\\\end{pmatrix}\\\quad \xrightarrow[第1行+(-2)\times第3行]{m所在列其他元素为0} \quad\begin{pmatrix}1 & 0 & 1 & 0 & -1/2 & 2\\4 & 0 & 0 & 1 & 0 & 16\\0 & 1 & 0 & 0 & 1/4 & 3\\\end{pmatrix}\\</script><p>|   \   |   $c_j:$    |   2   |   3   |   0   |   0   |   0   |  \   | \          |<br>| :—-: | :————-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—: | ————— |<br>| $c_B$ |    $X_B$    | $x_1$ | $x_2$ | $x_3$ | $x_4$ | $x_5$ | $b$  | $\theta_i$ |<br>|   0   |    $x_3$    |   1   |   0   |   1   |   0   | -1/2  |  2   |            |<br>|   0   |    $x_4$    |   4   |   0   |   0   |   1   |   0   |  16  |            |<br>|   3   |    $x_2$    |   0   |   1   |   0   |   0   |  1/4  |  3   |            |<br>|   \   | $\sigma_i:$ |       |       |       |       |       |  \   | \          |</p><p>重复步骤 3 ……</p></li><li><p>经过多次迭代，列出每次迭代过后的单纯形表：</p><ul><li><p>第一次迭代：</p><p>|   \   |   $c_j:$    |   2   |   3   |   0   |   0   |   0   |  \   | \          |<br>| :—-: | :————-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—: | ————— |<br>| $c_B$ |    $X_B$    | $x_1$ | $x_2$ | $x_3$ | $x_4$ | $x_5$ | $b$  | $\theta_i$ |<br>|   0   |    $x_3$    |   1   |   2   |   1   |   0   |   0   |  8   | 4          |<br>|   0   |    $x_4$    |   4   |   0   |   0   |   1   |   0   |  16  | ❌          |<br>|   0   |    $x_5$    |   0   |   4   |   0   |   0   |   1   |  12  | 3          |<br>|   \   | $\sigma_i:$ |   2   |   3   |   0   |   0   |   0   |  \   | \          |</p><p>$X^{(0)}=(0,0,8,16,12)^T$</p></li><li><p>第二次迭代：</p><p>|   \   |   $c_j:$    |   2   |   3   |   0   |   0   |   0   |  \   | \          |<br>| :—-: | :————-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—: | ————— |<br>| $c_B$ |    $X_B$    | $x_1$ | $x_2$ | $x_3$ | $x_4$ | $x_5$ | $b$  | $\theta_i$ |<br>|   0   |    $x_3$    |   1   |   0   |   1   |   0   | -1/2  |  2   | 2          |<br>|   0   |    $x_4$    |   4   |   0   |   0   |   1   |   0   |  16  | 4          |<br>|   3   |    $x_2$    |   0   |   1   |   0   |   0   |  1/4  |  3   | ❌          |<br>|   \   | $\sigma_i:$ |   2   |   0   |   0   |   0   | -3/4  |  \   | \          |</p><p>$X^{(1)}=(0,3,2,16,0)^T$</p></li><li><p>第三次迭代：</p><p>|   \   |   $c_j:$    |   2   |   3   |   0   |   0   |   0   |  \   | \          |<br>| :—-: | :————-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—: | ————— |<br>| $c_B$ |    $X_B$    | $x_1$ | $x_2$ | $x_3$ | $x_4$ | $x_5$ | $b$  | $\theta_i$ |<br>|   2   |    $x_1$    |   1   |   0   |   1   |   0   | -1/2  |  2   | ❌          |<br>|   0   |    $x_4$    |   0   |   0   |  -4   |   1   |   2   |  8   | 4          |<br>|   3   |    $x_2$    |   0   |   1   |   0   |   0   |  1/4  |  3   | 12         |<br>|   \   | $\sigma_i:$ |   0   |   0   |  -2   |   0   |  1/4  |  \   | \          |</p><p>$X^{(2)}=(2,3,0,8,0)^T$</p></li><li><p>第四次迭代：</p><p>|   \   |   $c_j:$    |   2   |   3   |   0   |   0   |   0   |  \   | \          |<br>| :—-: | :————-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—: | ————— |<br>| $c_B$ |    $X_B$    | $x_1$ | $x_2$ | $x_3$ | $x_4$ | $x_5$ | $b$  | $\theta_i$ |<br>|   2   |    $x_1$    |   1   |   0   |   0   |   0   |  1/4  |  4   |            |<br>|   0   |    $x_5$    |   0   |   0   |  -2   |  1/2  |   1   |  4   |            |<br>|   3   |    $x_2$    |   0   |   1   |  1/2  | -1/8  |   0   |  2   |            |<br>|   \   | $\sigma_i:$ |   0   |   0   | -3/2  | -1/8  |   0   |  \   | \          |</p><p>$X^{(3)}=(4,2,0,0,4)^T$</p><p>我们观察观察一下 $\sigma_j$ 这一行的数字看一下是否都 $≤0$？是，则该可行解就是最优解，即$X^* = X^{(3)}=(4,2,0,0,4)^T$</p><p>所以，$max Z = 2x_1 + 3x_2 + 0x_3 + 0x_4 + 0x_5 = 14$</p></li></ul></li></ol><h3 id="第二部分：整数线性规划"><a href="#第二部分：整数线性规划" class="headerlink" title="第二部分：整数线性规划"></a>第二部分：整数线性规划</h3><p>整数线性规划模型是在一般线性规划模型的基础上加上<u>决策变量取整数值的约束</u>，由此，我们可以得到整数线性规划问题的一般形式如下：</p><script type="math/tex; mode=display">maxZ = \sum_{j=1}^n c_jx_j \qquad ①\\s.t.\left\{\begin{aligned}\sum_{j=1}^n a_{i,j}x_j = b_j \quad i=1,2,3,...,m \qquad ② \\x_j \ge 0 \quad j=1,2,3,...,n \qquad ③\\x_1,x_2,x_3,...,x_n \in \Z \qquad ④\end{aligned}\right.</script><ol><li>先不考虑 $x \in \Z$，求解问题；</li><li>再不考虑 $x \in \Z$，结合 1 中的解，找到最优解。</li></ol><p>实际上，整数线性规划根据<u>决策变量取整数的情况</u>可以进行如下区分：</p><ul><li><p>混合整数规划 ＆ 全整数规划</p></li><li><p>0-1型整数规划 ＆ 非0-1型整数规</p></li></ul><h4 id="含-0-1-变量的建模"><a href="#含-0-1-变量的建模" class="headerlink" title="含 0-1 变量的建模"></a>含 0-1 变量的建模</h4><p>对不含0-1变量的整数规划问题，我们只需要按照一般线性规划问题的形式进行建模，然后综合问题的性质给相应变量增加取整的约束即可；但对于包含0-1变量的问题，由于0-1变量作为二进制变量（或逻辑量），其应用性很强，在实际问题的建模中常常需要灵活运用。</p><ul><li><p>表示系统是否处于某个特定状态，或决策时是否取某个特定方案，如</p><script type="math/tex; mode=display">x =\left\{\begin{aligned}1 \qquad \qquad决策取方案P时 \\0 \qquad 决策不取方案P时(\bar P) \\\end{aligned}\right.</script></li><li><p>当问题含多项要素，每项要素面临两种选择时，可用0-1变量来描述。<br>设问题有有限项要素 $E_1, E_2,…,E_n$，其中每项E，有两种选择 $A_j$ 和 $\bar A_j (j=1,2,…,n)$，可令：</p><script type="math/tex; mode=display">x_j =\left\{\begin{aligned}1 \qquad 若E_j选择A_j \\0 \qquad 若E_j选择\bar A_j \\\end{aligned}\right.</script></li></ul><h5 id="含有相互排斥的约束条件的问题"><a href="#含有相互排斥的约束条件的问题" class="headerlink" title="含有相互排斥的约束条件的问题"></a>含有相互排斥的约束条件的问题</h5><p>我们可以设两个 0-1 变量 $y_1,y_2$:</p><script type="math/tex; mode=display">y_1 =\left\{\begin{aligned}1 \qquad 若E_j选择A_j \\0 \qquad 若E_j选择\bar A_j \\\end{aligned}\right.</script><h4 id="分支定界法"><a href="#分支定界法" class="headerlink" title="分支定界法"></a>分支定界法</h4><p>可以理解为“二分比较”，对可行域进行二分，如果在当前可行域内有最优解</p><script type="math/tex; mode=display">maxZ = 40x_1 + 90x_2 \qquad ①\\s.t.\left\{\begin{aligned}9x_1 +7x_2 \le 56\qquad ② \\7x_1 + 20x_2 \le 70 \qquad ③\\x_1,x_2 \ge 0 \quad x_1,x_2\in \Z \qquad ④\end{aligned}\right.</script><ol><li><p>我们先设不考虑 $x_1,x_2\in \Z$ 的情况为B问题：</p><script type="math/tex; mode=display">maxZ = 40x_1 + 90x_2 \qquad ①\\s.t.\left\{\begin{aligned}9x_1 +7x_2 \le 56\qquad ② \\7x_1 + 20x_2 \le 70 \qquad ③\\x_1,x_2 \ge 0  \qquad ④\end{aligned}\right.</script></li><li><p>运用单纯形法，我们可以得出B问题的最优解 $X_B^* = (4.81,\;1.82)^T$，$maxZ_B = 356$</p></li><li><p>我们可以根据整数对可行域进行二分，然后再讨论：</p><ul><li><p>不考虑 $x_1,x_2\in \Z$ 的情况下 $x_1^* = 4.81$，所以我们可以在左右两边对区域进行划分，即 $x_1 \le 4$ 和 $x_1 \ge 5$ ，将新得到的约束分别加入到 B 问题中</p><p>(1) 问题 $B_1$</p><script type="math/tex; mode=display">maxZ = 40x_1 + 90x_2 \qquad ①\\s.t.\left\{\begin{aligned}9x_1 +7x_2 \le 56\qquad ② \\7x_1 + 20x_2 \le 70 \qquad ③\\x_1,x_2 \ge 0  \qquad ④\\x_1 \le 4 \qquad ⑤\end{aligned}\right.</script></li></ul></li></ol><pre><code> 运用单纯形法，我们可以得出 $B_1$ 问题的最优解 $&#123;X_B&#125;_1^* = (4,\;2.1)^T$，$max&#123;Z_B&#125;_1 = 349$ 我们可以在 $x_2$ 左右两边对区域进行划分，即 $x_2 \le 2$ 和 $x_2 \ge 3$ ，将新得到的约束分别加入到 $B_1$ 问题中： ​    (i) 问题 $B_&#123;11&#125;$ $$ maxZ = 40x_1 + 90x_2 \qquad ①\\ s.t.\left\&#123;\begin&#123;aligned&#125; 9x_1 +7x_2 \le 56\qquad ② \\ 7x_1 + 20x_2 \le 70 \qquad ③\\ x_1,x_2 \ge 0  \qquad ④\\ x_1 \le 4 \qquad ⑤\\ x_2 \le 2 \qquad ⑥ \end&#123;aligned&#125;\right. $$ ​    运用单纯形法，我们可以得出 $B_1$ 问题的最优解 $&#123;X_B&#125;_&#123;11&#125;^* = (4,\;2)^T$，$max&#123;Z_B&#125;_&#123;11&#125; = 340$ ​    (ii) 问题 $B_&#123;12&#125;$ $$ maxZ = 40x_1 + 90x_2 \qquad ①\\ s.t.\left\&#123;\begin&#123;aligned&#125; 9x_1 +7x_2 \le 56\qquad ② \\ 7x_1 + 20x_2 \le 70 \qquad ③\\ x_1,x_2 \ge 0  \qquad ④\\ x_1 \le 4 \qquad ⑤\\ x_2 \ge 3 \qquad ⑥ \end&#123;aligned&#125;\right. $$ ​    运用单纯形法，我们可以得出 $B_1$ 问题的最优解 $&#123;X_B&#125;_&#123;12&#125;^* = (1.42,\;3)^T$，$max&#123;Z_B&#125;_&#123;12&#125; = 327$ (2) 问题 $B_2$ $$ maxZ = 40x_1 + 90x_2 \qquad ①\\ s.t.\left\&#123;\begin&#123;aligned&#125; 9x_1 +7x_2 \le 56\qquad ② \\ 7x_1 + 20x_2 \le 70 \qquad ③\\ x_1,x_2 \ge 0  \qquad ④\\ x_1 \ge 5 \qquad ⑤ \end&#123;aligned&#125;\right. $$ 运用单纯形法，我们可以得出 $B_2$ 问题的最优解 $&#123;X_B&#125;_2^* = (5,\;1.57)^T$，$max&#123;Z_B&#125;_2 = 341$ 我们可以在 $x_2$ 左右两边对区域进行划分，即 $x_2 \le 1$ 和 $x_2 \ge 2$ ，将新得到的约束分别加入到 $B_2$ 问题中： ​    (i) 问题 $B_&#123;21&#125;$ $$ maxZ = 40x_1 + 90x_2 \qquad ①\\ s.t.\left\&#123;\begin&#123;aligned&#125; 9x_1 +7x_2 \le 56\qquad ② \\ 7x_1 + 20x_2 \le 70 \qquad ③\\ x_1,x_2 \ge 0  \qquad ④\\ x_1 \ge 5 \qquad ⑤\\ x_2 \le 1 \qquad ⑥ \end&#123;aligned&#125;\right. $$ ​    运用单纯形法，我们可以得出 $B_1$ 问题的最优解 $&#123;X_B&#125;_&#123;21&#125;^* = (5.44,\;1)^T$，$max&#123;Z_B&#125;_&#123;21&#125; = 308$ ​    (ii) 问题 $B_&#123;22&#125;$ $$ maxZ = 40x_1 + 90x_2 \qquad ①\\ s.t.\left\&#123;\begin&#123;aligned&#125; 9x_1 +7x_2 \le 56\qquad ② \\ 7x_1 + 20x_2 \le 70 \qquad ③\\ x_1,x_2 \ge 0  \qquad ④\\ x_1 \ge 5 \qquad ⑤\\ x_2 \ge 2 \qquad ⑥ \end&#123;aligned&#125;\right. $$ ​    运用单纯形法，我们可以得出 $B_1$ 问题的最优解 $&#123;X_B&#125;_&#123;22&#125;^*无可行解$</code></pre><h3 id="第三部分：动态规划"><a href="#第三部分：动态规划" class="headerlink" title="第三部分：动态规划"></a>第三部分：动态规划</h3><p>我们有如下问题，给定一个线路网络，两点之间连线上的数字表示两点间的距离（或费用），试求一段由 A 到 E 的管线铺路，使总距离为最短（或总费用最小）。</p><p><img src="/2022/04/19/%E8%BF%90%E7%AD%B9%E5%AD%A6/IMG_42512D145660-1.jpeg" alt="IMG_42512D145660-1" style="zoom:50%;"></p><p>其实从A到E并不是一次性的决策，$A \to B, \quad B \to C, \quad C\to D, \quad D \to E$。</p><p>由此我们可见，将问题分成若干相互联系的阶段，在每个阶段都需要做出决策，使全过程达到整体最优，这类问题我们称为多阶段决策问题（资源分配、生产存储）。最大特点就是可以把问题拆分成很多阶段。</p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li><p>阶段：将问题划分成若干个相互联系的阶段。$k$ 表示为阶段变量。</p><blockquote><p>上图有四个阶段，分别是：$A \to B, \quad B \to C, \quad C\to D, \quad D \to E$</p></blockquote></li><li><p>状态：每个阶段开始时所处的自然状态。$s_k$ 表示为状态变量。</p><blockquote><p>上图有10个状态，分别是：$A,\qquad B_1,B_2,B_3 \qquad C_1,C_2 \qquad D_1,D_2,D_3 \qquad E$</p></blockquote></li><li><p>决策：当过程处于某一阶段的某一状态时作出的<u>决定</u>，从而确定下一阶段的状态。$x_k$ 表示为决策变量。</p><ul><li>允许决策集合：决策变量的取值范围。$D_k(s_k)$ 表示第k阶段从状态$s_k$ 出发的允许决策集合。$x_k \in D_k(s_k)$</li></ul></li><li><p>策略：按顺序排列的决策集合。</p></li><li><p>状态转移方程：确定过程由一个状态到另一个状态的演变过程。$S_{k+1} = T_k(S_k,x_k)$。</p></li><li><p>指标函数：衡量所实现过程优劣的数值指标</p><ul><li>阶段指标函数 $v_k(S_k,x_k)$ ：从k阶段状态 $s_k$ 出发，选择决策 $x_k$ 所产生的第k阶段指标</li><li>过程指标函数 $V_k(S_k,x_k,x_{k+1},…,x_n)$：从k阶段状态 $S_k$ 出发，选择决策 $x_k,x_{k+1},…,x_n$ 所产生的过程指标<ul><li>$V_k(s_k,x_k,x_{k+1},…,x_n) = V[v_k(s_k,x_k),V_{k+1}(S_{k+1},x_{x+1},…,x_n)]$</li></ul></li></ul></li><li><p>最优值函数 $f_x(S_k)= \text{min/max}_{x_k\in D_k(S_k)} \quad V_k(s_k,x_k,x_{k+1},…,x_n)$</p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">连和形式</th><th style="text-align:center">连乘形式</th></tr></thead><tbody><tr><td style="text-align:center">指标函数</td><td style="text-align:center">$V_k(S_k,x_k,x_{k+1},…,x_n) = \sum _{j=k}^{n-1}v_j(s_j,x_j)+V_n$</td><td style="text-align:center">$V_k(S_k,x_k,x_{k+1},…,x_n) = \prod _{j=k}^{n-1}v_j(s_j,x_j)+V_n$</td></tr><tr><td style="text-align:center">最优值函数</td><td style="text-align:center">$f_x(S_k)= \text{min/max}_{x_k\in D_k(S_k)} \quad V_k(s_k,x_k,x_{k+1},…,x_n)$</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">动态规划模型</td><td style="text-align:center"></td></tr></tbody></table></div><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><ol><li>最优性原理：一个最优策略的子策略也是最优的。</li></ol><blockquote><p>例如：已知最优策略为 $A \to B_1 \to C_1 \to D_1 \to E$，则 $C \to E$ 的最优策略为  $C_1 \to D_1 \to E$ 。</p></blockquote><ol><li>无后效性原理：如果某阶段的状态给定之后，在此<u>阶段以后过程</u>的发展<u>不受这个阶段以前各个状态</u>的影响</li></ol><blockquote><p>我们以上图为例：</p><p>阶段 $k$：$k=1,2,3,4$</p><p>状态变量 $S_k$：$S_1=\{A\} \quad S_1=\{A\} \quad S_2=\{B_1,B_2,B_3\} \quad S_3=\{C_1,C_2\} \quad S_4=\{D_1,D_2,D_3\} \quad S_5=\{E\}$</p><p>决策变量 $x_k$ ：$S_k$ 状态时选择到达下一阶段的点</p><p>允许决策集合：$x_k \in D_k(S_k)$</p><p>状态指标函数 $v_k(S_k,x_k)$：状态点 $S_k$ 到决策点 $x_k$ 间的<u>最短距离</u></p><p>最优指标函数 $f_k(S_k)$：k阶段状态为 $S_k$ 时到终点 $E$ 间的<u>最短距离</u></p><p>递推方程：$\left\{\begin{aligned}<br>f_x(S_k)= \text{min}_{x_k\in D_k(S_k)} \quad \{v_k(s_k,x_k)+f_{k+1}(S_{k+1})\}, k=1,2,3,4 \\<br>f_{5}(S_{5})=0 \\<br>\end{aligned}\right.$</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;基础运筹学&quot;&gt;&lt;a href=&quot;#基础运筹学&quot; class=&quot;headerlink&quot; title=&quot;基础运筹学&quot;&gt;&lt;/a&gt;基础运筹学&lt;/h2&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&lt;a href&gt;本文章&lt;/a&gt;是根据法国国立高等电力技术、电子学、计算机、水力学与电信学校 (E.N.S.E.E.I.H.T.) 第七学期课程&lt;em&gt;“Recherche Operation”&lt;/em&gt; 总结而来的【部分课程笔记】。碍于本人学识有限，部分叙述难免存在纰漏，请读者注意甄别。&lt;/p&gt;
&lt;p&gt;总而言之，运筹学就是从真实系统中&lt;strong&gt;建立模型&lt;/strong&gt;，用数学的形式表示出来。&lt;/p&gt;</summary>
    
    
    
    <category term="课程笔记" scheme="https://dave0126.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="课程笔记" scheme="https://dave0126.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="最优化" scheme="https://dave0126.github.io/tags/%E6%9C%80%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>事务 Transaction 简介</title>
    <link href="https://dave0126.github.io/2022/04/11/%E4%BA%8B%E5%8A%A1transaction%E7%AE%80%E4%BB%8B/"/>
    <id>https://dave0126.github.io/2022/04/11/%E4%BA%8B%E5%8A%A1transaction%E7%AE%80%E4%BB%8B/</id>
    <published>2022-04-11T17:22:49.000Z</published>
    <updated>2022-04-19T11:51:50.616Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是「事务」？"><a href="#什么是「事务」？" class="headerlink" title="什么是「事务」？"></a>什么是「事务」？</h2><p><img src="/2022/04/11/%E4%BA%8B%E5%8A%A1transaction%E7%AE%80%E4%BB%8B/transaction.png" alt="「技术笔记」数据库系统概念-事务transaction 总结" style="zoom:50%;"></p><p>数据库事务通常包含了<u>一序列的对数据库的<strong>读/写</strong>操作</u>，是一系列操作的集合。包含有以下两个目的：</p><ol><li>为数据库操作序列提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。</li><li>当多个<a href="https://zh.wikipedia.org/wiki/应用程序">应用程序</a>在<a href="https://zh.wikipedia.org/wiki/并发">并发</a>访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。</li></ol><p>当事务被提交给了<a href="https://zh.wikipedia.org/wiki/数据库管理系统">数据库管理系统</a>（DBMS），则DBMS需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要<a href="https://zh.wikipedia.org/wiki/回滚_(数据管理">回滚</a>)，回到事务执行前的状态；同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行。</p><span id="more"></span><h2 id="为什么要有「事务」？"><a href="#为什么要有「事务」？" class="headerlink" title="为什么要有「事务」？"></a>为什么要有「事务」？</h2><p>事务是关系型数据库引入的概念，一个现实的业务操作往往关联多处数据，需要在数据库层面提供一种底层的逻辑保障，确保对数据的操作符合一定的特性，简化业务逻辑。<br>事务transaction解决以下问题：</p><ul><li><p>逻辑操作的原子性(<strong>Atomicity</strong>)：</p><p>一系列的逻辑操作要么成功的反应在数据库中，要么完全不反映在数据库中（意味着如果有任何一处失败，整个操作需要回滚）。</p></li><li><p>数据约束的一致性(<strong>Consistency</strong>)：</p><p>数据库的表之间存在各种约束条件，比如主键约束、外键约束等，在没有其他事务并发执行的情况下，对数据库的修改需要符合数据库的一致性约束。</p></li><li><p>并发执行的隔离性(<strong>Isolation</strong>)：</p><p>数据库需要能够并发执行多个事务，对于每个事务来说，其他事务是不可见的；整理看起来，事务并发执行的结果跟按顺序一个一个串行地执行结果一样。</p></li><li><p>执行结果的持久性(<strong>Durability</strong>)：</p><p>一旦对数据库操作结果返回成功，就代表这个改变是永久的，不管数据库系统出现什么故障，比如断电、系统故障、磁盘故障等等（意味着数据库需要在保证性能的情况下具备恢复能力，即，每个成功的操作均需要存储在非易失性存储器上）</p></li></ul><h2 id="「事务」跟「SQL」什么关系？"><a href="#「事务」跟「SQL」什么关系？" class="headerlink" title="「事务」跟「SQL」什么关系？"></a>「事务」跟「SQL」什么关系？</h2><p>事务是数据库逻辑逻辑的基本单元，由高级数据操纵语言编写；SQL全称为「结构化查询语言(Structured Query Language, SQL)就是数据库高级数据操纵语言的一种。在SQL语言的语法中，除了大家经常用到的<code>select</code>、<code>insert</code>、<code>delete</code>、<code>update</code>以外，也有赋值和其他逻辑操作。一个Transaction包含一条或者多条SQL语句，也可以不包含SQL语句。</p><h2 id="什么时候一个事务算成功执行？"><a href="#什么时候一个事务算成功执行？" class="headerlink" title="什么时候一个事务算成功执行？"></a>什么时候一个事务算成功执行？</h2><p>由于有「原子性」的要求，每个事务都有一个状态机，包含：</p><ul><li>活动状态(active)</li><li>部分提交(partially committed)</li><li>失败(failed)</li><li>中止(aborted)</li><li>提交(commit)</li></ul><p>只有当事务的commit日志记录到硬盘之后，日志才会进入提交状态，此时事务算是成功执行。<br>对于一些存在「可见外部写(observable exernal writes)」的事务，一般都是在提交状态之后操作。一个复杂的例子是ATM机：系统状态正常，但是吐钱的时候发生故障。</p><h2 id="「原子性」如何实现？"><a href="#「原子性」如何实现？" class="headerlink" title="「原子性」如何实现？"></a>「原子性」如何实现？</h2><ul><li>原理：影子拷贝(shadow copy)，在数据库副本上执行事务操作，如果成功，则更新数据库指针指向新的copy。</li><li>前提：数据库指针存储在磁盘上，更新磁盘上数据库指针的操作要确保原子性，要么写入新的指针，要么原指针不被擦除。这个由磁盘提供原子性支持，磁盘系统确保了对块或者磁盘扇区更新的原子性。</li><li>其他案例：文本编辑器在编辑的时候，也通过shadow copy的方案来确保编辑会话的事务性。</li></ul><h2 id="「持久性」如何实现？"><a href="#「持久性」如何实现？" class="headerlink" title="「持久性」如何实现？"></a>「持久性」如何实现？</h2><p>持久性的需求：事务成功返回，则记录必须有效保存在非易失存储器（比如硬盘）上。</p><h3 id="困难"><a href="#困难" class="headerlink" title="困难"></a>困难</h3><ul><li>每次事务都直接更新保存在硬盘上的数据库数据文件，不仅性能不行，也无法做到错误恢复；</li><li>如果在内存中加buffer，将一批事务批处理更新到数据库数据文件，则无法做到持久（系统随时有断电风险）</li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>每次事务的修改保存在硬盘上的「更新日志记录(update log record)」，而不是直接修改数据库「数据文件」。</p><p>日志文件和数据文件相比，虽然都是保存在硬盘上，但是有两个优点：</p><ol><li>效率更高：日志是「顺序」的，又叫顺序日志，记录都是append在上面，不需要磁头寻址；而数据文件是「随机」的，每次都需要寻址。几乎所有的磁盘针对数据库日志文件更新效率都很高。</li><li>确保事务的原子性：一个事务对应的日志包括start、commit作为开头和提交，只有日志完整的事务，才会被批量更新到数据文件。</li></ol><p>此外，日志文件的更新可以通过在内存中加buffer（日志记录缓冲）实现批处理，进一步提高效率，毕竟将数据输出到硬盘上开销还是比较高。在这种方案下，只要日志没有真正写入硬盘，事务就不进入提交状态。在高并发的情况下，让事务阻塞几纳秒，但是极大提高了日志写的效率，系统整体效率还是提升的。</p><p>日志文件中还可以加入「检查点(checkpoint)」,让数据库系统在恢复的时候可以少做一些工作，不需要从头开始redo日志记录，而是从最近的检查点开始。</p><h2 id="「隔离性」如何实现？"><a href="#「隔离性」如何实现？" class="headerlink" title="「隔离性」如何实现？"></a>「隔离性」如何实现？</h2><p>隔离性是针对事务并发的场景，需要达到的目标：</p><ul><li>事务尽可能并行执行，但是执行效果跟事务串行执行一样。</li><li>提高系统的吞吐量(throughput)和处理器、磁盘的利用率(utilization)</li><li>同时减少事务的平均响应时间(average response time)</li></ul><p><strong>调度(schedule)</strong>：一个事务组的操作的<strong>绝对执行顺序</strong>就是一个调度。</p><p><strong>冲突(conflict)</strong>：当两个事务 $T_i$、$T_j$ 对同一数据项 $x$ 进行操作，其中至少有一个是 <code>write</code> 操作时，事务 $T_i$ 和 $T_j$ 是冲突的。有冲突存在，决定了产生冲突的两个事务的冲突操作先后顺序不能改变。</p><p><strong>冲突可串行化</strong>：在不改变一个调度中同一数据项产生操作冲突的操作的先后顺序的情况下，可以将调度变成一个串行调度，则表示这个调度是冲突可串行化的。</p><h4 id="困难-1"><a href="#困难-1" class="headerlink" title="困难"></a>困难</h4><ol><li>调度可串行化：对于多个事务组成的事务组，每个事务包含多个操作（<code>read</code>、<code>write</code> 以及 <code>数据修改操作</code>），如何产生一个冲突可串行化的调度，同时尽可能的提高执行效率（并行执行）</li><li>调度可恢复&amp;无级联：对于一个调度，如果某一个事务 $T_1$ 失败了，确保整个调度是可以恢复的(recoverable)，也就是：既可以 <code>redo</code> 执行失败的事务，而不影响其他事务；也可以 <code>rollback</code> 回滚失败的事务，而不会导致其他事务级联回滚(cascading rollable)</li></ol><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol><li>为了保证调度的可串行性，首先要明确什么情况下会出现冲突，其次要确定处理冲突的方式。</li></ol><ul><li>定义冲突的过程中，我们可以对事务操作进行规范，降低复杂度。比如两阶段加锁、有效性检查等方法，都约定了事务操作的规范。</li><li>解决冲突的方式，要么延迟冲突的操作（比如加锁），要么终止发出冲突操作的事务（比如时间戳协议、有效性检查）。</li></ul><ol><li>为了保证调度的可恢复性和无级联性，需要确保「当T2事务读取了T1事务所写的数据项，那么T1事务必须T2读取该数据项之前提交」。</li></ol><h3 id="可串行化判定"><a href="#可串行化判定" class="headerlink" title="可串行化判定"></a>可串行化判定</h3><p>冲突可串行化判定原理：事务 $T_i$ 对数据项 $x$ 的 <code>read</code>、<code>write</code>操作和事务 $T_j$ 对数据项 $x$ 的 <code>read</code>、<code>write</code> 操作决定了他们的串行顺序。以下两种情况均表示 $T_i$ 依赖 $T_j$（$T_i \to T_j$）</p><ul><li>$T_i$ 事务 <code>read</code> 操作前，如果 $T_j$ 有 <code>write</code> 操作</li><li>$T_i$ 事务 <code>write</code> 操作前，如果 $T_j$ 有 <code>write</code> 或 <code>read</code> 操作<br>（两个事务的 <code>read</code> 操作无法确定依赖关系，任何对同一数据项 的<code>read</code>、<code>write</code> 操作可以确定一组依赖关系）</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">Read</th><th style="text-align:center">Write</th><th style="text-align:center">Increase</th><th style="text-align:center">Decrease</th></tr></thead><tbody><tr><td style="text-align:center"><strong>Read</strong></td><td style="text-align:center">OK</td><td style="text-align:center">依赖</td><td style="text-align:center">依赖</td><td style="text-align:center">依赖</td></tr><tr><td style="text-align:center"><strong>Write</strong></td><td style="text-align:center">依赖</td><td style="text-align:center">依赖</td><td style="text-align:center">依赖</td><td style="text-align:center">依赖</td></tr><tr><td style="text-align:center"><strong>Increase</strong></td><td style="text-align:center">依赖</td><td style="text-align:center">依赖</td><td style="text-align:center">OK</td><td style="text-align:center">OK</td></tr><tr><td style="text-align:center"><strong>Decrease</strong></td><td style="text-align:center">依赖</td><td style="text-align:center">依赖</td><td style="text-align:center">OK</td><td style="text-align:center">OK</td></tr></tbody></table></div><blockquote><p>例如：两个事务 $T_1$、$T_2$ 对同一数据项 $x$ 进行操作。在 $T_1$ 的操作 <code>write(x,1)</code> 之后 $T_2$ 中有操作 <code>read(x,1)</code>。我们可以得到一组依赖关系：$T_1 \to T_2$</p></blockquote><p>根据依赖关系可以画出调度的<strong>优先图(precedence graph)</strong>，如果该图是<strong>无环图</strong>，可以通过拓扑排序获得等价的串行 (serialisabilite)调度；否则表示这个<strong>调度是非串行的</strong>。</p><blockquote><p>例：</p></blockquote><pre class="mermaid">sequenceDiagram    participant T1    participant T2    participant T3    participant T4    Note over T1 :1. start();    Note over T2 :2. start();    Note over T3 :3. start();    Note over T4 :4. start();    Note over T1 :5. read(z);    Note over T2 :6. read(y);    Note over T3 :7. write(z,1);    Note over T1 :8. write(x,2);    Note over T4 :9. write(y,3);    Note over T3 :10. read(y);    Note over T2 :11. write(z,4);    Note over T4 :12. read(x);    Note over T3 :13. end();    Note over T2 :14. end();    Note over T4 :15. end();    Note over T1 :16. end();</pre><blockquote><p>调度优先图为：</p></blockquote><pre class="mermaid">graph LRT1 --"(7)"--> T3T2 --"(9)"--> T4T4 --"(10)"--> T3T1 --"(12)"--> T4T3 --"(11)"--> T2</pre><blockquote><p>由图可见，该图内存在环，所以不符合可串行性。</p></blockquote><h3 id="可串行性解决方案"><a href="#可串行性解决方案" class="headerlink" title="可串行性解决方案"></a>可串行性解决方案</h3><h4 id="方案1：加锁（悲观）"><a href="#方案1：加锁（悲观）" class="headerlink" title="方案1：加锁（悲观）"></a>方案1：加锁（悲观）</h4><p><strong>两阶段封锁协议(two-phase locking protocol, 2PL)</strong>：将事务加锁、解锁请求分成两个阶段，所有<strong>加锁请求必须在第一阶段</strong>（增长阶段growing phase）申请，<strong>所有解锁请求必须在第二阶段</strong>（缩减阶段shrinking phase）申请，<strong>加锁和解锁操作不能交叉执行（同一个事务内）</strong>。</p><p>两段锁协议规定所有的事务应遵守的规则：</p><blockquote><p>① 在对任何数据进行<strong>读、写操作之前</strong>，首先要<strong>申请</strong>并获得对该数据的<strong>锁</strong>。</p><p>② 在<strong>释放</strong>一个<strong>锁之后</strong>，事务<strong>不再申请</strong>和获得其它<strong>任何锁</strong>。</p></blockquote><ol><li><p>第一阶段（增长阶段Growing Phase）：</p><p>其实也就是该阶段可以进入加锁操作，在对任何数据进行读操作之前要申请获得S<strong>锁</strong>；在进行<strong>写操作之前要申请并获得X锁</strong>，加锁不成功，则事务进入等待状态，直到加锁成功才继续执行。<br>就是加锁后就不能解锁了。</p></li><li><p>第二阶段（缩减阶段Shrinking Phase）：</p><p>第二阶段是释放封锁，事务可以释放任何数据项上的任何类型的锁，但不能申请。</p><p>当事务释放一个封锁后，事务进入封锁阶段，在该阶段只能进行解锁而不能再进行加锁操作。</p></li></ol><pre class="mermaid">sequenceDiagram    participant T1    participant T2    Note over T1 :1. S_Lock(x);    Note over T1 :2. read(x);    Note over T1 :3. X_Lock(y);    Note over T2 :4. S_Lock(y);    Note over T1 :4. write(y,1);    Note over T2 :5. 等待;    Note over T2 :6. 等待;    Note over T1 :7. unlock(y);    Note over T2 :8. S_Lock(y);    Note over T1 :8. unlock(x);    Note over T2 :9. read(y);    Note over T2 :10. unlock(y);</pre><p>2PL协议解决「串行化」问题的思路是通过把可能冲突的数据操作集中在申请锁的阶段，由锁的不相容性延迟有冲突的事务，从而确定冲突事务的执行次序。这种加锁方式也避免了事务解锁了一部分锁之后又去申请新的锁，导致脏读的问题。但是，2PL协议<strong>无法解决「死锁(dead lock)」问题和级联回滚(cascading rollback) 问题</strong>。</p><p><strong>严格(strict)两阶段封锁协议</strong>：规定持有<strong>排他锁</strong>的事务必须在事务 <code>commit</code> <strong>之后</strong>才能<strong>释放锁</strong>。避免了<strong>级联回滚</strong>。<br><strong>强(rigorous)两阶段封锁协议</strong>：规定持有任何锁的事务必须在事务 <code>commit</code> <strong>之后</strong>才能<strong>释放锁</strong>。比strict模式更严格，避免了<strong>死锁</strong>。</p><p>大部分数据库要么采用strict 2PL，要么rigorous 2PL。为了提高并行性能，允许在增长阶段将共享锁S升级(upgrade)为排他锁X，同时在缩减阶段将排他锁X降级(downgrade)为共享锁S，这样确保在write的时间点才排他，操作完之后就不排他，减少事务等待时间。</p><p><strong>重点注意</strong>：使用2PL，虽然可以确保冲突可串行化，但是不代表它的执行效果跟串行一样。因为加锁状态下的可串行化是理论上的可串行化，是根据每个事物的封锁点(lock point，也就是最后加锁的位置)排序得到的串行化顺序，而<u>调度实际执行的时候主要依靠「锁」来保证对冲突操作的执行顺序，这个是并行执行的，因此会出现不同的事务都优先拿到对方需要的数据集的锁的情况（死锁）</u>。</p><p><strong>数据多粒度(granularity)封锁</strong>：理论情况下，加锁针对的数据项Q是没有粒度的。实际中，数据项在保存的时候，经常多个数据项聚成一个数据单元。这种情况下，如果要加锁一个范围比较大的数据时，需要挨个数据项加锁，比较费时；如果需要加锁一个范围比较小的数据时，又会锁定无关的数据项，导致整体并发性减弱。为数据建立<em>多粒度</em>机制就是解决方案。该方案根据数据在数据库中的存储特点，从「数据库」到「区域的文件节点」再到「记录」，形成一颗提现粒度层次的树。并引入「共享型意向锁IS」、「排他型意向锁IX」、「共享排他型意向锁SIX」，实现多粒度封锁。</p><p><strong>多版本两阶段封锁(Multiversion two-phase locking protocol)</strong>：2PL的并行性能有待提升，尤其是在大部分事务「只读」，小部分事务是「更新」操作的情况下，只读的事务会被延迟到更新事务完成，这种情况可以通过结合多版本的特性进行提升。<br>多版本的2PL协议，将事务分为「只读事务」和「更新事务」，针对每一个数据项 $x$ 维护一个全局的版本号ts-counter（计数器型时间戳），事务 $T_i$ 执行 <code>read(x)</code> 操作将返回时间戳小于 $TS(T_i)$ 的最大时间戳版本的内容；<code>write(x)</code> 操作会增加全局版本号以及写入 $x$ 的新版本。这种情况下，只读事务永远不需要等待锁，更新事务则执行强两阶段封锁协议，确保他们可以按照提交次序串行化。</p><h4 id="方案2：时间戳规则（乐观）"><a href="#方案2：时间戳规则（乐观）" class="headerlink" title="方案2：时间戳规则（乐观）"></a>方案2：时间戳规则（乐观）</h4><p><strong>时间戳排序协议(timestamp-ordering protocol)</strong>：不同于加锁的方式，通过锁的相容性决定冲突事务执行顺序，时间戳排序机制<strong>通过事务的时间戳</strong>来决定事务串行化的次序。</p><ol><li>为每一个数据项 $x$ 关联 <code>read</code>、<code>write</code> 操作最近一次成功执行的时间戳 $R_{ead}T_{imestamp}(x)\quad W_{rite}T_{imestamp}(x)$。</li><li>当事务 $T_i$ 对数据项 $x$ 进行 <code>write</code> 操作的时候，如果在事务 $T_i$ 开始之后，$x$ 被其他事务 <code>read</code> 或者 <code>write</code> 过，则当前事务 $T_i$ 进行回滚。</li></ol><blockquote><p>基本时间戳排序协议的工作原理如下：</p><ul><li><code>TS(Ti)</code>表示事务 $T_i$ 的时间戳。</li><li><code>RT(x)</code>表示数据项 $x$ 的读时间戳。</li><li><code>WT(x)</code>表示数据项 $x$ 的写时间戳。</li></ul><ol><li>每当事务 $T_i$ 发出 <code>read(x)</code> 操作时，请检查以下条件：</li></ol><ul><li>如果 $WT(x) &gt; TS(T_i)$ 则<strong>拒绝</strong>该操作；</li><li>如果 $WT(x) \le TS(T_i)$ 则<strong>执行</strong>操作；</li><li>更新所有数据项的时间戳。</li></ul><ol><li>每当事务 $T_i$ 发出 <code>write(x)</code> 操作时，请检查以下条件（<strong>Thomas 写规则</strong>）：</li></ol><ul><li>如果 $TS(T_i)&lt;RT(x)$，则表明 $T_i$ 准备写的值还没来得及写入，$x$ 就提前被读取了，所以 $T_i$ 的 <code>write(x)</code>操作被拒绝，并且事务 $T_i$ 被回滚</li><li>如果 $TS(T_i) &lt; WT(x)$，表明 $T_i$ 写的值已过期，比它更新的值已经写到 $x$ 上，所以 $T_i$ 的 <code>write(x)</code>操作被拒绝；</li><li>剩下的情况，<code>write(x)</code> 操作被允许；</li><li>更新所有数据项的时间戳。</li></ul></blockquote><p>时间戳排序协议<strong>不会有死锁</strong>，因为没有事务处于「等待」状态，事务发现数据项被后来者动过之后就回滚了。但是，这种规则有很强的「抢断」性质，容易导致<strong>长事务持续被短事务抢断，长事务反复重启，可能导致饿死</strong>。</p><p><em>Thomas写规则</em>：对时间戳排序协议的性能优化，当事务 $T_i$ 对数据项 $x$ 进行<code>write</code>操作的时候，如果在事务 $T_i$ 开始之后，$x$ 被其他事务<code>write</code> 过，则当前事务 $T_i$ 的 <code>write</code> 操作<strong>忽略</strong>，而不是进行<strong>回滚</strong>。通过这种方式减少不必要的回滚。</p><p><em>多版本时间戳排序机制(multiversion timestamp-ordering scheme)</em>：类似多版本两阶段封锁协议，让每个 <code>write(x)</code> 操作创建 $x$ 的新版本，而 <code>read(x)</code> 操作则会被分配一个合适的 $x$ 版本进行读取，提高「读」的效率。</p><h4 id="方案3：Validation-有效性规则（乐观）"><a href="#方案3：Validation-有效性规则（乐观）" class="headerlink" title="方案3：Validation 有效性规则（乐观）"></a>方案3：Validation 有效性规则（乐观）</h4><p>有效性检查协议：假设每个事物Ti的生命周期分为2个阶段（只读事务）或者3个阶段（更新事务）。读阶段只进行读、计算操作，之后进行$validation$ 检查，通过的话就进行写操作。每个阶段都关联一个时间戳：$Start(T_i)$，$Validation(T_i)$，$Finish(T_i)$。有效性测试的原理跟时间戳规则一样，</p><blockquote><p><em>如果事务 $T_i$ 在写数据项 $x$（有效性验证）的时候发现数据项已经被写过了，则事务 $T_i$ 回滚</em>。</p></blockquote><p>相比时间戳排序，有效性检查协议把 $validation$ 的时间作为事务的时间戳，而不是使用事务开始的时间，这样可以在冲突度低的情况下有更快响应。</p><p>有效性规则是一种<strong>乐观并发控制(optimistic concurrency control)</strong></p><h3 id="非可串行性解决方案：增强并发性能的「弱一致性级别」"><a href="#非可串行性解决方案：增强并发性能的「弱一致性级别」" class="headerlink" title="非可串行性解决方案：增强并发性能的「弱一致性级别」"></a>非可串行性解决方案：增强并发性能的「弱一致性级别」</h3><h4 id="为什么要有非可串行化解决方案"><a href="#为什么要有非可串行化解决方案" class="headerlink" title="为什么要有非可串行化解决方案"></a>为什么要有非可串行化解决方案</h4><p>在某些应用中，串行化方案可能会影响并发性能，但是应用并不需要精确的信息，因此可以牺牲串行性而提高并发性。</p><h4 id="二级一致性"><a href="#二级一致性" class="headerlink" title="二级一致性"></a>二级一致性</h4><h4 id="弱一致性要解决的问题"><a href="#弱一致性要解决的问题" class="headerlink" title="弱一致性要解决的问题"></a>弱一致性要解决的问题</h4><ol><li>脏读(Dirty read)：当前事务读取的数据项已经过时，原因是其他事务已经修改了该数据，但是并未最后提交（也可能最终回滚）。总之，当前事务读到的数据是不可靠的，是「脏数据」。</li><li>不重复读(Unrepeatable read)：同一个事务连续两次读取同一数据项 $x$，间隙之间其他事务修改了数据项 $x$，因此本事务先后两次读到的数据结果会不一致。</li><li>幻读(Phantom Read)：当前事务进行某个范围数据的读或者写的操作的同时，另一个事物插入了符合当前事务读写约束的新数据，当前事务再更新时，惊奇地发现了这些新数据，貌似之前读到的数据是幻觉一样。</li></ol><h4 id="弱一致性的级别：由弱到强一次解决上述3个问题"><a href="#弱一致性的级别：由弱到强一次解决上述3个问题" class="headerlink" title="弱一致性的级别：由弱到强一次解决上述3个问题"></a>弱一致性的级别：由弱到强一次解决上述3个问题</h4><ul><li>未提交读(Read uncommited)：读操作不加锁，可能读到已经过时的数据，存在「脏读」的问题。</li><li>已提交读(Read commited)：只允许读取已提交记录，但是不要求可重复读。事务连续两次读取同一数据之间会释放锁，因此两次读取结果不保证一样。解决了「脏读」，但是不解决「不重复读」。</li><li>可重复读(Repeatable read)：只允许读取已提交记录，且同一个事务两次读取同一数据项 $x$ 得到的结果是一致的。事务在提交之前不会释放锁。解决了「脏读」、「不重复读」问题，但是解决不了「幻读(Phantom Read)」。</li><li>串行化(Serializable)：执行结果跟串行执行一样。解决了「幻读」问题。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td style="text-align:center">未提交读(Read uncommited)</td><td style="text-align:center">N</td><td style="text-align:center">N</td><td style="text-align:center">N</td></tr><tr><td style="text-align:center">已提交读(Read commited)</td><td style="text-align:center">Y</td><td style="text-align:center">N</td><td style="text-align:center">N</td></tr><tr><td style="text-align:center">可重复读(Repeatable read)</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">N</td></tr><tr><td style="text-align:center">串行化(Serializable)</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr></tbody></table></div><h2 id="高效的数据库系统为什么对操作系统是有要求？"><a href="#高效的数据库系统为什么对操作系统是有要求？" class="headerlink" title="高效的数据库系统为什么对操作系统是有要求？"></a>高效的数据库系统为什么对操作系统是有要求？</h2><p>数据库系统进行数据操作的逻辑单元—事务，包含两个访问数据的核心操作：</p><ul><li><code>read(x)</code>：从数据库中把数据项 $x$ 传送到执行 <code>read</code> 操作的事务的局部缓冲区</li><li><code>write(x)</code>：从执行<code>write(x)</code> 操作的事务的局部缓冲区把数据项 $x$ 传回数据库</li></ul><h3 id="困难-2"><a href="#困难-2" class="headerlink" title="困难"></a>困难</h3><p>数据库系统为了实现「持久性」，必须遵守先写日志（write-ahead logging，WAL）规则，这样从数据库文件中读出的存放在内存中的数据块就不能由操作系统自由写回，而应该由数据库系统根据日志的完成情况，强制输出缓冲块。</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>数据库系统保留部分内存作为缓冲区并进行管理，而不是让操作系统来管理。</li></ol><ul><li>优点：由数据库管理，可以完全按照符合数据库规则的方式使用，效率高。</li><li>缺点：这部分保留内存无法被数据库以外的应用使用，限制了内存使用的灵活性。</li></ul><ol><li>数据库在操作系统提供的虚拟内存中实现缓冲区。</li></ol><ul><li>缺点：大部分操作系统都会完全控制虚拟内存，导致当数据库系需要输出某个数据块时（保存在虚拟内存中），需要更多次的操作。</li></ul><h2 id="死锁-Dead-lock-如何处理？"><a href="#死锁-Dead-lock-如何处理？" class="headerlink" title="死锁(Dead lock)如何处理？"></a>死锁(Dead lock)如何处理？</h2><p>死锁就是循环「等待(wait)」，只要事务需要等待，就有可能存在死锁。处理死锁问题的思路：</p><ol><li>死锁预防(deadlock prevention)：对加锁请求进行排序或者要求同时获得所有锁来确保不会发生循环等待。</li><li>死锁恢复(deadlock recovery)：在检测出死锁之后，根据一定的规则选择某些事务进行回滚，打破循环等待的状态。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>Database System Concepts（数据库系统概念）</li><li><a href="https://draveness.me/mysql-transaction">『浅入深出』MySQL 中事务的实现</a></li><li><a href="http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html">MySQL的InnoDB的幻读问题</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是「事务」？&quot;&gt;&lt;a href=&quot;#什么是「事务」？&quot; class=&quot;headerlink&quot; title=&quot;什么是「事务」？&quot;&gt;&lt;/a&gt;什么是「事务」？&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2022/04/11/%E4%BA%8B%E5%8A%A1transaction%E7%AE%80%E4%BB%8B/transaction.png&quot; alt=&quot;「技术笔记」数据库系统概念-事务transaction 总结&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
&lt;p&gt;数据库事务通常包含了&lt;u&gt;一序列的对数据库的&lt;strong&gt;读/写&lt;/strong&gt;操作&lt;/u&gt;，是一系列操作的集合。包含有以下两个目的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为数据库操作序列提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。&lt;/li&gt;
&lt;li&gt;当多个&lt;a href=&quot;https://zh.wikipedia.org/wiki/应用程序&quot;&gt;应用程序&lt;/a&gt;在&lt;a href=&quot;https://zh.wikipedia.org/wiki/并发&quot;&gt;并发&lt;/a&gt;访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当事务被提交给了&lt;a href=&quot;https://zh.wikipedia.org/wiki/数据库管理系统&quot;&gt;数据库管理系统&lt;/a&gt;（DBMS），则DBMS需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要&lt;a href=&quot;https://zh.wikipedia.org/wiki/回滚_(数据管理&quot;&gt;回滚&lt;/a&gt;)，回到事务执行前的状态；同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行。&lt;/p&gt;</summary>
    
    
    
    <category term="课程笔记" scheme="https://dave0126.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="并发系统" scheme="https://dave0126.github.io/tags/%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="SQL" scheme="https://dave0126.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Transition System(变迁系统) 与 TLA+</title>
    <link href="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/"/>
    <id>https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/</id>
    <published>2022-03-29T08:59:58.000Z</published>
    <updated>2022-06-14T12:50:38.697Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Transition-System-变迁系统-与-TLA"><a href="#Transition-System-变迁系统-与-TLA" class="headerlink" title="Transition System(变迁系统) 与 TLA+"></a>Transition System(变迁系统) 与 TLA+</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><a href="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/">本文章</a>是根据法国国立高等电力技术、电子学、计算机、水力学与电信学校 (E.N.S.E.E.I.H.T.) 第八学期课程“Système de Transition”总结而来的课程笔记。碍于本人学识有限，部分叙述难免存在纰漏，请读者注意甄别。</p><p>参考：</p><ul><li><a href="https://blog.csdn.net/campsisgrandiflora/category_10509594.html">系统分析与验证 - Campsisgrandiflora的博客</a> </li><li>《 Introduction to TLA 》- Lesie Lamport</li></ul><span id="more"></span><h4 id="变迁系统"><a href="#变迁系统" class="headerlink" title="变迁系统"></a>变迁系统</h4><p>在计算机科学和控制理论中，“变迁系统”用数学的方法描述离散系统的行为。变迁系统主要由“状态”和状态之间的“状态迁移”组成。 有标号的变迁系统可以从已定义的标签集合中选择相应标签来标记状态迁移，而且相同的标签可能被应用在多个状态迁移上。 变迁系统也可以是无标记的，此时也可以认为标签集合中只有单一标签元素，从而省略了状态迁移上的标签记号。</p><p>变迁系统在数学定义上和<strong>有向图</strong>一致，但与<strong>有限状态自动机</strong>有一定不同。</p><p>变迁系统的特点有：</p><ul><li>系统状态的集合不一定是有限的或可数的；</li><li>状态迁移的集合不一定是有限的或可数的；</li><li>变迁系统并不需要给出“开始”状态或“最终”状态；</li><li>变迁系统可以表示为<strong>有向图</strong>，有限状态自动机则不能。</li></ul><p>资料来源于<a href="https://zh.wikipedia.org/wiki/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F">维基百科：变迁系统</a></p><h4 id="TLA"><a href="#TLA" class="headerlink" title="TLA+"></a>TLA+</h4><h5 id="形式化验证"><a href="#形式化验证" class="headerlink" title="形式化验证"></a>形式化验证</h5><p>形式化验证技术想要解决的核心问题是：软件总是可能存在 Bug 的，而测试始终无法涵盖所有可能性，特别是对于并发系统及分布式系统来说，就算单元测试达到了 100% 分支覆盖率，也不能肯定的说这个系统在线程安全，一致性等方面不会出问题。那如何更好的来验证我们的程序是否符合预期呢？</p><p>形式化验证就旨在使用严谨的数学证明方法来证明某一算法是正确的。</p><h5 id="TLA-1"><a href="#TLA-1" class="headerlink" title="TLA+"></a>TLA+</h5><p><strong>T</strong>emporal <strong>L</strong>ogic of <strong>A</strong>ctions <strong>+</strong>是由<em>Leslie Lamport</em>开发的一种【形式化验证语言】。它用于设计、建模、记录和验证程序，尤其是并发系统和分布式系统。TLA +被描述为可完全测试的伪代码，其用途类似于为软件系统绘制蓝图。</p><p>由于 TLA+ 写的代码并不是用来实际运行的，故一般将其代码称为模型（Model）而非程序（Program）。</p><h4 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h4><ol><li><a href="https://learntla.com/">Learn TLA+</a></li><li><a href="https://lamport.azurewebsites.net/video/videos.html">L. Lamport 关于TLA+的视频</a></li><li><a href="https://lamport.azurewebsites.net/tla/tla.html">其他资源</a></li></ol><h3 id="第一部分：Transition-System"><a href="#第一部分：Transition-System" class="headerlink" title="第一部分：Transition System"></a>第一部分：Transition System</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><h5 id="变迁系统-1"><a href="#变迁系统-1" class="headerlink" title="变迁系统"></a>变迁系统</h5><p>Transition System在计算机科学中通常用作描述系统行为的模型，它是一种有向图，节点代表状态，边代表着状态的转化。</p><p>状态（state）描述了系统在其行为的特定时刻的一些信息。<br>例如，交通灯的状态指示灯的当前颜色。类似地，顺序计算机程序的状态指示所有程序变量的当前值，以及指示要执行的下一个程序语句的程序计数器的当前值。</p><p>转变（transition）指定系统如何从一种状态演变为另一种状态。<br>对交通信号灯来说，转换表示从一种颜色切换到另一种颜色。而对于顺序程序，转换通常对应于语句的执行，并且可能涉及某些变量和程序计数器的更改。</p><p>下面给出一种Transition System（TS）的定义</p><p>变迁系统是一个三元组$⟨S,I,R⟩$:</p><ul><li>$S$ 是状态集。包含 <strong>终结状态</strong> 和 <strong>非终结状态</strong></li><li>$I \subseteq S$ 是一个 <strong>初始状态</strong></li><li>$R \subseteq S \times S$ 是状态对之间的（转换）关系。$(s,s’) \in R$ 表示系统从状态 $s$ 到状态$s’$ 的转换。我们假定 $s$ 表示现在时刻的状态集合， $s$ 中的变量称为现态， $s’$ 表示发生转变之后的状态集合， $s’$ 中的变量称为次态。</li></ul><p>例：</p><script type="math/tex; mode=display">S = {S_0, S_1, S_2, S_3,S_4}</script><script type="math/tex; mode=display">I = {S_0}</script><script type="math/tex; mode=display">R = \{(S_0,S_0), (S_0,S_1), (S_0,S_2), (S_2,S_3), (S_3,S_4), (S_4,S_3)\}</script><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29 13.16.51-8552669.png" alt="2022-03-29 13.16.51" style="zoom:67%;"></p><h6 id="直接后继（Direct-Successors）"><a href="#直接后继（Direct-Successors）" class="headerlink" title="直接后继（Direct Successors）"></a>直接后继（Direct Successors）</h6><p>定义为：</p><script type="math/tex; mode=display">Post(s,α)=\{s'∈S | s\xrightarrow{α}s' \}</script><p>就是指状态$s$执行动作$α$之后能达到的状态的集合</p><p>如果α为任意动作，可以记为：</p><script type="math/tex; mode=display">Post(s)=\bigcup_{α∈Act}Post(s,α)</script><h6 id="直接前任（Direct-Predecessors）"><a href="#直接前任（Direct-Predecessors）" class="headerlink" title="直接前任（Direct Predecessors）"></a>直接前任（Direct Predecessors）</h6><script type="math/tex; mode=display">Pre(s, α) =\{s'∈S|s'\xrightarrow{α}s\}</script><p>指通过执行动作α之后能达到状态s的状态集合</p><p>同理，α如果为任意动作，则记为：</p><script type="math/tex; mode=display">Pre(s)=\bigcup_{α∈Act}Pre(s,α)</script><p>用图来表示前任和后继的话就是这样子的：</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/20201127224956365.png" alt="20201127224956365" style="zoom:50%;"></p><h6 id="终止状态"><a href="#终止状态" class="headerlink" title="终止状态"></a>终止状态</h6><p>对于TS模型来说，终止状态就是指没有后继状态的状态，即$Post(s)=\varnothing$</p><p>串行程序的终止状态代表着程序的终止。</p><p>对于并行程序来说，我们一般不考虑它的终止状态，因为并行程序大都要求持续运行下去。</p><h6 id="确定性TS（Deterministic-Transition-System）"><a href="#确定性TS（Deterministic-Transition-System）" class="headerlink" title="确定性TS（Deterministic Transition System）"></a>确定性TS（Deterministic Transition System）</h6><p>如果</p><script type="math/tex; mode=display">|S_{0}|≤1\;and\;|Post(s,α)|≤1</script><p>那么这个TS就可以称为动作确定的TS</p><p>如果</p><script type="math/tex; mode=display">|S_{0}|≤1\;and\;|Post(s,α)\cap \{s'∈S|L(s')=A\}|≤1(A∈2^{AP})</script><p>那么这个TS就可以称为AP确定的TS</p><h5 id="序列（Sequence）"><a href="#序列（Sequence）" class="headerlink" title="序列（Séquence）"></a>序列（Séquence）</h5><p>$S$ 是状态集：</p><ul><li>$S^<em>$ 是 $S$ 上的<em>*有限序列集</em></em>；</li><li>$S^w$ 是 $S$ 上的<strong>无限数据集</strong>；</li><li>$\sigma _i$ 是序列 $\sigma$ 从 0 开始的第 $i$个元素。</li><li>序列 $S$ 用以下形式表示：$⟨s1 → s2 → …⟩$</li><li>$⟨⟩$ 表示空序列；</li></ul><p>对于一个有限序列$\sigma$ ：</p><ul><li>$\sigma^<em>$ 是由任意的 $\sigma $ 重复产生的<em>*有限序列集</em></em>。</li><li>$\sigma^+ \triangleq \sigma^* \backslash \{ ⟨⟩ \}$</li><li>$\sigma^w$  是由任意的 $\sigma $ 重复产生的无限序列集。</li></ul><h5 id="迹（trace）"><a href="#迹（trace）" class="headerlink" title="迹（trace）"></a>迹（trace）</h5><h6 id="有限轨迹（Traces-finies）"><a href="#有限轨迹（Traces-finies）" class="headerlink" title="有限轨迹（Traces finies）"></a>有限轨迹（Traces finies）</h6><p>令 $⟨S, I, R⟩$ 是一个变迁系统。我们称有限迹为有限序列$\sigma \in S^*$ 使得</p><ul><li><p>$\sigma = ⟨s_0 → s_1 → … → s_{n-1} → s_n ⟩$</p></li><li><p>$\forall i \in [0 … n[:(s_i, s_{i-1}) \in R$</p></li></ul><h6 id="最大有限轨迹（Traces-finies-maximales）"><a href="#最大有限轨迹（Traces-finies-maximales）" class="headerlink" title="最大有限轨迹（Traces finies maximales）"></a>最大有限轨迹（Traces finies maximales）</h6><p>当有限轨迹$⟨s_0 → s_1 → … → s_{n-1} → s_n ⟩ \in S^*$ 时，我们称它是最大的。$s_n$没有后继状态，即$\forall s \in S:(s_n, s) \notin R$</p><h6 id="无限轨迹（Trace-infinies）"><a href="#无限轨迹（Trace-infinies）" class="headerlink" title="无限轨迹（Trace infinies）"></a>无限轨迹（Trace infinies）</h6><p>令 $⟨S, I, R⟩$ 是一个变迁系统，并且$s_0 \in S$。我们称从 $s_0$开始到元素 $tr \in S^w$ 的无限序列为</p><ul><li><p>$tr = ⟨s_0 → s_1 → s_2 → … ⟩$</p></li><li><p>$\forall i \in \mathbb{N}:(s_i, s_{i+1}) \in R$</p></li></ul><h6 id="来自状态的轨迹（Traces-issues-d’un-etat）"><a href="#来自状态的轨迹（Traces-issues-d’un-etat）" class="headerlink" title="来自状态的轨迹（Traces issues d’un état）"></a>来自状态的轨迹（Traces issues d’un état）</h6><p>令 $⟨S, I, R⟩$ 是一个变迁系统，并且$s \in S$。</p><ul><li>$Traces(s) $ 是从状态$s$ 开始的最大无限或有限轨迹的集合。</li></ul><h5 id="执行（Executions）"><a href="#执行（Executions）" class="headerlink" title="执行（Exécutions）"></a>执行（Exécutions）</h5><p>令 $⟨S, I, R⟩$ 是一个变迁系统，</p><p>一次执行片段 $σ = ⟨s_0 →…⟩ $ 是满足 $s_0 ∈ I $ 的最大无限或有限轨迹（如果是有限执行片段，那么它结束于终止状态，或者该片段是一个无限执行片段）。</p><ul><li>$Exec(S)$ 是 $S = \bigcup_{s_0 \in I} Traces(s_0)$ 的执行集。</li><li>如果 $I = ∅$，则我们有一个（也是唯一一个）空执行$ ⟨⟩$。</li><li>如果一个初始、有限执行片段的终止状态为s，那么s称为<strong>可达的</strong>(reachable)，直观来说，可达表示从初始状态开始能够到达某个状态。我们把所有的可达状态记为<strong>Reach(TS)</strong></li></ul><h5 id="练习一"><a href="#练习一" class="headerlink" title="练习一"></a>练习一</h5><h6 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h6><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29 13.16.51-8552669.png" alt="2022-03-29 13.16.51" style="zoom:67%;"></p><p>$s_0 → s_0 → s_2 → s_3$ 是一段非最大的有限轨迹。</p><ol><li>$Traces(s_1) = ⟨s_1⟩$</li><li>$Traces(s_3) = ⟨(s_3 → s_4)^w⟩$</li><li>$Traces(s_2) = ⟨s_2 → (s_3 → s_4)^w⟩$</li><li>$Traces(s_0) = ⟨{s_0}^w⟩, ⟨{s_0}^+ → s_1⟩, ⟨s_0 → s_2 → (s_3 → s_4)^w⟩$</li><li>$Exec(S) = Traces(s_0)$</li></ol><h6 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h6><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29 13.28.06-8553323.png" alt="2022-03-29 13.28.06" style="zoom:67%;"></p><ol><li>$Traces(s_2) = ⟨s_2 → s_4⟩, ⟨(s_2 → s_3 → s_0 → s_1)^w⟩, ⟨(s_2 → s_3 → s_0 → s_1)^* → s_2 → s_4⟩$</li><li>$Traces(s_0) = ⟨(s_0 → s_1 → s_2 → s_3⟩^w, ⟨s_0 → s_1 → (s_2 → s_3 → s_0 → s_1)^* → s_2 → s_4⟩$</li><li>$Exec(S) = Traces(s_0)$</li></ol><h6 id="例三"><a href="#例三" class="headerlink" title="例三"></a>例三</h6><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29 13.48.33-8554538.png" alt="2022-03-29 13.48.33" style="zoom:67%;"></p><ol><li>$Traces(s_2) = ⟨(s_2 → s_3)^w⟩, ⟨(s_2 → s_3)^* → s_2 → s_4⟩$</li><li>$Traces(s_0) = ⟨(s_0 → (s_2 → s_3)^w⟩, ⟨(s_0 → (s_2 → s_3)^* → s_2 → s_4⟩$</li><li>$Traces(s_1) = ⟨(s_1 → (s_3 → s_2)^w⟩, ⟨(s_1 → (s_3 → s_2)^+ → s_4⟩$</li><li>$Exec(S) = Traces(s_0) \cup Traces(s_1)$</li></ol><h5 id="可访问状态（Etats-accessibles）"><a href="#可访问状态（Etats-accessibles）" class="headerlink" title="可访问状态（Etats accessibles）"></a>可访问状态（Etats accessibles）</h5><p>令 $⟨S, I, R⟩$ 是一个变迁系统。</p><ul><li>$s ∈ S$ 是一个可访问状态 $\triangleq $ 有一个通过 $s$ 的执行（或等价的，有一个以 $s$ 结尾的执行前缀）;</li><li>$Acc(S)$ 是 $S$ 的可访问状态集。</li></ul><h5 id="执行图（Graphe-des-Executions）"><a href="#执行图（Graphe-des-Executions）" class="headerlink" title="执行图（Graphe des Exécutions）"></a>执行图（Graphe des Exécutions）</h5><p>令 $⟨S, I, R⟩$ 是一个变迁系统。</p><p>执行图是有向图，其中：</p><ul><li>顶点集是 $Acc(S)$；</li><li>有向边的集合是 $R$，仅限于可访问状态。</li></ul><p>因此它是$ ⟨S ∩ Acc(S), R ∩ (Acc(S) × Acc(S))⟩ $ 的图。</p><h5 id="被标记的变迁系统（Systeme-de-Transitions-etiquete-）"><a href="#被标记的变迁系统（Systeme-de-Transitions-etiquete-）" class="headerlink" title="被标记的变迁系统（Systeme de Transitions étiqueté ）"></a>被标记的变迁系统（Systeme de Transitions étiqueté ）</h5><p>被标记的变迁系统 是一个五元组$⟨S、I、R、L、Etiq⟩$：</p><ul><li>$S$：状态集。</li><li>$I ⊆ S$：初始状态集。</li><li>$R ⊆ S × S$：状态对之间的转换关系。</li><li>$L$：标签集。</li><li>$Etiq$：将标签与每个转换(transition) 相关联的函数：$Etiq ∈ R → L$。带</li></ul><p>被标记的变迁系统 非常接近自动机。但是没有 terminal state + infinity execution。</p><p>被标记的变迁系统 $⟨S, I, R, L, Etiq⟩$ <strong>等价于</strong>由如下定义的 未标记系统$⟨S’, I’, R’⟩$ ：</p><ul><li>$S’ = (L \cup \{ \epsilon \}) \times S$</li><li>$I’ = \{ \epsilon \} \times I$</li><li>$R’ = \{ ( ⟨I,s⟩, ⟨I’,s’⟩ )| (s, s’) \in R \land I’ = Etiq(s,s’)\}$</li></ul><p>转换(transition) $s_1 \xrightarrow{a} s_2 $ 可变成 $ ⟨$_$,s_1⟩ \to ⟨a,s_2⟩$，其中 _ 是任何标签。</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29 15.18.04.png" alt="2022-03-29 15.18.04" style="zoom:50%;"></p><p>可变为</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29 15.19.07-8559976.png" alt="2022-03-29 15.19.07" style="zoom:50%;"></p><h5 id="变迁系统-不等于-自动机"><a href="#变迁系统-不等于-自动机" class="headerlink" title="变迁系统 不等于 自动机"></a>变迁系统 不等于 自动机</h5><ul><li>转换没有标签：Pas d’étiquette sur les transitions (ou comme si)</li><li>转换不是由环境引起的：Une transition n’est pas causée par l’environnement</li><li>没有终结状态：Pas d’états terminaux</li><li>可能有许多的有限状态：Nombre d’états infini possible</li><li>可能有无限的执行：Exécution infinie possible</li></ul><h4 id="表示形式"><a href="#表示形式" class="headerlink" title="表示形式"></a>表示形式</h4><h5 id="显式的表示"><a href="#显式的表示" class="headerlink" title="显式的表示"></a>显式的表示</h5><p>在执行图(Graphe d’exécution) 中显式地给出，例如以图像形式或通过顶点和边的集合。仅适用于<strong>状态和转换数量有限</strong>的变迁系统。</p><h5 id="隐式的表示"><a href="#隐式的表示" class="headerlink" title="隐式的表示"></a>隐式的表示</h5><p>基于变量的变迁系统的三元组$ ⟨V, Init,Trans⟩ $ 中，</p><ul><li>$V = \{ v_1, …, v_n\}$：有限的的变量集；</li><li>$Init(v_1, …, v_n)$ ：定义初始状态并与变量 $v_i$ 相关的谓词（系数）</li><li>$Trans(v_1, …, v_n, {v_1}’, …, {v_n}’)$：谓词定义转换，涉及表示当前状态的变量 $v_i$ 和表示后续状态的变量 ${v_i}’$。</li></ul><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><h6 id="有界计数器"><a href="#有界计数器" class="headerlink" title="有界计数器"></a>有界计数器</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; N) &#123;</span><br><span class="line">i = i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在显式的表示中，$N = 5$:</li></ol><script type="math/tex; mode=display">⟨(0, 1, 2, 3, 4, 5), \{ 0\}, \{ (0,1), (1,2), (2,3), (3,4), (4,5)\}⟩</script><p>​    执行图(Graphe d’exécution)为</p><script type="math/tex; mode=display">0 \to 1 \to 2 \to 3 \to 4 \to5</script><ol><li>隐式的表示为：</li></ol><ul><li>$V \triangleq i \in \mathbb{N}$</li><li>$Init \triangleq i = 0$</li><li>$Trans \triangleq i &lt; N \land i’ = i+1$ 或 $Trans \triangleq i’ \leq N \land i’-i=1$ </li></ul><h6 id="循环计数器"><a href="#循环计数器" class="headerlink" title="循环计数器"></a>循环计数器</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">i = (i+<span class="number">1</span>) % N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在显式的表示中，$N = 4$:</li></ol><script type="math/tex; mode=display">⟨(0, 1, 2, 3, 4), \{ 0\}, \{ (0,1), (1,2), (2,3), (3,4), (4,0)\}⟩</script><p>​    执行图(Graphe d’exécution)为</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29 16.53.51-8565663.png" alt="2022-03-29 16.53.51" style="zoom:40%;"></p><ol><li>隐式的表示为：</li></ol><ul><li>$V \triangleq i \in \mathbb{N}$</li><li>$Init \triangleq i = 0$</li><li>$Trans \triangleq i’ = (i+1) \mod N $ </li></ul><h6 id="振荡整数"><a href="#振荡整数" class="headerlink" title="振荡整数"></a>振荡整数</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">i &gt; <span class="number">0</span> -&gt; i = i - <span class="number">1</span>;</span><br><span class="line">or</span><br><span class="line">  i &lt; N -&gt; i = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在显式的表示中，$N = 5$:</li></ol><script type="math/tex; mode=display">⟨(0, 1, 2, 3, 4, 5), \{ 0\}, \{ (0,1), (1,2), (2,3), (3,4), (4,5), (5,4), (4,3), (3,2), (2,1)\}⟩</script><p>​    执行图(Graphe d’exécution)为</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29 17.02.57.png" alt="2022-03-29 17.02.57" style="zoom:40%;"></p><ol><li>隐式的表示为：</li></ol><ul><li>$V \triangleq i \in \mathbb{N}$</li><li>$Init \triangleq i = 0$</li><li>$Trans \triangleq (i &gt; 0 \land i’=i-1) \lor (i &lt; N \land i’=i+1) $ 或 $Trans \triangleq \left| i’ -i \right| = 1 \land 0 \leq i’ \leq N$</li></ul><h5 id="表示形式所对应的变迁系统"><a href="#表示形式所对应的变迁系统" class="headerlink" title="表示形式所对应的变迁系统"></a>表示形式所对应的变迁系统</h5><p>对于符号描述$⟨V, Init,Trans⟩$，对应的变迁系统是$⟨S, I, R⟩$，其中：</p><ul><li>$S = \prod_{i \in 1..n} D_i$ ，其中$D_1,…,D_n$ 是变量 $v_1, …, v_n$ 的域（类型）</li><li>$I = \{ (v_1,…,v_n) | Init(v_1, …, v_n)\}$</li><li>$R = \{ ((v_1, …, v_n),({v_1}’, …, {v_n}’)) | Trans(v_1, …, v_n,{v_1}’, …, {v_n}’)\}$</li></ul><h5 id="状态谓词（Predicat-d’etat）"><a href="#状态谓词（Predicat-d’etat）" class="headerlink" title="状态谓词（Prédicat d’état）"></a>状态谓词（Prédicat d’état）</h5><p>状态谓词是与隐式表示的系统的（状态）变量有关的谓词。</p><p>状态谓词可以看作是 S 的一部分的特征函数。</p><h5 id="转换谓词（Predicat-de-transition）"><a href="#转换谓词（Predicat-de-transition）" class="headerlink" title="转换谓词（Prédicat de transition）"></a>转换谓词（Prédicat de transition）</h5><p>转换谓词是与已启动和未启动（状态）变量相关的谓词。</p><p>转换谓词可以看作是 $S × S$ 子集的特征函数。</p><h5 id="实例：谓词"><a href="#实例：谓词" class="headerlink" title="实例：谓词"></a>实例：谓词</h5><p>$V \triangleq n \in \mathbb{N} $ </p><p>$Init \triangleq -5 \leq n \leq 5$</p><p>$Trans \triangleq n \neq 1 \land ((n’ = n/2 \land n \equiv 0[2]) \lor (n’ = (3n+1)/2 \land n \equiv 1[2]))$</p><ul><li><p>Prédicat d’état : $ Init, n &lt; 20 $</p></li><li><p>Prédicat de transition : $Trans, n’ − n &gt; 3$</p></li></ul><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><h5 id="阻塞（Blocage）"><a href="#阻塞（Blocage）" class="headerlink" title="阻塞（Blocage）"></a>阻塞（Blocage）</h5><h6 id="死锁（Interblocage）"><a href="#死锁（Interblocage）" class="headerlink" title="死锁（Interblocage）"></a>死锁（Interblocage）</h6><p>一个系统有一个死锁  $\triangleq$  存在一个可访问的状态，没有关系 R 的后继。等效地，如果执行（execution）有限，系统就会出现死锁。</p><p>对于建模经典顺序程序的系统，死锁相当于终止。</p><h5 id="可复位（Reinitialisable）"><a href="#可复位（Reinitialisable）" class="headerlink" title="可复位（Réinitialisable）"></a>可复位（Réinitialisable）</h5><p>一个系统可以从任何可访问的状态重置  $\triangleq$  有一个有限轨迹导致一个初始状态。</p><p>这个属性意味着在任何时候，都有一系列的转换（transitions）返回到系统的初始状态，从而重新启动。 这样的系统只有无限的执行。</p><h5 id="重复（Begaiement）"><a href="#重复（Begaiement）" class="headerlink" title="重复（Bégaiement）"></a>重复（Bégaiement）</h5><p>重复状态  $\triangleq$  状态有一个循环：$(s,s) ∈ R$。</p><p>一个重复变迁系统  $\triangleq$  任何状态都有一个到自身的循环：$Id ⊆ R$。</p><p><strong>用处</strong></p><ol><li>我们可以在 $s_0$ 中停留任意时间后进入 $s_1$。</li></ol><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29 17.55.30.png" alt="2022-03-29 17.55.30" style="zoom:50%;"></p><ol><li>无限的执行：在无重复系统中，任何没有后继者的状态都有一个独特的后继者：它自己。</li><li>终止状态时（或死锁）$… \to s_i$  就相当于  $… \to {s_i}^w$</li><li>可以组成几个变迁系统。</li></ol><h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><h5 id="自由组合"><a href="#自由组合" class="headerlink" title="自由组合"></a>自由组合</h5><p>变迁系统 $⟨V,I,T⟩$  由带有重复的 $⟨V_1, I_1,T_1⟩$ 和 $⟨V_2, I_2, T_2⟩ $ 组成， 其中：</p><ul><li>$V \triangleq V_1 \cup V_2$ ：变量$V_1$和$V_2$的并集</li><li>$I \triangleq I_1 \land I_2$ ：每个子系统都从它的一个初始状态开始</li><li>$ T \triangleq T_1 ∧ T_2 $ ：每个子系统都根据其转换（transition）演变</li></ul><p>由于 $T_1$ 和 $T_2$ 中有循环的状态，因此 $T_1 ∧ T_2$ 意味着我们可以单独执行 $T_1$ 的转换和 $T_2$ 的循环，反之亦然，甚至可以与 $T_2$ 同时执行 $T_1$。</p><p>例：</p><script type="math/tex; mode=display">\left(    \begin{matrix}        V_1 \triangleq i \in \mathbb{N}\\        I_1 \triangleq i = 0 \\        T_1 \triangleq            \begin{cases}                i'=i+1\\        \lor \ i'=i\\            \end{cases}\\    \end{matrix}\right)\otimes\left(    \begin{matrix}        V_2 \triangleq j \in \mathbb{N}\\        I_2 \triangleq j = 0 \\        T_2 \triangleq            \begin{cases}                j'=j+1\\        \lor \ j'=j\\            \end{cases}\\    \end{matrix} \right)\to\left(    \begin{matrix}        V \triangleq i,j \in \mathbb{N}\\        I \triangleq i=0 \land j=0\\        T \triangleq            \begin{cases}                i'=i+1 \land j' = j\\        \lor \ (i'=i \land j'=j+1)\\        \lor \ (i'=i+1 \land j'=j+1)\\        \lor \ (i'=i \land j'=j)            \end{cases}\\    \end{matrix}\right)</script><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30 20.56.29.png" alt="2022-03-30 20.56.29" style="zoom:40%;"></p><h5 id="严格同步的组合"><a href="#严格同步的组合" class="headerlink" title="严格同步的组合"></a>严格同步的组合</h5><p>变迁系统 $⟨S,I,R,L⟩$  由标记为 $⟨S_1,I_1,R_1,L_1⟩$ 和  $⟨S_2,I_2,R_2,L_2⟩$ 严格同步地组成， 其中：</p><ul><li>$S \triangleq S_1 \times S_2$ ：状态对</li><li>$I \triangleq I_1 \times I_2$ ：每个子系统都从它的一个初始状态开始</li><li>$R \triangleq \{ ((s_1, s_2), ({s_1}’, {s_2}’)) | (s_1, {s_1}’) \in R_1 \land (s_2, {s_2}’) \in R_2 \land Etiq((s_1, {s_1}’)) = Etiq((s_2, {s_2}’)) \}$ ：这两个子系统严格根据带有相同标签转换</li><li>$ L \triangleq L_1 \cap L_2 $ </li></ul><p>例：</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30 21.14.36.png" alt="2022-03-30 21.14.36" style="zoom:45%;"></p><ol><li>Synchronizé strict avec LIFO 2 éléments (pile)</li></ol><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30 21.16.51.png" alt="2022-03-30 21.16.51" style="zoom:45%;"></p><p>​    Donne：</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30 21.18.02.png" alt="2022-03-30 21.18.02" style="zoom:40%;"></p><ol><li>Synchronizé strict avec FIFO 2 éléments (file)</li></ol><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30 21.22.31.png" alt="2022-03-30 21.22.31" style="zoom:45%;"></p><p>​    Donne:</p><p>​    <img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30 21.23.35.png" alt="2022-03-30 21.23.35" style="zoom:40%;"></p><h5 id="Synchronise-ouvert-的组合"><a href="#Synchronise-ouvert-的组合" class="headerlink" title="Synchronisé ouvert 的组合"></a>Synchronisé ouvert 的组合</h5><p>变迁系统 $⟨S,I,R,L⟩$  由标记为 $⟨S_1,I_1,R_1,L_1⟩$ 和  $⟨S_2,I_2,R_2,L_2⟩$ 同步地组成， 其中：</p><ul><li><p>$S \triangleq S_1 \times S_2$ ：状态对</p></li><li><p>$I \triangleq I_1 \times I_2$ ：每个子系统都从它的一个初始状态开始</p></li><li><script type="math/tex; mode=display">R \triangleq \begin{cases}    ((s_1, s_2), ({s_1}', {s_2}')) | (s_1, {s_1}') \in R_1 \land (s_2, {s_2}') \in R_2 \land Etiq((s_1, {s_1}')) = Etiq((s_2, {s_2}'))\\    ((s_1, s_2), ({s_1}', {s_2})) | (s_1, {s_1}') \in R_1 \land Etiq((s_1, {s_1}')) \notin L_2\\    ((s_1, s_2), ({s_1}, {s_2}')) | (s_2, {s_2}') \in R_2 \land Etiq((s_2, {s_2}')) \notin L_1\end{cases}</script></li><li><p>$ L \triangleq L_1 \cap L_2 $ </p></li></ul><p>例：</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30 21.42.35.png" alt="2022-03-30 21.42.35" style="zoom:50%;"></p><p>Synchronizé strict avec LIFO 2 éléments (pile)</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30 21.16.51-8669562.png" alt="2022-03-30 21.16.51" style="zoom:45%;"></p><p>Donne：</p><ul><li>strict：</li></ul><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30 21.42.56.png" alt="2022-03-30 21.42.56" style="zoom:50%;"></p><ul><li><p>ouvert</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30 21.43.21.png" alt="2022-03-30 21.43.21" style="zoom:45%;"></p></li></ul><h3 id="第二部分：Action"><a href="#第二部分：Action" class="headerlink" title="第二部分：Action"></a>第二部分：Action</h3><p>在《概述》中，我们提到<strong>T</strong>emporal <strong>L</strong>ogic of <strong>A</strong>ctions <strong>+</strong>是由<em>Leslie Lamport</em>开发的一种<strong>【形式化验证语言】</strong>。</p><p>本章我们会简单介绍这种语言。</p><h4 id="规约-Specification"><a href="#规约-Specification" class="headerlink" title="规约 Specification"></a>规约 Specification</h4><h5 id="规约的结构"><a href="#规约的结构" class="headerlink" title="规约的结构"></a>规约的结构</h5><p>一个TLA+的Model里应该包含的元素有：</p><ul><li>常数 Constant</li><li>变量 Variable（状态 = 变量的值）</li><li>Init. State 由状态谓词定义的一组初始状态 </li><li>动作 Action = 连接两个状态的转换谓词：<ol><li>当前状态，未启动的变量</li><li>到达状态，主要变量</li></ol></li><li>由动作的析取构造的过渡谓词（≈无限重复动作）</li></ul><p>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">---------------- MODULE example ----------------</span><br><span class="line">EXTENDS Naturals</span><br><span class="line">VARIABLE x</span><br><span class="line"></span><br><span class="line">\* 初始状态 Init是初始化谓词（initial predicate）</span><br><span class="line">Init == x \in 0..2\* 等价于x属于自然数 并且 0 &lt;= x &lt; 3</span><br><span class="line"></span><br><span class="line">\* 动作</span><br><span class="line">Plus == x&#x27;=x+1</span><br><span class="line">Sub == x&gt;0 /\ x&#x27;=x-1</span><br><span class="line">Next == Plus \/ Sub\* Next是Next-state动作（action）</span><br><span class="line">Spec == Init /\ [] [ Next ]_&lt;&lt;x&gt;&gt;</span><br></pre></td></tr></table></figure><p>上述规约语言等价于下述变迁系统</p><ul><li>$V \triangleq x \in \mathbb{N}$</li><li>$I \triangleq 0 \le x \le 2$</li><li>$R \triangleq \begin{cases} x’ = x+1\\ \lor x&gt;0 \land x’=x-1\\ \lor x’=x \end{cases}$</li></ul><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30 23.53.48.png" alt="2022-03-30 23.53.48" style="zoom:40%;"></p><h5 id="常量-Constantes"><a href="#常量-Constantes" class="headerlink" title="常量 Constantes"></a>常量 Constantes</h5><ul><li>显式常量：0、1、true、false、“string”</li><li>命名常量：$_{CONSTANT} \ N$，通常伴随着属性：$_{ASSUME}\ N \in Nat \land N \ge 2$</li></ul><h5 id="表达式-Expression"><a href="#表达式-Expression" class="headerlink" title="表达式 Expression"></a>表达式 Expression</h5><p>一切可以公理化的东西：</p><ul><li>逻辑表达式：$¬， ∧， ∨， ∀x ∈ S:p(x)， ∃x ∈ S:p(x)$</li><li>算术表达式：$+，-，&gt;，…$</li><li>集合表达式： $∈$，$∪$，$∩$，$⊂$，$\{e1, e2, . . . , en\}$，$n..m$，$\{x ∈ S : p(x)\}$，$\{f (x) : x ∈ S\}$，$_{UNION}\  S$，$_{SUBSET} \ S$</li><li>$_{IF}$ … $_{THEN}$ … $_{ELSE}$ …</li><li>从 X 到 Y 的函数</li><li>元组、序列等</li></ul><h5 id="集合运算符-Operateurs-ensemblistes"><a href="#集合运算符-Operateurs-ensemblistes" class="headerlink" title="集合运算符 Operateurs ensemblistes"></a>集合运算符 Operateurs ensemblistes</h5><ul><li>$\{e_1, …,e_n\}$ ： 扩展成集合</li><li>$n ..m$ ： $i \in Nat : n \le i \le m$</li><li>$\{ x \in S : p(x)\}$ ：S 中满足性质 p 的元素集合<ul><li>例1，$\{ n \in 1..10 : n\%2=0\} = \{2,4,6,8,10\} $ </li><li>例2，$\{ n \in Nat : n\%2=1\} = \{所有的奇数\} $ </li></ul></li><li>$\{ f(x) :x \in S\} $ ：所有$f(x)$ 的值的集合<ul><li>例1，$\{ 2*n: n \in 1..5\} = \{2,4,6,8,10\} $ </li><li>例2，$\{2*n+1 : n \in Nat\} = \{所有的奇数\} $ </li></ul></li><li>$_{UNION}\ S$ ：S 的元素的并集<ul><li>$_{UNION} \{ \{ 1,2\},  \{ 3,4\}\} =  \{ 1,2,3,4\}$</li></ul></li><li>$_{SUBSET}\ S$：S的所有子集的集合<ul><li>$_{SUBSET} \{ 1,2\} = \{ \{\}, \{1\}, \{ 2\}, \{ 1,2\}\}$</li></ul></li></ul><h4 id="动作-Action"><a href="#动作-Action" class="headerlink" title="动作 Action"></a>动作 Action</h4><h5 id="操作符-Action-Operators"><a href="#操作符-Action-Operators" class="headerlink" title="操作符 Action Operators"></a>操作符 Action Operators</h5><ul><li>$e’$ :  The value of e in the final state of a step (迭代器中e的更新值)</li><li>$[A]_e$ : $[A ∨ (e’ = e)]$ </li><li>$⟨A⟩_e$ : $[A ∧ (e’ \ne e)]$</li><li>$_{ENABLE} \ A$ : [An A step is possible]</li><li>$_{UNCHANGED}\ E$ : $[e’ = e]$</li><li>$A · B$ : [Composition of actions]</li></ul><p>动作 = 转换谓词 = 包含常量、变量和引发变量的布尔表达式。</p><p>动作 不等于 任务</p><ul><li><p>$\begin{aligned} &amp; x’=x+1\\   &amp; \equiv x’-x=1\\   &amp; \equiv x=x’-1\\  &amp; \equiv (x&gt;1 \land x’/x=1 \land x’\%x=1) \lor (1=x \land 2=x’) \lor (x=0 \land x’ \in \{y \in Nat:y+1=2*y\})\\ \end{aligned}$</p></li><li><p>Other types of actions:</p><ul><li>$x’ &gt; x$ 或 $x’ ∈ \{x + 1, x + 2, x + 3\}$（不确定性）</li><li>$x’ ∈ \{y ∈ \mathbb{N}: ∃z ∈ N: z ∗ y = x ∧ z \% 2 = 0\}$（不可评估）</li><li>$x’ = y ∧ y’ = x$（多个变量）</li></ul></li></ul><h5 id="由连词组成的动作"><a href="#由连词组成的动作" class="headerlink" title="由连词组成的动作"></a>由连词组成的动作</h5><ol><li>仅与起始状态有关的状态谓词</li><li>确定性转移谓词 $var’ = . . .$ 或 非确定性转移谓词 $var’ ∈ …$</li></ol><p>例：$x &lt; 10 ∧ x’ = x + 1$，而不是 $x′ = x + 1 ∧ x’ &lt; 11$ 或 $x′ - x = 1 ∧ x’ &lt; 11$</p><h5 id="重复（Begaiement）-1"><a href="#重复（Begaiement）-1" class="headerlink" title="重复（Bégaiement）"></a>重复（Bégaiement）</h5><h6 id="Begaiement"><a href="#Begaiement" class="headerlink" title="Bégaiement"></a>Bégaiement</h6><p>$[\mathcal{A}]_f \triangleq \mathcal{A} ∨ f’ = f$ ，其中 $f$ 是变量元组。</p><p>示例：</p><p>$\begin{aligned} {[x’=x+1]_{⟨x,y⟩}} &amp; = {(x’=x+1 ∨ (⟨x, y⟩’=⟨x,y⟩))} \\     &amp; = {(x’= x+1 ∨ (x’=x ∧ y’=y))} \\ \end{aligned}$</p><h6 id="Non-Begaiement"><a href="#Non-Begaiement" class="headerlink" title="Non Bégaiement"></a>Non Bégaiement</h6><p>$[\mathcal{A}]_f \triangleq \mathcal{A} ∨ f’ \ne f$ ，其中 $f$ 是变量元组。</p><h6 id="无约束变量-Variables-non-contraintes"><a href="#无约束变量-Variables-non-contraintes" class="headerlink" title="无约束变量 Variables non contraintes"></a>无约束变量 Variables non contraintes</h6><p>$\begin{aligned} {(x′=x+1)} &amp; = {(x’=x+1 \land y’= 任何值 )} \\     &amp; \ne {(x’=x+1 \land y’=y)} \\ \end{aligned}$</p><h6 id="UNCHANGED"><a href="#UNCHANGED" class="headerlink" title="UNCHANGED"></a>UNCHANGED</h6><p>$_{UNCHANGED}\ e \triangleq e’ = e$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">---------------- MODULE AlternatingBit ----------------</span><br><span class="line">EXTENDS Naturals</span><br><span class="line">CONSTANT Data</span><br><span class="line">VARIABLE val, ready, ack</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">\* 初始状态 Init是初始化谓词（initial predicate）</span><br><span class="line">Init == /\ val \in Data</span><br><span class="line">/\ ready \in &#123;0,1&#125;</span><br><span class="line">/\ ack = ready</span><br><span class="line"></span><br><span class="line">Send == /\ ready = ack</span><br><span class="line">/\ val&#x27; \in Data</span><br><span class="line">/\ ready&#x27; = 1 - ready</span><br><span class="line">/\ UNCHANGED ack</span><br><span class="line"></span><br><span class="line">Receive == /\ ready # ac k</span><br><span class="line">/\ ack&#x27; = 1 - ack</span><br><span class="line">/\ UNCHANGED &lt;&lt;val, ready&gt;&gt;</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">Next == Send \/ Receive\* Next是Next-state动作（action）</span><br><span class="line">Spec == Init /\ [] [ Next ]_&lt;&lt;val, ready, ack&gt;&gt;</span><br><span class="line">=========================================================</span><br></pre></td></tr></table></figure><h4 id="函数-Function"><a href="#函数-Function" class="headerlink" title="函数 Function"></a>函数 Function</h4><p>“映射(mapping) ”意义上的函数，对应：</p><ul><li>$X \to Y$ : 从 X 到 Y 的一组函数。</li><li>$f \in [X \to Y]$ : X 在 Y 中的 f 函数</li><li>$f[x]$ : x 处的 f 值。</li></ul><p>一个函数就是一个值。<br>一个包含函数的变量可以改变它的值⇒“函数改变”。</p><h5 id="符号的定义-Definition-of-symbol"><a href="#符号的定义-Definition-of-symbol" class="headerlink" title="符号的定义 Definition of symbol"></a>符号的定义 Definition of symbol</h5><p>$f[x \in Nat]$ : 关于x的表达式。例 : $Inc[x \in Nat] \triangleq x+1$</p><h5 id="值的定义-Definition-of-value"><a href="#值的定义-Definition-of-value" class="headerlink" title="值的定义 Definition of value"></a>值的定义 Definition of value</h5><p>$[x \in S \mapsto expr]$. 例 : $x \in 1..4 \mapsto 2*x$</p><h5 id="表-Table"><a href="#表-Table" class="headerlink" title="表 Table"></a>表 Table</h5><p>函数 $t ∈ [X → Y ]$ 其中 X 是整数区间。</p><h5 id="定义域-Domain"><a href="#定义域-Domain" class="headerlink" title="定义域 Domain"></a>定义域 Domain</h5><p>$_{DOMAIN}\ f$ : f 的定义域</p><h5 id="值域-Codomaine"><a href="#值域-Codomaine" class="headerlink" title="值域 Codomaine"></a>值域 Codomaine</h5><p>$Codomain(f) \triangleq \{ f[x]:x \in _{DOMAIN}f\}$</p><h5 id="EXCEPT"><a href="#EXCEPT" class="headerlink" title="EXCEPT"></a>EXCEPT</h5><p>$[a \ _{EXCEPT}\ ![i] =v] \triangleq [j\in _{DOMAIN} \ a \mapsto _{IF}\ j=i\ _{THEN}\ v\ _{ELSE}\ a[j]]$</p><p>例：$[a’ = a \ _{EXCEPT}\ ![2] =8] \not\equiv (a[2]’ =8)$</p><h5 id="IncF"><a href="#IncF" class="headerlink" title="IncF"></a>IncF</h5><p>IncF 是数学意义上的函数定义，等价于 $IncF \triangleq [x ∈ Nat \mapsto x + 1]$</p><ul><li>它的定义域：$_{DOMAIN}\ IncF$</li><li>它的值域：$ \{IncF[x] : x ∈ _{DOMAIN}IncF\}$</li><li>$IncF \in [X \mapsto Y]$</li></ul><h5 id="IncO"><a href="#IncO" class="headerlink" title="IncO"></a>IncO</h5><p>IncO 是运算符(Operator) 的定义</p><ul><li>写因式分解：类似于一个宏，其文本可以替换</li><li>没有定义域 和 值域</li><li>$IncO ∈ [X → Y ]$ 没有意义</li></ul><h5 id="记录-Record"><a href="#记录-Record" class="headerlink" title="记录 Record"></a>记录 Record</h5><p>记录是 $[X → Y]$ 的函数，其中 X 是一组字符串。</p><p>简写作：<br>$[“qwerty” \mapsto 1, “asdfgh” \mapsto 2] = [qwerty \mapsto 1,asdfgh \mapsto 2]$$</p><p>$rec[“qwerty”] = rec.qwerty$</p><h5 id="递归定义-Definition-recursive"><a href="#递归定义-Definition-recursive" class="headerlink" title="递归定义 Définition récursive"></a>递归定义 Définition récursive</h5><p>定义（函数或运算符）时，可以给出递归定义：</p><ul><li>函数：$fact[n \in Nat] \triangleq _{IF}\ n=0\ _{THEN}\ 1\ _{ELSE}\ n*fact(n-1)$</li><li>运算符：$fact(n) \triangleq _{IF}\ n=0\ _{THEN}\ 1\ _{ELSE}\ n*fact(n-1)$</li></ul><p>从理论上讲，必须证明这些定义的有效性。</p><h5 id="n元组-n-Tuple"><a href="#n元组-n-Tuple" class="headerlink" title="n元组 n-Tuple"></a>n元组 n-Tuple</h5><p>符号：⟨a, b, c⟩。</p><ul><li>n元组是定义域函数= $\{1,. . .,n\} :⟨a, b, c⟩[3] = c$</li><li>用于表示关系：$\{⟨x, y⟩ ∈ X × Y: R(x, y)\}$。示例：$\{⟨a, b⟩ ∈ Nat × Nat:a=2*b\}$。</li></ul><h5 id="序列-Sequence"><a href="#序列-Sequence" class="headerlink" title="序列 Sequence"></a>序列 Sequence</h5><p>$\begin{aligned} Seq(T) &amp; \triangleq _{UNION} \{[1..n → T]: n ∈ Nat\}\\ &amp; \triangleq 包含 T 的有限序列集 \end{aligned}$</p><p>运算符：$Len(s)$，$s ◦ t$（连接），$Append(s,e)$，$Head(s)$，$Tail(s)$。</p><h5 id="局部定义-Local-Definition"><a href="#局部定义-Local-Definition" class="headerlink" title="局部定义 Local Definition"></a>局部定义 Local Definition</h5><p>$LET$</p><ul><li><p>表达式： $_{LET}\ v \triangleq e\ _{IN}\ f$</p><p>等效于表达式 $f$，其中所有的符号 $v$ 的都被 $e$ 替换。例子：$_{LET}\ i \triangleq g(x)\ _{IN}\ f (i)≡ f (g(x))$</p></li></ul><p>例：</p><p>$Pythagore(x, y, z) \triangleq _{LET}\ square(n) \triangleq n∗n\ _{IN}\ square(x) + square(y) = square(z)$</p><h5 id="选择-CHOOSE"><a href="#选择-CHOOSE" class="headerlink" title="选择 CHOOSE"></a>选择 CHOOSE</h5><ul><li><p>$_{CHOOSE}\ x \in S:p$ ：确定性任意选择集合 S 中满足谓词 p 的元素。</p></li><li><p>$max[S \in _{SUBSET}\ Nat] \triangleq\ _{CHOOSE}\ m \in S:(\forall p \in S : m \ge p)$</p></li></ul><p>对于集合 S 和属性 p，选择的元素在所有执行过程中始终相同。 它不是一个随机选择器，它在每次调用时都给出一个不同的元素。所以$_{CHOOSE}\ x \in S:p = _{CHOOSE}\ x \in S:p$。</p><p><strong>规约</strong></p><ul><li><p>$(x =\ _{CHOOSE}\ n : n ∈ Nat) ∧ \Box [x’=_{CHOOSE}\ n : n ∈ Nat]_{⟨x⟩}$</p><p>有一个独特的执行：$ x = c → x = c → …$其中 c 是一个不确定的整数（由选择指定）。</p></li><li><p>$(x ∈ Nat) ∧ \Box [x’ ∈ Nat]_{⟨x⟩}$</p><p>有无限次执行，其中一些在每个状态中 x 是不同的，另一些在 x 是恒定的，另一些在 x 中循环</p></li></ul><h3 id="第三部分：线性时间属性-LT-Properties"><a href="#第三部分：线性时间属性-LT-Properties" class="headerlink" title="第三部分：线性时间属性(LT Properties)"></a>第三部分：线性时间属性(LT Properties)</h3><h4 id="刻画线性时间属性-LT-Properties"><a href="#刻画线性时间属性-LT-Properties" class="headerlink" title="刻画线性时间属性(LT Properties)"></a>刻画线性时间属性(LT Properties)</h4><p>因为线性时间属性（LT Properties）是TS中迹的要求，所以在原子命题（AP）上的线性时间属性是$S^{w}$<br>的子集。$S^{w}$表示的是AP中命题的无限级联的集合</p><p>如果AP={a,b}，那么$(2^{AP})^{w}$ 可以表示为</p><script type="math/tex; mode=display">\{\{a\}\{a,b\}\varnothing ...，\{b\}\{a\}\varnothing\varnothing...，...\}</script><p>类似该集合中的元素，由无限个字符级联在一起组成的序列称为无限字(infinite word)，无限字可以表示为:</p><script type="math/tex; mode=display">W=A_{0}A_{1}A_{2}...</script><p>当这个序列是有限时，便称为有限字(finite word)，有限字可以表示为:</p><script type="math/tex; mode=display">W=A_{0}A_{1}A_{2}...A_{n}</script><p>因为TS不考虑终止状态，所以也就无需使用有限字。</p><p>如果一个TS满足线性时间属性P，那么就表明：</p><script type="math/tex; mode=display">TS \vDash P\text{ 当且仅当}Traces(TS) ⊆ P</script><blockquote><p>我个人的理解是线性时间属性P刻画了AP上能够出现的原子命题序列，而迹表示的是系统在AP上出现的原子命题序列，如果系统的迹是P的子集，那么肯定这个系统就满足了线性时间属性P。</p></blockquote><h6 id="刻画基于信号量互斥系统的属性"><a href="#刻画基于信号量互斥系统的属性" class="headerlink" title="刻画基于信号量互斥系统的属性"></a>刻画基于信号量互斥系统的属性</h6><p>一说到信号量和互斥，再次搬出这个例子：</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/20201118212040185.png" alt="20201118212040185" style="zoom:50%;"></p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/20201118212152854.png" alt="20201118212152854" style="zoom:60%;"></p><p>在这里，$AP=\{crit_1, crit_2\}$，这个系统中的约束有一条：</p><blockquote><p>“Always at most one process is in its critical section”</p><p>就是最多有一个进程能够进入临界区</p></blockquote><p>用形式化的语言描述就是：</p><script type="math/tex; mode=display">P_{mutex} = 一个无限字的集合\{A_0A_1A_2...\} 且满足对于所有0\le i,\{crit_1, crit_2\} \nsubseteq A_{i}</script><p>这就完成对系统属性的刻画，描述一下就是对于这个TS的运行轨迹来说不存在$\{crit_1, crit2\}$满足条件的情况。</p><p>所以无限字可以是类似$\{crit_1\}\{crit_2\}\{crit_1\}\{crit_2\}…$或者$\varnothing\varnothing\varnothing\varnothing\varnothing…$反正就是不能出现$\{crit_1, crit2\}$这个元素。</p><p>那么再问一个问题，上面的那个TS系统满足这个$P_{mutex}$ 性质嘛？</p><ul><li>Yes，因为从图上看不存在$\{crit_1, crit2\}$以满足了我们定义的互斥性性质。</li></ul><h6 id="刻画无饥饿-starvation-freedom-系统的属性"><a href="#刻画无饥饿-starvation-freedom-系统的属性" class="headerlink" title="刻画无饥饿(starvation freedom)系统的属性"></a>刻画无饥饿(starvation freedom)系统的属性</h6><p>不存在饥饿的系统要求满足条件:</p><blockquote><p>“A process that wants to enter the critical section is eventually able to do so”</p><p>如果一个进程想要进入临界区，那么它最终总是能够进入临界区。</p></blockquote><p>这一次让$AP=\{crit_1,wait_1,crit_2,wait_2\}$</p><p>用形式化的语言描述为LT性质就是：</p><script type="math/tex; mode=display">P_{nostarve} = 一个无限字的集合\{A_0A_1A_2...\} \\ 满足(\overset{\infty}∃ j.\;wait_{i}∈A_{j})\Rightarrow (\overset{\infty}∃ j.\;crit_{i}∈A_{j})\; for\;each\;i∈\{1,2\}</script><p>其中 $\overset{\infty}∃$ 代表无限多</p><p>描述一下就是当一个进程进入等待状态后，之后肯定会进入临界区</p><p>那么基于信号量的互斥系统满足无饥饿性质嘛？no，如果是这样一条迹:$\varnothing\{wait_2\}\{wait_1,wait_2\}\{crit_1,wait_2\}\{wait_2\}\{wait_1,wait_2\}\{crit_1,wait_2\}…$，那么进程2将永远的不能进入临界区。</p><h5 id="不变性-Invariants"><a href="#不变性-Invariants" class="headerlink" title="不变性(Invariants)"></a>不变性(Invariants)</h5><p>事实上，上述（互斥与无死锁）安全性是一种特殊的性质：不变性。不变性是LT属性，由状态的条件$Φ$给出，并且要求$Φ$对所有可达到的状态保持不变。不变性是安全性的一种，也就是安全性的子集。</p><p>如果在AP上的线性属性$P_{inv}$是不变性，那么它具有如下形式：</p><script type="math/tex; mode=display">P_{inv}=\{A_{0}A_{1}A_{2}... ∈ (2^{AP})^{w} | ∀j \ge 0. A_{j} \vDash Φ \}</script><p>其中$Φ$AP上的逻辑命题公式，$Φ$ 被称为$P_{inv}$ 的不变条件。</p><p>让我们回想一下先前的基于信号量的互斥系统，在那个系统中$Φ=\lnot crit1\vee \lnot crit2$, 保证crit1和crit2不能同时为真。</p><script type="math/tex; mode=display">Invariants \triangleq \forall crit_1,crit_2 \; Value:Chosen(crit_1) \land Chosen(crit_2) \quad \Rightarrow \quad crit_1 = crit_2</script><p>设TS是一个没有终止状态的转换系统，那么有：</p><ul><li>$TS\vDash P_{inv}$<ul><li>$iff\; trace(\pi)∈ P_{inv}\; for\; all\; paths\;\pi \; in\; TS$</li><li>$iff\; L(s)\vDash Φ\; for\; all\; states\;s\;that\;belong\; to\; a\;path\; of\;TS$</li><li>$iff\; L(s)\vDash Φ\; for\; all\; states\;s∈Reach(TS)$</li></ul></li></ul><p>注意上面的最后一个式子，我们将TS能否满足不变性，转换成为了所有可达状态是否满足不变性这一问题。基于此我们可以设计检验不变性的算法。</p><h6 id="我们该如何检验一个系统是否满足了不变性呢？"><a href="#我们该如何检验一个系统是否满足了不变性呢？" class="headerlink" title="我们该如何检验一个系统是否满足了不变性呢？"></a>我们该如何检验一个系统是否满足了不变性呢？</h6><p>我们只要遍历系统的每个状态，从初始状态开始，利用深度优先(Dfs)或者广度优先(Bfs)算法，检查每一个可达状态是否满足$Φ$，只要找到一个可达状态不满足$Φ$，那么系统就不满足不变性，如果我们遍历所有状态发现均满足$Φ$，那么系统就满足不变性。</p><h5 id="安全性-safety"><a href="#安全性-safety" class="headerlink" title="安全性(safety)"></a>安全性(safety)</h5><p>上面我们可以看到，不变性可以被视为状态属性，并且可以通过考虑可达状态来检查。但是安全性不能仅考虑可达状态来验证，而是需要对有限路径片段提出要求。</p><blockquote><p>个人理解，不变性的要求是满足所有可达状态满足要求，而安全性是要求所有的系统上出现的有限路径片段满足要求，从这个角度来看，不变性就是安全性的一种特例，如果安全性要求的有限路径片段的长度为1的话，那就变成了不变性要求。</p></blockquote><p>我们考虑一个自动取款机（ATM）的例子，ATM机的要求是，只有在提供了正确的个人识别码（PIN）后，才能从自动取款机中取款。这个属性不是不变量，因为它不是一个单纯的状态属性。但是，它是一种安全性，例如</p><script type="math/tex; mode=display">"提供正确的PIN","取款",...</script><p>这样的路径片段是满足安全性的，但如果出现</p><script type="math/tex; mode=display">"提供错误的PIN","取款"...</script><p>这样的路径片段是是不满足安全性的，我们可以看到，一旦出现了这样”坏(bad)”的片段，不管后面如何都是不满足安全性的，我们引入前缀、坏前缀等概念来帮助我们定义安全性。</p><p>安全性通常被描述为“<strong>不会发生不好的事情</strong>”(nothing bad should happen)</p><h6 id="安全性的例子"><a href="#安全性的例子" class="headerlink" title="安全性的例子"></a>安全性的例子</h6><ul><li><strong>互斥性</strong>是一种典型的安全性，它要求在临界区最终只有一个进程存在，bad thing指的是在临界区存在两个或两个以上的进程，这种坏事要求永远不会发生</li><li><strong>无死锁性</strong>(deadlock freedom)是另一个典型的安全属性。在哲学家问题中，发生死锁的特征是所有哲学家都拿起了一把筷子，并且正在等待拿起第二把筷子，这种坏的（或unwanted，即不必要的）情况要求永远都不会发生。</li></ul><h6 id="安全性定义为"><a href="#安全性定义为" class="headerlink" title="安全性定义为"></a>安全性定义为</h6><script type="math/tex; mode=display">对于所有的\sigma∈(2^{AP})^w\setminus P_{safe}存在一个\sigma的有限前缀\hat{\sigma}满足 \\ P_{safe}\cap\{\sigma'∈(2^{AP})^w|\hat{\sigma}是\sigma'的有限前缀\}=\varnothing</script><p>解释一下，对于所有的无限字$\sigma=A_{0}A_{1}A_{2}…\in(2^{AP})^w\setminus P_{safe}$ ，存在$\sigma$的有限前缀 $\hat{\sigma}=A_{0}A_{1}…A_{n} $<br>，使得以 $\hat{\sigma}$ 有限前缀起始的字$A_{0}A_{1}…A_{n}B_{n+1}B_{n+2}…$ 不属于$P_{safe}$。</p><p>有限字 $\hat{\sigma}=A_{0}A_{1}…A_{n}$ 被称为$P_{safe}$ 的坏前缀(bad prefix)，符号表示为 $BadPref(P_{safe})$ 。</p><p>如果 $\hat{\sigma} $被称为 $P_{safe}$ 的最小坏前缀(minimal bad prefix)，那么就是说 $\hat{\sigma}$ 中没有比 $\hat{\sigma} $ 长度更小的坏前缀，符号表示为$MinBadPref(P_{safe})$。</p><p>对于一个TS系统满足安全性，那么当且仅当： </p><ul><li>$TS\models P_{safe}$</li><li>$iff\; trace(TS)\subseteq P_{safe}$</li><li>$iff\; trace_{fin}(TS) \cap BadPref=\varnothing$</li><li>$iff\; trace_{fin}(TS) \cap MinBadPref=\varnothing$</li></ul><p>以红绿灯系统为例，它拥有一个属性</p><blockquote><p>each red phase should be immediately preceded by a yellow phase<br>只有在黄灯亮了之后红灯才能亮</p></blockquote><p>AP定义为$\{red,yellow\}$，用形式化的符号表述为：</p><script type="math/tex; mode=display">一个无限字的集合\{A_{0}A_{1}A_{2}...\}\; 对于所有i>0满足red∈A_{i},yellow∈A_{i-1}</script><p>类似于$\varnothing\varnothing\{red\}$，$\varnothing\{red\}$ 都是最小坏前缀，因为 $\{red\}$之前没有出现 $\{yellow\}$</p><p>而类似于$\{yellow\}\{yellow\}\{red\}\{red\}\varnothing\{red\}$是坏前缀而不是最小坏前缀，因为存在比它更小的坏前缀 $\{yellow\}\{yellow\}\{red\}\{red\}$</p><h5 id="活性-liveness"><a href="#活性-liveness" class="headerlink" title="活性(liveness)"></a>活性(liveness)</h5><p>安全性规定“<strong>不好的事情永远不会发生</strong>”，一个算法可以很容易地实现一个安全性，只要检验一下看看会不会出现不好的情况。但是这很多时候是不需要的，有时候没有必要保证永远不会发生不好的事情，为此需要一些其他属性来补充。这样的属性称为”活性(liveness)”属性。可以说，活性表示<strong>“好事”将会发生</strong>(something good will happen)</p><h6 id="活性的例子"><a href="#活性的例子" class="headerlink" title="活性的例子"></a>活性的例子</h6><ul><li>“每个进程最终都会进入临界区”</li><li>“每个哲学家将会无限经常次吃到饭”</li></ul><p>从上面的定义中我们就可以知道，对于活性的判断和安全性完全不同，因为<u>安全性只要有一个坏前缀就可以驳倒安全性，不论后面的序列如何</u>。而<u>活性需要考虑未来无限路径中需要满足的特性</u>。</p><p>如果 $P_{live}$ 是AP上上的活性，那么无论何时：p$ref(P_{live})=(2^{AP})^{*}$ 被称为活性，那么每个在AP上的有限字都能够扩展成为 $P_{live}$ 中的无限字</p><h5 id="活性-vs-安全性"><a href="#活性-vs-安全性" class="headerlink" title="活性 vs 安全性"></a>活性 vs 安全性</h5><ul><li><p>活性和安全性是不相交的嘛？</p><p>是的</p></li><li><p>所有线性时间属性都是活性或者安全性嘛？</p><p>不是</p></li><li><p>有哪些既不是安全性也不是活性的例子？</p><p>例如：“机器在提供三次雪碧之后，会无限次提供啤酒”</p><p>这个例子由两个部分组成，一个是“提供三次雪碧之后”，这是一个安全属性，我们给出一个坏前缀，提供一次雪碧后提供啤酒，另一部分是“无限次提供啤酒”，这是一个活性属性。所以这种包含了安全性和活性的特性，既不属于安全性也不属于活性。</p></li><li><p>是否所有的线性时间属性都可以表示为安全性和活性的交集？</p><p>是的</p><p>根据分解定理(Decomposition theorem)</p><p>对于任何AP上的线性时间属性P，存在安全性$P_{safe}$ 和活性 $P_{live}$ 使得</p><script type="math/tex; mode=display">P=P_{safe}\cap P_{live}</script></li></ul><ul><li><p>线性时间属性的分类（注：不变性是包含在安全性里面，中间那块黄色的区域既是安全性又是活性，代表的含义是True）</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/20201120223125939.png" alt="20201120223125939" style="zoom:60%;"></p></li></ul><h3 id="第四部分：Fairness"><a href="#第四部分：Fairness" class="headerlink" title="第四部分：Fairness"></a>第四部分：Fairness</h3><p>系统的一个重要方面是公平性，公平性排除了被认为是不现实(unrealistic)的无限行为，并且这一步通常是建立活性属性所必需的。</p><p>我们通过在并发系统中经常遇到的一个问题来说明公平的概念：</p><blockquote><p>现有一个并发系统N，有进程 $P_{1},P_{2}…P_{N}$，它们在有需要时就会请求服务，但是现在只有一个服务进程名叫Server会为这些进程提供服务，现在Server采用如下策略：</p><ol><li>从P1开始检查，如果P1请求了服务，那么就为P1提供服务;</li><li>如果P1没有请求，那么就检查下一个进程P2，直到检查完毕，然后从头开始检查……</li></ol><p>我们可以想见，如果P1一直请求服务，那么Server会为P1无限次提供服务，而剩下的进程都会陷入无限等待的过程，这对除P1外的进程来说是是不公平(unfair)的，这种行为就属于不现实的无限行为。</p></blockquote><p>为了获得由TS建模的并行系统的行为的真实描述，我们需要一种另一种形式的LT属性，来解决TS中不确定性决策的问题。</p><p>于是，为了排除上述不现实的行为，我们需要添加公平性约束(Fairness Constraints)，而公平的执行或者轨迹(execute or trace)就是满足了某些公平性约束。</p><h4 id="公平性约束-Contraintes-d’equite"><a href="#公平性约束-Contraintes-d’equite" class="headerlink" title="公平性约束 Contraintes d’équité"></a>公平性约束 Contraintes d’équité</h4><p>公平性约束指定在程序的任何执行中必须<strong>经常无限</strong>地访问（或执行）某些状态（某些转换）。</p><p>通常，公平性约束用于将程序或其环境约束为<strong><u>活性（liveness）</u></strong>，而不涉及有关这些约束的实际实现的细节。</p><p>公平约束通过消除不尊重公平约束的执行来减少合法执行的集合。</p><h5 id="循环状态集-（Ensemble-recurrent-d’etats）"><a href="#循环状态集-（Ensemble-recurrent-d’etats）" class="headerlink" title="循环状态集 （Ensemble recurrent d’etats）"></a>循环状态集 （Ensemble recurrent d’etats）</h5><p>令 $⟨S, I, R⟩$ 是一个变迁系统，且$\sigma = \langle s_0 \to … \rangle$是一段执行。状态集$P$在$\sigma$ 中是循环的，当</p><ul><li>情况1：$\sigma$是无限的：$\forall i \in \mathbb{N} : ∃ j \ge i : s_j \in P$ （$P在\sigma中出现无限次$）</li><li>情况2：$\sigma$是有限的：$\sigma$的最终状态在$P$里</li></ul><blockquote><p>$Inf_S(P,\sigma)$ ：$P$是在$\sigma$中的循环状态集</p></blockquote><h5 id="循环转换集（Ensemble-recurrent-de-transitions）"><a href="#循环转换集（Ensemble-recurrent-de-transitions）" class="headerlink" title="循环转换集（Ensemble recurrent de transitions）"></a>循环转换集（Ensemble recurrent de transitions）</h5><p>令 $⟨S, I, R⟩$ 是一个变迁系统，且$\sigma = \langle s_0 \to … \rangle$是一段执行。转换集$Q$在$\sigma$ 中是循环的，当</p><ul><li>情况1：$\sigma$是无限的：$\forall i \in \mathbb{N} : ∃ j \ge i : s_j \to s_{j+1} \in Q$ （$Q在\sigma中出现无限次$）</li><li>情况2：$\sigma$是有限的：$\sigma$的最终转换在$Q$里</li></ul><blockquote><p>$Inf_T(Q,\sigma)$ ：$Q$是在$\sigma$中的循环状态集</p></blockquote><p>例（循环状态）：</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03 12.10.42.png" alt="2022-04-03 12.10.42" style="zoom:30%;"></p><ul><li><p>$s_1 \; is\;recurrent\;in\;⟨(s_0 → s_1 → s_3)^ω⟩$</p></li><li><p>$s_1 \; is\;recurrent\;in\;⟨(s_0 → s_1 → s_3 \to s_0 \to s_2 \to s_3)^ω⟩$</p></li><li><p>$s_1 \; is\;NOT\;recurrent\;in\;⟨(s_0 → s_1 → s_3)^* \to (s_0 \to s_2 \to s_3)^ω⟩$</p><blockquote><p>个人理解，这里在说循环状态时有两个判断标准：</p><ol><li>当这段执行是<strong>无限</strong>的时，该状态应该在这段<strong>无限执行内</strong>；</li><li>当这段执行是<strong>有限</strong>的时，该状态应该是这段<strong>有限执行的最终状态</strong>。</li></ol><p>下列循环转换可类比于循环状态</p></blockquote></li><li><p>$s_1 \to s_3 \; is\;recurrent\;in\;⟨(s_0 → s_1 → s_3 \to s_0 \to s_2 \to s_3)^ω⟩$</p></li><li><p>$s_1 \to s_3 \; is\;NOT\;recurrent\;in\;⟨(s_0 → s_1 → s_3)^* \to (s_0 \to s_2 \to s_3)^ω⟩$</p></li></ul><h4 id="关于状态的公平性"><a href="#关于状态的公平性" class="headerlink" title="关于状态的公平性"></a>关于状态的公平性</h4><h5 id="简单公平性"><a href="#简单公平性" class="headerlink" title="简单公平性"></a>简单公平性</h5><p>令 $⟨S, I, R⟩$ 是一个变迁系统，如果$ F ⊆ S $ 是一组公平的状态，那么任何执行 $σ$ 必须满足循环状态集 $Inf_S (F, σ)$。</p><p>例：</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03 12.23.47.png" alt="2022-04-03 12.23.47" style="zoom:40%;"></p><p>$Exec(S) = ⟨{s_0}^ω⟩,⟨{s_0}^+ \to s_1⟩,⟨{s_0}^+ \to s_2 \to (s_3 \to s_4) ^w⟩,⟨{s_0}^+ \to s_2 \to (s_3 \to s_4) ^+ \to s_5⟩$</p><ul><li>满足 $\{s_0\}$ 简单公平性的执行是：$⟨{s_0}^ω⟩$</li><li>满足 $\{s_1, s_4\}$ 简单公平性的执行是：$⟨{s_0}^+ \to s_1⟩,⟨{s_0}^+ \to s_2 \to (s_3 \to s_4) ^w⟩$</li><li>满足 $\{s_1, s_5\}$ 简单公平性的执行是：$⟨{s_0}^+ \to s_1⟩,⟨{s_0}^+ \to s_2 \to (s_3 \to s_4) ^+ \to s_5⟩$</li></ul><blockquote><p>满足 $\{s_0, s_1\}$ 简单公平性意味着<strong>分别满足</strong>$\{s_0\}$ 和 $\{s_1\}$ 的简单公平性</p></blockquote><h5 id="多重公平性"><a href="#多重公平性" class="headerlink" title="多重公平性"></a>多重公平性</h5><p>令 $⟨S, I, R⟩$ 是一个变迁系统，给定一个可枚举的集合，可由一组整数$ J = \{0, 1, 2,…\}$，公平集 $\{F_i\}i ∈ J$。</p><p>任何执行 $σ$ 必须满足 $∀i ∈ J : Inf_S (F_i, σ)$。</p><p>例：</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03 14.11.29.png" alt="2022-04-03 14.11.29" style="zoom:40%;"></p><p>$Exec(S) = ⟨{s_0}^ω⟩,⟨{s_0}^+ \to {s_1}^w⟩,⟨({s_0}^+ \to {s_1}^+)^w⟩,⟨({s_0}^+ \to {s_1}^+)^* \to {s_0}^+ \to {s_1}^w⟩$</p><ul><li>满足 $\{s_0\}$ 简单公平性的执行是：$⟨{s_0}^ω⟩, ⟨({s_0}^+ \to {s_1}^+)^w⟩$</li><li>满足 $\{s_0, s_1\}$ 简单公平性的执行是：$Exec(S)$</li><li>满足 $\{s_0\}\{s_1\}$ <strong>多重公平性</strong>的执行是：$⟨({s_0}^+ \to {s_1}^+)^w⟩$</li></ul><blockquote><p>满足 $\{s_0\}\{s_1\}$ <strong>多重公平性</strong>意味着<strong>同时满足</strong>$\{s_0\}$ 和 $\{s_1\}$ 的简单公平性</p></blockquote><h6 id="有限多重公平性-↔-简单公平性"><a href="#有限多重公平性-↔-简单公平性" class="headerlink" title="有限多重公平性 ↔ 简单公平性"></a>有限多重公平性 ↔ 简单公平性</h6><ol><li><p>简单情况：$J$ 是有限的。 $|J|$ 是 $J$ 的基数(cardinalite)。</p><p>下面的简单公平性系统$⟨S’, I’, R’⟩$ 是等价的（执行的平等投影到 S）：</p><ul><li>$S’ = S \times J$</li><li>$I’ = I \times \{0\}$</li><li>$\begin{aligned} R’ = &amp;\{ (⟨s,j⟩,⟨s’,j+1 \mod |J|⟩) | (s,s’) \in R \land s \in F_j\}\\ &amp;∪ \{(⟨s, j⟩,⟨s’, j⟩) |(s,s’) ∈ R ∧ s \notin F_j \} \end{aligned}$</li><li>简单公平状态$F’ = F_0 \times \{0\}$</li></ul><p>例：</p><p>带有多重公平性$F_0 = \{s_0\}$，$ F_1 =\{s_1\}$ 的ST系统<img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03 14.11.29.png" alt="2022-04-03 14.11.29" style="zoom:30%;">与下述带有简单公平性$\{(s_0,0)\}$的ST系统等价：</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03 14.45.46.png" alt="2022-04-03 14.45.46" style="zoom:40%;"></p></li></ol><ol><li><p>一般情况（J 可能无限）。</p><p>下面的简单公平性系统$⟨S’, I’, R’⟩$ 是等价的（执行的平等投影到 S）：</p><ul><li><p>$S’ = S \times J \times J$</p></li><li><p>$I’ = I \times \{0\} \times \{0\}$</p></li><li><p>$\begin{aligned} R’ = &amp;\{ (⟨s,i,i⟩,⟨s’,i⊕1,0⟩) | (s,s’) \in R \land s \in F_j\}\\ &amp;∪ \{(⟨s,i,j⟩,⟨s’,i,j+1⟩) | j &lt; i \land (s,s’) \in R \land s \in F_j\} \\&amp;∪ \{(⟨s,i,j⟩,⟨s’,i,j⟩) |(s,s’) ∈ R ∧ s \notin F_j \} \end{aligned}$</p></li><li><p>简单公平状态$F’ = F_0 \times J \times \{0\}$</p><p>注：$ i⊕1 \triangleq \begin{cases} i+1\;(if\;J是无限的) \\ i+1 \mod |J| \;(else)\end{cases}$</p></li></ul></li></ol><blockquote><p>在公平执行中，计数器 i、j 形成一个三角形：$⟨(0, 0) → (1, 0) → (1, 1) → (2, 0) → (2, 1) → (2, 2) → (3, 0) → …⟩$</p></blockquote><p>例：带有多重公平性$F_0 = \{s_0\}$，$ F_1 =\{s_1\}$ 的ST系统<img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03 14.11.29.png" alt="2022-04-03 14.11.29" style="zoom:30%;">与下述带有简单公平性$\{(s_0,0,0)\}$，$\{(s_0,1,0)\}$的ST系统等价：</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03 15.06.04.png" alt="2022-04-03 15.06.04" style="zoom:30%;"></p><h5 id="条件公平性"><a href="#条件公平性" class="headerlink" title="条件公平性"></a>条件公平性</h5><p>令 $⟨S, I, R⟩$ 是一个变迁系统，我们有两个集合 F 和 G。</p><p>任何执行 σ 必须满足 $Inf_S (F, σ) ⇒ Inf_S (G, σ)$。如果 $F$ 在 $σ$ 中循环，则 $G$ 必须在 $σ$ 中循环。</p><p>例：</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03 12.23.47.png" alt="2022-04-03 12.23.47" style="zoom:40%;"></p><p>$Exec(S) = ⟨{s_0}^ω⟩,⟨{s_0}^+ \to s_1⟩,⟨{s_0}^+ \to s_2 \to (s_3 \to s_4) ^w⟩,⟨{s_0}^+ \to s_2 \to (s_3 \to s_4) ^+ \to s_5⟩$</p><ul><li>满足 $\{s_0\} ⇒ \{s_5\} $ 简单公平性的执行是：$⟨{s_0}^+ \to s_1⟩,⟨{s_0}^+ \to s_2 \to (s_3 \to s_4) ^w⟩,⟨{s_0}^+ \to s_2 \to (s_3 \to s_4) ^+ \to s_5⟩$</li><li>满足 $\{s_3\} ⇒ \{s_4\} $ 简单公平性的执行是：$Exec(S)$</li></ul><blockquote><p>满足 $\{s_3\} ⇒ \{s_4\}$ 条件公平性意味着什么？</p></blockquote><h4 id="关于转换的公平性"><a href="#关于转换的公平性" class="headerlink" title="关于转换的公平性"></a>关于转换的公平性</h4><h5 id="基于动作的公平性约束"><a href="#基于动作的公平性约束" class="headerlink" title="基于动作的公平性约束"></a>基于动作的公平性约束</h5><p>如何表述这类公平性约束？这里采用基于动作 $\mathcal{A}$ (action)的观点.</p><hr><p>弱可能性 ( $WF$ )：</p><p>我们说，一个 TLA 的 Action 动作 $\mathcal{A}$ 在状态 $s$ 下是“使能的” 或者“可触发的”(Enabled)，当且仅当系统的行为序列中可能存在着一个状态 $t$ 是 $s$ 的一个下一个后续状态，即 $⟨上一个状态\;s, 下一个状态\;t⟩$，并且这个二元组可以满足 $\mathcal{A}⟨s\to t⟩$ 这个动作规范。 </p><p>$WF_f(\mathcal{A})$ 表示一个这样的系统行为：如果存在这样的一个 TLA 动 作 $\mathcal{A} ∧ (f’ \neq f)$，一旦变成是“使能的”、“可触发的”，就保持着， 并且永远是“使能的”，“可触发的”，我们认为，那么这个系统就会出现无限多次（Infinitely Many) 的 $\mathcal{A} ∧ (f’ \neq f)$ 步骤。<u>换言之， 如果一旦<strong>出现一个 Action 动作的可能性</strong>并且一直保持着这种系统<strong>会执行这个动作的可能性</strong>，那么就<strong>一定会出现和发生</strong>，或者说，<strong>被执行无限多次</strong>。</u></p><p>强可能性 ( $SF$ )：</p><p>TLA 规约另外也定义了强公平性 (Strong Fairness) $SF_f (\mathcal{A})$，其中 $f$ 是一个状态函数，$\mathcal{A}$ 是一个 TLA 动作范式。 强公平性范式表示，如果 $\mathcal{A} ∧ (f’ \neq f)$ 在一个无限的系统行为里<strong>存在着</strong>无限频繁多次的可能性，那么 $\mathcal{A} ∧ (f’ \neq f)$ 就一定会出现无限多次。<u>如果一个动作范式在某个时间点变得永远可能，那么 也满足“无限经常”的条件。</u>因此，强公平性 $SF_f(\mathcal{A})$ 中蕴含了 $WF_f(\mathcal{A})$</p><blockquote><p>个人理解：</p><ul><li>在弱可能性 $WF_f(\mathcal{A})$ 中，$\mathcal{A}$ 满足 $⟨上一个状态\;s, 下一个状态\;t⟩$ 的二元组，即 $s \to t$。当 TLA 处于当前状态 $s$ 时，动作 $\mathcal{A}$ 是 “Enable”，<strong>则该动作 $\mathcal{A}$ 一定会发生（被执行无限多次）</strong>。</li><li>在强可能性 $SF_f(\mathcal{A})$ 中，$\mathcal{A}$ 满足 $⟨上一个状态\;s, 下一个状态\;t⟩$ 的二元组，即 $s \to t$。当 TLA 处于当前状态 $s$ 时，动作 $\mathcal{A}$ 是 “Enable”，<strong>则该动作 $\mathcal{A}$ 可能会发生（存在被执行无限多次的可能性）</strong>。</li></ul></blockquote><hr><p>公平属性是 <a href="https://wikichi.icu/wiki/Precondition">前提条件</a> 施加在系统上以排除不切实际的痕迹。</p><ul><li>无条件公平的形式是<strong>“每个过程都会无休止地轮流使用”</strong>。</li><li>强公平性 (SF) 的形式是<strong>“如果无限频繁地启用它，则每个过程都将无限次地轮流运行”</strong>。</li><li>弱公平性 (WF) 的形式是<strong>“如果从某个特定点连续进行，则每个过程都会无限制地轮流转动”</strong>。</li></ul><p>之前我们看到了，LTL公式可以用来描述两进程互斥问题的公平性属性，现在我们将它推广到一般的公平性问题</p><p>设 $\phi$ 和 $\psi$ 是命题公式：</p><ul><li>无条件的公平性：$\Box\Diamond\psi$</li><li>强公平性：$\Box\Diamond\phi\rightarrow\Box\Diamond\psi$</li><li>弱公平性：$\Diamond\Box\phi\rightarrow\Box\Diamond\psi$</li></ul><p>对于公平性假设fair和LTL公式 $\phi$，我们有如下结论</p><script type="math/tex; mode=display">s\vDash_{fair}\phi \\ \text{当且仅当 对于所有的π∈Paths(s),如果}π\vDash fair，那么π\vDash\phi \\ \text{当且仅当 }s\vDash (fair\rightarrow\phi)</script><p>其实这里想要表达的意思是，如果我们有了一套算法或者说流程可以验证TS系统是否满足LTL公式，那么我们可以用相同的流程步骤来检测在加入公平性约束的情况下，TS系统是否满足LTL公式。</p><p>对于一个没有终止状态的$TS=⟨S,I,R⟩$，$ \alpha ⊆ Act$，TS上的无限执行片段$ρ =s{0}\xrightarrow{α{0}} s{1}\xrightarrow{α{1}}…$，公平约束具有三种：</p><ol><li><p>如果$\rho$是<strong>无条件公平性（unconditionally A-fair）</strong>，那么无论何时</p><script type="math/tex; mode=display">\text{if }\overset{∞}∃ j\ge 0,a_{j}∈A.</script><p>无条件A-fair的含义是，<u>无论在什么情况下，A中的动作总能无限经常次执行。</u></p></li><li><p>如果$\rho$是<strong>强公平性（strongly A-fair）</strong>，那么无论何时</p><script type="math/tex; mode=display">(\overset{∞}∃ j.Act(s_{j}\cap A\ne ∅)\Rightarrow(\text{if }\overset{∞}∃ j\ge 0,a_{j}∈A)</script><blockquote><p>strongly A-fair的含义是，<u><strong>存在无限经常次A为enabled时，A中动作将会无限经常次执行</strong>。</u></p></blockquote></li><li><p>如果$\rho$是<strong>弱公平性（weakly A-fair）</strong>，那么无论何时</p><script type="math/tex; mode=display">(\overset{∞}\forall j.Act(s_{j}\cap A\ne ∅)\Rightarrow(\text{if }\overset{∞}∃ j\ge 0,a_{j}∈A)</script><blockquote><p>weakly A-fair的含义是，<u><strong>从某个时刻起，A将会为enabled，从而A中动作将会无限经常次执行</strong>。</u></p></blockquote></li></ol><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/20201126194333746.png" alt="20201126194333746" style="zoom:70%;"></p><blockquote><p>strong和weak引入了enabled这个概念，</p><p>strongly A-fair要求在enable的片段中动作能够无限经常次执行，而在not enabled的片段中没有规定</p><p>weakly A-fair则是，不管之前如何，如果在某一个时间点之后，动作持续一直enabled，那么在这片段中动作要求能够无限经常次执行。</p><p>从上面的定义中我们可以容易得到</p><script type="math/tex; mode=display">\text{unconditionally A-fair}\Rightarrow \text{strongly A-fair}\Rightarrow \text{weakly A-fair}</script><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/20201126192818563.png" alt="20201126192818563" style="zoom:60%;"></p></blockquote><h3 id="第五部分：-LTL"><a href="#第五部分：-LTL" class="headerlink" title="第五部分：$LTL$"></a>第五部分：$LTL$</h3><h4 id="时间逻辑TL（Temporal-Logic）"><a href="#时间逻辑TL（Temporal-Logic）" class="headerlink" title="时间逻辑TL（Temporal Logic）"></a>时间逻辑TL（Temporal Logic）</h4><p>时间逻辑TL：用以表达与系统执行相关的属性。不能表达没有明确的转换关系，没有初始状态的概念。</p><p>TL逻辑定义为：</p><ul><li>一种语法：经典逻辑运算符加上时间运算符来谈论未来和过去。</li><li>语义：对象域（称为模型），我们将在其上测试公式的有效性，以及运算符的解释。</li></ul><h4 id="线性时间逻辑LTL（Linear-Temporal-Logic）"><a href="#线性时间逻辑LTL（Linear-Temporal-Logic）" class="headerlink" title="线性时间逻辑LTL（Linear Temporal Logic）"></a>线性时间逻辑LTL（Linear Temporal Logic）</h4><h5 id="LTL模型"><a href="#LTL模型" class="headerlink" title="LTL模型"></a>LTL模型</h5><p>LTL 公式总是与系统的<strong>给定迹</strong> $σ$ 相关：<strong>迹构成该逻辑的模型。</strong></p><blockquote><p>注意：我们经常说即时而不是状态，以指定迹 $σ$ 的元素。</p></blockquote><h5 id="LTL语法"><a href="#LTL语法" class="headerlink" title="LTL语法"></a>LTL语法</h5><ul><li>$s$：表示s在<strong>当前时刻成立</strong>，在轨迹表现为在第一个位置成立</li><li>$\neg P$</li><li>$P \lor Q$</li><li>$P \land Q$</li><li>$\bigcirc P$：表示P在<strong>下一个时刻成立</strong>，在轨迹表现为第二个位置成立</li><li>$\Box P$：表示<strong>P总是(always)成立</strong>，即在<strong>全部的时刻都成立</strong>，在轨迹上表现为每个位置都成立，$\Box P=\lnot \Diamond \lnot P$ </li><li>$\Diamond P$：表示的是<strong>P最终(eventually)能够成立</strong>，在轨迹上表现为，在<strong>某一个时刻的时候P成立</strong>，$\Diamond P = \lnot \Box \lnot P$ : $P$ 不永远为假 $\to$ 存在 $P$ 为真（在这个序列的某个点上 $F$ 为真，哪个点我不关心） </li><li>$\Diamond \Box P$：表示在某一个点之后 $F$ 永远为真。 </li><li>$\Box \Diamond P$：表示存在无穷多个点 $F$ 为真。有一个执行序列 $Exec$，任给一个迹 $\sigma$，总要包含一个 $F$ 为真。</li><li>$P \mathcal{U} Q$：表示<strong>直到Q成立前，P一直成立</strong></li><li>$P \rightsquigarrow Q$：表示<strong>当P成立时，Q一会后也成立</strong>。如果 $P$ 在某个点上为真了，那么 $Q$一定在后面的某个点上为真</li></ul><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03 16.06.08.png" alt="2022-04-03 16.06.08" style="zoom:40%;"></p><h6 id="最小的运算符"><a href="#最小的运算符" class="headerlink" title="最小的运算符"></a>最小的运算符</h6><p>最小的运算符是$\bigcirc P$ 和 $P \mathcal{U}Q$：</p><ul><li>$\Diamond P \triangleq True \; \mathcal{U} P$</li><li>$\Box P \triangleq \neg \Diamond \neg P$ </li><li>$P \rightsquigarrow Q \triangleq \Box (P ⇒ \Diamond Q)$</li></ul><h6 id="替代语法"><a href="#替代语法" class="headerlink" title="替代语法"></a>替代语法</h6><p>我们可以使用另一种语法：</p><ul><li>$\Box ↔ G$（Globally）</li><li>$\Diamond ↔ F$（Finally）</li><li>$\bigcirc↔ X$（Next）</li></ul><h6 id="互补运算符"><a href="#互补运算符" class="headerlink" title="互补运算符"></a>互补运算符</h6><p>运算符 <code>wating-for</code>（或 <code>unless</code> 或 <code>weak-less</code>）: Q 可能最终为真，同时 P 仍然为真</p><p>$P\; \mathcal{W}\;Q \triangleq \Box P ∨ P \mathcal{U}Q$</p><h6 id="释放运算符"><a href="#释放运算符" class="headerlink" title="释放运算符"></a>释放运算符</h6><p>$P \; \mathcal{R} \; Q \triangleq Q \mathcal{U}(P ∧ Q)$Q :  保持为真，直到 P 变为真。</p><h6 id="过去式运算符"><a href="#过去式运算符" class="headerlink" title="过去式运算符"></a>过去式运算符</h6><ul><li>$\ominus P$：<code>previous</code> : P 在前一个瞬间为真</li><li>$\boxminus P$：<code>has-always-been</code> : P 一直是真实的直到当前时刻</li><li>$ \diamond P$：<code>once</code> : P 在过去是真的</li><li>$P\; \mathcal{S}\;Q$：<code>since</code> : 自 Q 过去一直为真，而 P 自上次出现 Q 以来一直为真</li><li>$P\; \mathcal{B}\;Q$：<code>back-to</code> : P 自上次出现 Q 以来为真，或者如果 Q 从未为真，则自初始时刻起为真</li></ul><h5 id="LTL语义"><a href="#LTL语义" class="headerlink" title="LTL语义"></a>LTL语义</h5><p>我们用 $(σ, i)$ 表示后缀为 $⟨s_i → s_i+1 → …⟩$ 的迹 $σ = ⟨s0 → s1 → …⟩$</p><h6 id="系统验证"><a href="#系统验证" class="headerlink" title="系统验证"></a>系统验证</h6><p>系统 $S$ 验证（valid）公式 $F$ 当且仅当 $S$ 的所有执行从初始时刻验证它：</p><script type="math/tex; mode=display">\frac{\forall σ \in Exec(S):(σ,0) \models F}{S \models F}</script><h6 id="P-land-Q"><a href="#P-land-Q" class="headerlink" title="$P\land Q$"></a>$P\land Q$</h6><p>$(\sigma,i) \models P \land Q$ 当且仅当$(\sigma ,i) \models P$ <strong>并且</strong> $(\sigma ,i) \models Q$ </p><script type="math/tex; mode=display">\frac{(\sigma,i) \models P\qquad(\sigma,i) \models Q}{(\sigma,i) \models P \land Q}</script><h6 id="P-lor-Q"><a href="#P-lor-Q" class="headerlink" title="$P\lor Q$"></a>$P\lor Q$</h6><p>$(\sigma,i) \models P \land Q$ 当且仅当$(\sigma ,i) \models P$ <strong>或者</strong> $(\sigma ,i) \models Q$ </p><script type="math/tex; mode=display">\frac{(\sigma,i) \models P}{(\sigma,i) \models P \lor Q} \qquad\frac{(\sigma,i) \models Q}{(\sigma,i) \models P \lor Q}</script><h6 id="neg-P"><a href="#neg-P" class="headerlink" title="$\neg P$"></a>$\neg P$</h6><script type="math/tex; mode=display">\frac{\neg (\sigma,i) \models P}{(\sigma,i) \models \neg P}</script><h6 id="s"><a href="#s" class="headerlink" title="$s$"></a>$s$</h6><script type="math/tex; mode=display">\frac{\sigma_i=s}{(\sigma,i) \models s}</script><h6 id="bigcirc-P"><a href="#bigcirc-P" class="headerlink" title="$\bigcirc P$"></a>$\bigcirc P$</h6><p>$(\sigma,i) \models \bigcirc P$ 当且仅当对使$suffix(\sigma,1) = \sigma_{1},\sigma_{2},\sigma_{3}…\models P$</p><script type="math/tex; mode=display">\frac{(\sigma,i+1) \models P}{(\sigma,i) \models \bigcirc P}</script><h6 id="P-mathcal-U-Q"><a href="#P-mathcal-U-Q" class="headerlink" title="$P\;\mathcal{U}\;Q$"></a>$P\;\mathcal{U}\;Q$</h6><p>$(\sigma,i) \models P\;\mathcal{U}\;Q$ 存在 $j \ge 0$ 使得 $suffix(\sigma,j)=\sigma_{j},\sigma_{j+1},\sigma_{j+2}…\models Q$ 且 $suffix(\sigma,i)=\sigma_{i}, \sigma_{i+1}, \sigma_{i+2}…\models P$ ，$0\le i\lt 1$</p><script type="math/tex; mode=display">\frac{\{∃ k \ge 0:(\sigma,i+k) \models Q\} \land \{ \forall k',0 \le k' \le k:(\sigma, i+k')\models P\} } {(\sigma,i) \models P \mathcal{U} Q}</script><h6 id="Diamond-P"><a href="#Diamond-P" class="headerlink" title="$\Diamond P$"></a>$\Diamond P$</h6><p>$(\sigma,i) \models \Diamond P$ 当且仅当<strong>存在</strong> $i \ge 0$使得 $\sigma_{j},\sigma_{j+1},\sigma_{j+2}…\models P$</p><script type="math/tex; mode=display">\frac{∃k \ge 0 :(\sigma ,i+k) \models P}{(\sigma,i) \models \Diamond P}</script><h6 id="Box-P"><a href="#Box-P" class="headerlink" title="$\Box P$"></a>$\Box P$</h6><p>$(\sigma,i) \models \Box P$ 当且仅当<strong>对所有</strong> $i \ge 0$使得 $\sigma_{j},\sigma_{j+1},\sigma_{j+2}…\models P$</p><script type="math/tex; mode=display">\frac{\forall k \ge 0 :(\sigma ,i+k) \models P}{(\sigma,i) \models \Box P}</script><h6 id="P-rightsquigarrow-Q"><a href="#P-rightsquigarrow-Q" class="headerlink" title="$P \rightsquigarrow Q$"></a>$P \rightsquigarrow Q$</h6><script type="math/tex; mode=display">\frac{\{\forall k \ge 0 :(\sigma ,i+k) \models P \} \Rightarrow \{∃ k' \ge k :(\sigma ,i+k') \models Q\} } { (\sigma,i) \models P \rightsquigarrow Q}</script><h5 id="简化为纯逻辑"><a href="#简化为纯逻辑" class="headerlink" title="简化为纯逻辑"></a>简化为纯逻辑</h5><p>线性时序逻辑具有这样的表达能力，以至于它可以准确地表示根据转换系统描述的任何操作规范，因此：</p><ul><li>检查变迁系统 M 是否具有时间属性 $F_{\mathcal{S}pec}$：</li></ul><script type="math/tex; mode=display">\mathcal{M} \models F_{\mathcal{S}pec}</script><ul><li>相当于确定以下各项的有效性：<script type="math/tex; mode=display">F_{\mathcal{M}} ⇒ F_{\mathcal{S}pec}</script>其中 $F_{\mathcal{M}}$ 是一个公式，准确地表示模型 ${\mathcal{M}}$ 的执行（即它的初始状态、它的转换、它的公平性约束）。</li></ul><h4 id="例题（考试必考）"><a href="#例题（考试必考）" class="headerlink" title="例题（考试必考）"></a>例题（考试必考）</h4><h5 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h5><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03 17.18.20.png" alt="2022-04-03 17.18.20" style="zoom:50%;"></p><div class="table-container"><table><thead><tr><th></th><th>无公平性</th><th>简单公平性($s_1,s_2$)</th></tr></thead><tbody><tr><td>$s_0 \land \bigcirc s_0$</td><td>$n (s_0→{s_1}^ω) $</td><td>n</td></tr><tr><td>$s_0 \land \bigcirc (s_0 \lor s_1)$</td><td>o</td><td>o</td></tr><tr><td>$\Box (s_0 ⇒ \bigcirc s_0)$</td><td>$n (s_0→{s_1}^ω) $</td><td>n</td></tr><tr><td>$\Box (s_0 ⇒ \bigcirc (s_0 \lor s_1)$</td><td>o</td><td>o</td></tr><tr><td>$\Box (s_0 ⇒ \bigcirc s_1)$</td><td>o</td><td>o</td></tr><tr><td>$\Diamond (s_0 ⇒ \bigcirc s_1)$</td><td>$n ({s_0}^ω) $</td><td>o</td></tr><tr><td>$\Box s_0$</td><td>$n (s_0→{s_1}^ω) $</td><td>n</td></tr><tr><td>$\Diamond \neg s_0$</td><td>$n ({s_0}^ω) $</td><td>o</td></tr><tr><td>$\Diamond \Box s_0$</td><td>$n ({s_0}^ω) $</td><td>o</td></tr><tr><td>$s_0 \mathcal{W} s_1$</td><td>o</td><td>o</td></tr><tr><td>$s_0 \mathcal{U} s_1$</td><td>$n ({s_0}^ω) $</td><td>o</td></tr></tbody></table></div><h5 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h5><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03 17.34.49.png" alt="2022-04-03 17.34.49" style="zoom:50%;"></p><p>$Exec(S) = ⟨s_0 \to {s_1}^w⟩, ⟨(s_0 \to {s_1}^+)^w⟩, ⟨(s_0 \to {s_1}^+)^+ \to {s_2}^w⟩$</p><div class="table-container"><table><thead><tr><th></th><th>无公平性</th><th>$\mathcal{W_{eak}F_{airness}}(s_1,s_2)$</th><th>$\mathcal{S_{trong}F_{airness}}(s_1,s_2)$</th></tr></thead><tbody><tr><td>$\Box \Diamond \neg s_1$</td><td>$n (s_0→{s_1}^ω) $</td><td>o</td><td>o</td></tr><tr><td>$\Box (s_1 ⇒ \Diamond s_2)$</td><td>$n (s_0→{s_1}^ω) $</td><td>$n ((s_0→s_1)^ω) $</td><td>o</td></tr><tr><td>$\Diamond \Box (s_1 \lor s_2)$</td><td>$n ((s_0→s_1)^ω) $</td><td>n</td><td>o</td></tr><tr><td>$\Box (s_1 \mathcal{U} s_2)$</td><td>$n (s_0→…) $</td><td>n</td><td>n</td></tr><tr><td>$\Box (s_0 ⇒ s_0 \mathcal{U} s_1)$</td><td>o</td><td>o</td><td>o</td></tr><tr><td>$\Box(s_0 \mathcal{U} (s_1 \lor s_2))$</td><td>o</td><td>o</td><td>o</td></tr><tr><td>$\Box (s_1 ⇒ s_1 \mathcal{U} s_2)$</td><td>$n (s_0→{s_1}^ω) $</td><td>$n ((s_0→s_1)^ω) $</td><td>$n (s0→s1→s0→s1→s2^ω) $</td></tr><tr><td>$\Diamond (s_1 \mathcal{U} s_2)$</td><td>$n (s_0→{s_1}^ω) $</td><td>$n ((s_0→s_1)^ω) $</td><td>o</td></tr><tr><td>$\Diamond (s_1 \mathcal{W} s_2)$</td><td>$n ((s_0→s_1)^ω) $</td><td>n</td><td>o</td></tr><tr><td>$\Box \Diamond (s_1 \mathcal{U} (s_0 \lor s_2))$</td><td>$n (s_0→{s_1}^ω) $</td><td>o</td><td>o</td></tr></tbody></table></div><blockquote><p>个人理解：以例1中的第一行 $\Box \Diamond \neg s_1 $ 为例，可以将其视为一个条件，意为在该条件下是否满足“无公平性” 和 “$WF(s_1,s_2)$”：</p><p>$\Box \Diamond \neg s_1 $ 意为 “对于所有迹，最终都会不出现 $s_1$” ，此时我们需要找出有否所有的迹都符合该条件。</p><ol><li><p>对于“无公平性”：由图可见存在一个迹 $\sigma = ⟨s_0 \to {s_1}^w⟩$ ，并不符合$\Box \Diamond \neg s_1 $ ，所以为<code>n(means no)</code>。</p></li><li><p>对于“$WF(s_1, s_2)$”：在转换 $s_0 \to s_1$ 下，条件 $\Box \Diamond \neg s_1 $ 并<strong>总是成立</strong></p></li><li><p>对于“$SF(s_1, s_2)$”：在转换 $s_0 \to s_1$ 下，条件 $\Box \Diamond \neg s_1 $ 并<strong>会成立</strong></p></li></ol></blockquote><h4 id="时间逻辑TL属性"><a href="#时间逻辑TL属性" class="headerlink" title="时间逻辑TL属性"></a>时间逻辑TL属性</h4><h5 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h5><p>没有什么不好的事情发生（<a href="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/#%E5%AE%89%E5%85%A8%E6%80%A7-safety">详见第三部分</a>）= 在执行的有限前缀上无效的属性：</p><ul><li>$\Box P$, $\Box (P ⇒ \Box P)$, $P \mathcal{W} Q$, …</li></ul><h5 id="活性"><a href="#活性" class="headerlink" title="活性"></a>活性</h5><p>美好的事情终会发生 = 始终可以通过扩展运行前缀来验证的属性：</p><ul><li>$\Diamond P$, $P \rightsquigarrow Q$, …</li></ul><h5 id="活性与安全性的组合属性"><a href="#活性与安全性的组合属性" class="headerlink" title="活性与安全性的组合属性"></a>活性与安全性的组合属性</h5><p> 一些活性与安全性的组合属性，例如</p><ul><li>$P \mathcal{U} Q$, $\Box P \land \Diamond Q$, …</li><li>Reponse: $\Box \Diamond P$</li><li>Persistance: $\Diamond \Box P$</li></ul><h5 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h5><p>指定系统可达状态的超集（<a href="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/#%E4%B8%8D%E5%8F%98%E6%80%A7-Invariants">详见第三部分</a>：</p><script type="math/tex; mode=display">\mathcal{S} \models \Box P</script><p>其中 P 是状态谓词。</p><h5 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h5><p>指定情况发生时的稳定性：</p><script type="math/tex; mode=display">\mathcal{S} \models \Box(P ⇒ \Box P)</script><p>其中 P 是状态谓词</p><h5 id="可能性"><a href="#可能性" class="headerlink" title="可能性"></a>可能性</h5><p>指定在某个执行中可能达到满足 $P$ 的某个状态：</p><ul><li>对于任意 $P$ 是不可能的，但对于 $P$ 是一个状态谓词：<script type="math/tex; mode=display">\mathcal{S} \nvDash \Box \neg P</script>请注意<strong>否定性</strong>：$\neg \Box P = \Diamond \neg P$  但是 $\mathcal{S} \nvDash \Box P \nRightarrow \mathcal{S} \models \Diamond \neg P$</li></ul><h5 id="否定性"><a href="#否定性" class="headerlink" title="否定性"></a>否定性</h5><ul><li><p>对于 $σ$ 执行：$σ \models ¬P ≡ σ \nvDash P$</p></li><li><p>对于 $\mathcal{S}$ 系统： $\mathcal{S} \models ¬P ⇒ \mathcal{S} \nvDash P$ , 但不是等价的！</p><blockquote><p>$\mathcal{S} \nvDash P$ 表示至少有一次执行使 Q 无效（  $¬Q$ 有效），但并非所有执行都如此。</p><p>在 LTL 中，我们可以有$ S \nvDash Q ∧ S \nvDash ¬Q$ : </p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03 17.18.20.png" alt="2022-04-03 17.18.20" style="zoom:50%;"></p><script type="math/tex; mode=display">\frac { {s_0}^+ → {s_1}^w \nvDash \Box s_0}{\mathcal{S} \nvDash \Box s_0} \qquad\frac { {s_0}^w \nvDash \Diamond \neg s_0}{\mathcal{S} \nvDash \Diamond \neg s_0}</script></blockquote></li></ul><h5 id="无限经常"><a href="#无限经常" class="headerlink" title="无限经常"></a>无限经常</h5><p>指定 $P$ 在任何执行中都无限地经常为真：</p><script type="math/tex; mode=display">\mathcal{S} \models \Box \Diamond P</script><h5 id="最终总是"><a href="#最终总是" class="headerlink" title="最终总是"></a>最终总是</h5><p>指定 $P$ 最终保持绝对真：</p><script type="math/tex; mode=display">\mathcal{S} \models \Diamond \Box P</script><h4 id="LTL公式的性质"><a href="#LTL公式的性质" class="headerlink" title="LTL公式的性质"></a>LTL公式的性质</h4><h5 id="对偶率-Duality-laws"><a href="#对偶率-Duality-laws" class="headerlink" title="对偶率(Duality laws)"></a>对偶率(Duality laws)</h5><script type="math/tex; mode=display">\lnot\Box\phi\equiv\Diamond\lnot\phi \\ \lnot\Diamond\phi\equiv\Box\lnot\phi \\ \lnot\bigcirc\phi\equiv\bigcirc\lnot\phi</script><h5 id="幂等律-Idempotence-laws"><a href="#幂等律-Idempotence-laws" class="headerlink" title="幂等律(Idempotence laws)"></a>幂等律(Idempotence laws)</h5><script type="math/tex; mode=display">\Box\Box\phi\equiv\Box\phi \\ \Diamond\Diamond\phi\equiv\Diamond\phi \\ \phi U(\phi U\psi)\equiv\phi U\psi \\ (\phi U\psi)U\psi\equiv\phi U\psi</script><h5 id="吸收率-Absorption-laws"><a href="#吸收率-Absorption-laws" class="headerlink" title="吸收率(Absorption laws)"></a>吸收率(Absorption laws)</h5><script type="math/tex; mode=display">\Diamond\Box\Diamond\phi\equiv\Box\Diamond\phi \\ \Box\Diamond\Box\phi\equiv\Diamond\Box\phi</script><h5 id="分配律-Distributive-laws"><a href="#分配律-Distributive-laws" class="headerlink" title="分配律(Distributive laws)"></a>分配律(Distributive laws)</h5><script type="math/tex; mode=display">\bigcirc(\phi U\psi)\equiv (\bigcirc\phi)U(\bigcirc\psi) \\ \Diamond(\phi \vee\psi)\equiv (\Diamond\phi)\vee(\Diamond\psi) \\ \Box(\phi\wedge\psi)\equiv\Box\phi\wedge\Box\psi</script><h5 id="扩展率-Expansion-laws"><a href="#扩展率-Expansion-laws" class="headerlink" title="扩展率(Expansion laws)"></a>扩展率(Expansion laws)</h5><script type="math/tex; mode=display">\phi U\psi\equiv\psi\vee(\phi\wedge\bigcirc(\phi U\psi)) \\ \Diamond\phi\equiv\phi\vee\bigcirc\Diamond\phi \\ \Box\phi\equiv\phi\wedge\bigcirc\Box\phi</script><p><strong>扩展率是非常重要的一条性质</strong>，之后的LTL模型检测都会基于此。</p><p>特别是这个第一条公式，我个人感觉其实它的意思就是基于当前项然后向后走了一步，就拿 $\phi \mathcal{U}\psi$ 来说，它代表 $\psi$ 成立前 $\phi$ 一直成立，</p><ol><li>首先看扩展出来的第一个 $\psi$ ，如果当前项是 $\psi$ 那么就代表到达了公式成立的条件，后面的也就可以不用管了；</li><li>然后再看第二项 $\phi\wedge\bigcirc(\phi U\psi)$ 如果当前项是 $\phi$ 还没有达到公式成立的条件，那么如果公式成立，对于下一步来说肯定是满足 $\phi \mathcal{U}\psi$ 的。</li></ol><h4 id="用公式来表示LT性质"><a href="#用公式来表示LT性质" class="headerlink" title="用公式来表示LT性质"></a>用公式来表示LT性质</h4><h5 id="公平性"><a href="#公平性" class="headerlink" title="公平性"></a>公平性</h5><p>例如我们可以用它来表示两进程互斥问题中的公平性：</p><ul><li>无条件的公平性：$\Box \Diamond crit_{i}$</li><li>强公平性：$\Box \Diamond wait_{i}\rightarrow \Box \Diamond crit_{i}$</li><li>弱公平性：$\Diamond\Box wait_{i}\rightarrow \Box \Diamond crit_{i}$</li></ul><h5 id="Weak-until"><a href="#Weak-until" class="headerlink" title="Weak until"></a>Weak until</h5><p>前面介绍的until操作，它是一种比较强的限制，而weak until操作（或者称为unless）定义为:</p><script type="math/tex; mode=display">\phi W\psi=(\phi U\psi)\vee\Box\phiϕWψ=(ϕUψ)∨□ϕ</script><p>也就是说 $\phi \mathcal{W} \psi$ 表示为 $\phi \mathcal{U} \psi$ 成立或者 $\Box\phi$ 成立</p><p>weak until和until操作是对偶的，具体表现为：</p><script type="math/tex; mode=display">\lnot(\phi \mathcal{U}\psi)=(\phi \wedge\lnot\psi)\mathcal{W}(\lnot\phi\wedge\lnot\psi) \\ \lnot(\phi \mathcal{W}\psi)=(\phi \wedge\lnot\psi)\mathcal{U}(\lnot\phi\wedge\lnot\psi)</script><p>weak until和until两者的表达能力是相同的，两者之间可以互换</p><script type="math/tex; mode=display">\phi \mathcal{U} \psi=(\phi \mathcal{W} \psi)\wedge\lnot\Box\lnot\psi</script><p>也可以用它来表示一些其他属性：</p><h5 id="可达性"><a href="#可达性" class="headerlink" title="可达性"></a>可达性</h5><h6 id="简单可达性"><a href="#简单可达性" class="headerlink" title="简单可达性"></a>简单可达性</h6><script type="math/tex; mode=display">\Diamond\psi</script><h6 id="带条件的可达性"><a href="#带条件的可达性" class="headerlink" title="带条件的可达性"></a>带条件的可达性</h6><script type="math/tex; mode=display">\phi \mathcal{U} \psi</script><h6 id="安全性中的不变性"><a href="#安全性中的不变性" class="headerlink" title="安全性中的不变性"></a>安全性中的不变性</h6><script type="math/tex; mode=display">\Box\phi</script><h6 id="活性-1"><a href="#活性-1" class="headerlink" title="活性"></a>活性</h6><script type="math/tex; mode=display">\Box(\phi\Rightarrow\Diamond\psi)</script><h4 id="LTL公式的一些例子"><a href="#LTL公式的一些例子" class="headerlink" title="LTL公式的一些例子"></a>LTL公式的一些例子</h4><h5 id="Client-Server"><a href="#Client-Server" class="headerlink" title="Client / Server"></a>Client / Server</h5><h6 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h6><p>指定系统（扮演服务器的角色）总是响应（Q）给定的请求（P）：</p><script type="math/tex; mode=display">\mathcal{S} \models \Box (P ⇒ \Diamond Q)</script><p>通常称为<code>lead-to</code>：</p><script type="math/tex; mode=display">\mathcal{S} \models P \rightsquigarrow Q</script><h6 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h6><p>指定来自系统（扮演客户端的角色）的请求 P 只要没有有利的响应 Q 就稳定：</p><script type="math/tex; mode=display">\mathcal{S} \models \Box (P ⇒ P \mathcal{W} Q)</script><h5 id="互斥问题"><a href="#互斥问题" class="headerlink" title="互斥问题"></a>互斥问题</h5><p>两个进程不能同时进入临界区：</p><script type="math/tex; mode=display">\Box(\lnot crit_{1}\vee \lnot crit_{2}) \\OR \qquad \Box(\forall i,j \in 0..N-1: state[i]=crit \;\land\;state[j]=crit \quad \Rightarrow \quad i=j )</script><h5 id="无饥饿"><a href="#无饥饿" class="headerlink" title="无饥饿"></a>无饥饿</h5><p>两个进程可以无限经常次访问临界区：</p><script type="math/tex; mode=display">(\Box\Diamond w_{1}\Rightarrow\Box\Diamond c_{1})\wedge(\Box\Diamond w_{2}\Rightarrow\Box\Diamond c_{2})\\OR \qquad \forall i \in 0..N-1:state[i]=waiting \;\rightsquigarrow\; state[i]=crit</script><h5 id="火车轨道通行问题"><a href="#火车轨道通行问题" class="headerlink" title="火车轨道通行问题"></a>火车轨道通行问题</h5><script type="math/tex; mode=display">\Box(train\_is\_near\rightarrow gate\_is\_close)</script><h5 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h5><script type="math/tex; mode=display"> \Box(request\rightarrow \Diamond response)</script><h3 id="第六部分：-TLA"><a href="#第六部分：-TLA" class="headerlink" title="第六部分：$TLA^+$"></a>第六部分：$TLA^+$</h3><h4 id="TLA-逻辑"><a href="#TLA-逻辑" class="headerlink" title="$TLA+$ 逻辑"></a>$TLA+$ 逻辑</h4><p>$TLA+$ 是一种状态机思维，只要初始是正确的，规则是正确的，那么结果就一定是正确的。不管系统经历了怎样的运行路径。（类似于数学归纳法）</p><h5 id="逻辑表达式"><a href="#逻辑表达式" class="headerlink" title="逻辑表达式"></a>逻辑表达式</h5><p>带有 $\Box$ , $\Diamond$ , $\rightsquigarrow$的 LTL 表达式和引发变量 + 量词 $∀$，$∃$。</p><p>没有 $\mathcal{U}$，也没有 $\mathcal{W}$，但是：</p><ul><li>$\Box (p ⇒ (p \mathcal{W}q)) = \Box (p ⇒ (p’ \lor q))$</li><li>$\Box (p ⇒ (p \mathcal{U}q)) = \Box (p ⇒ (p’ \lor q)) \land \Box(p ⇒ \Diamond q)$</li></ul><h5 id="公平性-1"><a href="#公平性-1" class="headerlink" title="公平性"></a>公平性</h5><h6 id="ENABLE"><a href="#ENABLE" class="headerlink" title="ENABLE"></a>ENABLE</h6><p>$_{ENABLE} \mathcal{A}$ 是在状态 $s$ 中为真的状态函数，当且仅当存在通过动作 $\mathcal{A}$  从 $s$ 可访问的状态 t。</p><h6 id="弱-强公平"><a href="#弱-强公平" class="headerlink" title="弱/强公平"></a>弱/强公平</h6><ul><li><p>$\mathcal{WF}_e(\mathcal{A}) \triangleq \Box \Diamond \neg (_{ENABLE} ⟨\mathcal{A}⟩_e) \lor \Box \Diamond ⟨\mathcal{A}⟩_e$</p><p>如果 $\mathcal{A}$ 是持续可触发的，它将被触发。</p></li><li><p>$\mathcal{SF}_e(\mathcal{A}) \triangleq \Diamond \Box \neg (_{ENABLE} ⟨\mathcal{A}⟩_e) \lor \Box \Diamond ⟨\mathcal{A}⟩_e$</p><p>如果 A 是无限频繁可触发的，它将被触发。</p></li></ul><h5 id="TLA-规范的形式"><a href="#TLA-规范的形式" class="headerlink" title="TLA+ 规范的形式"></a>TLA+ 规范的形式</h5><p>通常，TLA+ 规范是一系列谓词的连词(conjonction)：</p><script type="math/tex; mode=display">\mathcal{I} \land \Box [\mathcal{N}]_v \land \mathcal{E}</script><ul><li>$\mathcal{I}$ = 描述初始状态的状态谓词；</li><li>$\mathcal{N}$ = 动作 $A_1 ∨ A_2 ∨ A_3 ∨… $的分解(disjonction)；</li><li>$\mathcal{E}$ = 行动公平性约束的合取(conjonction)：$\mathcal{WF}_v(\mathcal{A}_1) \land \mathcal{WF}_v(\mathcal{A}_3) \land …$</li></ul><h5 id="规约的细化"><a href="#规约的细化" class="headerlink" title="规约的细化"></a>规约的细化</h5><p>如果 $P_c ⇒ P_a$，则一个具体的规约 $P_c$ 细化（raffine）一个抽象的规约 $P_a$：$P_c$ 所做的一切在 $P_a$ 中都是可能的。</p><p>这意味着如果 $P_a \models P$ 满足 LTL 属性，则 $P_c \models P$ 也满足LTL属性。</p><h6 id="例1-1"><a href="#例1-1" class="headerlink" title="例1"></a>例1</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-----------------module somme1----------------</span><br><span class="line">EXTENDS Naturals</span><br><span class="line">CONSTANT N</span><br><span class="line">VARIABLE res</span><br><span class="line"></span><br><span class="line">TypeInvariant == res \in Nat</span><br><span class="line">Init == res = 0</span><br><span class="line">Next == res′ = ((N + 1) * N) / 2</span><br><span class="line">Spec == Init ∧ [][Next]_res /\ WF_res (Next)</span><br></pre></td></tr></table></figure><p>当 $N = 3$ 时的执行图:</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03 22.03.52.png" alt="2022-04-03 22.03.52" style="zoom:40%;"></p><h6 id="例2-1"><a href="#例2-1" class="headerlink" title="例2"></a>例2</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">----------------- module somme2 ----------------</span><br><span class="line">EXTENDS Naturals</span><br><span class="line">CONSTANT N</span><br><span class="line">VARIABLE res, acc, disp</span><br><span class="line"></span><br><span class="line">TypeInvariant == res \in Nat</span><br><span class="line">/\ acc \in Nat</span><br><span class="line">/\ disp \in SUBSET 1..N</span><br><span class="line">Init == res = 0</span><br><span class="line">/\ acc = 0</span><br><span class="line">/\ disp = 1..N</span><br><span class="line">Next == \/ \E i \in disp : acc&#x27; = acc + i /\ disp&#x27; = disp \ &#123;i&#125;</span><br><span class="line">/\ UNCHANGED res</span><br><span class="line">\/ disp = &#123;&#125; /\ res&#x27; = acc /\ UNCHANGED res</span><br><span class="line">Spec == Init ∧ [][Next]_&lt;&lt;res, disp, acc&gt;&gt; /\ WF_&lt;&lt;res, disp, acc&gt;&gt; (Next)</span><br></pre></td></tr></table></figure><p>当 $N = 3$ 时的执行图:</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03 22.11.22.png" alt="2022-04-03 22.11.22"></p><p>分解：引入中间转换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---------------- module somme2_raffine_somme1 ----------------</span><br><span class="line">EXTENDS somme2</span><br><span class="line">Orig == INSTANCE somme1</span><br><span class="line">Raffinement == Orig ! Spec</span><br><span class="line">THEOREM Spec =&gt; Orig ! Spec</span><br></pre></td></tr></table></figure><h6 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">----------------- module somme3 ----------------</span><br><span class="line">EXTENDS Naturals</span><br><span class="line">CONSTANT N</span><br><span class="line">VARIABLE res, acc, i</span><br><span class="line"></span><br><span class="line">TypeInvariant == res \in Nat</span><br><span class="line">/\ acc \in Nat</span><br><span class="line">/\ i \in 1..N</span><br><span class="line">Init == res = 0</span><br><span class="line">/\ acc = 0</span><br><span class="line">/\ i = N</span><br><span class="line">Next == \/ i &gt; 0 /\ acc&#x27; = acc + i /\ i&#x27; = i - 1 /\ UNCHANGED res</span><br><span class="line">\/ i = 0 /\ res&#x27; = acc /\ UNCHANGED &lt;&lt;i, res&gt;&gt;</span><br><span class="line">Spec == Init ∧ [][Next]_&lt;&lt;res, i, acc&gt;&gt; /\ WF_&lt;&lt;res, i, acc&gt;&gt; (Next)</span><br></pre></td></tr></table></figure><p>当 $N = 3$ 时的执行图:</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03 22.19.49.png" alt="2022-04-03 22.19.49" style="zoom:50%;"></p><p>减少非确定性 + 表示变化（数据细化） $disp = 1..i$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---------------- module somme3_raffine_somme2 ----------------</span><br><span class="line">EXTENDS somme3</span><br><span class="line">dispMapping == 1..i</span><br><span class="line">Orig == INSTANCE somme2 WITH disp &lt;- dispMapping</span><br><span class="line">Raffinement == Orig ! Spec</span><br><span class="line">THEOREM Spec =&gt; Orig ! Spec</span><br></pre></td></tr></table></figure><h4 id="公理证明"><a href="#公理证明" class="headerlink" title="公理证明"></a>公理证明</h4><h5 id="简单时序逻辑"><a href="#简单时序逻辑" class="headerlink" title="简单时序逻辑"></a>简单时序逻辑</h5><script type="math/tex; mode=display">\frac{F 在命题逻辑中可证明}{\Box F} \;STL1</script><p>意义：</p><script type="math/tex; mode=display">\frac{}{\Box F ⇒ F} \;STL2</script><script type="math/tex; mode=display">\frac{}{\Box \Box F = \Box G} \;STL3</script><script type="math/tex; mode=display">\frac{F ⇒ G}{\Box F ⇒ \Box G} \;STL4</script><script type="math/tex; mode=display">\frac{}{\Box (F \land G) = (\Box F) \land (\Box G)} \;STL5</script><script type="math/tex; mode=display">\frac{}{ (\Diamond \Box F) \land (\Diamond \Box G) = \Diamond \Box (F \land G)} \;STL6</script><h5 id="不变性-1"><a href="#不变性-1" class="headerlink" title="不变性"></a>不变性</h5><script type="math/tex; mode=display">\frac{P \land (v' = v) ⇒ P'}{\Box P = P \land \Box [P ⇒ P']_v} \;TLA1</script><script type="math/tex; mode=display">\frac{P \land [\mathcal{A}]_{v1} ⇒ Q \land [\mathcal{B}]_{v2}}{\Box P \land \Box [\mathcal{A}]_{v1} ⇒ \Box Q \land \Box[\mathcal{B}]_{v2}} \;TLA2</script><script type="math/tex; mode=display">\frac{I \land [\mathcal{N}]_{v} ⇒ I'}{I \land \Box[\mathcal{N}]_{v} ⇒ \Box I} \;INV1</script><script type="math/tex; mode=display">\frac{}{\Box I ⇒ (\Box[\mathcal{N}]_{v} = \Box [\mathcal{N} \land I \land I']_v)} \;INV2</script><h5 id="活性-2"><a href="#活性-2" class="headerlink" title="活性"></a>活性</h5><script type="math/tex; mode=display">\frac{\begin{aligned} P \land [\mathcal{N}]_v ⇒ (P' \lor Q') \\ P \land ⟨\mathcal{N} \land \mathcal{A}⟩_v ⇒ Q' \\ P ⇒ _{ENABLE} ⟨\mathcal{A}⟩_v\end{aligned}}{\Box [\mathcal{N}]_v) \land WF_v(\mathcal{A}) ⇒ (P \rightsquigarrow Q)} \;WF1</script><script type="math/tex; mode=display">\frac{\begin{aligned} P \land [\mathcal{N}]_v ⇒ (P' \lor Q') \\ P \land ⟨\mathcal{N} \land \mathcal{A}⟩_v ⇒ Q' \\ \Box P \land \Box [\mathcal{N}]_v \land \Box F ⇒ \Diamond  _{ENABLE} ⟨\mathcal{A}⟩_v\end{aligned}}{\Box [\mathcal{N}]_v) \land SF_v(\mathcal{A}) \land \Box F ⇒ (P \rightsquigarrow Q)} \;WF1</script><h5 id="推导规则"><a href="#推导规则" class="headerlink" title="推导规则"></a>推导规则</h5><script type="math/tex; mode=display">\frac{\Box(P ⇒ \Box P) \land \Diamond P}{\Diamond \Box P} \;LDSTBL</script><script type="math/tex; mode=display">\frac{P \rightsquigarrow Q \land Q \rightsquigarrow R}{P \rightsquigarrow R} \;TRANS</script><script type="math/tex; mode=display">\frac{\forall m \in W : P(m) \rightsquigarrow Q}{(∃ m \in W : P(m)) \rightsquigarrow Q} \;INFDIJ</script><h4 id="模型检查"><a href="#模型检查" class="headerlink" title="模型检查"></a>模型检查</h4><p>原则：构建执行图并研究属性。</p><ul><li>$\Box P$，其中 $P$ 是一个状态谓词（没有初始变量）：随着状态的构建。</li><li>$\Box P (v,v’)$，其中 $P(v,v’)$ 是一个转换谓词（具有带素变量和非素数变量的非时间谓词）：计算转换时。</li><li>活跃度 $\Diamond P$ ,  $P \rightsquigarrow Q$ , … ：一旦建立了图，寻找一个尊重公平约束并使属性无效的循环。</li></ul><h5 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h5><p>让系统 $\mathcal{S} = ⟨S, I, R⟩$ 的状态数$|S|$ 和 LTL的 $\mathcal{F}$ 公式的大小$|F|$（时间运算符的数量）。</p><p>验证 $\mathcal{S} \models \mathcal{F}$ 的时间（和空间）复杂度为</p><script type="math/tex; mode=display">O(|S| × 2^{|F|})</script><h5 id="TLC检查器"><a href="#TLC检查器" class="headerlink" title="TLC检查器"></a>TLC检查器</h5><p>TLC 模型检查器可以检查：</p><ol><li><p>带有保护的动作的规约；</p></li><li><p>没有初始变量的不变量 $\Box P$，其中 P 是状态谓词；</p></li><li><p>带有素变量（prime variables ）和重复（begaiement）的纯安全公式 $\Box [P]_v$ , 其中 P 是转换谓词；</p></li><li><p>$P \rightsquigarrow Q$ , 其中 P 和 Q 是状态谓词（没有素变量）；</p></li><li><p>将 $\Box$、$\Diamond $ 组合在一起的公式，没有带底数的变量。</p><p>注意：系统和公式的状态空间必须是有限的：例如任何有界量化。</p></li></ol><h3 id="第七部分：-CTL"><a href="#第七部分：-CTL" class="headerlink" title="第七部分：$CTL$"></a>第七部分：$CTL$</h3><p>在前面我们已经介绍了线性属性，为了方便地去描述这个线性属性，我们又介绍了线性时序逻辑，本节要介绍一种新的逻辑计算树逻辑（CTL），这种逻辑可以描述LTL不能描述的部分。</p><p>如果用文氏图来表示的话就是：</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/20201209125629367.png" alt="20201209125629367" style="zoom:40%;"></p><hr><p>让我们先来回想一下LTL之所以称为线性的，是因为时间的定性概念是<strong>基于路径</strong>的，并且被视为<strong>线性的</strong>：在每个时刻只有唯一的一个可能的后继状态，因此每个时刻都有一个唯一的可能的未来。 从技术上讲，这是基于以下事实：<u>LTL公式的解释是根据路径（即状态序列）定义的</u>。</p><p>但是路径本身可能<strong>存在着分支</strong>，例如在一个TS系统中，一个状态也许有着多个后继状态，从这个角度来看这种解释是基于状态分支的。我们想到，某些时候在一个状态的所有可能计算都满足某个条件，或者有些时候一个状态的部分可能计算满足某个条件，为了表述这些个性质，我们加入$\forall$ 和 $∃$ 符号。</p><p>LTL描述的从某个状态开始所有的路径情况，例如$s \models \Box(x\le 20)$，它表示对于从s开始的所有路径都满足 $x\le 20$</p><p>而<u>CTL描述的是从某个状态开始的所有或部分路径情况</u></p><p>例如$s\models \forall\Box(x\le 20)$,它表示对于从s开始的所有路径都满足$x\le 20$ , 而 $s\models∃\Box(x\le 20)$表示对于从s开始的某些路径满足$x\le 20$</p><h5 id="线性时间-vs-分支时间"><a href="#线性时间-vs-分支时间" class="headerlink" title="线性时间 vs 分支时间"></a>线性时间 vs 分支时间</h5><div class="table-container"><table><thead><tr><th></th><th>linear time</th><th>branching time</th></tr></thead><tbody><tr><td>行为behavior</td><td>path-based:trace(s)</td><td>state-based:computation tree of s</td></tr><tr><td>时间逻辑temporal logic</td><td>LTL path formulas</td><td>CTL state formulas</td></tr><tr><td>模型检测</td><td>$PSPACE-complete O(size(TS)·2^{\mid\phi\mid})$</td><td>$PTIME O(size(TS)·\mid\phi\mid)$</td></tr><tr><td>公平性</td><td>可以直接表示</td><td>需要额外的技术</td></tr></tbody></table></div><h5 id="执行集-vs-执行树"><a href="#执行集-vs-执行树" class="headerlink" title="执行集 vs 执行树"></a>执行集 vs 执行树</h5><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-04 22.04.31.png" alt="2022-04-04 22.04.31" style="zoom:50%;"></p><ul><li><p>执行集：$Exec(S) = ⟨({s_0}^+ → s_1 → s_2)^∗ → {s_0}^ω⟩,⟨({s_0}^+ → s_1 → s_2)^ω⟩,⟨({s_0}^+ → s_1 → s_2)^+ → s_3^ω⟩$</p></li><li><p>执行树：</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-04 22.10.01.png" alt="2022-04-04 22.10.01" style="zoom:50%;"></p></li></ul><h4 id="计算树逻辑CTL"><a href="#计算树逻辑CTL" class="headerlink" title="计算树逻辑CTL"></a>计算树逻辑CTL</h4><h5 id="模型描述"><a href="#模型描述" class="headerlink" title="模型描述"></a>模型描述</h5><p>CTL 公式始终与系统的给定状态 s 相关，迹 Trace(s) 源自该状态。S 的状态构成了这个逻辑的模型。</p><p>与 LTL 的区别（从句法上讲）在于迹量词的时间运算符的出现。</p><h4 id="CTL-语义"><a href="#CTL-语义" class="headerlink" title="CTL 语义"></a>CTL 语义</h4><h5 id="CTL状态公式的语义"><a href="#CTL状态公式的语义" class="headerlink" title="CTL状态公式的语义"></a>CTL状态公式的语义</h5><h6 id="s-models-a"><a href="#s-models-a" class="headerlink" title="$ s\models a$"></a>$ s\models a$</h6><p>当且仅当 $a∈L_(s)$</p><script type="math/tex; mode=display">\frac{}{s \models a}</script><h6 id="s-models-P-land-Q"><a href="#s-models-P-land-Q" class="headerlink" title="$s\models P \land Q$"></a>$s\models P \land Q$</h6><p>当且仅当 $s\models P$ 并且 $s\models Q$</p><script type="math/tex; mode=display">\frac{s \models P \qquad s \models Q}{s \models P \land Q}</script><h6 id="s-models-P-lor-Q"><a href="#s-models-P-lor-Q" class="headerlink" title="$s \models P \lor Q$"></a>$s \models P \lor Q$</h6><p>当且仅当 $s \models P$ 或者 $s \models Q$</p><script type="math/tex; mode=display">\frac{s \models P}{s \models P \lor Q} \qquad\frac{s \models Q}{s \models P \lor Q}</script><h6 id="s-nvDash-neg-P"><a href="#s-nvDash-neg-P" class="headerlink" title="$s\nvDash \neg P$"></a>$s\nvDash \neg P$</h6><p>当且仅当 $ s\models P$</p><script type="math/tex; mode=display">\frac{s \models P}{s \nvDash \neg P}</script><h6 id="s-models-∃-φ"><a href="#s-models-∃-φ" class="headerlink" title="$s\models ∃ φ$"></a>$s\models ∃ φ$</h6><p>当且仅当 $\pi\vDash\phi$ 对于<strong>某些</strong>从s开始的路径成立</p><h6 id="s-models-forall-φ"><a href="#s-models-forall-φ" class="headerlink" title="$s\models \forall φ$"></a>$s\models \forall φ$</h6><p>当且仅当 $\pi\vDash\phi$ 对于<strong>所有</strong>从s开始的路径成立</p><h5 id="CTL路径公式的语义"><a href="#CTL路径公式的语义" class="headerlink" title="CTL路径公式的语义"></a>CTL路径公式的语义</h5><ul><li>$\pi\vDash\bigcirc P$ 当且仅当 $\pi[1]=P$</li><li>$\pi\vDash P \mathcal{U} Q$ 当且仅当<strong>存在</strong> $j\ge0$ 使得 $s_{j}\vDash Q$ 且对于 $0\le k\lt j,\pi[k]\vDash P$</li></ul><h5 id="CTL在TS上的语义"><a href="#CTL在TS上的语义" class="headerlink" title="CTL在TS上的语义"></a>CTL在TS上的语义</h5><p>对于一个CTL公式 $\phi$，它的可满足集合(satisfaction set) $Sat(\phi)$ 定义为 :</p><script type="math/tex; mode=display">Sat(\phi)=\{s\in S | s\vDash \phi\}</script><p>说白了就是一些满足CTL公式$\phi$的状态的集合</p><p>如果我们说一个TS满足CTL公式 $\phi$ , 那么当且仅当公式 $\phi$ 在所有的初始状态上成立，用公式表示为：</p><script type="math/tex; mode=display">TS\vDash\phi\text{ 当且仅当 }S_{0}\subseteq Sat(\phi) \text{ 当且仅当 }\forall s_{0}\in S_{0}.s_{0}\vDash\phi</script><p>上面的 $S_{0}$ 就是初始状态的集合</p><h5 id="全称量词-从-s-开始的任何轨迹（对于-s-状态）"><a href="#全称量词-从-s-开始的任何轨迹（对于-s-状态）" class="headerlink" title="全称量词 : 从 s 开始的任何轨迹（对于 s 状态）"></a>全称量词 : 从 s 开始的任何轨迹（对于 s 状态）</h5><p>提醒：对于迹 $\sigma$，$\sigma_i$ 是从 0 开始的 $\sigma$ 的第 i 个元素，对于状态 s，Traces(s) 是来自 s 的迹线集合）</p><h6 id="s-models-forall-bigcirc-P"><a href="#s-models-forall-bigcirc-P" class="headerlink" title="$s \models \forall \bigcirc P$"></a>$s \models \forall \bigcirc P$</h6><p> P 在下一瞬间为真</p><script type="math/tex; mode=display">\frac{\forall \sigma \in Traces(S) :a_1 \models P}{s \models \forall \bigcirc P}</script><h6 id="s-models-forall-Box-P"><a href="#s-models-forall-Box-P" class="headerlink" title="$s \models \forall \Box P$"></a>$s \models \forall \Box P$</h6><p>P 在每个状态下始终为真</p><script type="math/tex; mode=display">\frac{\forall \sigma \in Traces(S) : \forall i \ge 0 :a_i \models P}{s \models \forall \Box P}</script><h6 id="s-models-forall-Diamond-P"><a href="#s-models-forall-Diamond-P" class="headerlink" title="$s \models \forall \Diamond P$"></a>$s \models \forall \Diamond P$</h6><p>P 最终为真（未来）</p><script type="math/tex; mode=display">\frac{\forall \sigma \in Traces(S) : ∃ i \ge 0 :a_i \models P}{s \models \forall \Diamond P}</script><h6 id="s-models-P-forall-mathcal-U-Q"><a href="#s-models-P-forall-mathcal-U-Q" class="headerlink" title="$s \models P\;\forall\;\mathcal{U}\;Q$"></a>$s \models P\;\forall\;\mathcal{U}\;Q$</h6><p>P 最终为真，同时 P 仍然为真</p><script type="math/tex; mode=display">\frac{\forall \sigma \in Traces(S) : ∃ j \ge 0 :a_j \models Q \land \forall i < j : \sigma_i \models P}{s \models P\;\forall\;\mathcal{U}\;Q}</script><h5 id="存在量词-从-s-开始的至少一条迹线（对于-s-状态）"><a href="#存在量词-从-s-开始的至少一条迹线（对于-s-状态）" class="headerlink" title="存在量词 : 从 s 开始的至少一条迹线（对于 s 状态）"></a>存在量词 : 从 s 开始的至少一条迹线（对于 s 状态）</h5><h6 id="s-models-∃-bigcirc-P"><a href="#s-models-∃-bigcirc-P" class="headerlink" title="$s \models ∃ \bigcirc P$"></a>$s \models ∃ \bigcirc P$</h6><p>P 在下一瞬间为真</p><script type="math/tex; mode=display">\frac{∃ \sigma \in Traces(S) :a_1 \models P}{s \models ∃ \bigcirc P}</script><h6 id="s-models-∃-Box-P"><a href="#s-models-∃-Box-P" class="headerlink" title="$s \models ∃ \Box P$"></a>$s \models ∃ \Box P$</h6><p>P 在每个状态下始终为真</p><script type="math/tex; mode=display">\frac{∃ \sigma \in Traces(S) : \forall i \ge 0 :a_i \models P}{s \models ∃ \Box P}</script><h6 id="s-models-∃-Diamond-P"><a href="#s-models-∃-Diamond-P" class="headerlink" title="$s \models ∃ \Diamond P$"></a>$s \models ∃ \Diamond P$</h6><p>P 最终为真（未来）</p><script type="math/tex; mode=display">\frac{∃ \sigma \in Traces(S) : ∃ i \ge 0 :a_i \models P}{s \models ∃ \Diamond P}</script><h6 id="s-models-P-∃-mathcal-U-Q"><a href="#s-models-P-∃-mathcal-U-Q" class="headerlink" title="$s \models P\;∃\;\mathcal{U}\;Q$"></a>$s \models P\;∃\;\mathcal{U}\;Q$</h6><p>Q 最终为真，同时 P 仍然为真</p><script type="math/tex; mode=display">\frac{∃ \sigma \in Traces(S) : ∃ j \ge 0 :a_j \models Q \land \forall i < j : \sigma_i \models P}{s \models P\;∃\;\mathcal{U}\;Q}</script><h5 id="forall-bigcirc-，-∃-bigcirc-图解"><a href="#forall-bigcirc-，-∃-bigcirc-图解" class="headerlink" title="$\forall \bigcirc$，$∃ \bigcirc$ 图解"></a>$\forall \bigcirc$，$∃ \bigcirc$ 图解</h5><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-04 23.03.07.png" alt="2022-04-04 23.03.07" style="zoom:40%;"></p><h5 id="forall-Box-，-∃-Box-图解"><a href="#forall-Box-，-∃-Box-图解" class="headerlink" title="$\forall \Box$，$∃ \Box$ 图解"></a>$\forall \Box$，$∃ \Box$ 图解</h5><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-04 23.07.21.png" alt="2022-04-04 23.07.21" style="zoom:40%;"></p><h5 id="forall-Diamond-，-∃-Diamond-图解"><a href="#forall-Diamond-，-∃-Diamond-图解" class="headerlink" title="$\forall \Diamond$，$∃ \Diamond$ 图解"></a>$\forall \Diamond$，$∃ \Diamond$ 图解</h5><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-04 23.08.46.png" alt="2022-04-04 23.08.46" style="zoom:40%;"></p><p>$\forall \mathcal{U}$，$∃ \mathcal{U}$ 图解</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-04 23.08.46.png" alt="2022-04-04 23.08.46" style="zoom:45%;"></p><h4 id="CTL-语法"><a href="#CTL-语法" class="headerlink" title="CTL 语法"></a>CTL 语法</h4><h5 id="最小运算符"><a href="#最小运算符" class="headerlink" title="最小运算符"></a>最小运算符</h5><p>$\{ \forall \bigcirc , \forall \mathcal{U}, ∃ \mathcal{U}\} \lor \{ ∃  \bigcirc , ∃ \Box, ∃ \mathcal{U}\} \lor \{ ∃  \diamond , ∃ \mathcal{U}, ∃ \bigcirc \}$</p><ul><li>$∃ \bigcirc P \triangleq \neg \forall \neg P$</li><li>$\forall \Diamond P \triangleq True \; \forall \mathcal{U} P$</li><li>$∃ \Diamond P \triangleq True \; ∃  \mathcal{U} P$</li><li>$\forall \Box P \triangleq \neg ∃ \Diamond \neg P$</li><li>$∃ \Box P \triangleq \neg \forall \Diamond \neg P$</li></ul><h5 id="替代语法-1"><a href="#替代语法-1" class="headerlink" title="替代语法"></a>替代语法</h5><ul><li>$∀ ↔ A$ (all) </li><li>$∃ ↔ E$ (exists) </li><li>$\Box ↔ G$ (globally)</li><li>$\Diamond ↔ F$ (finally)</li><li>$\bigcirc ↔ X$ (next)</li><li>$\mathcal{U} ↔ U$ (until)</li></ul><h5 id="互补运算符-1"><a href="#互补运算符-1" class="headerlink" title="互补运算符"></a>互补运算符</h5><ul><li>$P∃ \mathcal{W}Q \triangleq ∃ \Box P \lor P ∃ \mathcal{U} Q$</li><li>$P\forall \mathcal{W}Q $ 不等于 $  \forall \Box P \lor P \forall \mathcal{U} Q$；$P\forall \mathcal{W}Q \triangleq \neg (\neg Q ∃ \mathcal{U} (\neg P \land \neg Q))$</li></ul><h5 id="否定性-1"><a href="#否定性-1" class="headerlink" title="否定性"></a>否定性</h5><p>与 LTL 不同，对于任何 CTL 属性，我们有：</p><script type="math/tex; mode=display">S \models F，或\; S \models \neg F，或\; S \nvDash F ≡ S \models ¬F。</script><p>公式的否定$ ∀, ∃, \Box, \Diamond$</p><p>对基于 $ ∀, ∃, \Box, \Diamond$ 的公式的求反只需将每个运算符反转为对偶即可。</p><p>例：</p><ul><li><p>$¬(∀ \Diamond ∃ \Box p) = ∃\Box ∀\Diamond ¬p$</p></li><li><p>$(∀\Diamond ¬s_0 ⇒ ∀\Diamond s_3) = (∃\Box s_0 ∨ ∀\Diamond s_3) \qquad 因为 (p ⇒ q) = (¬p ∨ q)$</p></li></ul><h5 id="定点定义"><a href="#定点定义" class="headerlink" title="定点定义"></a>定点定义</h5><p>一旦定义了 $∃\bigcirc$ 和 $∀\bigcirc$，每个操作符就是最小的点</p><p>其归纳定义：</p><ul><li><p>$∀ \Box f = f ∧ ∀ \bigcirc ∀ \Box f$</p></li><li><p>$∃ \Box f = f ∧ ∃ \bigcirc ∃ \Box f$</p></li><li><p>$∀ \Diamond f = f ∨ ∀ \bigcirc ∀ \Diamond \Box f$</p></li><li><p>$∃ \Diamond f = f ∨ ∃ \bigcirc ∃ \Diamond \Box f$</p></li><li><p>$f ∀ \mathcal{U} g = g ∨ (f ∧ ∀\bigcirc (f ∀ \mathcal{U} g))$</p></li><li><p>$f ∃ \mathcal{U} g = g ∨ (f ∧ ∃\bigcirc (f ∃ \mathcal{U} g))$</p><p>（对于实现模型检查器特别有用）</p></li></ul><h3 id="第八部分：-LTL-vs-CTL"><a href="#第八部分：-LTL-vs-CTL" class="headerlink" title="第八部分：$LTL \; vs \; CTL$"></a>第八部分：$LTL \; vs \; CTL$</h3><h4 id="LTL和CTL的等价"><a href="#LTL和CTL的等价" class="headerlink" title="LTL和CTL的等价"></a>LTL和CTL的等价</h4><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/20201209125629367.png" alt="20201209125629367" style="zoom:50%;"></p><p>由之前的一张图我们看到，CTL和LTL有部分的表达是有交集的，这部分既可以用LTL表达，又可以用CTL表达，那么如何形式化地定义等价这个概念呢？</p><p>如果一个LTL公式 $φ$ 和一个CTL公式 $\Phi$ 是等价的（记为 $φ\equiv\Phi$），那么当且仅当，对于AP上的TS来说</p><script type="math/tex; mode=display">TS\vDash φ\Leftrightarrow TS\vDash\Phi</script><p>例如有这些个公式是等价的</p><div class="table-container"><table><thead><tr><th style="text-align:center">CTL公式 $\Phi$</th><th style="text-align:center">LTL公式 $φ$</th></tr></thead><tbody><tr><td style="text-align:center">$a$</td><td style="text-align:center">$a$</td></tr><tr><td style="text-align:center">$ \forall\bigcirc a$</td><td style="text-align:center">$\bigcirc a$</td></tr><tr><td style="text-align:center">$\forall(a\mathcal{U}b)$</td><td style="text-align:center">$a\mathcal{U}b$</td></tr><tr><td style="text-align:center">$\forall\Box a$</td><td style="text-align:center">$\Box a$</td></tr><tr><td style="text-align:center">$\forall\Diamond a$</td><td style="text-align:center">$\Diamond a$</td></tr><tr><td style="text-align:center">$\forall(a\mathcal{W}b)$</td><td style="text-align:center">$a\mathcal{W}b$</td></tr><tr><td style="text-align:center">$\forall\Box\forall\Diamond a$</td><td style="text-align:center">$\Box\Diamond a$</td></tr></tbody></table></div><h4 id="LTL和CTL各自能表达的部分"><a href="#LTL和CTL各自能表达的部分" class="headerlink" title="LTL和CTL各自能表达的部分"></a>LTL和CTL各自能表达的部分</h4><p>由上面的文氏图我们知道，LTL和CTL的表达能力并不完全等价，因为存在着只要有各自能够表达的部分</p><p>某些LTL公式不能表示成CTL公式，例如</p><ul><li>$\Diamond\Box a$</li><li>$\Diamond(a\land\bigcirc a)$</li></ul><p>某些CTL公式不能表示成LTL公式，例如</p><ul><li>$\forall\Diamond\forall\Box a$</li><li>$ \forall\Diamond(a\land\forall\bigcirc a)$</li><li>$\forall\Box\exist\Diamond a$</li></ul><h4 id="不等价案例"><a href="#不等价案例" class="headerlink" title="不等价案例"></a>不等价案例</h4><p>$\Diamond(a\wedge\bigcirc a)$ 与 $ \forall\Diamond(a\wedge\forall\bigcirc a)$ 不等价</p><p>例如下面这张图：</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2020121517502211.png" alt="2020121517502211" style="zoom:40%;"></p><p>我们可以看到它能表示LTL公式 $ \Diamond(a\land\bigcirc a)$，但是不能表示CTL公式$\forall\Diamond(a\land\forall\bigcirc a)$，因为看到 $S_{0},S_{3}$这条路径，对于用CTL表示的 $\forall\Diamond(a\wedge\forall\bigcirc a)$ 来说，从 $S_{0}$ 的角度看，它不满足所有的下一个状态 $a$ 成立。</p><p>再看另一个例子，$\Diamond\Box a$ 和 $\forall\Diamond\forall\Box a$ 不等价</p><p>就如下图所示</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/20201215203132106.png" alt="20201215203132106" style="zoom:40%;"></p><p>它能够表示LTL公式 $\Diamond\Box a$，但是不能表示CTL公式 $\forall\Diamond\forall\Box a$，我们把它的计算树画出来</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/20201215204837482.png" alt="20201215204837482"></p><p>我们看到最左边的那条路径，也就是说如果走的路径为 $S_{0}S_{0}S_{0}S_{0}S_{0}S_{0}…$ S 那么就会有一条路径不满足$\forall\Diamond\forall\Box a$。</p><h4 id="模型检测的复杂度"><a href="#模型检测的复杂度" class="headerlink" title="模型检测的复杂度"></a>模型检测的复杂度</h4><p>LTL模型检测的时间复杂度为</p><script type="math/tex; mode=display">O(|TS|·2^{|\phi|})</script><p>CTL模型检测的时间复杂度为</p><script type="math/tex; mode=display">O(|TS|·|\phi|)</script>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Transition-System-变迁系统-与-TLA&quot;&gt;&lt;a href=&quot;#Transition-System-变迁系统-与-TLA&quot; class=&quot;headerlink&quot; title=&quot;Transition System(变迁系统) 与 TLA+&quot;&gt;&lt;/a&gt;Transition System(变迁系统) 与 TLA+&lt;/h2&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/&quot;&gt;本文章&lt;/a&gt;是根据法国国立高等电力技术、电子学、计算机、水力学与电信学校 (E.N.S.E.E.I.H.T.) 第八学期课程“Système de Transition”总结而来的课程笔记。碍于本人学识有限，部分叙述难免存在纰漏，请读者注意甄别。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/campsisgrandiflora/category_10509594.html&quot;&gt;系统分析与验证 - Campsisgrandiflora的博客&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;《 Introduction to TLA 》- Lesie Lamport&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="课程笔记" scheme="https://dave0126.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="课程笔记" scheme="https://dave0126.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="系统" scheme="https://dave0126.github.io/tags/%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="TLA+" scheme="https://dave0126.github.io/tags/TLA/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发多线程编程 (JUC)</title>
    <link href="https://dave0126.github.io/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/"/>
    <id>https://dave0126.github.io/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/</id>
    <published>2022-03-23T20:13:13.000Z</published>
    <updated>2022-09-04T08:24:34.555Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-并发多线程编程"><a href="#Java-并发多线程编程" class="headerlink" title="Java 并发多线程编程"></a>Java 并发多线程编程</h2><p>视频课程: <a href="https://www.bilibili.com/video/BV16J411h7Rd?p=1">BiliBili - 黑马程序员Java并发编程 JUC</a></p><p>笔记参考: <a href="https://nyimac.gitee.io/2020/06/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发 - Nyima’s Blog</a></p><ul><li>注：本课程笔记基于JDK8，采用lsf4j打印日志</li></ul><span id="more"></span><h3 id="1-线程与进程"><a href="#1-线程与进程" class="headerlink" title="1 线程与进程"></a>1 线程与进程</h3><h4 id="1-1-进程"><a href="#1-1-进程" class="headerlink" title="1.1 进程"></a>1.1 进程</h4><ul><li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来<strong>加载指令、管理内存、管理 IO 的</strong>。</li><li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。</li><li>进程就可以视为<strong>程序的一个实例</strong>（程序是静态的，进程是动态的）。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器 等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）</li></ul><h4 id="1-2-线程"><a href="#1-2-线程" class="headerlink" title="1.2 线程"></a>1.2 线程</h4><ul><li>一个进程可以分为一到多个线程。</li><li><strong>一个线程就是一个指令流</strong>，将指令流中的一条条指令以一定的顺序交给 CPU 执行 。</li><li>Java 中，线程作为最小<strong>调度单位</strong>（执行指令），进程作为<strong>资源分配</strong>的最小单位。 在 Windows 中进程是不活动的，只是作 为线程的容器</li></ul><h4 id="1-3-两者对比"><a href="#1-3-两者对比" class="headerlink" title="1.3 两者对比"></a>1.3 两者对比</h4><ul><li><strong>进程基本上相互独立的</strong>，而<strong>线程存在于进程内</strong>，是进程的一个子集</li><li>进程拥有共享的资源，如内存空间等，供其<strong>内部的线程共享</strong><ul><li>进程间通信较为复杂 同一台计算机的进程通信称为 IPC（Inter-process communication）</li><li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP</li></ul></li><li>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量</li><li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</li></ul><h5 id="1-3-1-进程和线程的切换"><a href="#1-3-1-进程和线程的切换" class="headerlink" title="1.3.1 进程和线程的切换"></a>1.3.1 进程和线程的切换</h5><h6 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h6><p>内核为每一个进程维持一个上下文。<strong>上下文就是内核重新启动一个被抢占的进程所需的状态。</strong>包括以下内容：</p><ul><li>通用目的寄存器</li><li>浮点寄存器</li><li>程序计数器</li><li>用户栈</li><li>状态寄存器</li><li>内核栈</li><li>各种内核数据结构：比如描绘地址空间的<strong>页表</strong>，包含有关当前进程信息的<strong>进程表</strong>，以及包含进程已打开文件的信息的<strong>文件表</strong></li></ul><h6 id="进程切换和线程切换的主要区别"><a href="#进程切换和线程切换的主要区别" class="headerlink" title="进程切换和线程切换的主要区别"></a>进程切换和线程切换的主要区别</h6><p>最主要的一个区别在于<strong>进程切换涉及虚拟地址空间的切换而线程不会</strong>。因为每个进程都有自己的虚拟地址空间，而<strong>线程是共享所在进程的虚拟地址空间的</strong>，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换</p><p>页表查找是一个很慢的过程，因此通常使用cache来缓存常用的地址映射，这样可以加速页表查找，这个cache就是快表TLB（translation Lookaside Buffer，用来加速页表查找）。由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么<strong>当进程切换后页表也要进行切换，页表切换后TLB就失效了</strong>，cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致TLB失效，因为线程线程无需切换地址空间，因此我们通常说线程切换要比较进程切换快</p><p>而且还可能出现<strong>缺页中断</strong>，这就需要操作系统将需要的内容调入内存中，若内存已满则还需要将不用的内容调出内存，这也需要花费时间</p><h6 id="为什么TLB能加快访问速度"><a href="#为什么TLB能加快访问速度" class="headerlink" title="为什么TLB能加快访问速度"></a><strong>为什么TLB能加快访问速度</strong></h6><p>快表可以避免每次都对页号进行地址的有效性判断。快表中保存了对应的物理块号，可以直接计算出物理地址，无需再进行有效性检查</p><h4 id="1-4-并行与并发"><a href="#1-4-并行与并发" class="headerlink" title="1.4 并行与并发"></a>1.4 并行与并发</h4><ol><li><p>单核cpu 下，线程实际还是<strong>串行执行</strong>的。操作系统中有一个组件叫做任务调度器，将cpu 的时间片（windows 下时间片最小约为 15 毫秒）分给不同的线程使用，只是由于 cpu在线程间（时间片很短）的切换非常快，人类感觉是<strong>同时运行</strong>的。总结为一句话就是：“<strong>微观串行，宏观并行</strong>”<br>一般会将这种<strong>线程轮流使用 CPU</strong>的做法称为并发，Concurrent。</p></li><li><p>多核cpu下，每个核心都可以调度运行线程，此时线程间是可以<strong>并行</strong>(Parallel)的。</p></li></ol><p><strong>并发</strong>(Concurrent) 是一个CPU在不同的时间去不同线程中执行指令。</p><p><strong>并行</strong>(Parallel)是多个CPU同时处理不同的线程。</p><h4 id="1-5-应用"><a href="#1-5-应用" class="headerlink" title="1.5 应用"></a>1.5 应用</h4><h5 id="1-5-1-应用之异步调用（案例1）"><a href="#1-5-1-应用之异步调用（案例1）" class="headerlink" title="1.5.1 应用之异步调用（案例1）"></a>1.5.1 应用之异步调用（案例1）</h5><p>以<strong>调用方角度</strong>来讲，如果</p><ul><li>需要等待结果返回，才能继续运行就是同步</li><li>不需要等待结果返回，就能继续运行就是异步</li></ul><p>注意：同步在多线程中还有另外一层意思，即让多个线程步调一致</p><h6 id="1-设计"><a href="#1-设计" class="headerlink" title="1) 设计"></a>1) 设计</h6><p>多线程可以让方法执行变为异步的（即不要巴巴干等着）比如说读取磁盘文件时，假设读取操作花费了 5 秒钟，如果没有线程调度机制，这 5 秒 cpu 什么都做不了，其它代码都得暂停…</p><p>一般来讲，大文件的读写、耗时较长的工作可以异步执行</p><h6 id="2-结论"><a href="#2-结论" class="headerlink" title="2) 结论"></a>2) 结论</h6><ul><li>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程</li><li>tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞</li><li>tomcat 的工作线程 ui 程序中，开线程进行其他操作，避免阻塞 ui 线程</li></ul><h5 id="1-5-2-应用之提高效率（案例1）"><a href="#1-5-2-应用之提高效率（案例1）" class="headerlink" title="1.5.2 应用之提高效率（案例1）"></a>1.5.2 应用之提高效率（案例1）</h5><p>充分利用多核 cpu 的优势，提高运行效率。想象下面的场景，执行3个计算，最后将计算结果汇总。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">计算 1 花费10ms</span><br><span class="line">计算 2 花费11ms</span><br><span class="line">计算 3 花费9ms</span><br><span class="line">汇总需要1ms</span><br></pre></td></tr></table></figure><p>如果是串行执行，那么总共花费的时间是 <code>10 + 11 + 9 + 1 = 31ms</code></p><ul><li>但如果是四核 cpu，各个核心分别使用线程1 执行计算1，线程2执行计算2，线程3执行计算3，那么3个线程是并行的，花费时间只取决于最长的那个线程运行的时间，即<code>11ms</code> 。最后加上汇总时间，只会花费<code>12ms</code>。</li></ul><p><strong>注意</strong>：需要在多核cpu 才能提高效率，单核仍然时是轮流执行</p><h6 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h6><ol><li>单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用 cpu ，不至于一个线程总占用 cpu，别的线程没法干活</li><li>多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的<ul><li>有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任 务都能拆分（参考后文的【阿姆达尔定律】）</li><li>也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义</li></ul></li><li>IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 CPU，但需要一 直等待 IO 结束，没能充分利用线程。所以才有后面的【非阻塞 IO】和【异步 IO】优化。</li></ol><h3 id="2-Java-线程"><a href="#2-Java-线程" class="headerlink" title="2 Java 线程"></a>2 Java 线程</h3><h4 id="2-1-创建和运行线程"><a href="#2-1-创建和运行线程" class="headerlink" title="2.1 创建和运行线程"></a>2.1 创建和运行线程</h4><h5 id="方法一：直接使用构造器创建一个线程"><a href="#方法一：直接使用构造器创建一个线程" class="headerlink" title="方法一：直接使用构造器创建一个线程"></a>方法一：直接使用构造器创建一个线程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateThread</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;my thread running...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">myThread.start();  <span class="comment">// 启动线程</span></span><br><span class="line">    System.out.println(<span class="string">&quot;main thread running...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用继承方式的好处是，在<code>run()</code>方法内获取当前线程直接使用 <code>this</code> 就可以了，无须使用 <code>Thread.currentThread()</code>方法；</li><li>不好的地方是 Java 不支持多继承，如果<u>继承了 <code>Thread</code> 类</u>，那么就不能再继承其他类。另外<u>任务与代码没有分离</u>，当多个线程执行一样的任务时需要多份任务代码</li></ul><h5 id="方法二：使用-Runnable-配合-Thread（推荐）"><a href="#方法二：使用-Runnable-配合-Thread（推荐）" class="headerlink" title="方法二：使用 Runnable 配合 Thread（推荐）"></a>方法二：使用 <code>Runnable</code> 配合 <code>Thread</code>（推荐）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//创建线程任务</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">runnableInstance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Runnable running&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//将Runnable对象传给Thread</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnableInstannce);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">t.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过实现 <code>Runnable</code> 接口，并且实现 <code>run()</code>方法。好处是<strong><em><u>将任务和线程分离</u></em></strong>，更为灵活。在创建线程时作为参数传入该类的实例即可。</p><h5 id="方法二的简化：使用lambda表达式简化操作"><a href="#方法二的简化：使用lambda表达式简化操作" class="headerlink" title="方法二的简化：使用lambda表达式简化操作"></a>方法二的简化：使用lambda表达式简化操作</h5><p>当<strong>只有一个抽象方法的接口</strong>可以用 <code>@FunctionalInterface</code> 注解。当有该注解时，可以<strong>使用 lambda 来简化操作</strong>。所以方法二中的代码可以被简化为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//创建线程任务</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">      <span class="comment">//直接写方法体即可</span></span><br><span class="line">System.out.println(<span class="string">&quot;Runnable running&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Hello Thread&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//将Runnable对象传给Thread</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">    </span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">t.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还可以继续简化上述代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello Thread!&quot;</span>);</span><br><span class="line">    &#125;,<span class="string">&quot;name_of_thread&quot;</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 IDEA 中，可以在 <code>Runnable</code> 上使用<code>Alt + Enter</code>自动转换成 lambda 表达式。</p><h6 id="Thread-与-Runnable-的关系"><a href="#Thread-与-Runnable-的关系" class="headerlink" title="Thread 与 Runnable 的关系"></a>Thread 与 Runnable 的关系</h6><p>分析 <code>Thread</code> 的源码，理清它与 <code>Runnable</code> 的关系。</p><p>【方法一】</p><ul><li>首先，<code>Thread</code> 实现了 <code>Runnable</code> 接口，我们可以类比静态代理，将 <code>new Thread</code> 看作是代理对象。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;...&#125;</span><br></pre></td></tr></table></figure><ul><li>在方法 1 中，我们在  <code>new Thread</code> 对象中重写了 <code>run()</code> 方法。</li></ul><p>【方法二】</p><ul><li>在方法 2 中，<code>Thread</code> 的构造方法如下，会传入一个 <code>Runnable target</code> 对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(Runnable target)</span> &#123;</span><br><span class="line">        init(<span class="literal">null</span>, target, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ThreadGroup g, Runnable target, String name,<span class="type">long</span> stackSize)</span> &#123;</span><br><span class="line">        init(g, target, name, stackSize, <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>而在 <code>Thread</code> 的 <code>run()</code> 方法中，会先判断 <code>Runnable target</code> 对象是否为空，如果非空，就调用 <code>target.run()</code> 方法，</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">           target.run();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><blockquote><p>用 <code>Runnable</code> 更容易与线程池等高级 API 配合用 <code>Runnable</code> 让任务类脱离了 <code>Thread</code> 继承体系，更灵活。Java 推荐<strong><em><u>组合优于继承</u></em></strong></p></blockquote><h5 id="方法三：使用-FutureTask-与-Thread-结合"><a href="#方法三：使用-FutureTask-与-Thread-结合" class="headerlink" title="方法三：使用 FutureTask 与 Thread 结合"></a>方法三：使用 <code>FutureTask</code> 与 <code>Thread</code> 结合</h5><p>分析 <code>FutureTask</code> 源码我们可以知道， <code>FutureTask</code> 间接实现了  <code>Runnable</code> 和 <code>Future</code> 接口，所以他也可以像方法二一样创建一个线程。 <code>Future</code> 接口的 <code>get()</code> 方法可以用来返回任务的执行结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTask</span>&lt;V&gt; <span class="keyword">implements</span> <span class="title class_">RunnableFuture</span>&lt;V&gt; &#123;...&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RunnableFuture</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">Runnable</span>, Future&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外， <code>Runnable</code> 的 <code>run()</code> 方法没有返回值，这样就没有办法在两个线程之间传递返回值。所以 <code>FutureTask</code> 可以与 <code>Callable</code> 接口结合使用，就可以将任务的结果转递给其他线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用 <code>FutureTask</code> 可以用泛型指定<strong>线程的返回值</strong>类型（<code>Runnable</code> 的 <code>run()</code> 方法没有返回值）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">//需要传入一个 Callable 对象，使得任务结束时可以返回值</span></span><br><span class="line">FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Integer&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;线程执行!&quot;</span>);</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">r1.start();</span><br><span class="line">    </span><br><span class="line"><span class="comment">//获取线程中方法执行后的返回结果</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> task.get() <span class="comment">// 阻塞在此处等待结果的返回</span></span><br><span class="line">System.out.println(res);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【总结】</p><p>使用<strong>继承方式的好处是方便传参</strong>，你可以在子类里面添加成员变量，通过 <code>set()</code> 方法设置参数或者通过构造函数进行传递，而如果使用 <code>Runnable</code> 方式，则只能使用主线程里面被声明为 <code>final</code> 的变量。</p><p><strong>不好的地方是 Java 不支持多继承</strong>，如果继承了 <code>Thread</code> 类，那么子类不能再继承其他类，而 <code>Runable</code> 则没有这个限制。<strong>前两种方式都没办法拿到任务的返回结果，但是 <code>FutureTask</code> 方式可以</strong></p><h4 id="2-2-原理之线程运行"><a href="#2-2-原理之线程运行" class="headerlink" title="2.2 原理之线程运行"></a>2.2 原理之线程运行</h4><h5 id="2-2-1-栈与栈帧"><a href="#2-2-1-栈与栈帧" class="headerlink" title="2.2.1 栈与栈帧"></a>2.2.1 栈与栈帧</h5><p><a href="https://dave0126.github.io/2022/03/22/JVM-1/#2-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88">Java Virtual Machine Stacks</a> （Java 虚拟机栈） 我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？</p><ul><li>栈内存 $\to$ 线程。其实就是线程，每个线程启动后，虚拟机就会为其分配一块<strong><em><u>栈内存</u></em></strong></li><li>栈帧 $\to$ 调用方法。每个<strong><em><u>栈由多个栈帧</u></em></strong> (Frame) 组成，对应着每次<strong>方法调用时所占用的内存</strong></li><li>每个线程只能有<strong><em><u>一个活动栈帧</u></em></strong>，对应着当前正在执行的那个方法</li></ul><h6 id="JVM-工作流程："><a href="#JVM-工作流程：" class="headerlink" title="JVM 工作流程："></a>JVM 工作流程：</h6><p>当我们运行一个程序（类）时，</p><ol><li>我们先执行【类加载】，把该类的字节码放入方法区；</li><li>JVM 启动【主线程】，并且为其分配一个【主线程栈】内存空间；</li><li>从【主方法】开始，JVM 为主方法<u>在主线程栈内</u>分配一个【主方法栈帧】内存；</li><li>而在这个【主方法栈帧】内存中，存在着【局部变量表】【操作数栈】【锁记录】等</li><li>【局部变量表】用来存储方法内的局部变量；</li><li>当我们调用其他方法时，JVM 会为其在【主线程栈】中分配一块新的【栈帧】内存；</li><li>当我们【<code>new</code>】一个对象时，这个对象会被存储在【堆】，并将该对象的【引用】地址存入相应的地方（局部变量表等）</li><li>当我们创建一个线程时，JVM 会为其分配一个新的【栈】内存空间，不同的栈内存互不干扰。</li></ol><h5 id="2-2-2-线程上下文切换"><a href="#2-2-2-线程上下文切换" class="headerlink" title="2.2.2 线程上下文切换"></a>2.2.2 线程上下文切换</h5><p>因为以下一些原因导致 CPU 不再执行当前的线程，转而执行另一个线程的代码</p><p>【被动】</p><ul><li>线程的 CPU 时间片用完</li><li>垃圾回收（“Stop the world”）</li><li>有更高优先级的线程需要运行</li></ul><p>【主动】</p><ul><li>线程自己调用了 <code>sleep</code>、<code>yield</code>、<code>wait</code>、<code>join</code>、<code>park</code>、<code>synchronized</code>、<code>lock</code> 等方法</li></ul><p>当【上下文切换】发生时，需要由操作系统<strong>保存当前线程的状态</strong>，并<strong>恢复另一个线程的状态</strong>，Java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条 JVM 指令的执行地址，<strong><em><u>是线程私有的</u></em></strong></p><ul><li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li><li>上下文切换频繁发生会影响性能</li></ul><h4 id="2-3-常见方法"><a href="#2-3-常见方法" class="headerlink" title="2.3 常见方法"></a>2.3 常见方法</h4><div class="table-container"><table><thead><tr><th><strong>方法名</strong></th><th><strong>功能说明</strong></th><th style="text-align:left"><strong>注意</strong></th></tr></thead><tbody><tr><td><code>start()</code></td><td>启动一个新线程，在新线程上运行<code>run()</code>方法中的代码</td><td style="text-align:left"><code>start()</code> 方法只是让线程进入【就绪状态】，里面代码<strong><em><u>不一定立刻运行</u></em></strong>（<em>有可能 CPU 的时间片还没分给它</em>）。每个线程对象的<strong><code>start()</code>方法只能调用一次</strong>，如果调用了多次会出现 <code>IllegalThreadStateException</code></td></tr><tr><td><code>run()</code></td><td>新线程启动后会调用的方法</td><td style="text-align:left">如果在构造 <code>Thread</code> 对象时传递了 <code>Runnable</code> 参数，则线程启动后会调用 <code>Runnable</code> 中的<code>run()</code> 方法，否则默认不执行任何操作。但可以创建 <code>Thread</code> 的子类对象，来覆盖默认行为</td></tr><tr><td><code>join()</code></td><td>阻塞等待线程运行结束</td><td style="text-align:left"></td></tr><tr><td><code>join(long n)</code></td><td>阻塞等待线程运行结束最多等待 n 毫秒</td><td style="text-align:left"></td></tr><tr><td><code>getId()</code></td><td>获取线程长整型的`id·</td><td style="text-align:left"><code>id</code> 唯一</td></tr><tr><td><code>getName()</code></td><td>获取线程名</td><td style="text-align:left"></td></tr><tr><td><code>setName(String)</code></td><td>修改线程名</td><td style="text-align:left"></td></tr><tr><td><code>getPriority()</code></td><td>获取线程优先级</td><td style="text-align:left"></td></tr><tr><td><code>setPriority(int)</code></td><td>设置线程优先级</td><td style="text-align:left">java中规定线程优先级是 1~10 的整数，较大的优先级能提高该线程被 CPU 调度的机率</td></tr><tr><td><code>getState()</code></td><td>获取线程状态</td><td style="text-align:left">Java 中线程状态使用6个 enum 表示： <code>NEW</code>，<code>RUNNABLE</code>，<code>BLOCKED</code>，<code>WATING</code>，<code>TIMED_WAITING</code>，<code>TERMINATED</code></td></tr><tr><td><code>isInterrupted()</code></td><td>判断是否被打断</td><td style="text-align:left">不会清除打断标记</td></tr><tr><td><code>isAlive()</code></td><td>线程是否存活（还没有运行完毕）</td><td style="text-align:left"></td></tr><tr><td><code>interrupt()</code></td><td>打断线程</td><td style="text-align:left">如果被打断线程正在 <code>sleep, wait, join</code> 会导致被打断的线程抛出 <code>InterruptedException</code>，并<strong>清除打断标记</strong>；如果打断的正在运行的线程，则会<strong>设置打断标记</strong>；<code>park</code> 的线程被打断，也会<strong>设置打断标记</strong></td></tr><tr><td><code>currentThread()</code></td><td>获取当前正在执行的线程</td><td style="text-align:left"></td></tr><tr><td><code>sleep(long n)</code></td><td>让当前执行的线程休眠 n 毫秒，休眠时让出 CPU 的时间片给其它线程</td><td style="text-align:left">不会释放<strong>锁</strong>操作</td></tr><tr><td><code>yield()</code></td><td>提示线程调度器让出当前线程对 CPU 的使用</td><td style="text-align:left">主要是为了测试和调试</td></tr></tbody></table></div><h5 id="2-3-1-start-vs-run"><a href="#2-3-1-start-vs-run" class="headerlink" title="2.3.1 start() vs run()"></a>2.3.1 <code>start()</code> vs <code>run()</code></h5><ul><li><code>start()</code> 用来启动线程， <code>run()</code> 是线程启动之后要执行的方法。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test4</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;RUNNING...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不启动t1线程就直接run()</span></span><br><span class="line">    t1.run();</span><br><span class="line">    System.out.println(t1.getState());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUNNING...</span><br></pre></td></tr></table></figure><p>我们可以看到，貌似没有 <code>start()</code> 来启动 <code>t1</code> 线程， <code>run()</code> 也成功执行了。但是我们需要注意，这里的 <code>run()</code> 方法其实是<strong><em><u>主线程执行</u></em></strong>的。</p><p>被创建的 <code>Thread</code> 对象不启动直接调用重写的 <code>run()</code> 方法时， <code>run()</code> 方法是在<strong>主线程</strong>中被执行的，而不是在我们所创建的线程中执行。</p><p>所以如果想要在所创建的线程中执行 <code>run()</code> 方法，<strong>需要使用 <code>Thread</code> 对象的 <code>start()</code> 方法。</strong></p><h5 id="2-3-2-sleep-vs-yield"><a href="#2-3-2-sleep-vs-yield" class="headerlink" title="2.3.2 sleep() vs yield()"></a>2.3.2 <code>sleep()</code> vs <code>yield()</code></h5><ul><li><code>sleep()</code> ：当前线程从 <code>Running</code> 运行状态 $\to$  <code>Timed Waiting</code> 阻塞状态 $\stackrel{一段时间}{\longrightarrow}$   <code>Runnable</code> 就绪状态</li><li><code>yield()</code>：当前线程从 <code>Running</code> 运行状态 $\to$   <code>Runnable</code> 就绪状态</li></ul><blockquote><p>个人理解：</p><p><code>sleep()</code> 更偏向于阻塞一段时间，之后等待 CPU 执行到它再进入就绪状态；而 <code>yield()</code> 是让出当前这一次执行，进入就绪状态，不影响下一次执行。</p></blockquote><h6 id="sleep-使线程阻塞"><a href="#sleep-使线程阻塞" class="headerlink" title="sleep() 使线程阻塞"></a><code>sleep()</code> 使线程阻塞</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test5</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;t1开始sleep&quot;</span>);</span><br><span class="line">          Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">          System.out.println(<span class="string">&quot;t1结束sleep&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;t1被唤醒&quot;</span>);</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t1.strat();</span><br><span class="line">    </span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    System.out.println(t1.getState());</span><br><span class="line">    t1.interrupt(); <span class="comment">// 打断t1的sleep</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t1开始sleep</span><br><span class="line">t1: Timed Waiting</span><br><span class="line">t1被唤醒</span><br></pre></td></tr></table></figure><ol><li><p>调用 <code>sleep()</code> 会让当前线程从 <strong><code>Running</code> 进入 <code>Timed Waiting</code> 状态（阻塞）</strong>，可通过<code>state()</code>方法查看</p></li><li><p>其它线程可以使用 <strong><code>interrupt()</code></strong> 方法打断正在睡眠的线程，这时 <code>sleep()</code> 方法会抛出 <code>InterruptedException</code></p></li><li><p>睡眠结束后的线程未必会立刻得到回到 <code>Runnable</code> 状态</p></li><li><p>建议用 <strong><code>TimeUnit</code> 的 <code>sleep()</code></strong> 代替 Thread 的 <code>sleep()</code> 来获得更好的可读性 。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//休眠一秒</span></span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">Thread.sleep(<span class="number">1</span>*<span class="number">1000</span>);</span><br><span class="line"><span class="comment">//休眠一分钟</span></span><br><span class="line">TimeUnit.MINUTES.sleep(<span class="number">1</span>);</span><br><span class="line">Thread.sleep(<span class="number">1</span>*<span class="number">60</span>*<span class="number">1000</span>);</span><br></pre></td></tr></table></figure></li></ol><h6 id="yield-让出当前线程"><a href="#yield-让出当前线程" class="headerlink" title="yield() 让出当前线程"></a><code>yield()</code> 让出当前线程</h6><ol><li>调用 <code>yield()</code> 会让当前线程从 <strong><code>Running</code> 运行状态进入 <code>Runnable</code> 就绪状态</strong>（仍然有可能被执行），然后调度执行其它线程</li><li><strong><em><u>具体的实现</u></em></strong>依赖于操作系统的【任务调度器】</li></ol><h6 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h6><ul><li><p>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它</p></li><li><p>如果 CPU 比较忙，那么优先级高的线程会获得更多的时间片，但 CPU 闲时，优先级几乎没作用</p></li><li><p>设置方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread1.setPriority(Thread.MAX_PRIORITY); <span class="comment">//设置为优先级int(1~10)</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">Runnable</span> <span class="variable">task1</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;----&gt; task1&quot;</span> + count++);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="type">Runnable</span> <span class="variable">task2</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">      Thread.yield();</span><br><span class="line">      System.out.println(<span class="string">&quot;===== task2&quot;</span> + count++);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task1, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task1, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  t1.start();</span><br><span class="line">  t2.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果应为 t1打印的count 远大于 t2打印的count</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="2-3-3-join"><a href="#2-3-3-join" class="headerlink" title="2.3.3 join()"></a>2.3.3 <code>join()</code></h5><p>我们先分析如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test5</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;t1开始sleep&quot;</span>);</span><br><span class="line">          Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">          System.out.println(<span class="string">&quot;t1结束sleep&quot;</span>);</span><br><span class="line">          res = <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    t1.strat();</span><br><span class="line">    System.out.println(res);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><p>由于两个线程的执行次序与执行时间（操作系统线程调度）并不确定，所以我们不能够确定 <code>res</code> 取值。我们可以用 <code>join()</code> 方法等待其他线程的结束。流程图如下</p><pre class="mermaid">graph TDA1[main]--瞬间完成-->E1[r=0]E1 --> B1[t1.join]A1 --> C1[t1.start]C1 --1s后---> D1[r=10]D1 --t1结束--> B1B1 --> R1[res: r=10]</pre><p><code>join()</code>的底层原理就是 <code>wait()</code>。</p><p>用于等待某个线程结束。哪个线程内调用 <code>join()</code> 方法，就等待哪个线程结束，然后再去执行其他线程。</p><p>如在主线程中调用 <code>ti.join()</code>，则是主线程等待 <code>t1</code> 线程结束。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>();</span><br><span class="line"><span class="comment">//等待thread线程执行结束</span></span><br><span class="line">thread.join();</span><br><span class="line"><span class="comment">//最多等待1000ms,如果1000ms内线程执行完毕，则会直接执行下面的语句，不会等够1000ms</span></span><br><span class="line">thread.join(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h5 id="2-3-4-interrupt"><a href="#2-3-4-interrupt" class="headerlink" title="2.3.4 interrupt()"></a>2.3.4 <code>interrupt()</code></h5><p>用于打断<u>阻塞</u> (<code>sleep()</code>、<code>wait()</code>、<code>join()</code> …) 以及<u>正常运行</u>的线程。 处于<strong>阻塞状态</strong>的线程，CPU 不会给其分配时间片。</p><ul><li>如果一个线程在在运行中被打断，打断标记会被置为 <code>true</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test6</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t1开始运行&quot;</span>);</span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">this</span>.isInterrupted()) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        t1.interrupt(); <span class="comment">// 打断t1的sleep</span></span><br><span class="line">        System.out.println(<span class="string">&quot;t1的打断标记：&quot;</span> + t1.isInterrupted());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t1开始运行</span><br><span class="line">t1的打断标记：true</span><br></pre></td></tr></table></figure><ul><li>如果是打断因<code>sleep(), wait(), join()</code>方法而被阻塞的线程，会将打断标记会被清空，置为 <code>false</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于查看打断标记，返回值被boolean类型</span></span><br><span class="line">t1.isInterrupted();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test6</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;t1开始sleep&quot;</span>);</span><br><span class="line">          Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">          System.out.println(<span class="string">&quot;t1结束sleep&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;t1被打断&quot;</span>);</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t1.strat();</span><br><span class="line">    </span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    t1.interrupt(); <span class="comment">// 打断t1的sleep</span></span><br><span class="line">    System.out.println(<span class="string">&quot;t1的打断标记：&quot;</span> + t1.isInterrupted());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t1开始sleep</span><br><span class="line">t1被打断</span><br><span class="line">t1的打断标记：false</span><br></pre></td></tr></table></figure><p>正常运行的线程在被打断后，<strong>不会停止</strong>，会继续执行。如果要让线程在被打断后停下来，需要<strong>使用打断标记来判断</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throw</span> InterruptedException&#123;</span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  t1.start();</span><br><span class="line">  </span><br><span class="line">  Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  Log.debug(<span class="string">&quot;interrupted&quot;</span>);</span><br><span class="line">  t1.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="interrupt-的应用——两阶段终止模式"><a href="#interrupt-的应用——两阶段终止模式" class="headerlink" title="interrupt() 的应用——两阶段终止模式"></a><code>interrupt()</code> 的应用——两阶段终止模式</h6><p>当我们在执行线程一时，想要终止线程二，这是就需要使用 <code>interrupt()</code> 方法来<strong>优雅</strong>的停止线程二（料理后事: <u>释放锁和临界资源等</u>）。</p><p>【错误思路】</p><ul><li><code>stop()</code>：该方法会强制杀死线程，该方法虽然能在进程结束后立即释放锁对象，但是这种方法会破坏 <code>run()</code> 代码块的原子性（<code>synchronized</code> 保护其原子性），造成程序的逻辑错误（运行一半被突然恶意打断）。</li><li><code>suspend()</code>：暂停线程（挂起）和 <code>resume()</code>恢复线程，若线程对临界区资源上锁，则永远解锁，其他线程也无法获取锁。</li><li><code>System.exit(int)</code>：该方法会直接<strong>停止进程</strong>。</li></ul><p>【两阶段终止模式】</p><pre class="mermaid">graph TDA["while(true)"]B{是否被打断?}C[料理后事]D[睡眠2s]E(结束循环)F[执行监控记录]G["设置打断标记 = true"]A --> BB --yes--> CB --no--> DC --> ED --无异常--> FD --有异常--> GF --> AG --> A</pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  两阶段终止模式（Two Phase Termination）：在进程T1中终止进程T2</span></span><br><span class="line"><span class="comment">    在终止进程T2之前让T2释放锁和临界资源</span></span><br><span class="line"><span class="comment">    不用stop() 和 System.exit()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TwoPhaseTermination</span> &#123;</span><br><span class="line">    <span class="comment">// 监控线程</span></span><br><span class="line">    privite Thread monitor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动监控线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        monitor = <span class="keyword">new</span> <span class="title class_">Thread</span> (() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                <span class="keyword">if</span> (current.isInterrupted()) &#123;</span><br><span class="line">                    <span class="comment">// TODO 释放锁和临界资源</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;释放锁和临界资源&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    <span class="comment">//TODO 正常功能的代码块</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="comment">// 若sleep时被打断，会捕获错误e，此时的isInterrupted标记为false，程序会继续执行。所以有以下操作</span></span><br><span class="line">                    current.interrupt(); <span class="comment">// 重新设置isInterrupted打断标记, true -&gt; false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        monitor.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止监控线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        monitor.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-5-主线程与守护线程"><a href="#2-3-5-主线程与守护线程" class="headerlink" title="2.3.5 主线程与守护线程"></a>2.3.5 主线程与守护线程</h5><ul><li><p>主线程: 当 JAVA 进程中有多个线程在执行时，只有当所有非守护线程都执行完毕后，JAVA进程才会结束。</p></li><li><p>守护线程: <strong>但当非守护线程全部执行完毕后，守护线程无论是否执行完毕，也会一同结束。</strong>(垃圾回收线程)</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将线程设置为守护线程, 默认为false</span></span><br><span class="line">Thread.setDaemon(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h4 id="2-4-线程的状态"><a href="#2-4-线程的状态" class="headerlink" title="2.4 线程的状态"></a>2.4 线程的状态</h4><h5 id="2-4-1-五种状态（操作系统层面）"><a href="#2-4-1-五种状态（操作系统层面）" class="headerlink" title="2.4.1 五种状态（操作系统层面）"></a>2.4.1 五种状态（操作系统层面）</h5><p><img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/20200608144606.png" alt="20200608144606" style="zoom:75%;"></p><ol><li>【初始状态】：在<strong>语言层面创建了线程对象</strong>，但未与操作系统线程关联</li><li>【可运行状态】：（就需状态），已与操作系统线程关联，可由 cpu 调度执行</li><li>【运行状态】：获得 cpu 时间片，正在执行。<ul><li>当 cpu 分配的时间片用完，由【运行状态】转为【可运行状态】，导致线程的上下文切换</li></ul></li><li>【阻塞状态】：该状态下的线程不会占用 cpu ，会导致线程的上下文切换<ul><li>等阻塞操作结束，系统唤醒阻塞状态，切换至【可运行状态】</li></ul></li><li>【终止状态】：表示线程已经执行完毕，线程不会再转换成其他状态</li></ol><h5 id="2-4-2-六种状态（JAVA-API-层面）"><a href="#2-4-2-六种状态（JAVA-API-层面）" class="headerlink" title="2.4.2 六种状态（JAVA API 层面）"></a>2.4.2 六种状态（JAVA API 层面）</h5><p><img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/20200608144621.png" alt="20200608144621" style="zoom:75%;"></p><p>详见<a href="#3.9-线程状态转换">第三章 3.9【线程状态转换】</a></p><ol><li><p>【<code>NEW</code>】：线程被创建，还没有调用<code>strat()</code>方法</p></li><li><p>【<code>RUNNABLE</code>】：调用了<code>start()</code>方法后。该状态涵盖了<strong>操作系统层面</strong>的<em>【可运行状态】、【运行状态】和【阻塞状态】</em></p></li><li><p>三种“Java 中的阻塞状态”：后面会在状态转换一节详述。</p><p>(1) 【<code>BLOCKED</code>】：<code>synchronized</code> 等待获得锁时</p><p>(2)【<code>WAITING</code>】：<code>join()</code></p><p>(3)【<code>TIMED_WAITING</code>】：<code>sleep()</code></p></li><li><p>【<code>TERMINATED</code>】：代码运行结束</p></li></ol><h4 id="2-5-习题"><a href="#2-5-习题" class="headerlink" title="2.5 习题"></a>2.5 习题</h4><h5 id="2-5-1-统筹方法（烧水泡茶）"><a href="#2-5-1-统筹方法（烧水泡茶）" class="headerlink" title="2.5.1 统筹方法（烧水泡茶）"></a>2.5.1 统筹方法（烧水泡茶）</h5><p>阅读华罗庚《统筹方法》，给出烧水泡茶的多线程解决方案，提示：</p><ul><li>参考图二，用两个线程（两个人协作）模拟烧水泡茶过程<ul><li>文中办法乙、丙都相当于任务串行</li><li>而图一相当于启动了 4 个线程，有点浪费</li></ul></li><li>用<code>sleep(n)</code>模拟洗茶壶、洗水壶等耗费的时间</li></ul><p>附：华罗庚《统筹方法》</p><hr><p>统筹方法，是一种安排工作进程的数学方法。它的实用范围极广泛，在企业管理和基本建设中，以及关系复杂的科研项目的组织与管理中，都可以应用。</p><p>怎样应用呢？主要是把工序安排好。</p><p>比如，想泡壶茶喝。当时的情况是：开水没有；水壶要洗，茶壶、茶杯要洗;火已生了，茶叶也有了。<br>怎么办？</p><ul><li>办法甲：洗好水壶，灌上凉水，放在火上；在等待水开的时间里，洗茶壶、洗茶杯、 拿茶叶；等水开了，泡茶喝。</li><li>办法乙：先做好一些准备工作，洗水壶，洗茶壶茶杯，拿茶叶；一切就绪，灌水烧水；坐待水开了，泡茶喝。</li><li>办法丙：洗净水壶，灌上凉水，放在火上，坐待水开；水开了之后，急急忙忙找茶叶，洗茶壶茶杯，泡茶喝。</li></ul><p>哪一种办法省时间？我们能一眼看出，第一种办法好，后两种办法都窝了工。</p><p>这是小事，但这是引子，可以引出生产管理等方面有用的方法来。</p><p>水壶不洗，不能烧开水，因而洗水壶是烧开水的前提。没开水、没茶叶、不洗茶壶茶杯，就不能泡茶，因而这些又是泡茶的前提。它们的相互关系，可以用下图来表示：</p><pre class="mermaid">graph LR;A[洗水壶 1min]--> B[烧开水 15mins];B--> R[泡茶];C[洗茶壶 1min]--> R;D[洗茶杯 1min]--> R;E[拿茶叶 1min]--> R;</pre><p>从这个图上可以一眼看出，办法甲总共要16分钟（而办法乙、丙需要20分钟）。如果要缩短工时．提高工作效率，应当主要抓烧开水这个环节，而不是抓拿茶叶等环节。同时，洗茶壶茶杯、拿茶叶总共不过3分钟，大可利用“等水开”的时间来做。</p><p>是的，这好像是废话，卑之无甚高论。有但稍有变化，临事而迷的情况，常常是存任的。在近代工业的错综夏杂的工艺过程中，往往就不是像泡茶喝这么简单了。任务多了，几百几千，甚至有好几万个任务。关系多了，错综复杂，千头万绪，往往出现 “万事俱备，只欠东风” 的情况。由于一两个零件没完成，耽误了一台复杂机器的出厂时间。或往往因为抓的不是关键，连夜三班，急急忙忙，完成这一环节之后，还得等待旁的环节才能装配。</p><p>洗茶壶，洗茶杯，拿茶叶，或先或后，关系不大，而且同是一个人的活儿，因币可以合并成为：</p><pre class="mermaid">graph LR;A[洗水壶 1min]--> B[烧开水 15mins];B--> R[泡茶];C[洗茶壶, 洗茶杯, 拿茶叶 3mins]--> R;</pre><p>看来这是“小题大做”，但在工作环节太多的时候，这样做就非常必要了。</p><p>这里讲的主要是时间方面的事，但在具体生产实践中，还有其他方面的许多事。这种方法里然不一定能直接解决所有问题，但是，我们利用这种方法来考虑问题，也是不无裨益的。</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pubilc <span class="keyword">static</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    Log.debug(<span class="string">&quot;洗水壶&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    Log.debug(<span class="string">&quot;烧开水&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">15000</span>);</span><br><span class="line">  &#125;, <span class="string">&quot;小明&quot;</span>);</span><br><span class="line">    </span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    Log.debug(<span class="string">&quot;洗茶壶&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    Log.debug(<span class="string">&quot;洗茶杯&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    Log.debug(<span class="string">&quot;拿茶叶&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">     t1.join(); <span class="comment">// 由 小王 来泡茶 </span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="string">&quot;小王&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  t1.start();</span><br><span class="line">  t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">19:19:37.547[小明]c.TestMakeTea -洗茶壶</span><br><span class="line">19:19:37.547[小王]c.TestMakeTea - 洗水壶</span><br><span class="line">19:19:38.552[小明]c.TestMakeTea - 洗茶杯</span><br><span class="line">19:19:38.552[小王]c.TestMakeTea - 烧开水</span><br><span class="line">19:19:49.553[小明]c.TestMakeTea - 拿茶叶</span><br><span class="line">19:19:53.553[小明]c.TestMakeTea -泡茶</span><br></pre></td></tr></table></figure><p>解法1的缺陷：</p><ul><li>上面模拟的是小明等小王的水烧开了，小明泡茶，如果反过来要实现小王等小明的茶叶拿来了，小王泡茶呢？代码最好能适应两种情况</li><li>上面的两个线程其实是各执行各的，如果要模拟小王把水壶交给小明泡茶，或模拟小明把茶叶交给小王泡茶</li></ul><h4 id="2-6-小结"><a href="#2-6-小结" class="headerlink" title="2.6 小结"></a>2.6 小结</h4><p>本章的重点在于掌握</p><ul><li>线程的四种创建方式：<ol><li>使用构造器 <code>new Thread()</code>，重写其中的 <code>run()</code> 方法</li><li>重写 <code>Runnable</code> 接口的 <code>run()</code> 方法，再将其（任务）作为参数传入 <code>new Thread()</code>。线程和任务可以分离。</li><li>重写 <code>Callable</code> 接口的 <code>V call()</code> 方法，再将 <code>FutureTask&lt;&gt;(new Callable)</code> 任务作为参数传入 <code>new Thread()</code>。这样不仅可以实现线程和任务的分离，还可以返回线程的结果。</li><li>使用线程池。</li></ol></li><li>线程重要api， 如<code>start, run, sleep, join, interrupt</code>等</li><li>线程状态：操作系统的五种，Java 层面的六种</li><li>应用方面<ul><li>异步调用：主线程执行期间，其它线程异步执行耗时操作</li><li>提高效率：并行计算，缩短运算时间</li><li>同步等待：<code>join</code></li><li>统筹规划：合理使用线程，得到最优效果</li></ul></li><li>原理方面<ul><li>线程运行流程：栈、栈帧、上下文切换、程序计数器</li><li>Thread 三种创建方式的源码</li></ul></li><li>模式方面<ul><li>两阶段终止</li></ul></li></ul><h3 id="3-共享模型之管程"><a href="#3-共享模型之管程" class="headerlink" title="3 共享模型之管程"></a>3 共享模型之管程</h3><h4 id="3-1-共享带来的问题"><a href="#3-1-共享带来的问题" class="headerlink" title="3.1 共享带来的问题"></a>3.1 共享带来的问题</h4><p>Java 代码中的体现</p><p>两个线程对初始值为 0 的全局静态变量。一个做自增操作， 一个做自减操作，各执行5000次， 最终的结果是0吗？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">5000</span>; i++)&#123;</span><br><span class="line">      counter++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">5000</span>; i++)&#123;</span><br><span class="line">      counter--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  t1.start();</span><br><span class="line">  t2.start();</span><br><span class="line">  t1.join();</span><br><span class="line">  t2.join();</span><br><span class="line">  </span><br><span class="line">  Log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, counter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果大概率不为 <code>0</code></p><pre class="mermaid">sequenceDiagram    participant 线程1    participant 线程2    participant 静态变量 i    静态变量 i ->> 线程2 :getstatic i 读取0    线程2 ->> 线程2 :iconst_1 准备常数 1    线程2 ->> 线程2 :isub 减法, 线程内 i= -1    线程2 -x 静态变量 i :!!!还没来得及将i的结果写入    线程2 -->> 线程1 :上下文切换    线程1 ->> 线程1 :iconst_1 准备常数 1    线程1 ->> 线程1 :iadd 加法, 线程内 i= 1    线程1 ->> 静态变量 i :putstatic i 写入 1    线程1 -->> 线程2 :上下文切换    线程2 ->> 静态变量 i :putstatic i 写入 -1</pre><p>最终结果为 <code>-1</code>.</p><h5 id="3-1-1-临界区-Critical-Section"><a href="#3-1-1-临界区-Critical-Section" class="headerlink" title="3.1.1 临界区 Critical Section"></a>3.1.1 临界区 Critical Section</h5><ul><li>一个程序运行多个线程本身是没有问题的</li><li>问题出在多个线程访问共享资源<ul><li>多个线程读共享资源其实也没有问题</li><li>在多个线程对共享资源读写操作时发生指令交错，就会出现问题</li></ul></li><li>一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为<strong>临界区</strong></li></ul><p>例如，下面代码中的临界区</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 临界资源</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> </span><br><span class="line"><span class="comment">// 临界区 </span></span><br><span class="line">&#123;   </span><br><span class="line">    counter++; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> </span><br><span class="line"><span class="comment">// 临界区 </span></span><br><span class="line">&#123; </span><br><span class="line">    counter--; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-1-2-竞态条件-Race-Condition"><a href="#3-1-2-竞态条件-Race-Condition" class="headerlink" title="3.1.2 竞态条件 Race Condition"></a>3.1.2 竞态条件 Race Condition</h5><p>多个线程在<strong>临界区</strong>内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了<strong>竞态条件</strong></p><h4 id="3-2-Synchronized-解决方案"><a href="#3-2-Synchronized-解决方案" class="headerlink" title="3.2 Synchronized 解决方案"></a>3.2 <code>Synchronized</code> 解决方案</h4><h5 id="3-2-1-解决手段"><a href="#3-2-1-解决手段" class="headerlink" title="3.2.1 解决手段"></a>3.2.1 解决手段</h5><p>为了避免临界区的竞态条件发生，有多种手段可以达到目的。</p><ul><li>【阻塞式】的解决方案：<code>synchronized</code>，<code>Lock</code></li><li>【非阻塞式】的解决方案：原子变量</li></ul><p>本次课使用阻塞式的解决方案：<strong>synchronized</strong>，来解决上述问题，即俗称的<strong>【对象锁】</strong>，它采用互斥的方式让同一 时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住(blocked)。这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换。</p><h5 id="3-2-2-Synchronized-语法"><a href="#3-2-2-Synchronized-语法" class="headerlink" title="3.2.2 Synchronized 语法"></a>3.2.2 Synchronized 语法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(Object) &#123; <span class="comment">// 例如, 当线程1持有锁时, 线程2被阻塞; 等待线程1释放锁</span></span><br><span class="line"><span class="comment">//临界区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line"><span class="comment">//创建一个公共对象，作为对象锁的对象</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;    </span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;            </span><br><span class="line">        <span class="keyword">synchronized</span> (room) &#123; <span class="comment">// 上锁</span></span><br><span class="line">        counter++;            </span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;    </span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;       </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;         </span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123; <span class="comment">// 上锁</span></span><br><span class="line">            counter--;          </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    t1.start();    </span><br><span class="line">    t2.start(); </span><br><span class="line">    t1.join();   </span><br><span class="line">    t2.join();    </span><br><span class="line">    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,counter); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序流程如下图: </p><pre class="mermaid">sequenceDiagram    participant 线程1    participant 线程2    participant 静态变量 i    participant 🔒锁对象    线程2 ->> 🔒锁对象 :尝试获取锁    Note over 🔒锁对象,线程2 :拥有锁    静态变量 i ->> 线程2 :getstatic i 读取0    线程2 ->> 线程2 :iconst_1 准备常数 1    线程2 ->> 线程2 :isub 减法, 线程内 i= 0-1 = -1    线程2 -->> 线程1 :上下文切换    线程1 ->> 🔒锁对象 :尝试获取锁, 但是被阻塞(BLOCKED)    线程1 -->> 线程2 :上下文切换    线程2 ->> 静态变量 i :putstatic i 写入 -1    Note over 🔒锁对象,线程2 :拥有锁    线程2 ->> 🔒锁对象 :释放锁, 并唤醒阻塞的线程    Note over 🔒锁对象,线程1 :拥有锁    静态变量 i ->> 线程1 :getstatic i 读取-1    线程1 ->> 线程1 :iconst_1 准备常数 1    线程1 ->> 线程1 :iadd 加法, 线程内 i= -1+1 = 0    线程1 ->> 静态变量 i :putstatic i 写入 0    Note over 🔒锁对象,线程1 :拥有锁    线程1 ->> 🔒锁对象 :释放锁, 并唤醒阻塞的线程</pre><p>【思考】</p><p><code>synchronized</code> 实际是用<strong>对象锁</strong>保证了<strong>临界区内代码的原子性</strong>，临界区内的代码对外是不可分割的，不会被线程切换所打断。</p><p>将上一个代码块的例子解耦，使其资源类和任务类分开:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Room</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">      counter++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">      counter--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCounter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">  <span class="type">Room</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Room</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;            </span><br><span class="line">      room.increment();</span><br><span class="line">    &#125;    </span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;       </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">          room.decrement();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    t1.start();    </span><br><span class="line">    t2.start(); </span><br><span class="line">    t1.join();   </span><br><span class="line">    t2.join();    </span><br><span class="line">    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,room.getCounter()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-2-3-Synchronized-在方法上"><a href="#3-2-3-Synchronized-在方法上" class="headerlink" title="3.2.3 Synchronized 在方法上"></a>3.2.3 <code>Synchronized</code> 在方法上</h5><p>我们必须知道， <strong><code>Synchronized</code> 锁住的始终是对象</strong>. 以下两个例子看似是与方法有关, 实则依然是为对象加锁.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// synchronized 加在成员方法上</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123; <span class="comment">// 锁住 this 对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// synchronized 加在静态方法上</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Test.class) &#123; <span class="comment">// 锁住 Test 类对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li><code>sleep()</code> 方法不会释放 <code>synchronized</code> 锁。</li></ul><h4 id="3-3-变量的线程安全分析"><a href="#3-3-变量的线程安全分析" class="headerlink" title="3.3 变量的线程安全分析"></a>3.3 变量的线程安全分析</h4><h5 id="3-3-1-成员变量和静态变量的线程安全分析"><a href="#3-3-1-成员变量和静态变量的线程安全分析" class="headerlink" title="3.3.1 成员变量和静态变量的线程安全分析"></a>3.3.1 成员变量和静态变量的线程安全分析</h5><ul><li>如果没有变量<strong><em><u>没有在线程间共享</u></em></strong>，那么变量是<strong><em><u>安全</u></em></strong>的；</li><li>如果变量在线程间共享<ul><li>如果只有<strong><em><u>读操作</u></em></strong>，则线程<strong><em><u>安全</u></em></strong>；</li><li>如果有<strong><em><u>读写操作</u></em></strong>，则这段代码是临界区，需要<strong><em><u>考虑线程安全</u></em></strong>。</li></ul></li></ul><h5 id="3-3-2-局部变量线程安全分析"><a href="#3-3-2-局部变量线程安全分析" class="headerlink" title="3.3.2 局部变量线程安全分析"></a>3.3.2 局部变量线程安全分析</h5><ul><li><strong><em><u>局部变量被初始化</u></em></strong>为【基本数据类型】是<strong>安全</strong>的；</li><li><p><strong><em><u>局部变量<a href="https://dave0126.github.io/2022/03/22/JVM-1/#1-3-五种引用">引用的对象</a></u></em></strong> 【未必】是安全的；</p><ul><li>如果局部变量引用的对象<u>没有引用线程共享的对象</u>，那么是<u>线程安全</u>的；</li><li>如果局部变量引用的对象<u>引用了一个线程共享的对象</u>，那么要<u>考虑线程安全</u>。</li></ul></li><li><p><strong><em><u>局部变量是线程安全的</u></em></strong>——每个方法都在对应线程的栈中创建栈帧，不会被其他线程共享。</p></li></ul><p><img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/20200608144636.png" alt="20200608144636" style="zoom:75%;"></p><ul><li>如果局部变量引用的对象被共享，且执行了读写操作，则<strong>线程不安全</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassUnsafe</span> &#123;</span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(<span class="type">int</span> loopNumber)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;loopNumber; i++) &#123;</span><br><span class="line">            method2();</span><br><span class="line">            method3();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span> &#123;</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ClassUnsafe</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassUnsafe</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                test.method1(<span class="number">200</span>);</span><br><span class="line">            &#125;,<span class="string">&quot;thread &quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该程序的在运行过程中有可能会报错。因为多个线程会访问同一个 <code>ArrayList&lt;String&gt; list</code> 对象。</p><p><img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/20200608144649.png" alt="20200608144649" style="zoom:60%;"></p><ul><li>如果是局部变量，则会在<a href="https://dave0126.github.io/2022/03/22/JVM-1/#4-堆">堆</a>中创建对应的对象，不会存在线程安全问题。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassSafe</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(<span class="type">int</span> loopNumber)</span> &#123;</span><br><span class="line">      ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;loopNumber; i++) &#123;</span><br><span class="line">            method2(list);</span><br><span class="line">            method3(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(ArrayList&lt;String&gt; list)</span> &#123;</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">(ArrayList&lt;String&gt; list)</span> &#123;</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/20200608144702.png" alt="20200608144702" style="zoom:60%;"></p><h5 id="3-3-3-常见线程安全类"><a href="#3-3-3-常见线程安全类" class="headerlink" title="3.3.3 常见线程安全类"></a>3.3.3 常见线程安全类</h5><ul><li><code>String</code></li><li><code>Integer</code></li><li><code>StringBuffer</code></li><li><code>Random</code></li><li><code>Vector</code></li><li><code>Hashtable</code></li><li><code>java.util.concurrent</code> 包下的类 </li></ul><p>这里说它们是线程安全的是指，<u>多个线程调用它们同一个实例的某个方法时，是线程安全的</u>。也可以理解为</p><ul><li>它们的每个方法是原子的</li><li>但多个方法组合在一起就不是原子的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Hashtable</span> <span class="variable">table</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line"><span class="comment">// thread1, thread2</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"> <span class="keyword">if</span> (table.get(<span class="string">&quot;key&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">  table.put(<span class="string">&quot;key&quot;</span>,value1)</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"> <span class="keyword">if</span> (table.get(<span class="string">&quot;key&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">  table.put(<span class="string">&quot;key&quot;</span>,value2)</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre class="mermaid">sequenceDiagram    participant 线程1    participant 线程2    participant table    table ->> 线程1 :get("key") == null    table ->> 线程2 :get("key") == null    线程2 ->> table :put("key", value2)    线程1 ->> table :put("key", value1)</pre><h5 id="3-3-4-不可变类线程安全性"><a href="#3-3-4-不可变类线程安全性" class="headerlink" title="3.3.4 不可变类线程安全性"></a>3.3.4 不可变类线程安全性</h5><p><code>String</code>、<code>Integer</code> 等都是<strong>不可变类</strong>，因为<strong><em><u>其内部的属性不可以改变</u></em></strong>，因此它们的方法都是线程安全的</p><blockquote><p><strong>思考:</strong></p><p> <code>String</code> 有 <code>replace()</code>，<code>substring()</code> 等方法可以改变值，那么这些方法又是如何保证线程安全的呢？</p><p>这是因为这些方法的返回值都<strong><em><u>创建了一个新的对象</u></em></strong>，而不是直接改变 <code>String</code>、<code>Integer</code> 对象本身。</p></blockquote><h5 id="3-3-5-习题"><a href="#3-3-5-习题" class="headerlink" title="3.3.5 习题"></a>3.3.5 习题</h5><p>找出临界区代码，加锁</p><ul><li>买票：BiliBili - 黑马程序员全面深入学习Java并发编程，JUC并发编程全套教程 <a href="https://www.bilibili.com/video/BV16J411h7Rd?p=71">买票问题</a></li><li>转账：BiliBili - 黑马程序员全面深入学习Java并发编程，JUC并发编程全套教程 <a href="https://www.bilibili.com/video/BV16J411h7Rd?p=74">转账问题</a></li></ul><h4 id="3-4-Monitor"><a href="#3-4-Monitor" class="headerlink" title="3.4 Monitor"></a>3.4 <code>Monitor</code></h4><h5 id="3-4-0-Java-对象头"><a href="#3-4-0-Java-对象头" class="headerlink" title="3.4.0 Java 对象头"></a>3.4.0 Java 对象头</h5><blockquote><p>注意 ⚠️</p><p>个人认为，对于一个对象，当我们<strong><em><u>通过</u></em></strong>对象头信息的 【<code>Mark Word</code>】 <strong><em><u>区分</u></em></strong>（关于锁的）不同【对象类型】的时候，我们是通过【最后 <code>2 bits</code> 】来区分不同的锁信息的（<code>Normal</code> 和 <code>Biased</code> 则需要最后 <code>3 bits</code>，因为其后两位都为 <code>01</code>）。</p></blockquote><p>一个 Java 对象由【对象头】和【对象体】组成。以 <code>32 bits</code> 的虚拟机为例，</p><ul><li><p>普通对象：</p><p><img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/image-20220902142218758.png" alt="image-20220902142218758" style="zoom:70%;"></p><ul><li><p>普通对象的 Java 对象头由 <code>Mark Word</code> 和 <code>Klass World</code> 组成，一共 <code>64 bits</code>；</p></li><li><p><code>Klass World</code>：用来表示该对象的类型（如 <code>String</code> 等），是一个指针，用来找到类对象；</p></li><li><p><code>Mark Word</code> 在不同对象类型下的结构如下：</p><ol><li><code>Normal</code> 普通类型标记：<code>hashcode(25 bits)</code> 用来区分对象的哈希码；<code>age(4 bits)</code> GC 垃圾回收时的分代年龄；<code>biased_lock(1 bit)</code> 代表是否是偏向锁；最后 <code>2 bits</code> 代表该对象的加锁状态。  </li><li><code>Biased</code> 偏向锁标记</li><li><code>Ligthweight Locked</code> 轻量级锁标记（最后 <code>2 bits : 0 0</code>）：<code>ptr_to_lock_record(30 bits)</code> 指向 <code>LockRecord</code> 锁记录对象的指针；最后 <code>2 bits</code> 代表该对象的加锁状态。  </li><li><code>Heavyweight Locked</code> 重量级锁标记：<code>ptr_to_heavyweight_monitor(30 bits)</code> 指向 <code>Monitor</code> 的指针；最后 <code>2 bits</code> 代表该对象的加锁状态。  </li><li><code>GC</code> 垃圾回收标记：如果该对象已经被 <code>GC</code> 垃圾回收了，则将最后 <code>2 bits</code> 置为 <code>11</code>。</li></ol><p><img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/image-20220902142940973.png" alt="image-20220902142940973" style="zoom:70%;"></p></li></ul></li></ul><ul><li>数组对象：数组对象在普通对象 <code>(64 bits)</code> 的基础上增加了 <code>array length(32 bits)</code> 数组长度。</li></ul><p><img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/image-20220902142343013.png" alt="image-20220902142343013" style="zoom:70%;"></p><h5 id="3-4-1-Monitor-原理"><a href="#3-4-1-Monitor-原理" class="headerlink" title="3.4.1 Monitor 原理"></a>3.4.1 <code>Monitor</code> 原理</h5><blockquote><p><strong><em>2022.09.04</em></strong> 更新：<a href="https://dave0126.github.io/2022/09/02/关于ObjectMonitor的底层源码分析/">关于ObjectMonitor的底层源码分析</a></p></blockquote><p><code>Monitor</code> 又称为监视器或<strong>管程</strong>,，<strong><em><u>是 <code>synchronized</code> 实现的底层原理</u></em></strong>, 由<strong><em><u>【操作系统】提供</u></em></strong></p><p>每个 Java 对象都可以关联一个 <code>Monitor</code> 对象：如果使用 <code>synchronized</code> 关键字给对象上锁（重量级）之后，该对象与 <code>Monitor</code> 关联。其中</p><ul><li>【上锁】的字节码表示是 <code>monitorenter</code>，将该对象的对象头中的 <code>Mark Word</code> 的前 <code>30 bits</code> 设置为为指向 <code>Monitor</code> 的指针；</li><li>【解锁】的字节码表示是 <code>monitorexit</code>，将该 <code>Owner</code> 置为 <code>null</code>，唤醒 <code>EntryList</code> 里等待的线程。</li></ul><p><img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/20200608144917.png" alt="20200608144917"></p><ul><li>刚开始时， <code>Monitor</code> 的 <code>Owner</code> 为空</li><li>当线程执行到临界区代码时，如果使用了 <code>synchronized</code>，会先查询 <code>synchronized</code> 中所指定的对象（<code>obj</code>）<strong>是否关联了 <code>Monitor</code></strong><ul><li>如果<strong>没有关联</strong>，则会先去去与 <code>Monitor</code> 关联，并且将 <code>Owner</code> 设为当前线程。</li><li>如果已经关联，则会去查询该 <code>Monitor</code> 是否已经有了 <code>Owner</code><ul><li>如果没有，则 <code>Owner</code> 与将当前线程绑定</li><li>如果有，则放入 <code>EntryList</code>，进入阻塞状态（<code>blocked</code>）</li></ul></li></ul></li><li>当 <code>Monitor</code> 的 <code>Owner</code> 将临界区中代码执行完毕后，<code>Owner</code> 便会被清空，此时 <code>EntryList</code> 中处于<strong>阻塞</strong>状态的线程会被<strong>叫醒并竞争</strong>，此时的竞争是<strong>【非公平的】</strong></li></ul><blockquote><p><strong>注意</strong> ⚠️：</p><ul><li>对象在使用了 <code>synchronized</code> 后与 <code>Monitor</code> 绑定时，会将对象头中的 <code>Mark Word</code> 的前 <code>30 bits</code> 设置为为指向 <code>Monitor</code> 的指针。</li><li>每个对象都会绑定一个【唯一】的 <code>Monitor</code>，如果 <code>synchronized</code> 中所指定的对象（<code>obj</code>）不同，则会绑定不同的 <code>Monitor</code>。</li></ul></blockquote><h5 id="3-4-2-轻量级锁"><a href="#3-4-2-轻量级锁" class="headerlink" title="3.4.2 轻量级锁"></a>3.4.2 轻量级锁</h5><blockquote><p>我们之前已经知道，由 <code>synchronized</code> 关键字加锁的对象底层是通过 <code>monitor</code> 这种【重量级锁】实现的。那么当我们为了保证一个对象可以被互斥地访问而采取了 <code>synchronized</code>，但是这个对象在运行中不存在不同线程间竞争的关系。JVM 为此提供了一套对于 <code>synchronized</code> 的优化机制，以减小每次使用重量级锁的系统开销。</p><p>注意 ⚠️</p><p>个人认为，轻量级锁并<strong><em><u>不是一种【实体的锁】</u></em></strong>，而是一系列通过算法调度，优化 <code>Monitor</code> 的系统开销的”策略“。为了与 <code>Monitor</code> 这种重量级锁对应，我们才称其为轻量级锁。</p></blockquote><p>【使用场景】当一个对象被多个线程所访问，但访问的时间是错开的（不存在竞争），此时就可以使用轻量级锁来优化。</p><p>因为重量级锁由操作系统提供，使用时系统开销较大，所以在使用 <code>synchronized</code> 时【优先】使用轻量级锁。轻量级锁对使用者是透明的，即语法依然是 【<code>synchronized</code>】， 优先使用轻量级锁，如若失败则改用其他类型。</p><p>（1）每次想要访问<code>Object</code> 时，都会创建<strong>锁记录</strong> <code>Lock Record</code>对象。每个线程的栈帧都会包含一个锁记录对象，内部可以存储锁定对象的 <code>Mark Word</code>（不再一开始就使用 <code>Monitor</code>）；</p><p><img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/20200608144942.png" alt="20200608144942" style="zoom:75%;"></p><p>（2）让锁记录中的 <code>Object reference</code> 指向锁对象 <code>Object</code>，并尝试用 <code>cas</code>去替换 <code>Object</code> 中的 <code>Mark Word</code>，将此 <code>Mark Word</code> 放入 <code>lock record</code> 中保存；</p><blockquote><p>这里提到的 <code>cas</code> 在后面的章节会详细介绍，这里只需了解 <code>cas</code> 操作目的是<u>为了交换【对象头】的 <code>Mark Word</code> 与线程栈中【锁记录】的【地址 + 锁类型】信息</u>。该操作是<strong><em><u>原子性</u></em></strong>的。</p></blockquote><p><img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/20200608144950.png" alt="20200608144950" style="zoom:75%;"></p><p>（3）如果 <code>cas</code> 替换成功，则将 <code>Object</code> 的<u><strong><em>对象头的 <code>Mark Word</code></em></strong></u>替换为<strong><em><u>锁记录的地址和状态 <code>00</code>（轻量级锁状态）</u></em></strong>，表示由该线程给对象加锁</p><p><img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/20200608144957.png" alt="20200608144957" style="zoom:75%;"></p><p>（4）当一个【线程】想要访问一个加锁 【<code>Object</code> 】对象时，该线程会检查对象头 <strong><em><u><code>Mark Word</code> 的最后 <code>2 bits</code></u></em></strong> 是不是 <strong><em><u><code>01</code></u></em></strong>。若是，则为【步骤（3）】中的正常加锁流程；若是  <strong><em><u><code>00</code></u></em></strong>，则说明<strong><em><u>已经有线程持有了该 <code>Object</code> 的轻量级锁</u></em></strong>， <code>cas</code> 失败。以下根据<u>线程的不同</u>，分为<u>两种情况</u>讨论：</p><ul><li>如果是【其他线程】已经持有了该 <code>Object</code> 的轻量级锁，即对象头中的【锁记录地址】不指向本线程。这时表明有竞争，进入下一小节的【<a href>锁膨胀</a>】过程</li><li>如果是【本线程】已经持有了该 <code>Object</code> 的轻量级锁，也即加锁 <code>Object</code> 对象头中的锁记录地址指向本线程。当再一次使用这个加锁的 <code>Object</code> 时，新创建一个为<strong><em><u>地址与状态码为 <code>null</code>的【锁记录】</u></em></strong>。此时我们称执行了 <code>synchronized</code> 【锁重入】，而<strong><em><u>【锁记录】的个数</u></em></strong>就是该线程<strong><em><u>对 <code>Object</code> 加锁的次数</u></em></strong>。</li></ul><p><img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/image-20220326175731138-8313862.png" alt="image-20220326175731138" style="zoom:75%;"></p><p>（5）当退出 <code>synchronized</code> 【解锁】时，如果<strong><em><u>有取值为 <code>null</code> 的锁记录</u></em></strong>，表示有锁重入。这时清除这个记录，表示【重入计数 -1】</p><p><img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/20200608144957.png" alt="20200608144957" style="zoom:75%;"></p><p>（6）当退出 <code>synchronized</code> 【解锁】<strong><em><u>锁记录的值不为 <code>null</code></u></em></strong> 时，这时使用 <code>cas</code> 将 <code>Mark Word</code> 的值恢复给对象头：</p><ul><li>成功，则解锁成功；</li><li>失败，说明轻量级锁进行了【锁膨胀】或者已经升级为【重量级锁】，进入重量级锁解锁流程。</li></ul><h5 id="3-4-3-锁膨胀"><a href="#3-4-3-锁膨胀" class="headerlink" title="3.4.3 锁膨胀"></a>3.4.3 锁膨胀</h5><blockquote><p>锁膨胀：轻量级锁 $\stackrel{升级}{\longrightarrow}$ 重量级锁的过程。</p></blockquote><p>（1）如果一个线程在给一个对象加轻量级锁时，<strong><em><u><code>cas</code> 替换操作失败</u></em></strong>（因为此时其他线程已经给对象加了轻量级锁，<strong><em><u><code>Mark Word</code> 的最后 <code>2 bits</code></u></em></strong> 是 <strong><em><u><code>00</code></u></em></strong>），此时该线程就会进入【锁膨胀】过程：</p><p><img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/20200608145004.png" alt="20200608145004" style="zoom:75%;"></p><p>（2）此时便会给对象加上【重量级锁】（<code>Monitor</code>）：</p><p>将对象头的 <code>Mark Word</code> 改为 <strong><em><u><code>Monitor</code> 的地址</u></em></strong>，并且状态改为 <strong><em><u><code>10</code></u></em></strong>，进入【阻塞状态】</p><p><img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/20200608145148.png" alt="20200608145148" style="zoom:75%;"></p><p>（3）当 <code>Thread-0</code> 解锁时，想使用 <code>cas</code> 将 <code>Mark Word</code> 的值恢复给对象头，而此时的对象头里存放着 <code>Monitor</code>  的地址和状态码 <code>10</code>。<code>cas</code> 失败。这时会进入重量级解锁流程，即按照 <code>Monitor</code> 地址找到 <code>Monitor</code> 对象，设置<code>Owner</code> 为 <code>null</code>，唤醒 <code>EntryList</code> 中阻塞等待的线程。</p><h5 id="3-4-4-自旋优化"><a href="#3-4-4-自旋优化" class="headerlink" title="3.4.4 自旋优化"></a>3.4.4 自旋优化</h5><p><strong>重量级锁</strong>竞争时，还可以使用自旋来优化(在多核心cpu中才有意义)，如果当前线程在<strong>自旋成功</strong>（使用锁的线程退出了同步块，<strong>释放了锁</strong>，即当前线程可以直接成为新的Owner），这时就可以避免线程进入阻塞状态。</p><h6 id="自旋成功的情况"><a href="#自旋成功的情况" class="headerlink" title="自旋成功的情况"></a>自旋成功的情况</h6><pre class="mermaid">sequenceDiagram    participant t1 as 线程1(CPU 0)    participant obj as synchronized(Object)    participant t2 as 线程2(CPU 1)    Note over obj :状态码 01 (无锁)    t1 ->> +obj :访问同步块， 获取 Monitor    t1 ->> obj :成功加锁    Note over obj :重量级锁指针 ｜状态码 10 (重量级锁)    t2 -x obj :❌ 访问同步块， 获取 Monitor    t2 ->> t2 :自旋重试    Note over t1 :执行临界区代码块    t2 ->> t2 :自旋重试    obj ->> -t1 :成功解锁    Note over obj :状态码 01 (无锁)    t2 ->> +obj :成功加锁    Note over obj :重量级锁指针 ｜状态码 10 (重量级锁)    Note over t2 :执行临界区代码块    obj ->> -t2 : 成功解锁</pre><h6 id="自旋重试失败的情况"><a href="#自旋重试失败的情况" class="headerlink" title="自旋重试失败的情况"></a>自旋重试失败的情况</h6><pre class="mermaid">sequenceDiagram    participant t1 as 线程1(CPU 0)    participant obj as synchronized(Object)    participant t2 as 线程2(CPU 1)    Note over obj :状态码 01 (无锁)    t1 ->> +obj :访问同步块， 获取 Monitor    t1 ->> obj :成功加锁    Note over obj :重量级锁指针 ｜状态码 10 (重量级锁)    t2 -x obj :❌ 访问同步块， 获取 Monitor    t2 ->> t2 :自旋重试    Note over t1 :执行临界区代码块    t2 ->> t2 :自旋重试    t2 ->> t2 :自旋重试    t2 ->> t2 :自旋重试    Note over t2 :阻塞    obj ->> -t1 :成功解锁    Note over obj :状态码 01 (无锁)</pre><blockquote><p>由以上两个流程我们可以看到，可以设置【线程自旋重试的次数】来控制该线程是否要阻塞。在 JDK 1.6 之后版本的次数时自适应的。在<strong><em><u>单 CPU 下的自旋重试没有意义</u></em></strong>。</p></blockquote><h5 id="3-4-5-偏向锁"><a href="#3-4-5-偏向锁" class="headerlink" title="3.4.5 偏向锁"></a>3.4.5 偏向锁</h5><blockquote><p>注意 ⚠️</p><p>个人理解，对于一个类的对象的偏向锁，<strong><em><u>是对于一个【类本身】的偏向</u></em></strong>，而<strong><em><u>不是对于【类的对象】的偏向</u></em></strong>，一个类只能有一个偏向锁。</p></blockquote><p>轻量级锁在没有竞争时，每次<strong><em><u>【锁重入】</u></em></strong>（该线程执行的方法中再次锁住该对象）<strong><em><u>操作仍需要 <code>cas</code> 替换操作</u></em></strong>，这样是会使<strong><em><u>性能降低</u></em></strong>的。那么我们能不能减少 <code>cas</code> 操作呢？</p><p>所以引入了【偏向锁】对性能进行优化：在【第一次 <code>cas</code>】时会将【线程的 <code>ID</code>】写入对象的 <code>Mark Word</code>中。此后发现这个线程 <code>ID</code> 就是自己的，就表示没有竞争，就不需要再次 <code>cas</code>；以后只要不发生竞争，这个对象就归该线程所有。</p><blockquote><p>相当于在临界资源上刻上进程的名字， 该【资源】归【此进程】所有</p></blockquote><h6 id="偏向状态"><a href="#偏向状态" class="headerlink" title="偏向状态"></a>偏向状态</h6><p><code>Mark Word</code> 在不同对象类型下的结构如下：</p><p><img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/image-20220902142940973.png" alt="image-20220902142940973" style="zoom:70%;"></p><ol><li><code>Normal</code> 普通类型标记（最后 <code>3 bits : 0 0 1</code>）：<ul><li><code>hashcode(25 bits)</code> 用来区分对象的哈希码；</li><li><code>age(4 bits)</code> GC 垃圾回收时的分代年龄；</li><li><code>biased_lock(1 bit)</code> 代表是否是偏向锁；</li><li>最后 <code>2 bits</code> 代表该对象的加锁状态。  </li></ul></li><li><code>Biased</code> 偏向锁标记（最后 <code>3 bits : 1 0 1</code>）：<ul><li><code>thread(23 bits)</code> 用来存储获得偏向锁的（操作系统层面的）线程 <code>ID</code>；</li><li><code>epoch(2 bits)</code> 批量重偏向与批量撤销时用到；</li><li><code>age(4 bits)</code> GC 垃圾回收时的分代年龄；</li><li><code>biased_lock(1 bit)</code> 代表是否是偏向锁；</li><li>最后 <code>2 bits</code> 代表该对象的加锁状态。 </li></ul></li><li><code>Ligthweight Locked</code> 轻量级锁标记（最后 <code>2 bits : 0 0</code>）：<code>ptr_to_lock_record(30 bits)</code> 指向 <code>LockRecord</code> 锁记录对象的指针；最后 <code>2 bits</code> 代表该对象的加锁状态。  </li><li><code>Heavyweight Locked</code> 重量级锁标记（最后 <code>2 bits : 1 0</code>）：<code>ptr_to_heavyweight_monitor(30 bits)</code> 指向 <code>Monitor</code> 的指针；最后 <code>2 bits</code> 代表该对象的加锁状态。  </li><li><code>GC</code> 垃圾回收标记（最后 <code>2 bits : 1 1</code>）：如果该对象已经被 <code>GC</code> 垃圾回收了，则将最后 <code>2 bits</code> 置为 <code>11</code>。</li></ol><blockquote><p>TIPS :</p><ul><li>如果开启了偏向锁（默认开启），在创建对象时，对象的 <code>Mark Word</code> 后三位应该是 <code>1 0 1</code>；</li><li>但是偏向锁默认是<strong>有延迟</strong>的，不会再程序一启动就生效，而是会在程序运行一段时间（几秒之后），才会对创建的对象设置为偏向状态。可以使用<code>-XX:BiasedLockingStartupDelay=0</code> 来禁用延迟；</li><li>如果没有开启偏向锁，对象的 <code>Mark Word</code> 后三位应该是 <code>0 0 1</code>。</li></ul></blockquote><h6 id="撤销偏向"><a href="#撤销偏向" class="headerlink" title="撤销偏向"></a>撤销偏向</h6><p>以下几种情况会使对象的偏向锁失效</p><ul><li>调用对象的 <code>hashCode()</code>方法时才会产生哈希码，本来用来<strong><em><u>存储偏向锁的【线程 <code>ID</code>】的空间</u></em></strong>就要用来<strong><em><u>存【哈希码】</u></em></strong>，所以偏向锁就失效了；</li><li>【无竞争】的多个线程使用该对象（升级为【轻量级锁】），因为违背了偏向锁【只有一个线程使用该对象】的本意；</li><li>调用了 <code>wait() / notify()</code> 方法（调用 <code>wait()</code> 方法会导致锁膨胀而使用【重量级锁】）</li></ul><h6 id="批量重偏向"><a href="#批量重偏向" class="headerlink" title="批量重偏向"></a>批量重偏向</h6><p>如果对象虽然被多个线程访问，但是线程间不存在竞争，这时偏向 <code>thread-1</code> 的对象仍有机会重新偏向 <code>thread-2</code>。重偏向会重置 <code>Thread ID</code>。</p><p>当对同一个加锁对象（而不是对象的实例）撤销重偏向超过<strong><em><u>超过阈值</u></em></strong>时，JVM 会觉得是不是偏向错了，此后再给对象加锁时，JVM 会将该对象重新偏向至该线程。</p><h6 id="批量撤销"><a href="#批量撤销" class="headerlink" title="批量撤销"></a>批量撤销</h6><p>当撤销偏向锁的操作<strong><em><u>超过阈值</u></em></strong>以后，就会将<strong>整个类的对象都改为不可偏向的</strong></p><p>【图解】</p><p><img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/image-2022-09-02 19.29.43.png" alt="截屏2022-09-02 19.29.43"></p><h4 id="3-5-Wait-Notify"><a href="#3-5-Wait-Notify" class="headerlink" title="3.5 Wait() / Notify()"></a>3.5 <code>Wait() / Notify()</code></h4><p><img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/20200608144917.png" alt="20200608144917" style="zoom:75%;"></p><ul><li><p>Owner线程发现执行条件不满足，锁对象调用<code>wait()</code>方法（obj.wait），就会使当前线程进入WaitSet中，变为<code>WAITING</code>状态。</p></li><li><p>处于<code>BLOCKED</code>和<code>WAITING</code>状态的线程都为阻塞</p><p>状态，CPU都不会分给他们时间片。但是有所区别：</p><ul><li><strong><code>BLOCKED</code>状态的线程是在竞争对象</strong>时，发现Monitor的Owner已经是别的线程了，此时就会进入EntryList中，并处于BLOCKED状态</li><li><strong><code>WAITING</code>状态的线程是获得了对象的锁</strong>，但是自身因为某些原因需要进入阻塞状态时，锁对象调用了<code>wait()</code>方法而进入了WaitSet中，处于<code>WAITING</code>状态</li></ul></li><li><p>BLOCKED状态的线程会在锁被释放的时候被唤醒，但是处于<code>WAITING</code>状态的线程只有被锁对象调用了<code>notify()</code>或<code>notifyAll()</code>方法(obj.notify/obj.notifyAll)，才会被唤醒。</p></li></ul><h5 id="3-5-1-API介绍"><a href="#3-5-1-API介绍" class="headerlink" title="3.5.1 API介绍"></a>3.5.1 API介绍</h5><ol><li><code>obj.wait()</code>：让进入Monitor的线程到waitSet等待</li><li><code>obj.wait(long timeout)</code> 让进入obj监视器的线程到waitSet<strong>等待 timeout时间长度</strong>，继续执行</li><li><code>obj.notify()</code>：在object上正在waitSet等待的线程中<strong>挑一个</strong>唤醒</li><li><code>obj.notifyAll()</code>：在object上正在waitSet等待的线程<strong>全部</strong>唤醒</li></ol><p>注意⚠️：他们都是线程之间进行协作的手段，都属于Object对象的方法。<strong>必须获得此对象的锁</strong>，才能调用这几个方法。<strong>只有当对象被锁以后，才能调用wait和notify方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span> ();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span> (() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.wait(); <span class="comment">// 让线程t1在lock上一直等待下去</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span> (() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.wait(); <span class="comment">// 让线程t2在lock上一直等待下去</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123; <span class="comment">// 主线程</span></span><br><span class="line">        lock.notify(); <span class="comment">// 随机唤醒一个</span></span><br><span class="line">        lock.notifyAll(); <span class="comment">// 唤醒所有</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-5-2-wait-和sleep-的区别"><a href="#3-5-2-wait-和sleep-的区别" class="headerlink" title="3.5.2 wait() 和sleep()的区别"></a>3.5.2 wait() 和sleep()的区别</h5><ul><li><p>不同点：</p><ol><li>从API角度：sleep是Thread的静态方法，wait是所有对象（Object）的方法</li><li>sleep不用与synchronized一起用，wait需要与synchronized一起用</li><li>sleep<strong>不会释放锁</strong>，wait在等待时<strong>会释放锁</strong></li></ol></li><li><p>相同点：</p><ol><li>进入的线程状态都是TIMED_WAITING</li></ol></li></ul><p>为了解决wait的虚假唤醒，代码结构如下：(while)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">   <span class="keyword">while</span> (条件不成立) &#123;</span><br><span class="line">       lock.wait();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个线程</span></span><br><span class="line"><span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">    lock.notify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestCorrectPosture&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCorrectPostureStep4</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasCigarette</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasTakeout</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">                <span class="keyword">while</span> (!hasCigarette) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        room.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">                <span class="keyword">if</span> (hasCigarette) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没干成活...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                log.debug(<span class="string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);</span><br><span class="line">                <span class="keyword">while</span> (!hasTakeout) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没外卖，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        room.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);</span><br><span class="line">                <span class="keyword">if</span> (hasTakeout) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没干成活...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小女&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                hasTakeout = <span class="literal">true</span>;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖到了噢！&quot;</span>);</span><br><span class="line">                room.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;送外卖的&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-6-同步模式-之-保护性暂停"><a href="#3-6-同步模式-之-保护性暂停" class="headerlink" title="3.6 同步模式 之 保护性暂停"></a>3.6 同步模式 之 保护性暂停</h4><p>即Guarded Suspension，用于一个线程等待另一个线程的执行结果时。如下图。</p><p><img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/image-20220327195520317-8403730.png" alt="image-20220327195520317" style="zoom:67%;"></p><p>要点：</p><ul><li>有一个结果想从一个线程传递到另一个线程，可以让他们关联同一个GuardedObject</li><li>如果有结果不断的从一个结果到另一个结果，那么可以使用<strong>消息队列</strong>（见消费者/生产者）</li><li>JDK中，<code>join()</code>的实现、<code>future</code>的实现，采用的就是该模式</li><li>因为要等待另一方的结果，因此归类到该模式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="string">&quot;hello thread!&quot;</span>;</span><br><span class="line"><span class="type">Guarded</span> <span class="variable">guarded</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Guarded</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// thread 1</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;想要得到结果&quot;</span>);</span><br><span class="line"><span class="keyword">synchronized</span> (guarded) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;结果是：&quot;</span>+guarded.getResponse());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;得到结果&quot;</span>);</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//thread 2</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;设置结果&quot;</span>);</span><br><span class="line"><span class="keyword">synchronized</span> (guarded) &#123;</span><br><span class="line">guarded.setResponse(hello);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Guarded</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 要返回的结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Object response;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//优雅地使用wait/notify</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getResponse</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//如果返回结果为空就一直等待，避免虚假唤醒</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line"><span class="keyword">while</span>(response == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.wait();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setResponse</span><span class="params">(Object response)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.response = response;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line"><span class="comment">//唤醒休眠的线程</span></span><br><span class="line"><span class="built_in">this</span>.notifyAll();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Guarded&#123;&quot;</span> +</span><br><span class="line"><span class="string">&quot;response=&quot;</span> + response +</span><br><span class="line"><span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>带超时判断的暂停</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改上面代码块中的 getResponse() 方法</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getResponse</span><span class="params">(<span class="type">long</span> time)</span> &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line"><span class="comment">//获取开始时间</span></span><br><span class="line"><span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="comment">//用于保存已经等待了的时间</span></span><br><span class="line"><span class="type">long</span> <span class="variable">passedTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(response == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//看经过的时间-开始时间是否超过了指定时间</span></span><br><span class="line"><span class="type">long</span> <span class="variable">waitTime</span> <span class="operator">=</span> time -passedTime;</span><br><span class="line"><span class="keyword">if</span>(waitTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">//等待剩余时间</span></span><br><span class="line"><span class="built_in">this</span>.wait(waitTime);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取当前时间</span></span><br><span class="line">passedTime = System.currentTimeMillis()-currentTime</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-6-1-join-：使用保护性暂停模式"><a href="#3-6-1-join-：使用保护性暂停模式" class="headerlink" title="3.6.1 join()：使用保护性暂停模式"></a>3.6.1 join()：使用保护性暂停模式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis - now;</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay);</span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="3-6-2-扩展-Future"><a href="#3-6-2-扩展-Future" class="headerlink" title="3.6.2 扩展 - Future"></a>3.6.2 扩展 - Future</h5><p>图中的Future就好比居民楼一楼的信箱（每个信箱都有自己的编号），左边的t0，t2，t4就好比等待邮件的居民，右侧的t1，t3，t5就好比邮递员。</p><p>如果需要再多个雷之间使用GuardedObject对象，作为参数传递不是很方便，因此设计一个用来解耦的中间类，这样不仅可以解耦【结果等待者】和【结果生产者】，还能够同时支持多个任务的处理。</p><p><img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/image-20220327202425832-8405470.png" alt="image-20220327202425832" style="zoom:67%;"></p><h4 id="3-7-异步模式-之-生产者-消费者"><a href="#3-7-异步模式-之-生产者-消费者" class="headerlink" title="3.7 异步模式 之 生产者/消费者"></a>3.7 异步模式 之 生产者/消费者</h4><h5 id="3-7-1-要点"><a href="#3-7-1-要点" class="headerlink" title="3.7.1 要点"></a>3.7.1 要点</h5><ul><li>与前面的保护性暂停中的 Guardobject 不同，不需要产生结果和消费结果的线程一一对应</li><li>消费队列可以用来平衡生产和消费的线程资源</li><li>生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据</li><li>消息队列是有容量限制的，满时不会再加入数据（生产者阻塞），空时不会再消耗数据（消费者阻塞）</li><li>JDK 中各种阻塞队列，采用的就是这种模式</li></ul><p><img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/image-20220327204404520-8406649.png" alt="image-20220327204404520"></p><p>如上图所示，左边的三个线程是生产者，右边的是消费者。</p><h5 id="3-7-2-实现"><a href="#3-7-2-实现" class="headerlink" title="3.7.2 实现"></a>3.7.2 实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MessageQueue</span> &#123;</span><br><span class="line">  <span class="comment">// 消息的队列集合</span></span><br><span class="line">  <span class="keyword">private</span> LinkedList&lt;Message&gt;list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">  <span class="comment">// 队列容量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> capcity;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Message <span class="title function_">take</span><span class="params">()</span> &#123; <span class="comment">// 取消息</span></span><br><span class="line">  <span class="comment">// 检查队列是否为空</span></span><br><span class="line">    <span class="keyword">synchronized</span>(list)&#123;</span><br><span class="line">      <span class="keyword">while</span>(list.isEmply())&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;消息队列为空，消费者等待\n&quot;</span>);</span><br><span class="line">          list.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 从队列头获取消息并返回</span></span><br><span class="line">      <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> list.removeFrist();</span><br><span class="line">      System.out.println(<span class="string">&quot;已经消费一个消息\n&quot;</span> +message);</span><br><span class="line">      list.notifyAll();</span><br><span class="line">      <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Message message)</span> &#123; <span class="comment">// 存消息</span></span><br><span class="line">    <span class="comment">// 检查队列是否已满</span></span><br><span class="line">    <span class="keyword">synchronized</span>(list)&#123;</span><br><span class="line">      <span class="keyword">while</span>(list.size() == capcity) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;消息队列已满，生产者等待\n&quot;</span>);</span><br><span class="line">          list.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将消息加入队列尾部</span></span><br><span class="line">      list.addLast(message);</span><br><span class="line">      System.out.println(<span class="string">&quot;已经生产了一个消息：\n&quot;</span> +message);</span><br><span class="line">      list.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">  <span class="keyword">private</span> Object value;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Message</span> <span class="params">(<span class="type">int</span> id, Object value)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.id;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Message: id:&quot;</span>+id+<span class="string">&quot;, value:&quot;</span>+value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(<span class="number">2</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">      queue.put(<span class="keyword">new</span> <span class="title class_">Message</span>(id, <span class="string">&quot;value&quot;</span>+id));</span><br><span class="line">    &#125;, <span class="string">&quot;生产者&quot;</span>+i).start();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">      <span class="type">Message</span> <span class="variable">massage</span> <span class="operator">=</span> queue.take();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="string">&quot;消费者&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-8-Park-amp-Unpark"><a href="#3-8-Park-amp-Unpark" class="headerlink" title="3.8 Park &amp; Unpark"></a>3.8 Park &amp; Unpark</h4><h5 id="3-8-1-基本使用"><a href="#3-8-1-基本使用" class="headerlink" title="3.8.1 基本使用"></a>3.8.1 基本使用</h5><p><strong>park/unpark都是LockSupport类中的的方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暂停线程运行</span></span><br><span class="line">LockSupport.park;</span><br><span class="line"></span><br><span class="line"><span class="comment">//恢复线程运行</span></span><br><span class="line">LockSupport.unpark(thread);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;park&quot;</span>);</span><br><span class="line">      <span class="comment">//暂停线程运行</span></span><br><span class="line">LockSupport.park();</span><br><span class="line">System.out.println(<span class="string">&quot;resume&quot;</span>);</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">thread.start();</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;unpark&quot;</span>);</span><br><span class="line">    <span class="comment">//恢复线程运行</span></span><br><span class="line">LockSupport.unpark(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-8-2-特点"><a href="#3-8-2-特点" class="headerlink" title="3.8.2 特点"></a>3.8.2 特点</h5><p><strong>与wait/notify的区别</strong></p><ul><li>wait，notify 和 notifyAll 必须配合<strong>Object Monitor</strong>一起使用，而park，unpark不必</li><li>park ，unpark 是以<strong>线程为单位</strong>来<strong>【阻塞】</strong>和<strong>【唤醒】</strong>线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么【精确】</li><li>park &amp; unpark 可以<strong>先 unpark</strong>，而 wait &amp; notify 不能先 notify</li><li><strong>park不会释放锁</strong>，而wait会释放锁</li></ul><h5 id="3-8-3-原理"><a href="#3-8-3-原理" class="headerlink" title="3.8.3 原理"></a>3.8.3 原理</h5><p>每个线程都有一个自己的<strong>Park对象</strong>，并且该对象<code>_counter</code>,  <code>_cond</code>, <code>_mutex</code>组成</p><ul><li><p>先调用park再调用unpark时</p><ol><li>先调用park<ul><li>线程运行时，会将Park对象中<code>_counter</code>的值设为0；</li><li>调用park时，会先查看<code>_counter</code>的值是否为0，如果为0，则将线程放入阻塞队列<code>_cond</code>中</li><li>放入阻塞队列中后，会<strong>再次</strong>将<code>_counter</code>设置为0</li></ul></li></ol><p><img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/20200608145250.png" alt="20200608145250" style="zoom:70%;"></p><ol><li>然后调用unpark<ul><li>调用unpark方法后，会将<code>_counter</code>的值设置为1</li><li>去唤醒阻塞队列<code>_cond</code>中的线程</li><li>线程继续运行并将<code>_counter</code>的值设为0</li></ul></li></ol><p><img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/20200608145303.png" alt="20200608145303" style="zoom:60%;"></p></li><li><p>先调用unpark，再调用park</p><ol><li><p>调用unpark</p><ul><li>会将<code>_counter</code>设置为1（运行时0）</li></ul></li><li><p>调用park方法</p><ul><li>查看<code>_counter</code>是否为0</li><li>因为unpark已经把<code>_counter</code>设置为1，所以此时将<code>_counter</code>设置为0，但<strong>不放入</strong>阻塞队列<code>_cond</code>中</li></ul></li></ol></li></ul><p><img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/20200608145313.png" alt="20200608145313" style="zoom:60%;"></p><h4 id="3-9-线程状态转换"><a href="#3-9-线程状态转换" class="headerlink" title="3.9 线程状态转换"></a>3.9 线程状态转换</h4><p><img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/20200608144621-8409900.png" alt="20200608144621" style="zoom:75%;"></p><h5 id="情况一：NEW-gt-RUNNABLE"><a href="#情况一：NEW-gt-RUNNABLE" class="headerlink" title="情况一：NEW --&gt; RUNNABLE"></a>情况一：<code>NEW --&gt; RUNNABLE</code></h5><ul><li>当调用了<code>t.start()</code>方法时，由<code>NEW</code> –&gt; <code>RUNNABLE</code></li></ul><h5 id="情况二：RUNNABLE-lt-gt-WAITING"><a href="#情况二：RUNNABLE-lt-gt-WAITING" class="headerlink" title="情况二：RUNNABLE &lt;--&gt; WAITING"></a>情况二：<code>RUNNABLE &lt;--&gt; WAITING</code></h5><ul><li>当调用了t 线程用 <code>synchronized(obj)</code> 获取了对象锁后<ul><li>调用 <code>obj.wait()</code> 方法时，t 线程从 <code>RUNNABLE</code> –&gt;<code>WAITING</code></li><li>调用 <code>obj.notify()</code> ， <code>obj.notifyAll()</code> ，<code>t.interrupt()</code> 时<ul><li>竞争锁成功，t 线程从 <code>WAITING</code> –&gt; <code>RUNNABLE</code></li><li>竞争锁失败，t 线程从 <code>WAITING</code> –&gt; <code>BLOCKED</code></li></ul></li></ul></li></ul><h5 id="情况三：RUNNABLE-lt-gt-WAITING"><a href="#情况三：RUNNABLE-lt-gt-WAITING" class="headerlink" title="情况三：RUNNABLE &lt;--&gt; WAITING"></a>情况三：<code>RUNNABLE &lt;--&gt; WAITING</code></h5><ul><li><p>当前线程</p><p>调用 <code>t.join()</code> 方法时，当前线程从 <code>RUNNABLE</code> –&gt; <code>WAITING</code></p><ul><li>注意是<strong>当前线程</strong>在t 线程对象的监视器上等待</li></ul></li><li><p>t 线程<strong>运行结束</strong>，或调用了<strong>当前线程</strong>的 <code>interrupt()</code> 时，当前线程从 <code>WAITING</code> –&gt; <code>RUNNABLE</code></p></li></ul><h5 id="情况四：-RUNNABLE-lt-gt-WAITING"><a href="#情况四：-RUNNABLE-lt-gt-WAITING" class="headerlink" title="情况四： RUNNABLE &lt;--&gt; WAITING"></a>情况四： <code>RUNNABLE &lt;--&gt; WAITING</code></h5><ul><li>当前线程调用 <code>LockSupport.park()</code> 方法会让当前线程从 <code>RUNNABLE</code> –&gt; <code>WAITING</code></li><li>调用 <code>LockSupport.unpark(目标线程)</code> 或调用了线程 的 <code>interrupt()</code> ，会让目标线程从 <code>WAITING</code> –&gt; <code>RUNNABLE</code></li></ul><h5 id="情况五：-RUNNABLE-lt-gt-TIMED-WAITING"><a href="#情况五：-RUNNABLE-lt-gt-TIMED-WAITING" class="headerlink" title="情况五： RUNNABLE &lt;--&gt; TIMED_WAITING"></a>情况五： <code>RUNNABLE &lt;--&gt; TIMED_WAITING</code></h5><p>t 线程用 <code>synchronized(obj)</code> 获取了对象锁后</p><ul><li>调用 <code>obj.wait(long n)</code> 方法时，t 线程从 <code>RUNNABLE</code> –&gt; <code>TIMED_WAITING</code></li><li>t 线程等待时间超过了 n 毫秒，或调用 <code>obj.notify()</code>， <code>obj.notifyAll()</code> ，<code>t.interrupt()</code> 时<ul><li>竞争锁成功，t 线程从 <code>TIMED_WAITING</code> –&gt; <code>RUNNABLE</code></li><li>竞争锁失败，t 线程从 <code>TIMED_WAITING</code> –&gt; <code>BLOCKED</code></li></ul></li></ul><h5 id="情况六：RUNNABLE-lt-gt-TIMED-WAITING"><a href="#情况六：RUNNABLE-lt-gt-TIMED-WAITING" class="headerlink" title="情况六：RUNNABLE &lt;--&gt; TIMED_WAITING"></a>情况六：<code>RUNNABLE &lt;--&gt; TIMED_WAITING</code></h5><ul><li>当前线程调用 <code>t.join(long n)</code> 方法时，当前线程从 <code>RUNNABLE</code> –&gt; <code>TIMED_WAITING</code><ul><li>注意是当前线程在t 线程对象的监视器上等待</li></ul></li><li>当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 <code>interrupt()</code> 时，当前线程从 <code>TIMED_WAITING</code> –&gt; <code>RUNNABLE</code></li></ul><h5 id="情况七：RUNNABLE-lt-gt-TIMED-WAITING"><a href="#情况七：RUNNABLE-lt-gt-TIMED-WAITING" class="headerlink" title="情况七：RUNNABLE &lt;--&gt; TIMED_WAITING"></a>情况七：<code>RUNNABLE &lt;--&gt; TIMED_WAITING</code></h5><ul><li>当前线程调用 <code>Thread.sleep(long n)</code>，当前线程从 <code>RUNNABLE</code> –&gt; <code>TIMED_WAITING</code></li><li>当前线程等待时间超过了 n 毫秒，当前线程从 <code>TIMED_WAITING</code> –&gt; <code>RUNNABLE</code></li></ul><h5 id="情况八：RUNNABLE-lt-gt-TIMED-WAITING"><a href="#情况八：RUNNABLE-lt-gt-TIMED-WAITING" class="headerlink" title="情况八：RUNNABLE &lt;--&gt; TIMED_WAITING"></a>情况八：<code>RUNNABLE &lt;--&gt; TIMED_WAITING</code></h5><ul><li>当前线程调用 <code>LockSupport.parkNanos(long nanos)</code> 或 <code>LockSupport.parkUntil(long millis)</code> 时，当前线 程从 <code>RUNNABLE</code>–&gt; <code>TIMED_WAITING</code></li><li>调用 <code>LockSupport.unpark(目标线程)</code> 或调用了线程 的 <code>interrupt()</code> ，或是等待超时，会让目标线程从 <code>TIMED_WAITING</code> –&gt; <code>RUNNABLE</code></li></ul><h5 id="情况九：RUNNABLE-lt-gt-BLOCKED"><a href="#情况九：RUNNABLE-lt-gt-BLOCKED" class="headerlink" title="情况九：RUNNABLE &lt;--&gt; BLOCKED"></a>情况九：<code>RUNNABLE &lt;--&gt; BLOCKED</code></h5><ul><li>t 线程用 <code>synchronized(obj)</code> 获取了对象锁时如果<strong>竞争失败</strong>，从 <code>RUNNABLE</code> –&gt; <code>BLOCKED</code></li><li>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 <code>BLOCKED</code> 的线程重新竞争，如果其中 t 线程竞争 成功，从 <code>BLOCKED</code> –&gt; <code>RUNNABLE</code> ，其它<strong>失败</strong>的线程仍然 <code>BLOCKED</code></li></ul><h5 id="情况十：-RUNNABLE-lt-gt-TERMINATED"><a href="#情况十：-RUNNABLE-lt-gt-TERMINATED" class="headerlink" title="情况十： RUNNABLE &lt;--&gt; TERMINATED"></a>情况十： <code>RUNNABLE &lt;--&gt; TERMINATED</code></h5><p>当前线<strong>程所有代码运行完毕</strong>，进入 <code>TERMINATED</code></p><h4 id="3-10-多把锁"><a href="#3-10-多把锁" class="headerlink" title="3.10 多把锁"></a>3.10 多把锁</h4><p><strong>将锁的粒度细分</strong></p><p>例如一套房子中有多个房间，书房和卧室的功能毫不相干。所以我们可以把锁分别加在卧室和书房上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BigRoom</span> &#123;</span><br><span class="line">    <span class="comment">//额外创建对象来作为锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">studyRoom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">bedRoom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-11-线程的活跃性"><a href="#3-11-线程的活跃性" class="headerlink" title="3.11 线程的活跃性"></a>3.11 线程的活跃性</h4><h5 id="3-11-1-死锁"><a href="#3-11-1-死锁" class="headerlink" title="3.11.1 死锁"></a>3.11.1 死锁</h5><p>有这样的情况：一个线程需要<strong>同时获取多把锁</strong>，这时就容易发生死锁</p><p>如：</p><ul><li><code>t1线程</code> 获得 <code>A对象锁</code>，接下来想获取 <code>B对象的锁</code></li><li><code>t2线程</code> 获得 <code>B对象锁</code>，接下来想获取 <code>A对象的锁</code></li></ul><p>在并发环境下，各进程因竞争资源而造成的一种<strong>互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象</strong>，就是死锁。</p><p>每个人都占有一个资源，同时又在等待另一个人手里的资源。发生“死锁”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">Object</span> <span class="variable">A</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">final</span> <span class="type">Object</span> <span class="variable">B</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;TODO&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;TODO&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="发生死锁的必要条件"><a href="#发生死锁的必要条件" class="headerlink" title="发生死锁的必要条件"></a>发生死锁的必要条件</h6><ul><li><p><strong>死锁产生的必要条件：</strong></p><ol><li><p>互斥条件：只有对必须互斥使用的资源的争抢才会产生死锁。</p></li><li><p>不可剥夺条件：进程所获得的资源在未使用完之前，不能<strong>由其他进程强行夺走</strong></p></li><li><p>请求和保持条件：进程已经<strong>保持了至少一个资源</strong>，但<strong>又提出了新的资源请求</strong>，而该资源又被其他进程占有，此时请求进程被阻塞，但又<strong>对自己已有的资源保持不放</strong></p></li><li><p>循环等待条件：存在一种进程</p><p>资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</p><ul><li><strong>死锁 -&gt; 一定有循环等待； 循环等待 不一定 发生死锁</strong></li></ul></li></ol></li><li><p><strong>预防死锁：</strong> 破坏<strong>死锁产生的必要条件</strong>，即可预防死锁。</p></li></ul><h6 id="避免死锁的方法"><a href="#避免死锁的方法" class="headerlink" title="避免死锁的方法"></a>避免死锁的方法</h6><p>在线程使用锁对象时<strong>，顺序加锁</strong>即可避免死锁。线程1按顺序获得A，B对象的锁：</p><pre class="mermaid">sequenceDiagram    participant t1 as 线程1    participant t2 as 线程2    participant obj1 as 对象1    participant obj2 as 对象2    t1 -->> obj1 : 尝试获取锁    Note over t1,obj1 :拥有锁    t2 --x obj1 : 尝试获取锁（失败）    t2 -->> obj1 : 阻塞    t1 -->> obj2 : 尝试获取锁    Note over t1,obj2 :拥有锁</pre><h5 id="3-11-2-活锁"><a href="#3-11-2-活锁" class="headerlink" title="3.11.2 活锁"></a>3.11.2 活锁</h5><p>活锁出现在两个线程<strong>互相改变对方的结束条件</strong>，后谁也无法结束。</p><h6 id="避免活锁的方法"><a href="#避免活锁的方法" class="headerlink" title="避免活锁的方法"></a>避免活锁的方法</h6><p>在线程执行时，中途给予<strong>不同的间隔时间</strong>即可。</p><h6 id="死锁与活锁的区别"><a href="#死锁与活锁的区别" class="headerlink" title="死锁与活锁的区别"></a>死锁与活锁的区别</h6><ul><li>死锁是因为线程互相持有对象想要的锁，并且都不释放，最后到时<strong>线程阻塞</strong>，<strong>停止运行</strong>的现象。</li><li>活锁是因为线程间修改了对方的结束条件，而导致代码<strong>一直在运行</strong>，却一直<strong>运行不完</strong>的现象。</li></ul><h5 id="3-11-3-饥饿"><a href="#3-11-3-饥饿" class="headerlink" title="3.11.3 饥饿"></a>3.11.3 饥饿</h5><p>某些线程因为优先级太低，导致一直无法获得资源的现象。</p><p>为了避免死锁而使用顺序加锁时，可能会出现饥饿现象</p><h5 id="3-11-4-死锁、饥饿和死循环的异同点"><a href="#3-11-4-死锁、饥饿和死循环的异同点" class="headerlink" title="3.11.4 死锁、饥饿和死循环的异同点"></a>3.11.4 死锁、饥饿和死循环的异同点</h5><div class="table-container"><table><thead><tr><th></th><th>共同点</th><th>区别</th></tr></thead><tbody><tr><td>死锁</td><td>都是进程无法顺利向前推进的现象</td><td>死锁一定是“循环等待对方手里的资源”导致的，因此如果有死锁现象，那<strong>至少有两个或两个以上的进程同时发生死锁</strong>。另外，发生死锁的进程一定处于阻塞态</td></tr><tr><td>饥饿</td><td><strong>可能只有一个进程发生饥饿</strong>。发生饥饿的进程可能是阻塞态（如长期得不到需要的IO设备），也可能是就绪态（长期得不到处理机）</td><td></td></tr><tr><td>死循环</td><td>可能只有一个进程发生死循环。死循环可以是运行态，只不过无法继续推进。死锁和饥饿是由于操作系统分配资源的策略不合理导致的，而死循环是由代码逻辑错误导致的。<strong>死锁和饥饿是管理者(操作系统)的问题，死循环是被管理者的问题。</strong></td></tr></tbody></table></div><h5 id="3-11-5-预防死锁-静态策略"><a href="#3-11-5-预防死锁-静态策略" class="headerlink" title="3.11.5 预防死锁 - 静态策略"></a>3.11.5 预防死锁 - 静态策略</h5><h6 id="3-11-5-1-资源分配图（Graphe-d’allocation）"><a href="#3-11-5-1-资源分配图（Graphe-d’allocation）" class="headerlink" title="3.11.5.1 资源分配图（Graphe d’allocation）"></a>3.11.5.1 资源分配图（Graphe d’allocation）</h6><ul><li>两种结点<ul><li>进程结点：对应一个进程</li><li>资源结点：对应一类资源，一类资源可能有多个。（一般用矩形代表资源结点，矩形中的小圆圈代表该类资源的数量）</li></ul></li><li>两种边：<ul><li>进程结点 -&gt; 资源结点：<strong>请求边</strong>，表示进程<strong>想申请几个资源</strong>（一条边代表一个）</li><li>资源结点 -&gt; 进程结点：<strong>分配边</strong>，表示<strong>已经为进程分配了几个资源</strong></li></ul></li></ul><pre class="mermaid">graph LR  A(P1) --> B  B[R2:2] --> C  C(P2) --> D  D[R1:3] --> C  D --> A  D --> A</pre><p>如果系统中剩余的可用资源数足够满足进程的需求，那么这个进程暂时是不会阻塞的，可以顺利地执行下去。</p><pre class="mermaid">graph LR;  A(P1)   B[R2:2] --> C  C(P2) --> D  D[R1:3] --> C</pre><p>如果这个进程执行结束了把资源归还系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去。<br>相应的，这些被激活的进程执行完了之后又会归还一些资源，这样可能又会激活另外一些阻塞的进程….</p><pre class="mermaid">graph TB;  A(P1)   B[R2:2]  C(P2)  D[R1:3]</pre><p>如果按上述过程分析，最终<strong>能消除所有边</strong>，就称这个图是<strong>可完全简化的</strong>。此时一定<strong>没有发生死锁</strong>（相当于能找到一个安全序列）</p><p>另一个例子：</p><pre class="mermaid">graph LR;  A(P1)  B[R2:2]  C(P2)  D[R1:3]  E(P3)  E --> B  A --> B  A --> B  B --> C  C --> D  D --> C  D --> A  D --> A</pre><p>如果最终<strong>不能消除所有边</strong>，那么此时就是<strong>发生了死锁</strong>。 <strong>最终没有被消除的边所连的进程就发生了死锁</strong>。</p><h6 id="3-11-5-2-死锁的解除"><a href="#3-11-5-2-死锁的解除" class="headerlink" title="3.11.5.2 死锁的解除"></a>3.11.5.2 死锁的解除</h6><p>用死锁检测算法化简资源分配图后，还连着边的那此进程就是死锁进程。 解除死锁的主要方法有：</p><ol><li>资源剥夺法。挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</li><li>撤销进程法（或称终止进程法）。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源，这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，己经接近结束了，旦被终止可谓功亏一篑，以后还得从头再来。</li><li>进程回退法。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统耍记录进程的历史信息，设置还原点</li></ol><h5 id="3-11-6-避免死锁-动态策略"><a href="#3-11-6-避免死锁-动态策略" class="headerlink" title="3.11.6 避免死锁 - 动态策略"></a>3.11.6 避免死锁 - 动态策略</h5><h6 id="3-11-6-1-安全序列"><a href="#3-11-6-1-安全序列" class="headerlink" title="3.11.6.1 安全序列"></a>3.11.6.1 安全序列</h6><p>所谓<strong>安全序列</strong>，就是值如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是<strong>安全状态</strong>。当然，<strong>安全序列可能有多个</strong>。<br>如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了<strong>不安全状态</strong>。这就意味着之后<strong>可能</strong>所有进程都无法顺利的进行下去。当然，如果有进程提前归还了一些资源，那系统也<strong>有可能重新回到安全状态</strong>，不过我们在分配资源之前总是要考虑到最坏的情况。</p><p>因此可以<strong>在资源分配之前前预判这次分配是否会导致系统进入不安全状态</strong>，一次决定是否答应资源分配的请求。这也是“<strong>银行家算法</strong>”的核心思想。</p><h6 id="3-11-6-2-银行家算法"><a href="#3-11-6-2-银行家算法" class="headerlink" title="3.11.6.2 银行家算法"></a>3.11.6.2 银行家算法</h6><p>假设系统中有<code>n</code>个进程，<code>m</code>种资源每个进程在运行前先声明对各种资源的最大需求数，则可用一个<code>n*m</code>的矩阵（可用二维数组实现） 表示所有进程对各种资源的最大需求数。不妨称为<strong>最大需求矩阵</strong> <code>Max</code>， <code>Max[i,j] = K</code> 表示进程<code>P_i</code>最多需要K个资源<code>R_j</code>。同理，系统可以用一个<code>n*m</code> 的<strong>分配矩阵 Allocation</strong> 表示对所有进程的资源分配情况。<code>Max - Allocation = Need</code> 矩阵，表示各进程最多还需要多少各类资源。<br>另外，还要用一个长度为<code>m</code>的一维数组 <code>Available(...)</code> 表示当前系统中<strong>还有多少可用资源</strong><br>某进程pi向系统申请资源，可用1个长度为<code>m</code>的一维数组 <code>Request(...)</code>， 表示<strong>本次申请的各种资源量</strong>。</p><div class="table-container"><table><thead><tr><th>进程</th><th>最大需求(Max 矩阵)</th><th>已分配(Allocation 矩阵)</th><th>最多还需要(Need 矩阵)</th></tr></thead><tbody><tr><td>P0</td><td>(7,5,3)</td><td>(0,1,0)</td><td>(7,4,3)</td></tr><tr><td>P1</td><td>(3,2,2)</td><td>(2,0,0)</td><td>(1,2,2)</td></tr><tr><td>P2</td><td>(9,0,2)</td><td>(3,0,2)</td><td>(6,0,0)</td></tr><tr><td>P3</td><td>(2,2,2)</td><td>(2,1,1)</td><td>(0,1,1)</td></tr><tr><td>P4</td><td>(4,3,3)</td><td>(0,0,2)</td><td>(4,3,1)</td></tr></tbody></table></div><p>可用<strong>银行家算法</strong>预判本次分配是否会导致系统进入不安全状态：</p><ol><li>如果 <code>Request_i[j] &lt; Need[i,j] (0 &lt;= j &lt; m)</code>便转向②：否则认为出错</li><li>如果 <code>Request_i[j] &lt; Available[i,j] (0 &lt;= j &lt; m)</code>，便转向③：否则表示尚无足够资源，p必须等待</li><li>系统试探着把资源分配给进程Pi，并修改相应的数据（并非真的分配，修改数值只是为了做预判)：<ul><li><code>Available = Available - Request_j;</code></li><li><code>Allocation[i,j] = Allocation[i,j] + Request_i[j];</code></li><li><code>Need[i,j] = Need[i,j] - Request_i[j]</code></li></ul></li><li>操作系统执行<strong>安全性算法</strong>，检查此次资源分配后，系统是<strong>否处于安全状态</strong>。若安全，才正式分配;否则，恢复相应数据，让进程阻塞等待。</li></ol><p>银行家算法步骤：</p><ol><li>检查此次申请是否超过了之前声明的最大需求数</li><li>检查此时系统剩余的可用资源是否还能满足这次请求</li><li>试探着分配，更改各数据结构</li><li>用安全性算法检查此次分配是否会导致系统进入不安全状态</li></ol><p>安全性算法步骤： 检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该讲程持有的资源全部回收。 不断重复上述过程，看最终是否能让所有进程都加入安全序列。</p><h4 id="3-12-ReentrantLock-可重入锁"><a href="#3-12-ReentrantLock-可重入锁" class="headerlink" title="3.12 ReentrantLock (可重入锁)"></a>3.12 ReentrantLock (可重入锁)</h4><p><strong>和synchronized相比具有的的特点</strong></p><ul><li>可被别的线程中断</li><li>可以设置超时时间</li><li>可以设置为公平锁 (先到先得)</li><li>支持多个条件变量( 具有<strong>多个</strong>waitSet)</li></ul><h5 id="3-12-1-基本语法"><a href="#3-12-1-基本语法" class="headerlink" title="3.12.1 基本语法"></a>3.12.1 基本语法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取ReentrantLock对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//需要执行的代码</span></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//释放锁</span></span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-12-2-可重入"><a href="#3-12-2-可重入" class="headerlink" title="3.12.2 可重入"></a>3.12.2 可重入</h5><ul><li>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁</li><li>如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">    method1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123; </span><br><span class="line">    lock.lock(); <span class="comment">// 锁的重入</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;execute method1&quot;</span>); </span><br><span class="line">        method2(); <span class="comment">// 调用method2</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">finally</span> &#123; </span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123; </span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;execute method2&quot;</span>); </span><br><span class="line">        method3(); <span class="comment">// 调用method3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; </span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span> &#123; </span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;execute method3&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; </span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">17:59:11.862 [main] c.TestReentrant - execute method1</span><br><span class="line">17:59:11.865 [main] c.TestReentrant - execute method2</span><br><span class="line">17:59:11.865 [main] c.TestReentrant - execute method3</span><br></pre></td></tr></table></figure><h5 id="3-12-3-可打断"><a href="#3-12-3-可打断" class="headerlink" title="3.12.3 可打断"></a>3.12.3 可打断</h5><p>被动避免死等。</p><p>如果某个线程处于阻塞状态，可以调用其interrupt方法让其停止阻塞，获得锁失败</p><p><strong>简而言之</strong>就是：处于阻塞状态的线程，被打断了就不用阻塞了，直接停止运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); </span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;启动...&quot;</span>); </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有竞争，那么此方法就会获得lock对象锁</span></span><br><span class="line">        <span class="comment">// 如果有竞争就进入阻塞队列，可以被其他进程用 interrupt 方法打断</span></span><br><span class="line">        lock.lockInterruptibly(); <span class="comment">// 可中断锁</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace(); </span><br><span class="line">        log.debug(<span class="string">&quot;等锁的过程中被打断&quot;</span>); </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获得了锁&quot;</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">lock.lock(); </span><br><span class="line">log.debug(<span class="string">&quot;获得了锁&quot;</span>); </span><br><span class="line">t1.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    t1.interrupt(); <span class="comment">// 执行中断</span></span><br><span class="line">    log.debug(<span class="string">&quot;执行打断&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">finally</span> &#123; </span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">18:02:40.520 [main] c.TestInterrupt - 获得了锁 </span><br><span class="line">18:02:40.524 [t1] c.TestInterrupt - 启动... </span><br><span class="line">18:02:41.530 [main] c.TestInterrupt - 执行打断</span><br><span class="line">java.lang.InterruptedException</span><br><span class="line">    at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchr onizer.java:898)</span><br><span class="line">    at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchron izer.java:1222)</span><br><span class="line">    at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:335) at cn.itcast.n4.reentrant.TestInterrupt.lambda$main$0(TestInterrupt.java:17)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">18:02:41.532 [t1] c.TestInterrupt - 等锁的过程中被打断</span><br></pre></td></tr></table></figure><p>注意如果是不可中断模式，那么即使使用了 <code>interrupt</code> 也不会让等待中断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;启动...&quot;</span>);</span><br><span class="line">    lock.lock(); <span class="comment">// 普通锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获得了锁&quot;</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">lock.lock(); </span><br><span class="line">log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    t1.interrupt(); <span class="comment">// 执行中断</span></span><br><span class="line">    log.debug(<span class="string">&quot;执行打断&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">finally</span> &#123; </span><br><span class="line">    log.debug(<span class="string">&quot;释放了锁&quot;</span>); </span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">18:06:56.261 [main] c.TestInterrupt - 获得了锁</span><br><span class="line">18:06:56.265 [t1] c.TestInterrupt - 启动...</span><br><span class="line">18:06:57.266 [main] c.TestInterrupt - 执行打断 // 这时 t1 并没有被真正打断, 而是仍继续等待锁</span><br><span class="line">18:06:58.267 [main] c.TestInterrupt - 释放了锁</span><br><span class="line">18:06:58.267 [t1] c.TestInterrupt - 获得了锁</span><br></pre></td></tr></table></figure><h5 id="3-12-4-锁超时"><a href="#3-12-4-锁超时" class="headerlink" title="3.12.4 锁超时"></a>3.12.4 锁超时</h5><p>主动避免死等</p><p>使用<strong>lock.tryLock</strong>方法会返回获取锁是否成功。如果成功则返回true，反之则返回false。</p><p>并且tryLock方法可以<strong>指定等待时间</strong>，参数为：<code>tryLock(long timeout, TimeUnit unit)</code>, 其中<code>timeout</code>为最长等待时间，<code>TimeUnit</code>为时间单位</p><p><strong>简而言之</strong>就是：获取失败了、获取超时了或者被打断了，不再阻塞，直接停止运行</p><p>例：不设置等待时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); </span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;启动...&quot;</span>); </span><br><span class="line">    <span class="keyword">if</span> (!lock.tryLock()) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获取立刻失败，返回&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; </span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line">log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">t1.start(); </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    sleep(<span class="number">2</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">18:15:02.918 [main] c.TestTimeout - 获得了锁</span><br><span class="line">18:15:02.921 [t1] c.TestTimeout - 启动...</span><br><span class="line">18:15:02.921 [t1] c.TestTimeout - 获取立刻失败，返回</span><br></pre></td></tr></table></figure><p>例：设置等待时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//判断获取锁是否成功，最多等待1秒</span></span><br><span class="line"><span class="keyword">if</span>(!lock.tryLock(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;获取失败&quot;</span>);</span><br><span class="line"><span class="comment">//获取失败，不再向下执行，直接返回</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="comment">//被打断，不再向下执行，直接返回</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;得到了锁&quot;</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// TODO : 临界区代码</span></span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">t1.start();</span><br><span class="line"><span class="comment">//打断等待</span></span><br><span class="line">t1.interrupt();</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-12-5-公平锁"><a href="#3-12-5-公平锁" class="headerlink" title="3.12.5 公平锁"></a>3.12.5 公平锁</h5><p>在线程获取锁失败，进入阻塞队列时，<strong>先进入</strong>的会在锁被释放后<strong>先获得</strong>锁。这样的获取方式就是<strong>公平</strong>的。但会降低并发度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认是不公平锁，需要在创建时指定为公平锁</span></span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="type">boolean</span> fair);</span><br></pre></td></tr></table></figure><h5 id="3-12-6-条件变量"><a href="#3-12-6-条件变量" class="headerlink" title="3.12.6 条件变量"></a>3.12.6 条件变量</h5><p>synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入waitSet 等待</p><p>ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持<strong>多个</strong>条件变量的，这就好比</p><ul><li>synchronized 是那些不满足条件的线程都在一间休息室等消息</li><li>而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒</li></ul><p>使用要点：</p><ul><li><code>await()</code> 前需要<strong>获得锁</strong></li><li><code>await()</code> 执行后，会释放锁，进入 conditionObject 等待</li><li>await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁</li><li>竞争 lock 锁成功后，从 await 后继续执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">// 创建新的条件变量（休息室）</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">condition1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">condition2</span> <span class="operator">=</span> lock.newCondition(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line"></span><br><span class="line">    condition1.await(); <span class="comment">// 进入“休息室”等待</span></span><br><span class="line"></span><br><span class="line">    condition1.signal(); <span class="comment">// 从“休息室”唤醒</span></span><br><span class="line"></span><br><span class="line">    condition1.signalAll();<span class="comment">// 从“休息室”唤醒所有</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestCorrectPosture&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCorrectPostureStep4</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasCigarette</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasTakeout</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">ROOM</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">  <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">waitCigaretteSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Condition</span>();</span><br><span class="line">  <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">waitTakeOutSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Condition</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            ROOM.lock();</span><br><span class="line">          <span class="keyword">try</span>&#123;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">                <span class="keyword">while</span> (!hasCigarette) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        waitCigaretteSet.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              ROOM.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            ROOM.lock();</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);</span><br><span class="line">                <span class="keyword">while</span> (!hasTakeout) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没外卖，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        waitTakeOutSet.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              ROOM.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小女&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            ROOM.lock();</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">                hasTakeout = <span class="literal">true</span>;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖到了噢！&quot;</span>);</span><br><span class="line">                waitTakeOutSet.signal();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              ROOM.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;送外卖的&quot;</span>).start();</span><br><span class="line">      </span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            ROOM.lock();</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">                hasTakeout = <span class="literal">true</span>;</span><br><span class="line">                log.debug(<span class="string">&quot;烟到了噢！&quot;</span>);</span><br><span class="line">                waitCigaretteSet.signal();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              ROOM.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;送烟的&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">15:34:20.249 c.Test24[小女] - 外卖送到没？ [false]</span><br><span class="line">15:34:20.260 c.Test24[小女] - 没外卖，先歇会！</span><br><span class="line">15:34:20.303 c.Test24[小南] - 有烟没？[false]</span><br><span class="line">15:34:20.303 c.Test24[小南] - 没烟，先歇会！</span><br><span class="line">15:34:21.238 c.Test24[小女] - 可以开始干活了</span><br><span class="line">15:34:22.241 c.Test24[小南] - 可以开始干活了</span><br></pre></td></tr></table></figure><h4 id="3-13-同步模式-之-顺序控制"><a href="#3-13-同步模式-之-顺序控制" class="headerlink" title="3.13 同步模式 之 顺序控制"></a>3.13 同步模式 之 顺序控制</h4><h5 id="3-13-1-固定运行顺序"><a href="#3-13-1-固定运行顺序" class="headerlink" title="3.13.1 固定运行顺序"></a>3.13.1 固定运行顺序</h5><p>比如先打印“2”，再打印“1”</p><h6 id="wait-notify-方法"><a href="#wait-notify-方法" class="headerlink" title="wait / notify 方法"></a><code>wait / notify 方法</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="comment">//判断先执行的内容是否执行完毕</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">Boolean</span> <span class="variable">t2Runned</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line"><span class="keyword">while</span> (!t2Runned) &#123; <span class="comment">// 判断 2 是否打印过</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">LOCK.wait();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">t2Runned = <span class="literal">true</span>;</span><br><span class="line">LOCK.notify(); <span class="comment">//执行完毕，唤醒所有等待线程</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="park-unpark方法"><a href="#park-unpark方法" class="headerlink" title="park / unpark方法"></a><code>park / unpark方法</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span> (() -&gt; &#123;</span><br><span class="line">    LockSupport.park();</span><br><span class="line">    System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">  &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">  </span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span> (() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    LockSupport.unpark(t1);</span><br><span class="line">  &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-13-2-交替输出"><a href="#3-13-2-交替输出" class="headerlink" title="3.13.2 交替输出"></a>3.13.2 交替输出</h5><p>线程 1 输出a 5次，线程2输出b 5次，线程3 输出c 5次。现在要求输出 abcabcabcabcabc 怎么实现？</p><h6 id="wait-notify-方法-1"><a href="#wait-notify-方法-1" class="headerlink" title="wait / notify 方法"></a><code>wait / notify 方法</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">输出内容等待标记下一个标记</span></span><br><span class="line"><span class="comment">a12</span></span><br><span class="line"><span class="comment">b23</span></span><br><span class="line"><span class="comment">c31</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WaitSymbol</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> flag; <span class="comment">// 等待标记</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> loopNum; <span class="comment">// 循环次数</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">WaitSymbol</span> <span class="params">(<span class="type">int</span> flag, <span class="type">int</span> loopNum)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.flag = flag;</span><br><span class="line">    <span class="built_in">this</span>.loopNum = loopNum;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str, <span class="type">int</span> waitFlag, <span class="type">int</span> nextFlag)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;loopNum; i++) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(flag != waitFlag) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(str);</span><br><span class="line">        flag = nextFlag;</span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">WaitSymbol</span> <span class="variable">ws</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitSymbol</span>(<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span> (() -&gt; &#123;</span><br><span class="line">    ws.print(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">  </span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span> (() -&gt; &#123;</span><br><span class="line">    ws.print(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">  &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">  </span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span> (() -&gt; &#123;</span><br><span class="line">    ws.print(<span class="string">&quot;c&quot;</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;, <span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abcabcabcabcabc</span><br></pre></td></tr></table></figure><h6 id="ReentrantLock-方法"><a href="#ReentrantLock-方法" class="headerlink" title="ReentrantLock 方法"></a><code>ReentrantLock 方法</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AwaitSignal</span> <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">loopNum</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">AwaitSignal</span> <span class="params">(<span class="type">int</span> loopNum)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loopNum = loopNum;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 参数1：打印内容参数2：进入哪一间休息室参数3：下一间休息室</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str, Condition current, Condition next)</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;loopNumber; i++) &#123;</span><br><span class="line">lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">current.await();</span><br><span class="line">System.out.print(str);</span><br><span class="line">next.signal();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">AwaitSignal</span> <span class="variable">awaitSignal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AwaitSignal</span>();</span><br><span class="line"><span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">conditionA</span> <span class="operator">=</span> awaitSignal.newCondition();</span><br><span class="line"><span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">conditionB</span> <span class="operator">=</span> awaitSignal.newCondition();</span><br><span class="line"><span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">conditionC</span> <span class="operator">=</span> awaitSignal.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">awaitSignal.print(<span class="string">&quot;a&quot;</span>, conditionA, conditionB);</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">awaitSignal.print(<span class="string">&quot;b&quot;</span>, conditionB, conditionC);</span><br><span class="line">&#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">awaitSignal.print(<span class="string">&quot;c&quot;</span>, conditionC, conditionA);</span><br><span class="line">&#125;, <span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">awaitSignal.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;开始...&quot;</span>);</span><br><span class="line">conditionA.signal(); <span class="comment">// 唤醒一个等待的线程</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">awaitSignal.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abcabcabcabcabc</span><br></pre></td></tr></table></figure><h6 id="park-unpark-方法"><a href="#park-unpark-方法" class="headerlink" title="park / unpark 方法"></a><code>park / unpark 方法</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ParkUnpark</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> loopNum;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ParkUnpark</span><span class="params">(<span class="type">int</span> loopNum)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loopNum = loopNum;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str, thread next)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;loopNum; i++) &#123;</span><br><span class="line">      LockSupport.park();</span><br><span class="line">      System.out.print(str);</span><br><span class="line">      LockSupport.unpark(next);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Thread t1;</span><br><span class="line"><span class="keyword">static</span> Thread t2;</span><br><span class="line"><span class="keyword">static</span> Thread t3;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">ParkUnpark</span> <span class="variable">pu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParkUnpark</span>(<span class="number">5</span>);</span><br><span class="line">  t1 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    pu.print(<span class="string">&quot;a&quot;</span>, t2);</span><br><span class="line">  &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">t2 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    pu.print(<span class="string">&quot;b&quot;</span>, t3);</span><br><span class="line">  &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">t3 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    pu.run(<span class="string">&quot;c&quot;</span>, t1);</span><br><span class="line">  &#125;, <span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line">  </span><br><span class="line">  LockSupport.unpark(t1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abcabcabcabcabc</span><br></pre></td></tr></table></figure><h4 id="3-14-经典问题：哲学家就餐问题"><a href="#3-14-经典问题：哲学家就餐问题" class="headerlink" title="3.14 经典问题：哲学家就餐问题"></a>3.14 经典问题：哲学家就餐问题</h4><p><img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/image-20220327221126928.png" alt="image-20220327221126928" style="zoom:50%;"></p><p>圆桌上坐着5名哲学家，每两个哲学家之问的桌上摆一根筷子，桌子的中间是一碗米饭。哲学们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时才试图拿起左、右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐。当进餐完毕后，放下筷子继续思考。</p><ol><li>关系分析。系统中有5个哲学家进程，5位哲学家<strong>与左右邻居对其中间筷子的访问</strong>是<strong>互斥关系</strong></li><li>整理思路。这个问题中只有互斥关系，但与之前遇到的问题不同的事，每个哲学家进程需要同时持有两个临界资源才能开始吃饭。如何<strong>避免临界资源分配不当造成的死锁现象</strong>，是哲学家问题的精髓。</li><li>信号量设置。定义互斥信号量数组<code>chopstick [5] = &#123;1,1,1,1,1&#125;</code>用于实现对5个筷子的互斥访问。并对哲学家按<code>0~4</code>编号，哲学家<code>i</code>左边的筷子编号为<code>i</code>，右边的筷子编号为<code>(i+1) % 5</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Semaphore chopstick[<span class="number">5</span>] = <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">Semaphore</span> <span class="variable">mutex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line">Philosoph_i () &#123;    <span class="comment">// i号哲学家进程</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        chopstick[i].down();            <span class="comment">// 拿起左边筷子</span></span><br><span class="line">        chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>].down();      <span class="comment">// 拿起右边筷子</span></span><br><span class="line">        吃饭；</span><br><span class="line">        chopstick[i].up();              <span class="comment">// 放下左边筷子</span></span><br><span class="line">        chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>].up();        <span class="comment">// 放下右边筷子</span></span><br><span class="line">        思考；</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    这种情况下，所有哲学家都会拿起左边的筷子，会造成死锁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>这种情况下，所有哲学家都会拿起左边的筷子，会造成 <strong>死锁</strong>。这种解决方案不合理。</p><p><strong>如何防止死锁的发生呢？</strong></p><ol><li>可以对哲学家进程施加一些限制条件，比如最多允许<strong>四个哲学家同时进餐</strong>。这样可以<strong>保证至少有一个哲学家是可以拿到左右两只筷子</strong>的</li><li>要求<strong>奇数号哲学家先拿左边的筷子，然后再拿右边的筷子</strong>，而<strong>偶数号哲学家刚好相反</strong>。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一支后再等待另一只的情况。</li><li>当且仅当一个哲学家<strong>左右两只筷子都可用时才允许他挂起筷子</strong>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Semaphore chopstick[<span class="number">5</span>] = <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">Semaphore</span> <span class="variable">mutex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>); <span class="comment">// 互斥地取筷子</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    实现方法3.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Philosoph_i () &#123;    <span class="comment">// i号哲学家进程</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        mutex.down();                   <span class="comment">// 拿两个筷子的锁</span></span><br><span class="line">        chopstick[i].down();            <span class="comment">// 拿起左边筷子</span></span><br><span class="line">        chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>].down();      <span class="comment">// 拿起右边筷子</span></span><br><span class="line">        mutex.up();</span><br><span class="line">        吃饭；</span><br><span class="line">        chopstick[i].up();              <span class="comment">// 放下左边筷子</span></span><br><span class="line">        chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>].up();        <span class="comment">// 放下右边筷子</span></span><br><span class="line">        思考；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>这些<strong>进程之间只存在互斥关系</strong>，但是与之前接触到的互斥关系不同的是，每个进程都需要同时持有两个临界资源，因此就有“死锁”问题的隐患。</li><li>如果在考试中遇到了一个进程需要同时持有<strong>多个临界资源的情况</strong>，应该<strong>参考哲学家问题的思想</strong>，分析题中给出的进程之间<strong>是否会发生循环等待，是否会发生死锁</strong>。</li><li>可以参考哲学家就餐问题解决死锁的三种思路</li></ul><h3 id="4-共享模型之内存"><a href="#4-共享模型之内存" class="headerlink" title="4 共享模型之内存"></a>4 共享模型之内存</h3><p>上一章讲解的 Monitor 主要关注的是访问共享变量时，保证临界区代码的原子性。这一章我们将进一步学习共享变量在多线程间的【可见性】问题与多条指令执行时的【有序性】问题。</p><p>本章节单独作为一篇：<a href="https://dave0126.github.io/2022/08/26/JMM-Java-内存模型/">JMM - Java 内存模型</a>，点击跳转。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Java-并发多线程编程&quot;&gt;&lt;a href=&quot;#Java-并发多线程编程&quot; class=&quot;headerlink&quot; title=&quot;Java 并发多线程编程&quot;&gt;&lt;/a&gt;Java 并发多线程编程&lt;/h2&gt;&lt;p&gt;视频课程: &lt;a href=&quot;https://www.bilibili.com/video/BV16J411h7Rd?p=1&quot;&gt;BiliBili - 黑马程序员Java并发编程 JUC&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;笔记参考: &lt;a href=&quot;https://nyimac.gitee.io/2020/06/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/&quot;&gt;Java并发 - Nyima’s Blog&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注：本课程笔记基于JDK8，采用lsf4j打印日志&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="Java" scheme="https://dave0126.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://dave0126.github.io/tags/Java/"/>
    
    <category term="JUC" scheme="https://dave0126.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Java 虚拟机 - JVM</title>
    <link href="https://dave0126.github.io/2022/03/22/JVM-1/"/>
    <id>https://dave0126.github.io/2022/03/22/JVM-1/</id>
    <published>2022-03-22T20:52:44.000Z</published>
    <updated>2022-08-26T17:31:41.593Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM-基础学习"><a href="#JVM-基础学习" class="headerlink" title="JVM 基础学习"></a>JVM 基础学习</h1><ul><li><a href="#一、JVM-结构">第一章：JVM 结构</a></li><li><a href="#二、JVM-内存结构">第二章：JVM 内存结构</a></li><li><a href="#三、JVM-垃圾回收">第三章：JVM 垃圾回收</a></li><li><a href="#四、类加载与字节码技术">第四章：类加载与字节码技术</a></li></ul><p>【参考资料】</p><ol><li>视频课程：<a href="https://www.bilibili.com/video/BV1yE411Z7AP">BiliBili - 黑马程序员 JVM 完整教程</a></li><li><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">The Java® Virtual Machine Specification - Java SE 8 Edition 官方文档</a></li></ol><span id="more"></span><h2 id="什么是-JVM？"><a href="#什么是-JVM？" class="headerlink" title="什么是 JVM？"></a>什么是 JVM？</h2><p><code>JVM (Java Virtual Machine)</code> 是 Java 程序的运行环境(Java 二进制字节码的运行环境)</p><p><strong>好处:</strong></p><ul><li>可以提供一个跨平台的一致的运行环境, 达到平台无关性；</li><li>提供内存管理, 垃圾回收功能；</li></ul><p><code>JRE = JVM + 基础类库</code></p><p><code>JDK = JVM + 基础类库 + 编译工具</code></p><p><img src="/2022/03/22/JVM-1/image-20220719142025243.png" alt="image-20220719142025243" style="zoom:40%;"></p><h2 id="一、JVM-结构"><a href="#一、JVM-结构" class="headerlink" title="一、JVM 结构"></a>一、JVM 结构</h2><p><img src="/2022/03/22/JVM-1/image-20220719142921758.png" alt="image-20220719142921758"></p><p>总体分为三大部分：</p><ul><li><code>ClassLoader</code> 类加载器：<code>Java</code> 代码编译成二进制后，会经过类加载器，这样才能加载到 <code>JVM</code> 中运行。</li><li><code>JVM</code> 内存结构</li><li>执行引擎</li></ul><h2 id="二、JVM-内存结构"><a href="#二、JVM-内存结构" class="headerlink" title="二、JVM 内存结构"></a>二、JVM 内存结构</h2><ol><li>程序计数器 (Program Counter Register)</li><li>虚拟机栈 (JVM Stacks)</li><li>本地方法栈 (Native Method Stacks)</li><li>堆 (Heap)</li><li>方法区 (Method Area)</li></ol><h3 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1. 程序计数器"></a>1. 程序计数器</h3><p>Java中 <code>JVM</code> 指令的实行流程</p><p><img src="/2022/03/22/JVM-1/image-20220719144541816.png" alt="image-20220719144541816" style="zoom:50%;"></p><p>作用: 在指令的执行中, 记住<strong>下一条 <code>JVM</code> 指令的执行地址</strong>. 在物理上可使用<strong>寄存器</strong>实现.</p><p>特点:</p><ul><li>线程私有。在多线程下, 线程间切换时需要保存当前环境, 需要用到程序计数器记住下一条 <code>JVM</code> 指令的执行地址</li><li>不存在内存溢出。</li></ul><h3 id="2-虚拟机栈"><a href="#2-虚拟机栈" class="headerlink" title="2. 虚拟机栈"></a>2. 虚拟机栈</h3><h4 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h4><p>回忆数据结构中“<strong>栈</strong>”的结构: 先进后出</p><p>虚拟机栈是<strong><u>线程</u>运行需要的内存空间</strong>，<strong>一个栈由多个栈帧组成</strong>。一个栈帧对应一次方法的调用，<strong>栈帧(Frame)</strong>即<strong>每个方法调用时需要的内存(参数、局部变量、返回地址等)</strong>。</p><ul><li>每个线程只能有一个<strong><u>活动栈帧</u></strong>，对应着<strong><u>当前正在执行的那个方法</u></strong>，栈顶的栈帧。</li></ul><blockquote><p>注意⚠️：可以在 IDEA 中用 “debug” 模式下的“Debugger”视图中看到栈和栈帧.</p></blockquote><p><strong>思考:</strong></p><ul><li>在函数的调用中, <ol><li>先把主调函数入栈，调用被调函数，紧接着被调函数入栈，活动栈帧为被调函数；</li><li>等被调函数返回返回值时，被调函数出栈，活动栈帧为主调函数。</li></ol></li><li><u>垃圾回收不涉及栈内存</u>, 因为每次执行后栈内存都会被清空(出栈)</li><li><p>栈内存越大, 线程数越小 (默认 1024KB)</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xss 1m or 1024k or 1048576</span><br></pre></td></tr></table></figure></li></ul><h4 id="2-2-栈内存溢出"><a href="#2-2-栈内存溢出" class="headerlink" title="2.2 栈内存溢出"></a>2.2 栈内存溢出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.StackOverflowError</span><br></pre></td></tr></table></figure><ol><li><p>栈帧过多导致内存溢出</p><ul><li><p>想象一下，在不断的调用方法时，一直入栈没有出栈，直到某一次调用时无法分配新的栈帧内存。</p><p>e.g. 无递归终止条件的<strong>递归调用</strong></p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackOverflowTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> count;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      method1();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable a) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      System.out.print(count);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    count++;</span><br><span class="line">    method1();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>栈帧过大导致内存溢出，栈帧 &gt; 栈内存</li></ol><h4 id="2-3-线程运行诊断"><a href="#2-3-线程运行诊断" class="headerlink" title="2.3 线程运行诊断"></a>2.3 线程运行诊断</h4><p>如何查看某个进程中 CPU 的占用情况</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps H -eo pid,tid,%cpu | grep 进程id</span><br></pre></td></tr></table></figure><p><code>JDK</code> 自带一个工具 <code>JStack</code> 命令, 用于定位 CPU占用过多的 Java线程(TID). 根据线程 id(TID) 找到有问题的线程,即可能有问题的代码行数. 也可以发现<strong>有死锁的进程</strong>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack 进程id(PID)</span><br></pre></td></tr></table></figure><h3 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3. 本地方法栈"></a>3. 本地方法栈</h3><p>本地方法是由于 Java 语言限制, 不能直接和操作系统底层“打交道”，所以需要 <code>c/c++</code> 语言编写的方法直接与底层操作系统“打交道”， 而java代码可以使用本地方法调用来调用这些方法。</p><p>本地方法使用的内存就是本地方法栈.</p><ul><li>例如 <code>hashCode()</code>, <code>wait()</code>, <code>notify()</code>, <code>notifyAll()</code> 等</li><li>由 <code>native</code> 修饰</li></ul><h3 id="4-堆"><a href="#4-堆" class="headerlink" title="4. 堆"></a>4. 堆</h3><p>线程共享的区域，都要考虑线程安全问题</p><h4 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h4><ul><li>通过 <code>new</code> 关键字 $\to$ 创建一个堆，都会使用堆的内存</li></ul><p>特点:</p><ul><li><strong><u>线程共享</u></strong>，堆中对象都要考虑线程安全问题</li><li><strong><u>有垃圾回收机制</u></strong>，当对象不再被引用时，其占用的内存会被回收</li></ul><h4 id="4-2-堆内存溢出"><a href="#4-2-堆内存溢出" class="headerlink" title="4.2 堆内存溢出"></a>4.2 堆内存溢出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 创建堆</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            list.add(a);</span><br><span class="line">            a = a + a; <span class="comment">// Hello, HelloHello, HelloHelloHelloHello, ....</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-堆内存诊断"><a href="#4-3-堆内存诊断" class="headerlink" title="4.3 堆内存诊断"></a>4.3 堆内存诊断</h4><p><code>Java</code> 常用工具:</p><ol><li><code>jps</code> 工具<ul><li>查看当前系统中有哪些java进程</li></ul></li><li><code>jmap</code> 工具 <ul><li>查看某一时刻下,堆内存的占用情况</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ jps</span><br><span class="line">$ jmap -heap 进程id(PID)</span><br></pre></td></tr></table></figure><ol><li><code>jconsole</code> 工具<ul><li>图形界面的, 多功能的检查工具, 可以连续监测</li></ul></li><li><code>jvisualvm</code> 工具 (需要自行下载)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;1....&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">    <span class="type">byte</span>[] array = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>];  <span class="comment">// 堆中内存占用新增10MB</span></span><br><span class="line">    System.out.println(<span class="string">&quot;2....&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">    array = <span class="literal">null</span>;</span><br><span class="line">    System.gc();                                <span class="comment">// 垃圾回收</span></span><br><span class="line">    System.out.println(<span class="string">&quot;3....&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5. 方法区"></a>5. 方法区</h3><h4 id="5-1-定义"><a href="#5-1-定义" class="headerlink" title="5.1 定义"></a>5.1 定义</h4><p>方法区是 <code>JVM</code> 中<strong>所有线程共享</strong>的区域.</p><p>存储了与<strong>类</strong>结构相关的信息: </p><ul><li>成员变量 (field)</li><li>方法的数据 (method data)</li><li>方法的代码 (code of method)</li><li>构造器的代码 (code of constructor)</li><li>运行时常量池 (run-time constant pool)</li></ul><p>方法区在 <code>JVM</code> <strong><u>启动时</u></strong>创建，逻辑上是<u><strong>堆</strong></u>的一部分。</p><h4 id="5-2-组成"><a href="#5-2-组成" class="headerlink" title="5.2 组成"></a>5.2 组成</h4><p>JDK 1.6 与 JDK 1.8。</p><ul><li>JDK 1.6 中，方法区这种概念的实现方式（永久代）属于 <code>JVM</code> 的内存结构；</li><li>JDK 1.8 中，方法区这种概念的实现方式（元空间）从 <code>JVM</code> 的内存结构中提取出来，属于操作系统内存结构的一部分</li></ul><p><img src="/2022/03/22/JVM-1/IMG_6B2CE85A4DCA-1.jpeg" alt="methodArea"></p><h4 id="5-3-方法区的内存溢出"><a href="#5-3-方法区的内存溢出" class="headerlink" title="5.3 方法区的内存溢出"></a>5.3 方法区的内存溢出</h4><ul><li>永久代内存溢出（JDK 1.8以前）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR INFO: java.lang.OutOfMemoryError: PermGen space</span><br><span class="line">-XX:MaxPermSize=8m</span><br></pre></td></tr></table></figure><ul><li>元空间内存溢出（JDK 1.8以后）</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR INFO: java.lang.OutOfMemoryError: Metaspace</span><br><span class="line">-XX:MaxMetaspaceSize=8m</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123; <span class="comment">// 类加载器: 可以用来加载类的二进制字节码, 动态加载</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">Demo</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++, j++) &#123;</span><br><span class="line">        <span class="type">ClassWriter</span> <span class="variable">cw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(<span class="number">0</span>); <span class="comment">// ClassWriter作用是生成类的二进制字节码</span></span><br><span class="line">        cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, <span class="string">&quot;Class&quot;</span> + i, <span class="literal">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="literal">null</span>); </span><br><span class="line">        <span class="comment">// 版本号, public, 类名:1~10000, 包名:null, 父类: 继承自&quot;java/lang/Object&quot;, 接口名:null</span></span><br><span class="line">        <span class="comment">//返回 byte[]</span></span><br><span class="line">        <span class="type">byte</span>[] code = cw.toByteArray();</span><br><span class="line">        <span class="comment">// 只执行类的加载, 而不链接</span></span><br><span class="line">        test.defineClass(<span class="string">&quot;Class&quot;</span> + i, code, <span class="number">0</span>, code.length); <span class="comment">// class 对象</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      System.out.println(j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有可能的溢出场景：实际生产中，动态产生并加载类时容易产生这种内存溢出</p><ol><li><code>Spring</code> 框架中的 <code>cglib</code> 字节码技术，<code>AOP</code> 的核心 - 生成动态代理类</li><li><code>Mybatis</code> 框架中的 <code>cglib</code> 字节码技术</li></ol><h4 id="5-4-运行时常量池"><a href="#5-4-运行时常量池" class="headerlink" title="5.4 运行时常量池"></a>5.4 运行时常量池</h4><p>编译后的<strong>二进制字节码</strong>包含: <u>类基本信息</u>、<u>常量池</u>、<u>类方法定义</u>、<u>虚拟机指令</u></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -v &lt;xxx.class&gt; // -v 显示反编译后的详细信息</span><br></pre></td></tr></table></figure><p>例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后的详细信息: </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">Classfile /test.class// 类基本信息</span><br><span class="line">  Last modified 2022年3月6日; size 413 bytes</span><br><span class="line">  SHA-256 checksum 7ab757ee2d78f0e76a52ba8b03b43fee2fe9d7994d74bc7d133b2e309ceed8f3</span><br><span class="line">  Compiled from &quot;test.java&quot;</span><br><span class="line">public class test</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 59</span><br><span class="line">  flags: (0x0021) ACC_PUBLIC, ACC_SUPER// 访问修饰符</span><br><span class="line">  this_class: #21                         // test</span><br><span class="line">  super_class: #2                         // 父类:java/lang/Object</span><br><span class="line">  interfaces: 0, fields: 0, methods: 2, attributes: 1</span><br><span class="line">  </span><br><span class="line">Constant pool:// 常量池</span><br><span class="line">   #1 = Methodref          #2.#3          // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Class              #4             // java/lang/Object</span><br><span class="line">   #3 = NameAndType        #5:#6          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #4 = Utf8               java/lang/Object</span><br><span class="line">   #5 = Utf8               &lt;init&gt;</span><br><span class="line">   #6 = Utf8               ()V</span><br><span class="line">   #7 = Fieldref           #8.#9          // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #8 = Class              #10            // java/lang/System</span><br><span class="line">   #9 = NameAndType        #11:#12        // out:Ljava/io/PrintStream;</span><br><span class="line">  #10 = Utf8               java/lang/System</span><br><span class="line">  #11 = Utf8               out</span><br><span class="line">  #12 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #13 = String             #14            // Hello World</span><br><span class="line">  #14 = Utf8               Hello World</span><br><span class="line">  #15 = Methodref          #16.#17        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">  #16 = Class              #18            // java/io/PrintStream</span><br><span class="line">  #17 = NameAndType        #19:#20        // println:(Ljava/lang/String;)V</span><br><span class="line">  #18 = Utf8               java/io/PrintStream</span><br><span class="line">  #19 = Utf8               println</span><br><span class="line">  #20 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">  #21 = Class              #22            // test</span><br><span class="line">  #22 = Utf8               test</span><br><span class="line">  #23 = Utf8               Code</span><br><span class="line">  #24 = Utf8               LineNumberTable</span><br><span class="line">  #25 = Utf8               main</span><br><span class="line">  #26 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #27 = Utf8               SourceFile</span><br><span class="line">  #28 = Utf8               test.java</span><br><span class="line">  </span><br><span class="line">&#123;// 方法定义的区域</span><br><span class="line">  public test();// 当程序没有构造方法时, 编译器会默认生成一个无参的构造方法</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (0x0001) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 1: 0</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);// main方法</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: (0x0009) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">      // 虚拟机指令#n: 对应着常量池中的变量</span><br><span class="line">         0: getstatic     #7// Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #13// String Hello World 加载引用地址</span><br><span class="line">         5: invokevirtual #15// Method java/io/PrintStream.println:(Ljava/lang/String)V</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">        line 4: 8</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;test.java&quot;</span><br></pre></td></tr></table></figure><ul><li><strong>常量池</strong>就是<u>一张常量查找表</u>，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量(如字符串、整型、bool类型等)等信息；</li><li>运行时常量池，就是当该类被加载时，它的常量池信息会放入运行常量池，地址会替换为真正的内存地址。</li></ul><h4 id="5-5-StringTable串池"><a href="#5-5-StringTable串池" class="headerlink" title="5.5 StringTable串池"></a>5.5 <em>StringTable</em>串池</h4><p>特征：</p><ul><li><p>常量池中的信息，都会被加载到运行时常量池中。这时 <code>&quot;a&quot;, &quot;b&quot;, &quot;ab&quot;</code> 都是常量池中的符号，<strong>还不是 字符串对象</strong></p></li><li><p>常量池中的字符串仅是符号，只有<strong>在被第一次引用到时才会转化为对象</strong> <code>ldc</code></p></li><li><p>StringTable在内存结构上是哈希表，不能扩容</p></li><li><p>利用串池的机制，来避免重复创建字符串对象</p></li><li><p>字符串<strong>变量</strong>拼接的原理是<strong>StringBuilder</strong></p></li><li><p>字符串<strong>常量</strong>拼接的原理是<strong>编译器优化</strong></p></li><li><p>可以使用 <strong><code>intern()</code> 方法</strong>，主动将串池中还没有的字符串对象放入串池中</p><ul><li>JDK 1.8 中，尝试将串池中还没有的字符串对象放入串池时，如果串池中有该对象则不会放入；若没有，则放入串池，且将串池中的对象返回</li><li>JDK 1.6 中，尝试将串池中还没有的字符串对象放入串池时，如果串池中有该对象则不会放入；若没有，则会先将该对象复制一份，然后放入串池，最后将串池中的对象返回</li></ul><p><strong>注意</strong>：无论是串池还是堆里面的字符串，都是对象</p></li></ul><h5 id="5-5-1-串池"><a href="#5-5-1-串池" class="headerlink" title="5.5.1 串池"></a>5.5.1 串池</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableStudy</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>; </span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">ab</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常量池中的信息:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0: ldc           #2                  // String a</span><br><span class="line">2: astore_1// 把 a符号 变成 “a”字符串对象</span><br><span class="line">3: ldc           #3                 // String b</span><br><span class="line">5: astore_2// 把 b符号 变成 “b”字符串对象</span><br><span class="line">6: ldc           #4                  // String ab</span><br><span class="line">8: astore_3// 把 ab符号 变成 “ab”字符串对象</span><br><span class="line">9: return</span><br></pre></td></tr></table></figure><ol><li><p>当执行到 <code>ldc #2</code> 时，会把符号 a 变为 “a” 字符串对象，<strong>并放入串池中</strong>（hashtable结构 不可扩容）</p></li><li><p>当执行到 <code>ldc #3</code> 时，会把符号 b 变为 “b” 字符串对象，并放入串池中</p></li><li><p>当执行到 <code>ldc #4</code> 时，会把符号 ab 变为 “ab” 字符串对象，并放入串池中</p></li><li><p>最终 <code>StringTable [&quot;a&quot;, &quot;b&quot;, &quot;ab&quot;]</code></p><p><strong>注意</strong>：字符串对象的创建都是<strong>懒惰的</strong>，只有当运行到那一行字符串且在串池中不存在的时候（如 ldc #2）时，该字符串才会被创建并放入串池中。</p></li></ol><h5 id="5-5-2-串池：拼接变量字符串对象创建字符串"><a href="#5-5-2-串池：拼接变量字符串对象创建字符串" class="headerlink" title="5.5.2 串池：拼接变量字符串对象创建字符串"></a>5.5.2 串池：拼接变量字符串对象创建字符串</h5><p>使用拼接<strong>字符串变量对象</strong>创建字符串的过程: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableStudy</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">ab</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">ab2</span> <span class="operator">=</span> a+b;<span class="comment">// new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toSrting()</span></span><br><span class="line">    <span class="comment">// 相当于创建了一个新的 String对象</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(ab == ab2); <span class="comment">// 结果为false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后的结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">    stack=2, locals=5, args_size=1</span><br><span class="line">       0: ldc           #2                  // String a</span><br><span class="line">       2: astore_1</span><br><span class="line">       3: ldc           #3                  // String b</span><br><span class="line">       5: astore_2</span><br><span class="line">       6: ldc           #4                  // String ab</span><br><span class="line">       8: astore_3</span><br><span class="line">       9: new           #5                  // class java/lang/StringBuilder</span><br><span class="line">      12: dup</span><br><span class="line">      13: invokespecial #6                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">      16: aload_1</span><br><span class="line">      17: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      20: aload_2</span><br><span class="line">      21: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      24: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">      27: astore        4</span><br><span class="line">      29: return</span><br></pre></td></tr></table></figure><p>通过拼接的方式来创建字符串的<strong>过程</strong>是：<code>new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString()</code>，地址应该在<strong>堆</strong>中</p><p>最后的toString方法的返回值是一个<strong>新的字符串</strong>，但字符串的<strong>值</strong>和拼接的字符串一致，但是两个不同的字符串，<strong>一个存在于串池之中，一个存在于堆内存之中</strong></p><h5 id="5-5-3-串池：拼接常量字符串对象的方法创建字符串"><a href="#5-5-3-串池：拼接常量字符串对象的方法创建字符串" class="headerlink" title="5.5.3 串池：拼接常量字符串对象的方法创建字符串"></a>5.5.3 串池：<strong>拼接常量字符串对象</strong>的方法创建字符串</h5><p>使用<strong>拼接字符串常量对象</strong>的方法创建字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableStudy</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">ab</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ab2</span> <span class="operator">=</span> a+b;</span><br><span class="line"><span class="type">String</span> <span class="variable">ab3</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>; <span class="comment">// 使用拼接字符串的方法创建字符串，由于编译期间的优化</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(ab == ab3); <span class="comment">// 结果为true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后的结果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">  stack=2, locals=6, args_size=1</span><br><span class="line">     0: ldc           #2                  // String a</span><br><span class="line">     2: astore_1</span><br><span class="line">     3: ldc           #3                  // String b</span><br><span class="line">     5: astore_2</span><br><span class="line">     6: ldc           #4                  // String ab</span><br><span class="line">     8: astore_3</span><br><span class="line">     9: new           #5                  // class java/lang/StringBuilder</span><br><span class="line">    12: dup</span><br><span class="line">    13: invokespecial #6                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">    16: aload_1</span><br><span class="line">    17: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">    20: aload_2</span><br><span class="line">    21: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">    24: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">    27: astore        4// ab3初始化时直接从串池中获取字符串</span><br><span class="line">    29: ldc           #4                  // String ab</span><br><span class="line">    31: astore        5</span><br><span class="line">    33: return</span><br></pre></td></tr></table></figure><ul><li><p>当虚拟机执行到<strong>第0、3、5行</strong>时，会将“a” “b“ ”ab“放入串池。当执行到<strong>29行</strong>时我们可以看到，虚拟机不会先找“a” 再找“b”然后再将它们拼接起来，而是之间找到拼接后的“ab”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringTable[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;ab&quot;</span>]</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>⚠️ 需要注意的是：</p><ul><li>使用<strong>拼接字符串<u>常量</u></strong> 的方法来创建新的字符串时，因为<strong>内容是<u>常量</u>，<code>javac</code> 在编译期会进行优化，结果已在编译期确定为 <code>ab</code></strong>，而创建 <code>ab</code> 的时候已经在串池中放入了 <code>&quot;ab&quot;</code>，所以 <code>ab3</code> 直接从串池中获取值，所以进行的操作和 <code>ab = &quot;ab&quot;</code> 一致。</li><li>使用<strong>拼接字符串<u>变量</u></strong> 的方法来创建新的字符串时，因为<strong>内容是<u>变量</u></strong>，只能<strong>在运行期确定它的值，所以需要使用StringBuilder来创建</strong></li></ul></blockquote><h5 id="5-5-4-串池：intern-方法-JDK1-8"><a href="#5-5-4-串池：intern-方法-JDK1-8" class="headerlink" title="5.5.4 串池：intern() 方法(JDK1.8)"></a>5.5.4 串池：<code>intern()</code> 方法(JDK1.8)</h5><p>调用字符串对象的 <code>intern()</code> 方法，会将该字符串对象尝试放入到串池中</p><ul><li>如果串池中没有该字符串对象，则放入成功</li><li>如果有该字符串对象，则放入失败</li><li>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</li></ul><h6 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h6><p>JDK 1.8 环境下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableInternMethod1</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    <span class="comment">// &quot;a&quot;&quot;b&quot; 被放入串池中，str 则存在于堆中</span></span><br><span class="line">    <span class="comment">// StringTable[&quot;a&quot;, &quot;b&quot;]</span></span><br><span class="line">    <span class="comment">// new String(&quot;a&quot;) 和 new String(&quot;b&quot;) 两个字符串对象</span></span><br><span class="line">    <span class="comment">// 字符串对象 str = new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toSrting()</span></span><br><span class="line">    </span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> str.intern();</span><br><span class="line">    <span class="comment">// 调用str的intern()方法，这时串池中没有&quot;ab&quot;，则会将该字符串对象放入到串池中，此时堆内存与串池中的&quot;ab&quot;是同一个对象</span></span><br><span class="line">    </span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    <span class="comment">// 给str3赋值，因为此时串池中已有&quot;ab&quot;，则直接将串池中的内容返回</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 因为堆内存与串池中的&quot;ab&quot;是同一个对象，所以以下两条语句打印的都为true</span></span><br><span class="line">System.out.println(str2 == str);</span><br><span class="line">System.out.println(str3 == str);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h6><p>JDK 1.8 与 JDK 1.6</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SringTableInternMethod2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">/* 此处创建字符串对象&quot;ab&quot;，因为串池中还没有&quot;ab&quot;，所以将其放入串池中 */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="comment">/* &quot;a&quot; &quot;b&quot; 被放入串池中，str则存在于堆内存之中 */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="comment">/* 此时因为在创建str3时，&quot;ab&quot;已存在与串池中，所以放入失败，但是会返回串池中的&quot;ab&quot; */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> str.intern();</span><br><span class="line">    </span><br><span class="line">System.out.println(str == str2); <span class="comment">//false</span></span><br><span class="line">System.out.println(str == str3); <span class="comment">//false</span></span><br><span class="line">System.out.println(str2 == str3); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h6><p>JDK 1.6环境下，与<a href="#例1">例1</a>进行比较。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableInternMethod3</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    <span class="comment">// &quot;a&quot;&quot;b&quot; 被放入串池中，str 则存在于堆中</span></span><br><span class="line">    <span class="comment">// StringTable[&quot;a&quot;, &quot;b&quot;]</span></span><br><span class="line">    <span class="comment">// new String(&quot;a&quot;) 和 new String(&quot;b&quot;) 两个字符串对象</span></span><br><span class="line">    <span class="comment">// 字符串对象 str = new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toSrting()</span></span><br><span class="line">    </span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> str.intern();</span><br><span class="line">    <span class="comment">// 调用str的intern()方法，这时串池中没有&quot;ab&quot;，则会将该字符串对象放入到串池中，此时堆内存与串池中的&quot;ab&quot;是同一个对象</span></span><br><span class="line">    <span class="comment">// 将 str 复制一份，将复制后的对象放入串池</span></span><br><span class="line">    <span class="comment">// 此时 str2 与串池中的对象相同；str 则不同，是其的复制</span></span><br><span class="line">    </span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    <span class="comment">// 给str3赋值，因为此时串池中已有&quot;ab&quot;，则直接将串池中的内容返回，即 str3 = str2</span></span><br><span class="line">    </span><br><span class="line">System.out.println(str3 == str2);<span class="comment">// true</span></span><br><span class="line">System.out.println(str3 == str); <span class="comment">// false</span></span><br><span class="line">    <span class="comment">// JDK1.8 环境下都为true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-5-5-串池的位置"><a href="#5-5-5-串池的位置" class="headerlink" title="5.5.5 串池的位置"></a>5.5.5 串池的位置</h5><p>在 JDK 1.6 中：</p><p><img src="/2022/03/22/JVM-1/IMG_9A689689FB20-1.jpeg" alt="1.6" style="zoom: 60%;"></p><p>我们可以看到，由于串池逻辑上处于方法区中，而方法区是由永久代实现的，在垃圾回收时需要 <code>FullGC</code> 才能清理永久代，这样就会造成串池迟迟得不到清理，从而导致内存溢出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JDK1.6 环境下：</span><br><span class="line">-XX:MaxPermSize=10m</span><br><span class="line">-Xmx10m -XX:-UseGCOverheadLimit</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableJDK1_6Demo</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;~&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000000</span>; j++) &#123;</span><br><span class="line">        list.add(String.valueOf(j).intern());</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR INFO:</span><br><span class="line">java.lang.OutOfMemoryError: PermGen space</span><br></pre></td></tr></table></figure><p>为了解决以上问题，在 JDK 1.8 中改进了串池的位置。</p><p>在 JDK 1.8 中：</p><p><img src="/2022/03/22/JVM-1/IMG_42907AA7BAF6-1.jpeg" alt="StringTable1.8"></p><p>串池位于堆中，在垃圾回收时需要 <code>MinorGC</code> 进行垃圾回收，从而减轻内存占用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JDK1.6 环境下：</span><br><span class="line">-Xmx10m -XX:-UseGCOverheadLimit</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableJDK1_8Demo</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;~&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000000</span>; j++) &#123;</span><br><span class="line">        list.add(String.valueOf(j).intern());</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR INFO:</span><br><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure><h5 id="5-5-6-串池的垃圾回收"><a href="#5-5-6-串池的垃圾回收" class="headerlink" title="5.5.6 串池的垃圾回收"></a>5.5.6 串池的垃圾回收</h5><p><code>StringTable</code> 在内存紧张时，会发生<a href="#三、JVM-垃圾回收">垃圾回收</a>。</p><h5 id="5-5-7-串池的性能调优"><a href="#5-5-7-串池的性能调优" class="headerlink" title="5.5.7 串池的性能调优"></a>5.5.7 串池的性能调优</h5><ul><li><p>因为 <code>StringTable</code> 是用 <code>HashTable</code> 实现的，所以我们可以<strong>适当增加 <code>HashTable</code> 的桶的个数</strong>，来减少字符串放入串池所需要的时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:StringTableSize=xxxx</span><br></pre></td></tr></table></figure></li><li><p>考虑是否需要将字符串对象入池，可以通过 <strong><code>intern()</code> 方法减少重复入池</strong></p></li></ul><h3 id="6-直接内存"><a href="#6-直接内存" class="headerlink" title="6. 直接内存"></a>6. 直接内存</h3><h4 id="6-1-定义"><a href="#6-1-定义" class="headerlink" title="6.1 定义"></a>6.1 定义</h4><p>直接内存不属于 <code>JVM</code> 内存结构，而是<strong>操作系统的内存</strong>。</p><ul><li>属于操作系统，常见于 NIO 操作时，<strong>用于数据缓冲区</strong></li><li>分配回收成本较高，但读写性能高</li><li>不受 <code>JVM</code> 内存回收管理</li></ul><h4 id="6-2-基本使用"><a href="#6-2-基本使用" class="headerlink" title="6.2 基本使用"></a>6.2 基本使用</h4><p><img src="/2022/03/22/JVM-1/image-20220816162626624.png" alt="image-20220816162626624"></p><p>使用了 <code>DirectBuffer</code> 后，</p><p>【直接内存】是操作系统和 <code>Java</code> 代码<strong>都可以访问的一块区域</strong>，无需将代码从系统内存复制到 <code>Java</code> 堆内存，从而提高了效率</p><p><img src="/2022/03/22/JVM-1/image-20220816163058539.png" alt="image-20220816163058539"></p><h4 id="6-3-分配和回收原理"><a href="#6-3-分配和回收原理" class="headerlink" title="6.3 分配和回收原理"></a>6.3 分配和回收原理</h4><ul><li>使用了 <code>Unsafe</code> 类来完成直接内存的分配回收，而且回收需要主动调用<strong>unsafe.freeMemory()</strong>方法</li><li><code>ByteBuffer</code> 的实现内部使用了 <code>Cleaner</code>（<a href="#1-3-五种引用">虚引用</a>）来检测 <code>ByteBuffer</code>。一旦 <code>ByteBuffer</code> 被垃圾回收，那么会由 <code>ReferenceHandler</code> 来调用 Cleaner 的 <code>clean()</code> 方法调用 <code>freeMemory</code> 来释放内存</li></ul><p>直接内存的回收不是通过JVM的垃圾回收来释放的，而是通过<strong>unsafe.freeMemory()</strong>来手动释放</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过ByteBuffer申请1M的直接内存</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(_1M);</span><br></pre></td></tr></table></figure><p>申请直接内存，但JVM并不能回收直接内存中的内容，它是如何实现回收的呢？</p><h5 id="allocateDirect-的实现底层源码分析"><a href="#allocateDirect-的实现底层源码分析" class="headerlink" title="allocateDirect() 的实现底层源码分析"></a>allocateDirect() 的实现底层源码分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title function_">allocateDirect</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectByteBuffer</span>(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>DirectByteBuffer</code> 类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">DirectByteBuffer(<span class="type">int</span> cap) &#123;   <span class="comment">// package-private</span></span><br><span class="line">   </span><br><span class="line">    <span class="built_in">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">pa</span> <span class="operator">=</span> VM.isDirectMemoryPageAligned();</span><br><span class="line">    <span class="type">int</span> <span class="variable">ps</span> <span class="operator">=</span> Bits.pageSize();</span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> Math.max(<span class="number">1L</span>, (<span class="type">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        base = unsafe.allocateMemory(size); <span class="comment">//申请内存</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.setMemory(base, size, (<span class="type">byte</span>) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// Round up to page boundary</span></span><br><span class="line">        address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    cleaner = Cleaner.create(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">Deallocator</span>(base, size, cap)); <span class="comment">//通过虚引用，来实现直接内存的释放，this为虚引用的实际对象</span></span><br><span class="line">    att = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了一个Cleaner的 <code>create()</code> 方法，且后台线程还会对虚引用的对象监测，如果虚引用的实际对象（这里是 <code>DirectByteBuffer</code>）被回收以后，就会调用Cleaner的 <code>clean()</code> 方法，来清除直接内存中占用的内存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clean</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (remove(<span class="built_in">this</span>)) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="built_in">this</span>.thunk.run(); <span class="comment">//调用run方法</span></span><br><span class="line">           &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable var2) &#123;</span><br><span class="line">               AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">                   <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                       <span class="keyword">if</span> (System.err != <span class="literal">null</span>) &#123;</span><br><span class="line">                           (<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Cleaner terminated abnormally&quot;</span>, var2)).printStackTrace();</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       System.exit(<span class="number">1</span>);</span><br><span class="line">                       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><p>对应对象的 <code>run()</code> 方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (address == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Paranoia</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.freeMemory(address); <span class="comment">// 释放直接内存中占用的内存</span></span><br><span class="line">    address = <span class="number">0</span>;</span><br><span class="line">    Bits.unreserveMemory(size, capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="三、JVM-垃圾回收"><a href="#三、JVM-垃圾回收" class="headerlink" title="三、JVM 垃圾回收"></a>三、JVM 垃圾回收</h2><h3 id="0-主要内容大纲"><a href="#0-主要内容大纲" class="headerlink" title="0 主要内容大纲"></a>0 主要内容大纲</h3><p>【概述】</p><p>之前我们讲解了 JVM 的内存结构，其中我们了解到<a href="#4-堆">堆</a>存在着垃圾回收机制。这一章我们将重点介绍这一部分内容。</p><ol><li><a href="#1-如何判断对象可以被回收">如何判断对象可以回收</a></li><li><a href="#2-垃圾回收算法">垃圾回收算法</a></li><li><a href="#3-分代垃圾回收机制">分代垃圾回收</a></li><li><a href>垃圾回收器</a></li><li><a href>垃圾回收调优</a></li></ol><h3 id="1-如何判断对象可以被回收"><a href="#1-如何判断对象可以被回收" class="headerlink" title="1 如何判断对象可以被回收"></a>1 如何判断对象可以被回收</h3><h4 id="1-1-引用计数法"><a href="#1-1-引用计数法" class="headerlink" title="1.1 引用计数法"></a>1.1 引用计数法</h4><ul><li>只要一个对象被其他变量所引用，那我们就让这个对象的计数 $+1$，如果被引用两次，该计数就为2。</li><li>如果某个变量不再引用这个对象，该对象的引用计数 $-1$。</li><li>当计数为 0 时，表示没有变量引用这个对象了，则可作为垃圾回收掉。</li></ul><p><img src="/2022/03/22/JVM-1/20200608150750 (1).png" alt="20200608150750 (1)" style="zoom:60%;"></p><blockquote><p>弊端：在例如上图的循环引用时，两个对象的计数都为 1，导致两个对象都无法被释放</p></blockquote><h4 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2 可达性分析算法"></a>1.2 可达性分析算法</h4><p>首先先要确定【根对象】。那么什么是根对象呢？就是那些<u>肯定不能被当成垃圾回收的对象</u>。</p><p>在垃圾回收之前，我们先扫描堆内存中的所有对象，检查对象<u>是否被根对象直接或者间接的引用</u>。若是，则不能被回收；反之则可以被回收。</p><ul><li>JVM中的垃圾回收器通过<strong>可达性分析</strong>来探索所有存活的对象</li><li>扫描堆中的对象，看能否沿着 <code>GC Root</code> 对象（根对象）为起点的引用链找到该对象，如果<strong>找不到，则表示可以回收</strong></li></ul><blockquote><p>可以作为 <code>GC Root</code>的对象：</p><ul><li>虚拟机栈（栈帧中的局部变量表）中引用的对象；</li><li>方法区中类静态属性引用的对象；</li><li>方法区中常量引用的对象；</li><li>本地方法栈中JNI（即一般说的 Native方法）引用的对象</li></ul></blockquote><h4 id="1-3-五种引用"><a href="#1-3-五种引用" class="headerlink" title="1.3 五种引用"></a>1.3 五种引用</h4><p><img src="/2022/03/22/JVM-1/20200608150800.png" alt="20200608150800"></p><p>【总结】引用应用垃圾回收 GC 的时机：</p><ol><li>强引用：只有 GC Root <strong>都不引用</strong>该对象时，才会回收<strong>强引用</strong>对象</li><li>软引用：<ul><li><strong>仅有</strong>软引用引用该对象时，在垃圾回收之后，内存仍不足时会再次触发垃圾回收，回收软引用对象</li><li>可以配合引用队列来释放软引用自身</li></ul></li><li>弱引用：<ul><li><strong>只有</strong><u>弱引用</u>引用该对象时，在垃圾回收时，<strong>无论内存是否充足</strong>，都会回收弱引用所引用的对象。</li><li>可以配合引用队列来释放弱引用自身</li></ul></li><li>虚引用：<ul><li>必须配合<strong>引用队列</strong>使用，主要配合 <code>ByteBuffer</code> 使用。</li><li>被引用对象回收时，会讲虚引用入队列，由 <code>Reference Handler</code> 线程调用虚引用的相关方法释放内存。</li></ul></li><li>终结器引用：<ul><li>无需手动编码，但其内部配合引用队列使用。</li><li>在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由 <code>Finalizer</code> 线程通过终结器引用找到被引用对象并调用它的 <code>finalize()</code> 方法，第二次 GC 时才能回收被引用对象</li></ul></li></ol><h5 id="1-3-1-强引用"><a href="#1-3-1-强引用" class="headerlink" title="1.3.1 强引用"></a>1.3.1 强引用</h5><p>如上图，实线箭头表示强引用。日常使用中的引用都属于强引用。例如，<code>new</code> 一个对象，使用 <code>&quot;=&quot;</code> 将该对象赋值给一个变量，那么这个变量就强引用该对象。</p><blockquote><p><strong>垃圾回收的条件：</strong></p><p>只有 GC Root <strong>都不引用</strong>该对象时，才会回收<strong>强引用</strong>对象</p></blockquote><ul><li>如上图 B、C 对象都不引用 A1 对象时，A1 对象才会被回收</li></ul><p>案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoStrongReference</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_4M</span> <span class="operator">=</span> <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 强引用</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_4M]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure><h5 id="1-3-2-软引用-Soft-Reference"><a href="#1-3-2-软引用-Soft-Reference" class="headerlink" title="1.3.2 软引用 (Soft Reference)"></a>1.3.2 软引用 (Soft Reference)</h5><p>使用场景：当内存空间有限时，一些不重要的资源可以用软引用。</p><p>只要 A2、A3 两个对象没有被直接的强引用所引用，当垃圾回收发生时，都有可以被回收。</p><blockquote><p><strong>垃圾回收的条件：</strong></p><p>当 GC Root 指向软引用对象（垃圾回收）时，在<strong>内存不足时</strong>，会<strong>回收软引用所引用的对象</strong>。（先回收一次，如果内存还不够，回收软引用所引用的对象）</p></blockquote><ul><li>如上图如果 B 对象不再引用 A2 对象且内存不足时，软引用所引用的 A2 对象就会被回收</li></ul><p>案例 1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 软引用演示</span></span><br><span class="line"><span class="comment"> * -Xmx20m -XX:+PrintGCDetails -verbose:gc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoSoftReference1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_4M</span> <span class="operator">=</span> <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span></span><br><span class="line">        List&lt;SoftReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 强引用</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">            SoftReference&lt;<span class="type">byte</span>[]&gt; ref= <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[_4M]); <span class="comment">// 软引用</span></span><br><span class="line">            <span class="comment">// List list --强引用--&gt; SoftReference ref --软引用--&gt; byte[_4M]</span></span><br><span class="line">            System.out.println(ref.get());</span><br><span class="line">            list.add(ref);</span><br><span class="line">            System.out.println(list.size());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;循环结束：&quot;</span> + list.size());</span><br><span class="line">        <span class="keyword">for</span> (SoftReference&lt;<span class="type">byte</span>[]&gt; ref : list) &#123;</span><br><span class="line">            System.out.println(ref.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[B@75b84c92</span><br><span class="line">1</span><br><span class="line">[B@6bc7c054</span><br><span class="line">2</span><br><span class="line">[B@232204a1</span><br><span class="line">3</span><br><span class="line">[B@4aa298b7</span><br><span class="line">4</span><br><span class="line">[B@7d4991ad</span><br><span class="line">5</span><br><span class="line">循环结束：5</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">[B@7d4991ad// 只有最后一个数组被保留，上面的都被垃圾回收了</span><br></pre></td></tr></table></figure><p>如果在垃圾回收时发现内存不足，在回收软引用所指向的对象时，<strong>软引用本身不会被清理</strong></p><p>如果想要<strong>清理软引用</strong>，需要使<strong>用引用队列</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoSoftReference2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_4M</span> <span class="operator">=</span> <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用引用队列，用于移除引用为空的软引用对象</span></span><br><span class="line">        ReferenceQueue&lt;<span class="type">byte</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;(); <span class="comment">// 引用队列</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span></span><br><span class="line">        List&lt;SoftReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 强引用</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 关联了引用队列，当软引用所关联的 byte[]被回收时，软引用自自己会加入到 queue 中去</span></span><br><span class="line">            SoftReference&lt;<span class="type">byte</span>[]&gt; ref= <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[_4M], queue); <span class="comment">// 软引用</span></span><br><span class="line">            <span class="comment">// List list --强引用--&gt; SoftReference ref --软引用--&gt; byte[_4M]</span></span><br><span class="line"></span><br><span class="line">            System.out.println(ref.get());</span><br><span class="line">            list.add(ref);</span><br><span class="line">            System.out.println(list.size());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历引用队列，如果有元素，则取出</span></span><br><span class="line">        Reference&lt;? <span class="keyword">extends</span> <span class="title class_">byte</span>[]&gt; poll = queue.poll(); <span class="comment">// poll(), 取出最先放入队列的元素，返回类型Reference</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(poll != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 引用队列不为空，则从集合中移除该元素</span></span><br><span class="line">            list.remove(poll);</span><br><span class="line">            <span class="comment">// 移动到引用队列中的下一个元素</span></span><br><span class="line">            poll = queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;========================&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (SoftReference&lt;<span class="type">byte</span>[]&gt; ref : list) &#123;</span><br><span class="line">            System.out.println(ref.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[B@75b84c92</span><br><span class="line">1</span><br><span class="line">[B@6bc7c054</span><br><span class="line">2</span><br><span class="line">[B@232204a1</span><br><span class="line">3</span><br><span class="line">[B@4aa298b7</span><br><span class="line">4</span><br><span class="line">[B@7d4991ad</span><br><span class="line">5</span><br><span class="line">========================</span><br><span class="line">[B@7d4991ad</span><br></pre></td></tr></table></figure><p><strong>大概思路为：</strong>查看引用队列中有无软引用，如果有，则将该软引用从存放它的集合中移除（这里为一个list集合）</p><h5 id="1-3-3-弱引用-Weak-Referrnce"><a href="#1-3-3-弱引用-Weak-Referrnce" class="headerlink" title="1.3.3 弱引用 (Weak Referrnce)"></a>1.3.3 弱引用 (Weak Referrnce)</h5><blockquote><p><strong>垃圾回收的条件：</strong></p><p>当<strong>只有</strong><u>弱引用</u>引用该对象时，在垃圾回收时，<strong>无论内存是否充足</strong>，都会回收弱引用所引用的对象。</p></blockquote><ul><li>如上图如果B对象不再引用A3对象，则A3对象会被回收</li></ul><p><strong>弱引用的使用和软引用类似</strong>，只是将 <strong>SoftReference 换为了 WeakReference</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoWeakReference1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_4M</span> <span class="operator">=</span> <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">        List&lt;WeakReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 强引用</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">            WeakReference&lt;<span class="type">byte</span>[]&gt; ref= <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[_4M]); <span class="comment">// 软引用</span></span><br><span class="line">            <span class="comment">// List list --强引用--&gt; WeakReference ref --弱引用--&gt; byte[_4M]</span></span><br><span class="line">            list.add(ref);</span><br><span class="line">            <span class="keyword">for</span> (WeakReference&lt;<span class="type">byte</span>[]&gt; weakReference : list) &#123;</span><br><span class="line">                System.out.print(weakReference.get() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;循环结束：&quot;</span> + list.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[B@75b84c92</span><br><span class="line">[B@75b84c92[B@6bc7c054</span><br><span class="line">[B@75b84c92[B@6bc7c054[B@232204a1</span><br><span class="line">[B@75b84c92[B@6bc7c054[B@232204a1[B@4aa298b7</span><br><span class="line">null[B@6bc7c054[B@232204a1[B@4aa298b7[B@7d4991ad</span><br><span class="line">null[B@6bc7c054[B@232204a1[B@4aa298b7null[B@28d93b30</span><br><span class="line">循环结束：6</span><br></pre></td></tr></table></figure><h5 id="1-3-4-虚引用-Phantom-Reference"><a href="#1-3-4-虚引用-Phantom-Reference" class="headerlink" title="1.3.4 虚引用 (Phantom Reference)"></a>1.3.4 虚引用 (Phantom Reference)</h5><p>必须配合<strong>引用队列</strong>一同使用。当虚（终结器）引用被创建时，会<u>关联一个引用队列</u>。</p><blockquote><ul><li>当虚引用对象所引用的对象被回收以后，虚引用对象就会被放入引用队列中，调用虚引用的方法</li><li>虚引用的一个体现是<strong>释放直接内存所分配的内存</strong>，当引用的对象 <code>ByteBuffer</code> 被垃圾回收以后，虚引用对象 <code>Cleaner</code> 就会被放入引用队列中，然后调用 <code>Cleaner</code> 的 <code>clean()</code> 方法来释放直接内存</li></ul></blockquote><ul><li>如上图，B 对象不再引用 <code>ByteBuffer</code> 对象，<code>ByteBuffer</code> 就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象 <code>Cleaner</code> 放入引用队列中，然后调用它的 <code>clean()</code> 方法来释放直接内存</li></ul><h5 id="1-3-5-终结器引用-Finalize-Reference"><a href="#1-3-5-终结器引用-Finalize-Reference" class="headerlink" title="1.3.5 终结器引用 (Finalize Reference)"></a>1.3.5 终结器引用 (Finalize Reference)</h5><p>所有的对象都继承自 <code>Object</code> 类，<code>Object</code> 类有一个 <code>finalize()</code> 方法。</p><blockquote><p>当某个对象不再被其他的对象所引用时，会先将终结器引用对象放入引用队列中（处理这个引用队列的<em>FinalizeHandler 线程</em> 优先级很低），然后根据终结器引用对象找到它所引用的对象，然后调用该对象的 <code>finalize()</code> 方法。调用以后，该对象就可以被垃圾回收了。</p></blockquote><ul><li>如上图，B对象不再引用A4对象。这是终结器对象就会被放入引用队列中，引用队列会根据它，找到它所引用的对象。然后调用被引用对象的finalize()方法。调用以后，该对象就可以被垃圾回收了</li></ul><h3 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2 垃圾回收算法"></a>2 垃圾回收算法</h3><h4 id="2-1-标记-清除-算法-Mark-Sweep"><a href="#2-1-标记-清除-算法-Mark-Sweep" class="headerlink" title="2.1 标记 - 清除 算法 (Mark - Sweep)"></a>2.1 标记 - 清除 算法 (Mark - Sweep)</h4><p><img src="/2022/03/22/JVM-1/20200608150813.png" alt="20200608150813" style="zoom:50%;"></p><p><strong>定义</strong>：标记清除算法顾名思义，是指在虚拟机执行垃圾回收的过程中，先<u>采用标记算法确定可回收对象</u>（图中为没有GC Root引用的块），然后<u>垃圾收集器根据标识清除相应的内容</u>，给堆内存腾出相应的空间。</p><ul><li>这里的腾出内存空间并不是将内存空间的字节清零，而是记录下这段内存的起始结束地址，下次分配内存的时候，会直接<strong>覆盖</strong>这段内存。同理于操作系统中的内存管理</li></ul><blockquote><p><strong>优点</strong>：垃圾回收速度快</p><p><strong>缺点</strong>：<strong>容易产生大量的内存碎片</strong>，可能无法满足大对象的内存分配，一旦导致无法分配对象，那就会导致 <code>JVM</code> 启动 GC，一旦启动 GC，我们的应用程序就会暂停，这就导致应用的响应速度变慢。同理于操作系统中的内存碎片。</p></blockquote><h4 id="2-2-标记-整理-算法-Mark-Compact"><a href="#2-2-标记-整理-算法-Mark-Compact" class="headerlink" title="2.2 标记 - 整理 算法 (Mark - Compact)"></a>2.2 标记 - 整理 算法 (Mark - Compact)</h4><p><img src="/2022/03/22/JVM-1/20200608150827.png" alt="20200608150827"></p><p><strong>标记-整理</strong> 会将不被 GC Root 引用的对象回收，清理其占用的内存空间。然后整理剩余的对象（将其地址向前移动，使内存更为紧凑，连续空间更多）.</p><blockquote><p>优点：可以<strong>有效避免因内存碎片而导致的问题</strong></p><p>缺点：但是因为整体需要消耗一定的时间，所以<strong>效率较低</strong></p></blockquote><h4 id="2-3-复制-算法-Copy"><a href="#2-3-复制-算法-Copy" class="headerlink" title="2.3 复制 算法 (Copy)"></a>2.3 复制 算法 (Copy)</h4><p>将内存分为等大小的两个区域，<code>FROM</code> 和 <code>TO</code>（其中 <code>TO</code> 中是空闲的）。</p><p>先将被 GC Root 引用的对象从 <code>FROM</code> 复制到 <code>TO</code> 中，再回收不被 GC Root 引用的对象。然后交换 <code>FROM</code> 和<code>TO</code>。</p><ol><li>如下图，先采用标记算法确定可回收对象（图中为没有 GC Root 引用的块）</li></ol><p><img src="/2022/03/22/JVM-1/20200608150842.png" alt="20200608150842" style="zoom:75%;"></p><ol><li>将 <code>FROM</code> 区域中存活的对象复制到 <code>TO</code> 区域</li></ol><p><img src="/2022/03/22/JVM-1/20200608150856.png" alt="20200608150856" style="zoom:75%;"></p><ol><li>此时由于 <code>FROM</code> 区域中全是垃圾，全部清空</li></ol><p><img src="/2022/03/22/JVM-1/20200608150907.png" alt="20200608150907" style="zoom:75%;"></p><ol><li>交换 <code>FROM</code> 区域 和 <code>TO</code> 区域 的位置</li></ol><p><img src="/2022/03/22/JVM-1/20200608150919.png" alt="20200608150919" style="zoom:75%;"></p><blockquote><p>优点：可以避免内存碎片的问题</p><p>缺点：但是会<strong>占用双倍的内存空间</strong>。</p></blockquote><h4 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4 总结"></a>2.4 总结</h4><ol><li>标记 - 清除 算法 (Mark - Sweep)<ul><li><strong>优点</strong>：垃圾回收速度快</li><li><strong>缺点</strong>：<strong>容易产生大量的内存碎片</strong></li></ul></li><li>标记 - 整理 算法 (Mark - Compact)<ul><li>优点：可以<strong>有效避免因内存碎片而导致的问题</strong></li><li>缺点：但是因为整体需要消耗一定的时间，所以<strong>效率较低</strong></li></ul></li><li>复制 算法 (Copy)<ul><li>优点：可以避免内存碎片的问题</li><li>缺点：但是会<strong>占用双倍的内存空间</strong>。</li></ul></li></ol><h3 id="3-分代垃圾回收机制"><a href="#3-分代垃圾回收机制" class="headerlink" title="3 分代垃圾回收机制"></a>3 分代垃圾回收机制</h3><p><img src="/2022/03/22/JVM-1/20200608150931.png" alt="20200608150931"></p><p>如上图，我们将堆内存划分成两个部分，一个是左边的 <em>YoungGeneration</em> 新生代 (新生代又分为【伊甸园 Eden】、【幸存区 FROM】和【幸存区 TO】三个部分)，另一个是老年代 <em>OldGeneration</em>。</p><p>Java 中，<u>长时间使用的对象放在老年代中</u>，<u>用完就可以丢弃的对象放在新生代中</u>。这样就可以根据对象的存活时间的不同特点进行不用的回收策略。<u>老年代中的垃圾回收很久发生一次</u>，而<u>新生代中回收更频繁</u>。</p><h4 id="3-1-分代回收流程"><a href="#3-1-分代回收流程" class="headerlink" title="3.1 分代回收流程"></a>3.1 分代回收流程</h4><blockquote><p>简要流程：</p><ol><li>对象首先分配在伊甸园区域；</li><li>新生代空间不足时，触发 Minor GC，伊甸园和 FROM 存活的对象使用 copy 复制到 TO 中，存活的对象年龄加 1，并且交换 FROM 和 TO；</li><li>当幸存区中的对象的<strong>寿命超过阈值</strong>（最大为15，4bit），就会<strong>晋升到老年代</strong>中；</li><li>如果新生代中的内存空间不足时，先触发 Minor GC；垃圾回收后发现新生代中的内存空间仍然不足，且老年代中的内存空间也不足，再触发 <strong>Full GC</strong> (整体清理)；</li><li>内存分配失败，触发 <code>java.lang.OutOfMemoryError</code>。</li></ol></blockquote><p>【流程图解】</p><p>1、新创建的对象都被放在了<strong>新生代的伊甸园</strong>中，伊甸园逐渐就会被占满。</p><p><img src="/2022/03/22/JVM-1/20200608150939.png" alt="20200608150939"></p><p><img src="/2022/03/22/JVM-1/20200608150946.png" alt="20200608150946"></p><p>2、当伊甸园中的内存不足时，就会进行一次垃圾回收，这时<u>新生代的垃圾回收叫做 <strong>Minor GC</strong></u></p><p>​    (1) Minor GC 触发后，采用“可达性分析算法”，沿着以 GC Root 对象（根对象）为起点的引用链，采用“标记算法”确定可回收对象；</p><p>​    (2) 标记完成后，采用“复制算法”将<strong><u>伊甸园</u>和<u>幸存区 FROM</u></strong> 存活的对象<strong>先</strong>复制到<strong><u>幸存区 TO</u></strong> 中， 并让其<strong>寿命$+1$</strong>；</p><p><img src="/2022/03/22/JVM-1/20200608150955.png" alt="20200608150955"></p><p>​    (3) 根据复制算法，我们将交换<u>幸存区 FROM</u> 和<u>幸存区 TO</u> 的位置</p><p><img src="/2022/03/22/JVM-1/20200608151002.png" alt="20200608151002"></p><p>3、再次创建对象，若新生代的伊甸园又满了，则会<strong>再次触发 Minor GC</strong>（会触发 <strong>“Stop the world”</strong>， 暂停其他用户线程，只让垃圾回收线程工作）；</p><p>这时不仅会回收伊甸园中的垃圾，<strong>还会回收幸存区中的垃圾</strong>，再将活跃对象复制到<u>幸存区 TO</u> 中；</p><p>回收以后会交换两个幸存区，并让幸存区中的对象<strong>寿命加1</strong></p><p><img src="/2022/03/22/JVM-1/20200608151010.png" alt="20200608151010"></p><p>4、如此反复。如果幸存区中的对象的<strong>寿命超过某个阈值</strong>（最大为15，4bit），就会<strong>晋升到老年代</strong>中</p><p><img src="/2022/03/22/JVM-1/20200608151018.png" alt="20200608151018"></p><p>5、如果新生代中的内存空间不足时，先触发 Minor GC；垃圾回收后发现新生代中的内存空间仍然不足，且老年代中的内存空间也不足，再触发 <strong>Full GC</strong> (整体清理)，也会触发“Stop the world”，时间更长，以扫描<strong>新生代和老年代中</strong>所有不再使用的对象并回收</p><p>6、如果老年代的内存也不够，内存分配失败，触发 <code>java.lang.OutOfMemoryError</code>。</p><p><img src="/2022/03/22/JVM-1/IMG_FB5339E468EB-1.jpeg" alt="IMG_FB5339E468EB-1"></p><h4 id="3-2-相关虚拟机参数"><a href="#3-2-相关虚拟机参数" class="headerlink" title="3.2 相关虚拟机参数"></a>3.2 相关虚拟机参数</h4><div class="table-container"><table><thead><tr><th style="text-align:left">含义</th><th style="text-align:left">参数</th></tr></thead><tbody><tr><td style="text-align:left">堆初始大小</td><td style="text-align:left"><code>-Xms</code></td></tr><tr><td style="text-align:left">堆最大大小</td><td style="text-align:left"><code>-Xmx</code> 或 <code>-XX:MaxHeapSize=size</code></td></tr><tr><td style="text-align:left">新生代大小</td><td style="text-align:left"><code>-Xmn</code> 或 <code>-XX:NewSize=size + XX:MaxNewSize=size</code></td></tr><tr><td style="text-align:left">幸存区比例（动态）</td><td style="text-align:left"><code>-XX:InitialSurvivorRatio=ratio</code> 和 <code>-XX:+UseAdaptiveSizePolicy</code></td></tr><tr><td style="text-align:left">幸存区比例</td><td style="text-align:left"><code>-XX:SurvivorRatio=ratio</code></td></tr><tr><td style="text-align:left">晋升阈值</td><td style="text-align:left"><code>-XX:MaxTenuringThreshold=threshold</code></td></tr><tr><td style="text-align:left">晋升详情</td><td style="text-align:left"><code>-XX:+PrintTenuringDistribution</code></td></tr><tr><td style="text-align:left">GC 详情</td><td style="text-align:left"><code>-XX:+PrintGCDetails -verbose:gc</code></td></tr><tr><td style="text-align:left">在 FullGC 前执行 MinorGC</td><td style="text-align:left"><code>-XX:+ScavengeBeforeFullGC</code></td></tr></tbody></table></div><h4 id="3-3-GC分析"><a href="#3-3-GC分析" class="headerlink" title="3.3  GC分析"></a>3.3  GC分析</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 1505K [0x00000007be800000, 0x00000007bf200000, 0x00000007bf200000)</span><br><span class="line">  eden space 8192K,  18% used [0x00000007be800000, 0x00000007be9786f8, 0x00000007bf000000)</span><br><span class="line">  from space 1024K,   0% used [0x00000007bf000000, 0x00000007bf000000, 0x00000007bf100000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000007bf100000, 0x00000007bf100000, 0x00000007bf200000)</span><br><span class="line"> tenured generation   total 14336K, used 0K [0x00000007bf200000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line">   the space 14336K,   0% used [0x00000007bf200000, 0x00000007bf200000, 0x00000007bf200200, 0x00000007c0000000)</span><br><span class="line"> Metaspace       used 3132K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 341K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure><p>垃圾回收信息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: 1333K-&gt;331K(9216K), 0.0003968 secs] 1333K-&gt;331K(23552K), 0.0004083 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br></pre></td></tr></table></figure><ul><li><code>GC</code> 表示是新生代的 <code>MinorGC</code>；<code>FullGC</code> 表示是老年代的垃圾回收</li><li><code>DefNew</code> 表示垃圾回收发生在新生代，<code>xxx -&gt; xxx</code> 表示回收之前的占用和回收之后的占用</li></ul><p>案例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_512K</span> <span class="operator">=</span> <span class="number">512</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1M</span> <span class="operator">=</span>  <span class="number">1</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_5M</span> <span class="operator">=</span>  <span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_6M</span> <span class="operator">=</span>  <span class="number">6</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_7M</span> <span class="operator">=</span>  <span class="number">7</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_7M]);</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_512K]);</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_512K]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: 1508K-&gt;366K(9216K), 0.0006691 secs] 1508K-&gt;366K(23552K), 0.0006841 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [DefNew: 8210K-&gt;876K(9216K), 0.0012508 secs] 8210K-&gt;8044K(23552K), 0.0012588 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 1716K [0x00000007be800000, 0x00000007bf200000, 0x00000007bf200000)</span><br><span class="line">  eden space 8192K,  10% used [0x00000007be800000, 0x00000007be8d1eb8, 0x00000007bf000000)</span><br><span class="line">  from space 1024K,  85% used [0x00000007bf000000, 0x00000007bf0db1e8, 0x00000007bf100000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000007bf100000, 0x00000007bf100000, 0x00000007bf200000)</span><br><span class="line"> tenured generation   total 14336K, used 7168K [0x00000007bf200000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line">   the space 14336K,  50% used [0x00000007bf200000, 0x00000007bf900010, 0x00000007bf900200, 0x00000007c0000000)</span><br><span class="line"> Metaspace       used 3199K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 352K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure><h5 id="3-3-1-大对象处理策略"><a href="#3-3-1-大对象处理策略" class="headerlink" title="3.3.1 大对象处理策略"></a>3.3.1 大对象处理策略</h5><p>当遇到一个<strong>较大的对象</strong>时，就算新生代的<strong>伊甸园</strong>为空，也<strong>无法容纳该对象</strong>时，会将该对象<strong>直接晋升为老年代</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_8M</span> <span class="operator">=</span>  <span class="number">8</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_8M]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 1497K [0x00000007be800000, 0x00000007bf200000, 0x00000007bf200000)</span><br><span class="line">  eden space 8192K,  18% used [0x00000007be800000, 0x00000007be9766e8, 0x00000007bf000000)</span><br><span class="line">  from space 1024K,   0% used [0x00000007bf000000, 0x00000007bf000000, 0x00000007bf100000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000007bf100000, 0x00000007bf100000, 0x00000007bf200000)</span><br><span class="line"> tenured generation   total 14336K, used 8192K [0x00000007bf200000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line">   the space 14336K,  57% used [0x00000007bf200000, 0x00000007bfa00010, 0x00000007bfa00200, 0x00000007c0000000)</span><br><span class="line"> Metaspace       used 3106K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 333K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure><h5 id="3-3-2-线程内存溢出"><a href="#3-3-2-线程内存溢出" class="headerlink" title="3.3.2 线程内存溢出"></a>3.3.2 线程内存溢出</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_8M</span> <span class="operator">=</span>  <span class="number">8</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            ArrayList&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_8M]);</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_8M]);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;sleep...&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sleep...</span><br><span class="line">[GC (Allocation Failure) [DefNew: 3683K-&gt;572K(9216K), 0.0010077 secs][Tenured: 8192K-&gt;8762K(14336K), 0.0015132 secs] 11875K-&gt;8762K(23552K), [Metaspace: 4106K-&gt;4106K(1056768K)], 0.0025433 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (Allocation Failure) [Tenured: 8762K-&gt;8707K(14336K), 0.0012168 secs] 8762K-&gt;8707K(23552K), [Metaspace: 4106K-&gt;4106K(1056768K)], 0.0012369 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">Exception in thread &quot;Thread-0&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">at GC_Analyse.Demo.lambda$main$0(Demo.java:17)</span><br><span class="line">at GC_Analyse.Demo$$Lambda$1/455659002.run(Unknown Source)</span><br><span class="line">at java.lang.Thread.run(Thread.java:750)</span><br><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 383K [0x00000007be800000, 0x00000007bf200000, 0x00000007bf200000)</span><br><span class="line">  eden space 8192K,   4% used [0x00000007be800000, 0x00000007be85fc28, 0x00000007bf000000)</span><br><span class="line">  from space 1024K,   0% used [0x00000007bf100000, 0x00000007bf100000, 0x00000007bf200000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000007bf000000, 0x00000007bf000000, 0x00000007bf100000)</span><br><span class="line"> tenured generation   total 14336K, used 8707K [0x00000007bf200000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line">   the space 14336K,  60% used [0x00000007bf200000, 0x00000007bfa80c48, 0x00000007bfa80e00, 0x00000007c0000000)</span><br><span class="line"> Metaspace       used 4133K, capacity 4676K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 461K, capacity 496K, committed 512K, reserved 1048576K</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>某个线程的内存溢出了而抛异常 (<code>java.lang.OutOfMemoryError</code>)，不会让其他的线程结束运行，原因如下：</p><ul><li>当一个线程<strong>抛出 <code>OutOfMemoryError</code> 异常后</strong>，<strong>它所占据的内存资源会全部被释放掉</strong>，从而不会影响其他线程的运行，<strong>其他进程依然正常</strong></li></ul><h3 id="4-垃圾回收器"><a href="#4-垃圾回收器" class="headerlink" title="4 垃圾回收器"></a>4 垃圾回收器</h3><h4 id="4-0-概述"><a href="#4-0-概述" class="headerlink" title="4.0 概述"></a>4.0 概述</h4><ol><li>串行垃圾回收器<ul><li>实质是一个单线程的垃圾回收器</li><li>使用场景：堆内存较小，适合个人电脑</li></ul></li><li>吞吐量优先垃圾回收器<ul><li>多线程</li><li>使用场景：堆内存较大，多核 CPU 支持</li><li>在单位时间内，STW 的时间最短。例如，在一小时内，垃圾回收了 2 次，总时长是 0.2 + 0.1 秒</li></ul></li><li>响应时间优先垃圾回收器<ul><li>多线程</li><li>使用场景：堆内存较大，多核 CPU 支持</li><li>垃圾清理（STW）的单次时间尽可能最短</li></ul></li></ol><h4 id="4-1-串行垃圾回收器"><a href="#4-1-串行垃圾回收器" class="headerlink" title="4.1 串行垃圾回收器"></a>4.1 串行垃圾回收器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseSerialGC=Serial+SerialOld // 新生代copy算法，老年代 标记整理</span><br></pre></td></tr></table></figure><p><img src="/2022/03/22/JVM-1/image-20220818231033690.png" alt="image-20220818231033690" style="zoom:50%;"></p><h4 id="4-2-吞吐量优先垃圾回收器"><a href="#4-2-吞吐量优先垃圾回收器" class="headerlink" title="4.2 吞吐量优先垃圾回收器"></a>4.2 吞吐量优先垃圾回收器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC -XX:+UseParallelOldGC</span><br><span class="line">-XX:ParallelGCThreads=n // 设置垃圾回收线程数</span><br><span class="line">-XX:+UseAdaptiveSizePolicy // 自适应调整</span><br><span class="line">-XX:GCTimeRatio=ratio // 调整垃圾回收时间与总时间的占比: 1/(1+ratio)</span><br><span class="line">-XX:MaxGCPauseMillis=ms // 最大暂停时间(毫秒)</span><br></pre></td></tr></table></figure><p><img src="/2022/03/22/JVM-1/image-20220818231641184.png" alt="image-20220818231641184" style="zoom:50%;"></p><h4 id="4-3-响应时间优先垃圾回收器"><a href="#4-3-响应时间优先垃圾回收器" class="headerlink" title="4.3 响应时间优先垃圾回收器"></a>4.3 响应时间优先垃圾回收器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseConcMarkSweepGC ~ -XX:+UseParNewGC ~ SerialOld</span><br><span class="line">-XX:ParallelGCThreads=n ~ -XX:ConcGCThreads=threads</span><br><span class="line">-XX:CMSInitiatingOccupancyFraction=percent</span><br><span class="line">-XX:+CMSScavengeBeforeRemark</span><br></pre></td></tr></table></figure><p><img src="/2022/03/22/JVM-1/image-20220818235606862.png" alt="image-20220818235606862" style="zoom:50%;"></p><h4 id="4-4-G1-Garbage-First-垃圾回收器"><a href="#4-4-G1-Garbage-First-垃圾回收器" class="headerlink" title="4.4 G1 (Garbage First) 垃圾回收器"></a>4.4 G1 (Garbage First) 垃圾回收器</h4><p>JDK 1.9 之后代替 <code>CMS</code> 回收器，成为默认的垃圾回收器。</p><p>【适用场景】</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseG1GC</span><br></pre></td></tr></table></figure><ul><li><p>同时注重吞吐量 (Throughput) 和低延迟 (Low latency)，默认的暂停目标是 200 ms</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxGCPauseMillis=time</span><br></pre></td></tr></table></figure></li><li><p>超大堆内存，会将堆划分为多个大小相等的 <code>Region</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:G1HeapRegionSize=size // size = 2^n</span><br></pre></td></tr></table></figure></li><li><p>整体上是<u>标记整理</u>算法，两个区域之间是<u>复制</u></p></li></ul><h5 id="4-4-1-G1-垃圾回收阶段"><a href="#4-4-1-G1-垃圾回收阶段" class="headerlink" title="4.4.1 G1 垃圾回收阶段"></a>4.4.1 G1 垃圾回收阶段</h5><p><img src="/2022/03/22/JVM-1/image-20220819112113472.png" alt="image-20220819112113472" style="zoom:50%;"></p><h5 id="4-4-2-Young-Collection"><a href="#4-4-2-Young-Collection" class="headerlink" title="4.4.2 Young Collection"></a>4.4.2 Young Collection</h5><p>首先，G1 垃圾回收器会将堆内存 (Heap) 分成若干个大小相等的区域 (Region)，也就是说，<u>Region 是 G1 操作时的单位</u>。</p><p><img src="/2022/03/22/JVM-1/image-20220819113509917.png" alt="image-20220819113509917" style="zoom: 45%;"></p><p>当一个为<strong><em><u>伊甸园 E</u></em></strong> 的 Region 被占满时，使用<u>拷贝</u>算法将非垃圾对象放入<strong><em><u>幸存区 S</u></em></strong>，如下图</p><p><img src="/2022/03/22/JVM-1/image-20220819114148727.png" alt="image-20220819114148727" style="zoom:45%;"></p><p>继续运行一段时间，当：</p><ul><li><strong><em><u>幸存区 S</u></em></strong> 中的对象年龄到达可以晋升<strong><em><u>老年代 O</u></em></strong> 的阈值时；</li><li>或<strong><em><u>幸存区 S</u></em></strong> 的空间不足时</li></ul><p><img src="/2022/03/22/JVM-1/image-20220819114932406.png" alt="image-20220819114932406" style="zoom:45%;"></p><h5 id="4-4-3-Young-Collection-Concurrent-Mark"><a href="#4-4-3-Young-Collection-Concurrent-Mark" class="headerlink" title="4.4.3 Young Collection + Concurrent Mark"></a>4.4.3 Young Collection + Concurrent Mark</h5><ul><li><p>在 <code>Young GC</code> 时会进行 <code>GC Root</code> 的<strong><em><u>初始标记</u></em></strong></p></li><li><p>老年代占用堆空间比例达到阈值时，进行<strong><em><u>并发标记</u></em></strong> （不会 STW），由下面的 <code>JVM</code> 参数决定</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:InitiatingHeapOccupancyPercent=percent （默认45%）</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2022/03/22/JVM-1/image-20220819120000627.png" alt="image-20220819120000627" style="zoom:45%;"></p><h5 id="4-4-4-Mixed-Collection"><a href="#4-4-4-Mixed-Collection" class="headerlink" title="4.4.4 Mixed Collection"></a>4.4.4 Mixed Collection</h5><p>会对<strong><em><u>伊甸园 E</u></em></strong>、<strong><em><u>幸存区 S</u></em></strong>、<strong><em><u>老年代 O</u></em></strong> 进行全面垃圾回收：</p><ul><li><p><strong><em><u>最终标记 (重新标记 Remark)</u></em></strong> 会 STW</p></li><li><p><strong><em><u>拷贝存活 (Evacuation)</u></em></strong> 会 STW</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX: MaxGCPauseMillis=ms</span><br></pre></td></tr></table></figure></li></ul><p><img src="/2022/03/22/JVM-1/image-20220819122114517.png" alt="image-20220819122114517" style="zoom:45%;"></p><p>如上图所示，对于<strong><em><u>伊甸园 E</u></em></strong> 和<strong><em><u>幸存区 S</u></em></strong> 的垃圾回收与之前一样：</p><ul><li><strong><em><u>伊甸园 E</u></em></strong> 被占满时，使用<u>拷贝</u>算法将非垃圾对象放入<strong><em><u>幸存区 S</u></em></strong>；</li><li><strong><em><u>幸存区 S</u></em></strong> 中的对象年龄到达可以晋升<strong><em><u>老年代 O</u></em></strong> 的阈值时，将其放入<strong><em><u>老年代 O</u></em></strong> ；</li><li><strong><em><u>幸存区 S</u></em></strong> 的空间不足时，复制存活的对象到<strong><em><u>另一个幸存区 S</u></em></strong> 中。</li></ul><p>对于<strong><em><u>老年代 O</u></em></strong>，我是使用一系列的算法，在最大暂停时间 <code>MaxGCPauseMillis</code> 内，来筛选“有价值”的存活对象，复制到<strong><em><u>另一个老年代 O</u></em></strong> 中。</p><p>那么，什么是“有价值”的存活对象呢？</p><p>个人理解是在空间不足的<strong><em><u>老年代 O</u></em></strong> 中，挑选出那些<u>可以在最大暂停时间 <code>MaxGCPauseMillis</code> 内完成复制的存活对象后</u>，并且该<strong><em><u>老年代 O</u></em></strong> 可以最大程度上的被回收，从而尽可能多的释放空间。我们将那些存活对象复制到<strong><em><u>另一个老年代 O</u></em></strong> 中。从 Region 的角度考虑，就是优先回收垃圾最多的 Region。</p><h5 id="4-4-5-Full-GC"><a href="#4-4-5-Full-GC" class="headerlink" title="4.4.5 Full GC"></a>4.4.5 Full GC</h5><ul><li>串行垃圾回收器<ul><li>新生代内存不足时发生的垃圾收集：Minor GC</li><li>老年代内存不足时发生的垃圾收集：Full GC</li></ul></li><li>并行垃圾回收器<ul><li>新生代内存不足时发生的垃圾收集：Minor GC</li><li>老年代内存不足时发生的垃圾收集：Full GC</li></ul></li><li>并发垃圾回收器 CMS<ul><li>新生代内存不足时发生的垃圾收集：Minor GC</li><li>老年代内存不足时发生的垃圾收集：触发并发垃圾回收</li></ul></li><li>G1 垃圾回收器<ul><li>新生代内存不足时发生的垃圾收集：Minor GC</li><li>老年代内存不足时发生的垃圾收集：老年代占用堆空间比例达到阈值时，进行<strong><em><u>并发标记</u></em></strong> （不会 STW），并进入到 Mixed Collection 阶段。当产生垃圾的速度大于垃圾收集的速度，触发 Full GC。</li></ul></li></ul><h5 id="4-4-6-Young-Collection-的跨代引用问题"><a href="#4-4-6-Young-Collection-的跨代引用问题" class="headerlink" title="4.4.6 Young Collection 的跨代引用问题"></a>4.4.6 Young Collection 的跨代引用问题</h5><p>持续更新中。。。</p><h2 id="四、类加载与字节码技术"><a href="#四、类加载与字节码技术" class="headerlink" title="四、类加载与字节码技术"></a>四、类加载与字节码技术</h2><h3 id="0-主要内容大纲-1"><a href="#0-主要内容大纲-1" class="headerlink" title="0 主要内容大纲"></a>0 主要内容大纲</h3><blockquote><p>提示：本章节可与 <a href="https://github.com/Dave0126/S8_2A_SN_ENSEEIHT/tree/master/UE - Sémantique et Traduction des Langages/Sémantique et Traduction des Langages">“ Sémantique et Traduction des Langages “</a> 结合理解</p></blockquote><ol><li><a href="#1-类文件结构">类文件结构</a></li><li><a href="#2-字节码指令">字节码指令</a></li><li><a href="#3-编译期处理">编译期处理</a></li><li><a href>类加载阶段</a></li><li><a href>类加载器</a></li><li><a href>运行期优化</a></li></ol><p><img src="/2022/03/22/JVM-1/image-20220819161019323.png" alt="image-20220819161019323" style="zoom:50%;"></p><h3 id="1-类文件结构"><a href="#1-类文件结构" class="headerlink" title="1 类文件结构"></a>1 类文件结构</h3><p><a href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">参考文献：Oracle JDK 1.8 官方文档</a></p><p>我们以 <code>HelloWorld.java</code> 文件为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ClassFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoHelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -parameters -d src/main/java/ClassFile/DemoHelloWorld.java</span><br></pre></td></tr></table></figure><p>编译后的 <code>DemoHelloWorld.class</code> 是这样的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">od -t xC ClassFile/DemoHelloWorld.class </span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 标号内容</span><br><span class="line">0000000    ca  fe  ba  be  00  00  00  3b  00  1f  0a  00  02  00  03  07</span><br><span class="line">0000020    00  04  0c  00  05  00  06  01  00  10  6a  61  76  61  2f  6c</span><br><span class="line">0000040    61  6e  67  2f  4f  62  6a  65  63  74  01  00  06  3c  69  6e</span><br><span class="line">0000060    69  74  3e  01  00  03  28  29  56  09  00  08  00  09  07  00</span><br><span class="line">0000100    0a  0c  00  0b  00  0c  01  00  10  6a  61  76  61  2f  6c  61</span><br><span class="line">0000120    6e  67  2f  53  79  73  74  65  6d  01  00  03  6f  75  74  01</span><br><span class="line">0000140    00  15  4c  6a  61  76  61  2f  69  6f  2f  50  72  69  6e  74</span><br><span class="line">0000160    53  74  72  65  61  6d  3b  08  00  0e  01  00  0c  48  65  6c</span><br><span class="line">0000200    6c  6f  20  57  6f  72  6c  64  21  0a  00  10  00  11  07  00</span><br><span class="line">0000220    12  0c  00  13  00  14  01  00  13  6a  61  76  61  2f  69  6f</span><br><span class="line">0000240    2f  50  72  69  6e  74  53  74  72  65  61  6d  01  00  07  70</span><br><span class="line">0000260    72  69  6e  74  6c  6e  01  00  15  28  4c  6a  61  76  61  2f</span><br><span class="line">0000300    6c  61  6e  67  2f  53  74  72  69  6e  67  3b  29  56  07  00</span><br><span class="line">0000320    16  01  00  18  43  6c  61  73  73  46  69  6c  65  2f  44  65</span><br><span class="line">0000340    6d  6f  48  65  6c  6c  6f  57  6f  72  6c  64  01  00  04  43</span><br><span class="line">0000360    6f  64  65  01  00  0f  4c  69  6e  65  4e  75  6d  62  65  72</span><br><span class="line">0000400    54  61  62  6c  65  01  00  04  6d  61  69  6e  01  00  16  28</span><br><span class="line">0000420    5b  4c  6a  61  76  61  2f  6c  61  6e  67  2f  53  74  72  69</span><br><span class="line">0000440    6e  67  3b  29  56  01  00  10  4d  65  74  68  6f  64  50  61</span><br><span class="line">0000460    72  61  6d  65  74  65  72  73  01  00  04  61  72  67  73  01</span><br><span class="line">0000500    00  0a  53  6f  75  72  63  65  46  69  6c  65  01  00  13  44</span><br><span class="line">0000520    65  6d  6f  48  65  6c  6c  6f  57  6f  72  6c  64  2e  6a  61</span><br><span class="line">0000540    76  61  00  21  00  15  00  02  00  00  00  00  00  02  00  01</span><br><span class="line">0000560    00  05  00  06  00  01  00  17  00  00  00  1d  00  01  00  01</span><br><span class="line">0000600    00  00  00  05  2a  b7  00  01  b1  00  00  00  01  00  18  00</span><br><span class="line">0000620    00  00  06  00  01  00  00  00  03  00  09  00  19  00  1a  00</span><br><span class="line">0000640    02  00  17  00  00  00  25  00  02  00  01  00  00  00  09  b2</span><br><span class="line">0000660    00  07  12  0d  b6  00  0f  b1  00  00  00  01  00  18  00  00</span><br><span class="line">0000700    00  0a  00  02  00  00  00  05  00  08  00  06  00  1b  00  00</span><br><span class="line">0000720    00  05  01  00  1c  00  00  00  01  00  1d  00  00  00  02  00</span><br><span class="line">0000740    1e                                                            </span><br><span class="line">0000741</span><br></pre></td></tr></table></figure><p>根据 JVM 规范，类文件的结构如下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">  u4magic;</span><br><span class="line">  u2minor_version;</span><br><span class="line">  u2major_version;</span><br><span class="line">  u2constant_pool_count;</span><br><span class="line">  cp_infoconstant_pool[constant_pool_count - <span class="number">1</span>];</span><br><span class="line">  u2access_flags;</span><br><span class="line">  u2this_class;</span><br><span class="line">  u2super_class;</span><br><span class="line">  u2interfaces_count;</span><br><span class="line">  u2interfaces[interfaces_count];</span><br><span class="line">  u2fields_count;</span><br><span class="line">  field_infofield[fields_count];</span><br><span class="line">  u2methods_count;</span><br><span class="line">  method_infomethods[methods_count];</span><br><span class="line">  u2attributes_count;</span><br><span class="line">  attribute_infoattributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示意图如下：</p><p><img src="/2022/03/22/JVM-1/1-1001259.png" alt="1" style="zoom:67%;"></p><h4 id="1-1-魔数-Magic"><a href="#1-1-魔数-Magic" class="headerlink" title="1.1 魔数 Magic"></a>1.1 魔数 Magic</h4><ul><li><code>前四个字节 (0~3)</code>，表示该文件是否是 <code>.class</code> 类型的文件</li></ul><blockquote><p>0000000    <font color="red">ca fe ba be</font>  00  00  00  3b  00  1f  0a  00  02  00  03  07</p></blockquote><h4 id="1-2-版本-Version"><a href="#1-2-版本-Version" class="headerlink" title="1.2 版本 Version"></a>1.2 版本 Version</h4><ul><li><code>4~7 个字节</code>，表示类的版本 (<code>minor_version + major_version</code>)。 <code>00 3b</code> 表示 JDK 15。</li></ul><blockquote><p>0000000    ca  fe  ba  be  <font color="red">00  00  00  3b</font>  00  1f  0a  00  02  00  03  07</p></blockquote><h4 id="1-3-常量池-Constant-Pool"><a href="#1-3-常量池-Constant-Pool" class="headerlink" title="1.3 常量池 Constant Pool"></a>1.3 常量池 Constant Pool</h4><div class="table-container"><table><thead><tr><th style="text-align:left">Constant Type (Bytes)</th><th style="text-align:center">Value (hex)</th></tr></thead><tbody><tr><td style="text-align:left"><code>CONSTANT_Class(1B): 引用索引(2B)</code></td><td style="text-align:center"><code>07</code></td></tr><tr><td style="text-align:left"><code>CONSTANT_Filedref(1B): CONSTANT_Class(2B) + CONSTANT_NameAndType(2B)</code></td><td style="text-align:center"><code>09</code></td></tr><tr><td style="text-align:left"><code>CONSTANT_Methodref(1B): CONSTANT_Class(2B) + CONSTANT_NameAndType(2B)</code></td><td style="text-align:center"><code>0a</code></td></tr><tr><td style="text-align:left"><code>CONSTANT_InterfaceMethodref(1B): CONSTANT_Class(2B) + CONSTANT_NameAndType(2B)</code></td><td style="text-align:center"><code>0b</code></td></tr><tr><td style="text-align:left"><code>CONSTANT_String(1B): CONSTANT_Utf8(2B)</code></td><td style="text-align:center"><code>08</code></td></tr><tr><td style="text-align:left"><code>CONSTANT_Integer(1B): value(4B)</code></td><td style="text-align:center"><code>03</code></td></tr><tr><td style="text-align:left"><code>CONSTANT_Float(1B): value(4B)</code></td><td style="text-align:center"><code>04</code></td></tr><tr><td style="text-align:left"><code>CONSTANT_Long(1B): value(8B)</code></td><td style="text-align:center"><code>05</code></td></tr><tr><td style="text-align:left"><code>CONSTANT_Double(1B): value(8B)</code></td><td style="text-align:center"><code>06</code></td></tr><tr><td style="text-align:left"><code>CONSTANT_NameAndType(1B): Name_引用索引(2B) + Type_引用索引(2B)</code></td><td style="text-align:center"><code>0c</code></td></tr><tr><td style="text-align:left"><code>CONSTANT_Utf8(1B): 长度(2B) + 数据(nB)</code></td><td style="text-align:center"><code>01</code></td></tr><tr><td style="text-align:left"><code>CONSTANT_MethodHandle(1B)</code></td><td style="text-align:center"><code>0f</code></td></tr><tr><td style="text-align:left"><code>CONSTANT_MethodType(1B)</code></td><td style="text-align:center"><code>10</code></td></tr><tr><td style="text-align:left"><code>CONSTANT_InvokeDynamic(1B)</code></td><td style="text-align:center"><code>12</code></td></tr></tbody></table></div><ul><li><code>8~9 字节</code>，表示常量池的长度。<code>00 1f</code> 表示常量池的长度是 31，有 #1～#30 项。注意 #0 项不计入，也没有值</li></ul><blockquote><p>0000000    ca  fe  ba  be  00  00  00  3b  <font color="red">00  1f</font>  0a  00  02  00  03  07</p></blockquote><ul><li><p>（第 #1 项）<code>10~14 字节</code>中，<code>10 字节</code>表示常量的类型（见上表），<code>0a</code> 表示一个 Methodref 信息；</p><p><code>11~12 字节</code>和 <code>13~14 字节</code>，<code>00 02</code> 和 <code>00 03</code> 表示它引用了常量池中 #2 和 #3 项来获得这个方法的【<strong><em><u>所属类</u></em></strong>】和【<strong><em><u>方法名</u></em></strong>】</p></li></ul><blockquote><p>0000000|    ca  fe  ba  be  00  00  00  3b  00  1f  <font color="red">0a   00  02   00   03</font>  07</p></blockquote><ul><li><p>（第 #2 项）<code>15~17 字节</code>中，<code>15 字节</code>表示常量的类型（见上表），<code>07</code> 表示一个 Class 信息；</p><p><code>16~17 字节</code>，<code>00 04</code> 表示它 表示它引用了常量池中 #4 项。</p></li></ul><blockquote><p>0000000|    ca  fe  ba  be  00  00  00  3b  00  1f  0a  00  02  00  03  <font color="red">07</font></p><p>0000020|    <font color="red">00   04</font>  0c  00 05  00  06  01  00  10  6a  61  76  61  2f  6c</p></blockquote><ul><li><p>（第 #3 项）<code>18~22 字节</code>中，<code>18 字节</code>表示常量的类型（见上表），<code>0c</code> 表示一个 “名称 + 类型” 信息；</p><p><code>19~20 字节</code>和 <code>21~22 字节</code>，<code>00 05</code> 和 <code>00 06</code> 表示它 表示它引用了常量池中 #5 项和第 #6 项。</p></li></ul><blockquote><p>0000020|    00  04  <font color="red">0c   00  05  00   06</font>  01  00  10  6a  61  76  61  2f  6c</p></blockquote><ul><li>（第 #4 项）<code>23~41 字节</code>中，<code>23 字节：01</code> 表示一个 utf8 串，后两位 <code>00 10</code> 表示这个串的长度是 16。所以后面紧跟的 16 个字节就是这个串的内容：<code>6a 61 76 61 2f 6c 61 6e 67 2f 4f 62 6a 65 63 74</code>，转义后是：<code>java/lang/Object</code></li></ul><blockquote><p>0000020|    00  04  0c  00  05  00  06  <font color="red">01   00  10  6a   61  76   61   2f  6c</font><br>0000040|    <font color="red">61   6e   67   2f  4f   62  6a   65   63   74</font>  01  00  06  3c  69  6e</p></blockquote><ul><li>（第 #5 项）<code>42~50 字节</code>中，<code>42 字节：01</code> 表示一个 utf8 串，后两位 <code>00 06</code> 表示这个串的长度是 6。所以后面紧跟的 6 个字节就是这个串的内容：<code>3c 69 6e 69 74 3e</code>，转义后是：<code>&lt;init&gt;</code></li></ul><blockquote><p>0000040|    61  6e  67  2f  4f  62  6a  65  63  74  <font color="red">01  00  06   3c   69   6e</font><br>0000060|   <font color="red">69   74   3e</font>  01  00  03  28  29  56  09  00  08  00  09  07  00</p></blockquote><ul><li>（第 #6 项）<code>51~56 字节</code>中，<code>51 字节：01</code> 表示一个 utf8 串，后两位 <code>00 03</code>表示这个串的长度是 3。所以后面紧跟的 3 个字节就是这个串的内容：<code>28 29 56</code>，转义后是：<code>()V</code>，表示<u>无参、无返回值</u></li></ul><blockquote><p>0000060|    69  74  3e  <font color="red">01   00  03   28   29  56</font>  09  00  08  00  09  07  00</p></blockquote><ul><li>（第 #7 项）<code>57~61 字节</code>中，<code>57 字节：09</code> 表示一个 Filedref 信息，后四位 <code>00 08</code> 和 <code>00 09</code> 表示它引用了常量池中 #8 和 #9 项来获得这个成员变量的【<strong><em><u>所属类</u></em></strong>】和【<strong><em><u>成员变量名</u></em></strong>】</li></ul><blockquote><p>0000060|    69  74  3e  01  00  03  28  29  56  <font color="red">09   00  08  00  09</font>  07  00</p></blockquote><p>以此类推……</p><h4 id="1-4-访问标识与继承信息"><a href="#1-4-访问标识与继承信息" class="headerlink" title="1.4 访问标识与继承信息"></a>1.4 访问标识与继承信息</h4><p>常量池 Constant Pool 结束之后，紧接着的<strong><em><u>两个字节</u></em></strong>代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是接口还是类；是否被定义为 <code>public</code> 类型；是否定义为 <code>abstract</code> 类型；如果是类的话，是否被声明为 <code>final</code> 等。</p><div class="table-container"><table><thead><tr><th>Flag Name</th><th>Value (hex)</th><th>Description</th></tr></thead><tbody><tr><td><code>ACC_PUBLIC</code></td><td><code>00 01</code></td><td>是否为 <code>public</code> 类型</td></tr><tr><td><code>ACC_FINAL</code></td><td><code>00 10</code></td><td>是否被声明为 <code>final</code>，只有类可以设置</td></tr><tr><td><code>ACC_SUPER</code></td><td><code>00 20</code></td><td>是否允许使用 <em>invokespecial</em> 字节码指令的新语义</td></tr><tr><td><code>ACC_INTERFACE</code></td><td><code>02 00</code></td><td>标志这是一个接口</td></tr><tr><td><code>ACC_ABSTRACT</code></td><td><code>04 00</code></td><td>是否为 <code>abstract</code> 类型，对于接口或者抽象类来说，次标志值为真，其他类型为假</td></tr><tr><td><code>ACC_SYNTHETIC</code></td><td><code>10 00</code></td><td>标志这个类并非由用户代码产生</td></tr><tr><td><code>ACC_ANNOTATION</code></td><td><code>20 00</code></td><td>标志这是一个注解</td></tr><tr><td><code>ACC_ENUM</code></td><td><code>40 00</code></td><td>标志这是一个枚举</td></tr></tbody></table></div><ul><li><code>00 21</code> 可以推断是由 <code>ACC_PUBLIC</code> 和 <code>ACC_SUPER</code> 通过 <code>OR</code> 组合而成。</li></ul><blockquote><p>0000540|        76  61  <font color="red">00  21</font>  00  15  00  02  00  00  00  00  00  02  00  01</p></blockquote><ul><li><code>00 15</code> 表示根据常量池中的<u>第 #15 项</u>找到<strong><em><u>本类的全限定名</u></em></strong></li></ul><blockquote><p>0000540|        76  61  00  21   <font color="red">00   15</font>  00  02  00  00  00  00  00  02  00  01</p></blockquote><ul><li><code>00 02</code> 表示根据常量池中的<u>第 #2 项</u>找到<strong><em><u>父类的全限定名</u></em></strong></li></ul><blockquote><p>0000540|        76  61  00  21  00  15  <font color="red">00  02</font>  00  00  00  00  00  02  00  01</p></blockquote><ul><li><code>00 00</code> 表示本类中接口的数量，为 0</li></ul><blockquote><p>0000540|        76  61  00  21  00  15  00  02  <font color="red">00  00</font>  00  00  00  02  00  01</p></blockquote><h4 id="1-5-成员变量-Field"><a href="#1-5-成员变量-Field" class="headerlink" title="1.5 成员变量 Field"></a>1.5 成员变量 Field</h4><p>字段表（field info）用于描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。</p><p><code>field info</code> 的结构:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">field_info &#123;</span><br><span class="line">u2access_flags;</span><br><span class="line">u2name_index;</span><br><span class="line">u2descriptor_index;</span><br><span class="line">u2attributes_count;</span><br><span class="line">attribute_infoattributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>access_flags</code>: 字段的作用域（<code>public, private, protected</code> 修饰符），是实例变量还是类变量（<code>static</code> 修饰符）,可否被序列化（<code>transient</code> 修饰符）,可变性（<code>final</code>）,可见性（<code>volatile</code> 修饰符，是否强制从主内存读写）。</li><li><code>name_index</code>: 对常量池的引用，表示的字段的名称；</li><li><code>descriptor_index</code>: 对常量池的引用，表示字段和方法的描述符；</li><li><code>attributes_count</code>: 一个字段还会拥有一些额外的属性，<code>attributes_count</code> 存放属性的个数；</li><li><code>attributes[attributes_count]</code>: 存放具体属性具体内容。</li></ul><p>紧接接口信息后的<strong><em><u>两个字节</u></em></strong>为 <code>00 00</code> 表示成员变量的数量，为 0。</p><blockquote><p>0000540|        76  61  00  21  00  15  00  02. 00  00  <font color="red">00  00</font>  00  02  00  01</p></blockquote><p>在 <code>.class</code> 文件中，成员变量的类型由更简洁的字符表示，其与源代码 <code>.java</code>中的类型对应表如下：</p><div class="table-container"><table><thead><tr><th>Field Type(<code>.class</code>)</th><th>Field Type(<code>.java</code>)</th><th>Description</th></tr></thead><tbody><tr><td><code>B</code></td><td><code>byte</code></td><td><code>byte</code> 类型</td></tr><tr><td><code>C</code></td><td><code>char</code></td><td><code>char</code> 类型</td></tr><tr><td><code>D</code></td><td><code>double</code></td><td><code>double</code> 类型</td></tr><tr><td><code>F</code></td><td><code>float</code></td><td><code>float</code> 类型</td></tr><tr><td><code>I</code></td><td><code>int</code></td><td><code>int</code> 类型</td></tr><tr><td><code>J</code></td><td><code>long</code></td><td><code>long</code> 类型</td></tr><tr><td><code>L</code> <em>ClassName</em></td><td><code>reference</code></td><td>类 <em>ClassName</em> 的引用类型</td></tr><tr><td><code>S</code></td><td><code>short</code></td><td><code>short</code> 类型</td></tr><tr><td><code>Z</code></td><td><code>boolean</code></td><td><code>boolean</code> 类型</td></tr><tr><td><code>[</code></td><td><code>reference</code></td><td>一维数组类型</td></tr></tbody></table></div><h4 id="1-6-方法-Method"><a href="#1-6-方法-Method" class="headerlink" title="1.6 方法 Method"></a>1.6 方法 Method</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             methods_count;</span><br><span class="line">method_info    methods[methods_count];</span><br></pre></td></tr></table></figure><p><code>methods_count</code> 表示方法的数量，而 <code>method_info</code> 表示的方法表。</p><p><code>.class</code> 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。</p><p><code>method_info</code> (方法表的) 结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">method_info &#123;</span><br><span class="line">u2access_flags;</span><br><span class="line">u2name_index;</span><br><span class="line">u2descriptor_index;</span><br><span class="line">u2attributes_count;</span><br><span class="line">attribute_infoattributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>方法表的 <code>access_flags</code> 取值：</p><div class="table-container"><table><thead><tr><th><code>access_flags</code></th><th>Value (hex)</th><th>Description</th></tr></thead><tbody><tr><td><code>ACC_PUBLIC</code></td><td><code>00 01</code></td><td>是否为 <code>public</code> 类型</td></tr><tr><td><code>ACC_PRIVATE</code></td><td><code>00 02</code></td><td>是否为 <code>private</code> 类型</td></tr><tr><td><code>ACC_PROTECTED</code></td><td><code>00 04</code></td><td>是否为 <code>protected</code> 类型</td></tr><tr><td><code>ACC_STATIC</code></td><td><code>00 08</code></td><td>是否为 <code>static</code> 类型</td></tr><tr><td><code>ACC_FINAL</code></td><td><code>00 10</code></td><td>是否被声明为 <code>final</code>，只有类可以设置</td></tr><tr><td><code>ACC_VOLATILE</code></td><td><code>00 40</code></td><td>是否为 <code>volatile</code> 类型，不可和 <code>ACC_FIANL</code> 一起使用</td></tr><tr><td><code>ACC_TRANSIENT</code></td><td><code>00 80</code></td><td>在序列化中被忽略的字段</td></tr><tr><td><code>ACC_SYNTHETIC</code></td><td><code>10 00</code></td><td>标志这个类并非由用户代码产生</td></tr><tr><td><code>ACC_ENUM</code></td><td><code>40 00</code></td><td>标志这是一个枚举</td></tr></tbody></table></div><h4 id="1-7-属性-Attribute"><a href="#1-7-属性-Attribute" class="headerlink" title="1.7 属性 Attribute"></a>1.7 属性 Attribute</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">attribute_infoattributes[attributes_count];<span class="comment">//属性表集合</span></span><br></pre></td></tr></table></figure><p>在 <code>.class</code> 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 <code>.class</code> 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。</p><h3 id="2-字节码指令"><a href="#2-字节码指令" class="headerlink" title="2 字节码指令"></a>2 字节码指令</h3><h4 id="2-1-入门"><a href="#2-1-入门" class="headerlink" title="2.1 入门"></a>2.1 入门</h4><p>接着上一节，研究一下两组字节码指令，一个是</p><p><code>public ClassFile.DemoHelloWorld();</code> 构造方法的字节码指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2a b7 00 01 b1</span><br></pre></td></tr></table></figure><ol><li><code>2a</code> $\Rightarrow$ <code>aload_0</code> 加载 <code>slot 0</code> 的局部变量，即 <code>this</code>，做为下面的 <code>imvokespecial</code> 构造方法调用的参数</li><li><code>b7</code> $\Rightarrow$ <code>invokespecial</code> 预备调用构造方法，哪个方法呢？</li><li><code>0001</code> $\Rightarrow$ 引用常量池中第 #1 项，即 <code>Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</code></li><li><code>b1</code> $\Rightarrow$ 表示 <code>return</code></li></ol><p>另一个是主方法的字节码指令 <code>public static void main(java.lang.String[]);</code> </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b2 00 02 12 03 b6 00 04 b1</span><br></pre></td></tr></table></figure><ol><li><code>b2</code> $\Rightarrow$ <code>getstatic</code> 用来加载静态变量，哪个静态变量呢？</li><li><code>00 02</code> $\Rightarrow$ 引用常量池中 #2 项，即 <code>Field javallang System.out:Ljava/io/Printstream;</code></li><li><code>12</code>  $\Rightarrow$ <code>ldc</code> 加载参数，哪个参数呢？</li><li><code>03</code> $\Rightarrow$ 引用常量池中 #3 项，即 <code>String hello world!</code></li><li><code>b6</code> $\Rightarrow$ <code>invokevirtual</code> 预备调用成员方法，哪个方法呢？</li><li><code>00 04</code> $\Rightarrow$ 引用常量池中 #4 项，即<code>Method java/io/Printstream.println:(Ljava/lang/String;)V</code></li><li><code>b1</code> $\Rightarrow$ 表示 <code>return</code></li></ol><h4 id="2-2-javap-工具"><a href="#2-2-javap-工具" class="headerlink" title="2.2 javap 工具"></a>2.2 <code>javap</code> 工具</h4><p>由以上步骤我们可以深刻体会到，手动分析 <code>.class</code> 文件太繁琐了。我们可以使用 Oracle 提供的 <code>javap</code> 工具来反编译 <code>.class</code> 文件。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -v file_name.class</span><br></pre></td></tr></table></figure><p><code>javap</code> 反编译后的 <code>DemoHelloWorld.class</code> 输出信息为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">Classfile /Users/JavaVM/target/classes/ClassFile/DemoHelloWorld.class</span><br><span class="line">  Last modified 2022年8月19日; size 481 bytes</span><br><span class="line">  SHA-256 checksum d5b3da891b099837a6618847d9ccee77453fb9a3cafca7bdcda19487f6020290</span><br><span class="line">  Compiled from &quot;DemoHelloWorld.java&quot;</span><br><span class="line">public class ClassFile.DemoHelloWorld</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 59</span><br><span class="line">  flags: (0x0021) ACC_PUBLIC, ACC_SUPER</span><br><span class="line">  this_class: #21                         // ClassFile/DemoHelloWorld</span><br><span class="line">  super_class: #2                         // java/lang/Object</span><br><span class="line">  interfaces: 0, fields: 0, methods: 2, attributes: 1</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #2.#3          // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Class              #4             // java/lang/Object</span><br><span class="line">   #3 = NameAndType        #5:#6          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #4 = Utf8               java/lang/Object</span><br><span class="line">   #5 = Utf8               &lt;init&gt;</span><br><span class="line">   #6 = Utf8               ()V</span><br><span class="line">   #7 = Fieldref           #8.#9          // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #8 = Class              #10            // java/lang/System</span><br><span class="line">   #9 = NameAndType        #11:#12        // out:Ljava/io/PrintStream;</span><br><span class="line">  #10 = Utf8               java/lang/System</span><br><span class="line">  #11 = Utf8               out</span><br><span class="line">  #12 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #13 = String             #14            // Hello World!</span><br><span class="line">  #14 = Utf8               Hello World!</span><br><span class="line">  #15 = Methodref          #16.#17        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">  #16 = Class              #18            // java/io/PrintStream</span><br><span class="line">  #17 = NameAndType        #19:#20        // println:(Ljava/lang/String;)V</span><br><span class="line">  #18 = Utf8               java/io/PrintStream</span><br><span class="line">  #19 = Utf8               println</span><br><span class="line">  #20 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">  #21 = Class              #22            // ClassFile/DemoHelloWorld</span><br><span class="line">  #22 = Utf8               ClassFile/DemoHelloWorld</span><br><span class="line">  #23 = Utf8               Code</span><br><span class="line">  #24 = Utf8               LineNumberTable</span><br><span class="line">  #25 = Utf8               main</span><br><span class="line">  #26 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #27 = Utf8               MethodParameters</span><br><span class="line">  #28 = Utf8               args</span><br><span class="line">  #29 = Utf8               SourceFile</span><br><span class="line">  #30 = Utf8               DemoHelloWorld.java</span><br><span class="line">&#123;</span><br><span class="line">  public ClassFile.DemoHelloWorld();// 构造方法</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (0x0001) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1// 操作的栈的最大深度、本地变量的个数、参数的个数</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]); // 主方法</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: (0x0009) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1// 操作的栈的最大深度、本地变量的个数、参数的个数</span><br><span class="line">         0: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #13                 // String Hello World!</span><br><span class="line">         5: invokevirtual #15                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 5: 0</span><br><span class="line">        line 6: 8</span><br><span class="line">    MethodParameters:</span><br><span class="line">      Name                           Flags</span><br><span class="line">      args</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;DemoHelloWorld.java&quot;</span><br></pre></td></tr></table></figure><h4 id="2-3-图解方法执行流程"><a href="#2-3-图解方法执行流程" class="headerlink" title="2.3 图解方法执行流程"></a>2.3 图解方法执行流程</h4><h5 id="2-3-1-原始-Java-代码"><a href="#2-3-1-原始-Java-代码" class="headerlink" title="2.3.1 原始 Java 代码"></a>2.3.1 原始 Java 代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ClassFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Short.MAX_VALUE + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-2-编译后的字节码文件"><a href="#2-3-2-编译后的字节码文件" class="headerlink" title="2.3.2 编译后的字节码文件"></a>2.3.2 编译后的字节码文件</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">Classfile /Users/JavaVM/target/classes/ClassFile/Demo2.class</span><br><span class="line">  Last modified 2022年8月20日; size 597 bytes</span><br><span class="line">  SHA-256 checksum 564a035722627c2a2e6345f6fe7c7ae07e64c76a49d6666827fdcff254d7b5d9</span><br><span class="line">  Compiled from &quot;Demo2.java&quot;</span><br><span class="line">public class ClassFile.Demo2</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: (0x0021) ACC_PUBLIC, ACC_SUPER</span><br><span class="line">  this_class: #6                          // ClassFile/Demo2</span><br><span class="line">  super_class: #7                         // java/lang/Object</span><br><span class="line">  interfaces: 0, fields: 0, methods: 2, attributes: 1</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #7.#25         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Class              #26            // java/lang/Short</span><br><span class="line">   #3 = Integer            32768</span><br><span class="line">   #4 = Fieldref           #27.#28        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #5 = Methodref          #29.#30        // java/io/PrintStream.println:(I)V</span><br><span class="line">   #6 = Class              #31            // ClassFile/Demo2</span><br><span class="line">   #7 = Class              #32            // java/lang/Object</span><br><span class="line">   #8 = Utf8               &lt;init&gt;</span><br><span class="line">   #9 = Utf8               ()V</span><br><span class="line">  #10 = Utf8               Code</span><br><span class="line">  #11 = Utf8               LineNumberTable</span><br><span class="line">  #12 = Utf8               LocalVariableTable</span><br><span class="line">  #13 = Utf8               this</span><br><span class="line">  #14 = Utf8               LClassFile/Demo2;</span><br><span class="line">  #15 = Utf8               main</span><br><span class="line">  #16 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #17 = Utf8               args</span><br><span class="line">  #18 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #19 = Utf8               a</span><br><span class="line">  #20 = Utf8               I</span><br><span class="line">  #21 = Utf8               b</span><br><span class="line">  #22 = Utf8               c</span><br><span class="line">  #23 = Utf8               SourceFile</span><br><span class="line">  #24 = Utf8               Demo2.java</span><br><span class="line">  #25 = NameAndType        #8:#9          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #26 = Utf8               java/lang/Short</span><br><span class="line">  #27 = Class              #33            // java/lang/System</span><br><span class="line">  #28 = NameAndType        #34:#35        // out:Ljava/io/PrintStream;</span><br><span class="line">  #29 = Class              #36            // java/io/PrintStream</span><br><span class="line">  #30 = NameAndType        #37:#38        // println:(I)V</span><br><span class="line">  #31 = Utf8               ClassFile/Demo2</span><br><span class="line">  #32 = Utf8               java/lang/Object</span><br><span class="line">  #33 = Utf8               java/lang/System</span><br><span class="line">  #34 = Utf8               out</span><br><span class="line">  #35 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #36 = Utf8               java/io/PrintStream</span><br><span class="line">  #37 = Utf8               println</span><br><span class="line">  #38 = Utf8               (I)V</span><br><span class="line">&#123;</span><br><span class="line">  public ClassFile.Demo2();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (0x0001) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   LClassFile/Demo2;</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: (0x0009) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=4, args_size=1</span><br><span class="line">         0: bipush        10</span><br><span class="line">         2: istore_1</span><br><span class="line">         3: ldc           #3                  // int 32768</span><br><span class="line">         5: istore_2</span><br><span class="line">         6: iload_1</span><br><span class="line">         7: iload_2</span><br><span class="line">         8: iadd</span><br><span class="line">         9: istore_3</span><br><span class="line">        10: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        13: iload_3</span><br><span class="line">        14: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">        17: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 5: 0</span><br><span class="line">        line 6: 3</span><br><span class="line">        line 7: 6</span><br><span class="line">        line 8: 10</span><br><span class="line">        line 9: 17</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      18     0  args   [Ljava/lang/String;</span><br><span class="line">            3      15     1     a   I</span><br><span class="line">            6      12     2     b   I</span><br><span class="line">           10       8     3     c   I</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;Demo2.java&quot;</span><br></pre></td></tr></table></figure><h5 id="2-3-3-常量池载入-“运行时常量池”"><a href="#2-3-3-常量池载入-“运行时常量池”" class="headerlink" title="2.3.3 常量池载入 “运行时常量池”"></a>2.3.3 常量池载入 “运行时常量池”</h5><p><img src="/2022/03/22/JVM-1/2.png" alt="2"></p><h5 id="2-3-4-方法字节码载入方法区"><a href="#2-3-4-方法字节码载入方法区" class="headerlink" title="2.3.4 方法字节码载入方法区"></a>2.3.4 方法字节码载入方法区</h5><p><img src="/2022/03/22/JVM-1/3.png" alt="3"></p><h5 id="2-3-5-主线程开始运行，分配栈帧内存"><a href="#2-3-5-主线程开始运行，分配栈帧内存" class="headerlink" title="2.3.5 主线程开始运行，分配栈帧内存"></a>2.3.5 主线程开始运行，分配栈帧内存</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack=<span class="number">2</span>, locals=<span class="number">4</span> <span class="comment">// 操作的栈的最大深度=2、本地变量的个数=4</span></span><br></pre></td></tr></table></figure><p><img src="/2022/03/22/JVM-1/4.png" alt="4"></p><h6 id="bipush-10"><a href="#bipush-10" class="headerlink" title="bipush 10"></a><code>bipush 10</code></h6><p>将一个 byte 压入操作数栈（其长度会补齐4个字节），类似的指令还有</p><ul><li><code>sipush</code> 将一个 <code>short</code> 压入操作数栈（其长度会补齐4个字节）</li><li><code>ldc</code> 将一个 <code>int</code> 压入操作数栈</li><li><code>lde2_w</code> 将一个 <code>long</code> 压入操作数栈（分两次压入，因为 <code>long</code> 是 8 个字节）</li><li>这里小的数字（4 个字节）都是和字节码指令存在一起，超过 <code>short</code> 范围的数字存入了常量池</li></ul><p><img src="/2022/03/22/JVM-1/5.png" alt="5"></p><h6 id="istore-1"><a href="#istore-1" class="headerlink" title="istore 1"></a><code>istore 1</code></h6><p>将操作数栈栈顶的元素弹出，存入本地变量表的 slot 1</p><p><img src="/2022/03/22/JVM-1/6.png" alt="6"></p><p><img src="/2022/03/22/JVM-1/7.png" alt="7"></p><h6 id="ldc-3"><a href="#ldc-3" class="headerlink" title="ldc #3"></a><code>ldc #3</code></h6><ul><li>从常量池加载 #3 数据到操作数栈</li><li>注意：<code>Short.MAX_ VAIUE</code> 是 <code>32767</code>，所以 <code>32768 = Short. MAX_ VAIUE ＋ 1</code>实际是在编译期间计算</li></ul><p><img src="/2022/03/22/JVM-1/8.png" alt="8"></p><h6 id="istore-2"><a href="#istore-2" class="headerlink" title="istore 2"></a><code>istore 2</code></h6><p><img src="/2022/03/22/JVM-1/9.png" alt="9"></p><p><img src="/2022/03/22/JVM-1/10.png" alt="10"></p><h6 id="iload-1"><a href="#iload-1" class="headerlink" title="iload 1"></a><code>iload 1</code></h6><p><img src="/2022/03/22/JVM-1/11.png" alt="11"></p><h6 id="iload-2"><a href="#iload-2" class="headerlink" title="iload 2"></a><code>iload 2</code></h6><p><img src="/2022/03/22/JVM-1/12.png" alt="12"></p><h6 id="iadd"><a href="#iadd" class="headerlink" title="iadd"></a><code>iadd</code></h6><p><img src="/2022/03/22/JVM-1/13.png" alt="13"></p><p><img src="/2022/03/22/JVM-1/14.png" alt="14"></p><h6 id="istore-3"><a href="#istore-3" class="headerlink" title="istore 3"></a><code>istore 3</code></h6><p><img src="/2022/03/22/JVM-1/15.png" alt="15"></p><p><img src="/2022/03/22/JVM-1/16.png" alt="16"></p><h6 id="getstatic-4"><a href="#getstatic-4" class="headerlink" title="getstatic #4"></a><code>getstatic #4</code></h6><p><img src="/2022/03/22/JVM-1/17.png" alt="17"></p><p><img src="/2022/03/22/JVM-1/18.png" alt="18"></p><h6 id="iload-3"><a href="#iload-3" class="headerlink" title="iload 3"></a><code>iload 3</code></h6><p><img src="/2022/03/22/JVM-1/19.png" alt="19"></p><h6 id="invokevirtual-5"><a href="#invokevirtual-5" class="headerlink" title="invokevirtual #5"></a><code>invokevirtual #5</code></h6><ul><li>找到常量池 #5 项</li><li>定位到方法区 <code>java/io/PrintStream.println:(I)V</code>方法</li><li>生成新的栈帧（分配 <code>locals</code>、<code>stack</code>等）</li><li>传递参数，执行新栈帧中的字节码</li></ul><p><img src="/2022/03/22/JVM-1/20.png" alt="20"></p><ul><li>执行操作，弹出栈帧</li><li>清除 <code>main</code> 栈帧中操作数栈内容</li></ul><p><img src="/2022/03/22/JVM-1/21.png" alt="21"></p><h6 id="return"><a href="#return" class="headerlink" title="return"></a><code>return</code></h6><ul><li>完成 <code>main</code> 方法调用，弹出 <code>main</code> 栈帧</li><li>程序结束</li></ul><h4 id="2-4-从字节码角度分析-i-与-i"><a href="#2-4-从字节码角度分析-i-与-i" class="headerlink" title="2.4 从字节码角度分析 i++ 与 ++i"></a>2.4 从字节码角度分析 <code>i++</code> 与 <code>++i</code></h4><blockquote><ul><li><code>i++</code> $\Rightarrow$ 先执行 <code>iload</code>，再执行 <code>iinc</code></li><li><code>++i</code> $\Rightarrow$ 先执行 <code>iinc</code>，再执行 <code>iload</code></li><li><code>iinc 1 -1</code> 自增运算操作再本地变量表中进行操作，而非操作数栈。意为<u>在 slot 1 的本地变量自增 <code>-1</code></u></li></ul></blockquote><h4 id="2-5-条件判断指令"><a href="#2-5-条件判断指令" class="headerlink" title="2.5 条件判断指令"></a>2.5 条件判断指令</h4><div class="table-container"><table><thead><tr><th style="text-align:left">指令 (hex)</th><th>助记符</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:left"><code>99</code></td><td><code>ifeq</code></td><td>判断是否 $=0$</td></tr><tr><td style="text-align:left"><code>9a</code></td><td><code>ifne</code></td><td>判断是否 $\ne 0$</td></tr><tr><td style="text-align:left"><code>9b</code></td><td><code>iflt</code></td><td>判断是否 $&lt; 0$</td></tr><tr><td style="text-align:left"><code>9c</code></td><td><code>ifge</code></td><td>判断是否 $ \ge 0$</td></tr><tr><td style="text-align:left"><code>9d</code></td><td><code>ifgt</code></td><td>判断是否 $&gt;0$</td></tr><tr><td style="text-align:left"><code>9e</code></td><td><code>ifle</code></td><td>判断是否 $\le 0$</td></tr><tr><td style="text-align:left"><code>9f</code></td><td><code>if_icmpeq</code></td><td>判断两个 <code>int</code> 是否 $=$</td></tr><tr><td style="text-align:left"><code>a0</code></td><td><code>if_icmpne</code></td><td>判断两个 <code>int</code> 是否 $\ne$</td></tr><tr><td style="text-align:left"><code>a1</code></td><td><code>if_icmplt</code></td><td>判断两个 <code>int</code> 是否 $&lt;$</td></tr><tr><td style="text-align:left"><code>a2</code></td><td><code>if_icmpge</code></td><td>判断两个 <code>int</code> 是否 $\ge$</td></tr><tr><td style="text-align:left"><code>a3</code></td><td><code>if_icmpgt</code></td><td>判断两个 <code>int</code> 是否 $&gt;$</td></tr><tr><td style="text-align:left"><code>a4</code></td><td><code>if_icmple</code></td><td>判断两个 <code>int</code> 是否 $\le$</td></tr><tr><td style="text-align:left"><code>a5</code></td><td><code>if_acmpeq</code></td><td>判断两个 <code>引用</code> 是否 $=$</td></tr><tr><td style="text-align:left"><code>a6</code></td><td><code>if_acmpne</code></td><td>判断两个 <code>引用</code> 是否 $\ne$</td></tr><tr><td style="text-align:left"><code>c6</code></td><td><code>ifnull</code></td><td>判断是否为 <code>null</code></td></tr><tr><td style="text-align:left"><code>c7</code></td><td><code>ifnonnull</code></td><td>判断是否为 <code>非null</code></td></tr></tbody></table></div><ul><li><code>byte, short, char</code> 都会按照 <code>int</code> 来比较，因为操作数栈都是 4 个字节</li><li>条件判断指令后，使用 <code>goto</code> 语句来跳转到指定位置</li></ul><h4 id="2-6-构造方法"><a href="#2-6-构造方法" class="headerlink" title="2.6 构造方法"></a>2.6 构造方法</h4><h5 id="2-6-1-lt-clinit-gt-V"><a href="#2-6-1-lt-clinit-gt-V" class="headerlink" title="2.6.1 &lt;clinit&gt;()V"></a>2.6.1 <code>&lt;clinit&gt;()V</code></h5><p><code>&lt;clinit&gt;()V</code> 是<strong><em><u>类构造器方法</u></em></strong>，也就是在 JVM 进行”类加载 - 链接 - 初始化”中的初始化阶段，JVM 会调用 <code>&lt;clinit&gt;()V</code> 方法。<code>&lt;clinit&gt;()V</code> 是<strong><em><u>类构造器</u></em></strong>对<u>静态变量，静态代码块进行初始化</u>。</p><p>从字节码角度分析如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    i = <span class="number">20</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    i = <span class="number">30</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会按照<strong><em><u>从上至下</u></em></strong>的顺序，收集所有的 <code>static</code> 静态代码块的静态成员赋值的代码，合并成一个特殊的方法 <code>&lt;clinit&gt;()V</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> 0: bipush        10</span><br><span class="line"> 2: putstatic     #3                  // Field i:I</span><br><span class="line"> 5: bipush        20</span><br><span class="line"> 7: putstatic     #3                  // Field i:I</span><br><span class="line">10: bipush        30</span><br><span class="line">12: putstatic     #3                  // Field i:I</span><br><span class="line">15: return</span><br></pre></td></tr></table></figure><h5 id="2-6-2-lt-init-gt-V"><a href="#2-6-2-lt-init-gt-V" class="headerlink" title="2.6.2 &lt;init&gt;()V"></a>2.6.2 <code>&lt;init&gt;()V</code></h5><p><code>&lt;init&gt;()V</code> 是<strong><em><u>对象构造器方法</u></em></strong>，也就是说在程序执行 <code>new</code> 一个对象，调用该对象类的构造器方法时才会执行 <code>&lt;init&gt;()V</code> 方法。<code>&lt;init&gt;()V</code> 是<strong><em><u>实例构造器</u></em></strong>，对<u>非静态变量解析初始化</u>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ClassFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoStatic</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;s1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        b = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="string">&quot;s2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DemoStatic</span><span class="params">(String a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DemoStatic</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoStatic</span>(<span class="string">&quot;s3&quot;</span>,<span class="number">30</span>);</span><br><span class="line">        System.out.println(demo.a + <span class="string">&quot;\t&quot;</span> + demo.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译器会按照<strong><em><u>从上至下</u></em></strong>的顺序，收集所有的 <code>&#123;&#125;</code> 初始化代码块的静态成员赋值的代码，合并成一个特殊的方法 <code>&lt;init&gt;()V</code>，但原始<strong><em><u>构造方法</u></em></strong>内的代码总是在最后。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span>: aload_0</span><br><span class="line"> <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line"> <span class="number">4</span>: aload_0</span><br><span class="line"> <span class="number">5</span>: ldc           #<span class="number">2</span>                  <span class="comment">// String &quot;s1&quot;</span></span><br><span class="line"> <span class="number">7</span>: putfield      #<span class="number">3</span>                  <span class="comment">// Field a:Ljava/lang/String;</span></span><br><span class="line"><span class="number">10</span>: aload_0</span><br><span class="line"><span class="number">11</span>: bipush        <span class="number">20</span></span><br><span class="line"><span class="number">13</span>: putfield      #<span class="number">4</span>                  <span class="comment">// Field b:I</span></span><br><span class="line"><span class="number">16</span>: aload_0</span><br><span class="line"><span class="number">17</span>: bipush        <span class="number">10</span></span><br><span class="line"><span class="number">19</span>: putfield      #<span class="number">4</span>                  <span class="comment">// Field b:I</span></span><br><span class="line"><span class="number">22</span>: aload_0</span><br><span class="line"><span class="number">23</span>: ldc           #<span class="number">5</span>                  <span class="comment">// String &quot;s2&quot;</span></span><br><span class="line"><span class="number">25</span>: putfield      #<span class="number">3</span>                  <span class="comment">// Field a:Ljava/lang/String;</span></span><br><span class="line"><span class="number">28</span>: aload_0</span><br><span class="line"><span class="number">29</span>: aload_1</span><br><span class="line"><span class="number">30</span>: putfield      #<span class="number">3</span>                  <span class="comment">// Field a:Ljava/lang/String;</span></span><br><span class="line"><span class="number">33</span>: aload_0</span><br><span class="line"><span class="number">34</span>: iload_2</span><br><span class="line"><span class="number">35</span>: putfield      #<span class="number">4</span>                  <span class="comment">// Field b:I</span></span><br><span class="line"><span class="number">38</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><h4 id="2-7-方法的调用"><a href="#2-7-方法的调用" class="headerlink" title="2.7 方法的调用"></a>2.7 方法的调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ClassFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoCallMethod</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DemoCallMethod</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoCallMethod</span>();</span><br><span class="line">        demo.test1();</span><br><span class="line">        demo.test2();</span><br><span class="line">        demo.test3();</span><br><span class="line">        demo.test4();</span><br><span class="line">        DemoCallMethod.test4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">         <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class ClassFile/DemoCallMethod</span></span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">-        <span class="number">4</span>: invokespecial #<span class="number">3</span>                  <span class="comment">// Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">7</span>: astore_1</span><br><span class="line">         <span class="number">8</span>: aload_1</span><br><span class="line">-        <span class="number">9</span>: invokespecial #<span class="number">4</span>                  <span class="comment">// Method test1:()V</span></span><br><span class="line">        <span class="number">12</span>: aload_1</span><br><span class="line">-       <span class="number">13</span>: invokespecial #<span class="number">5</span>                  <span class="comment">// Method test2:()V</span></span><br><span class="line">        <span class="number">16</span>: aload_1</span><br><span class="line">+       <span class="number">17</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method test3:()V</span></span><br><span class="line">        <span class="number">20</span>: aload_1</span><br><span class="line">        <span class="number">21</span>: pop</span><br><span class="line">&amp;       <span class="number">22</span>: invokestatic  #<span class="number">7</span>                  <span class="comment">// Method test4:()V</span></span><br><span class="line">        <span class="number">25</span>: invokestatic  #<span class="number">7</span>                  <span class="comment">// Method test4:()V</span></span><br><span class="line">        <span class="number">28</span>: <span class="keyword">return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>在以上例子中，出现了三种不同的方法调用：</p><ul><li><code>invokespecial</code>：构造方法、私有方法 <code>private</code>、<code>final</code> 修饰的方法</li><li><code>invokevirtual</code>：公共方法 <code>public</code></li><li><code>invokestatic</code>：静态方法 <code>static</code></li></ul><p>在 JVM 中，<code>invokespecial</code> 和 <code>invokestatic</code> 属于<strong><em><u>静态方法绑定</u></em></strong>，在字节码文件生成时就已知该方法属于哪个类；但 <code>public</code> 方法有可能出现方法重写的情况，编译期间无法确定该方法属于哪个类（子类或父类），所以使用 <code>invokevirtual</code> <strong><em><u>动态方法绑定</u></em></strong>，需要在运行时确定。</p><blockquote><p>细节说明：</p><ul><li><code>new</code> 关键字调用构造方法时，先在<u>堆空间分配对象所需的内存</u>，分配成功后，再<u>将对象引用放入操作数栈</u>。</li><li><code>dup</code> 复制栈顶元素</li></ul></blockquote><h4 id="2-8-多态的原理"><a href="#2-8-多态的原理" class="headerlink" title="2.8 多态的原理"></a>2.8 多态的原理</h4><p>在上一小节中，我们提到 <code>invokevirtual</code> <strong><em><u>动态方法绑定</u></em></strong>，在此节中，我们将了解 Java 中多态的原理。</p><p><a href="https://b23.tv/bRZKMKb">视频讲解：BiliBili - 黑马程序员 JVM - P119 多态原理</a></p><p>当执行 <code>invokevirtual</code> 指令时，</p><ol><li>先通过栈帧中的对象引用找到对象</li><li>分析对象头，找到对象的实际 <code>Class</code></li><li><code>Class</code> 结构中有 <code>vtable</code>，它在类加载的链接阶段就已经根据方法的重写规则生成好了</li><li>查表得到方法的具体地址</li><li>执行方法的字节码</li></ol><h4 id="2-9-处理异常"><a href="#2-9-处理异常" class="headerlink" title="2.9 处理异常"></a>2.9 处理异常</h4><h5 id="2-9-1-单-try-catch-代码块"><a href="#2-9-1-单-try-catch-代码块" class="headerlink" title="2.9.1 单 try-catch 代码块"></a>2.9.1 单 <code>try-catch</code> 代码块</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ClassFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i = <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            i = <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码（重要的部分）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: (<span class="number">0x0009</span>) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: iconst_0</span><br><span class="line">         <span class="number">1</span>: istore_1<span class="comment">// i = 0</span></span><br><span class="line">         <span class="number">2</span>: bipush        <span class="number">10</span></span><br><span class="line">         <span class="number">4</span>: istore_1<span class="comment">// i = 10</span></span><br><span class="line">         <span class="number">5</span>: goto          <span class="number">12</span><span class="comment">// 没有异常，跳转 12</span></span><br><span class="line">         <span class="number">8</span>: astore_2<span class="comment">// Execption e</span></span><br><span class="line">         <span class="number">9</span>: bipush        <span class="number">20</span></span><br><span class="line">        <span class="number">11</span>: istore_1</span><br><span class="line">        <span class="number">12</span>: <span class="keyword">return</span></span><br><span class="line">*     Exception table:<span class="comment">// 异常表，若[from, to)范围内出现异常且匹配type类型，跳转到target</span></span><br><span class="line">         from    to  target type</span><br><span class="line">             <span class="number">2</span>     <span class="number">5</span>     <span class="number">8</span>   Class java/lang/Exception</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">9</span>       <span class="number">3</span>     <span class="number">2</span>     e   Ljava/lang/Exception;</span><br><span class="line">            <span class="number">0</span>      <span class="number">13</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">2</span>      <span class="number">11</span>     <span class="number">1</span>     i   I</span><br></pre></td></tr></table></figure><ul><li>可以看到，字节码文件中多出来一个 <em>”Exception table“</em> 的结构，<code>[from,to)</code> 是前闭后开的检测范围，一旦这个范围内的字节码执行出现异常，则通过 <code>type</code> 匹配异常类型，如果一致，进入 <code>target</code> 所指示行号；</li><li>8 行的字节码指令 <code>astore 2</code> 是将异常对象引用存入局部变量表的 <code>slot 2</code> 位置</li></ul><h5 id="2-9-2-单-try-多-catch-代码块-（一）"><a href="#2-9-2-单-try-多-catch-代码块-（一）" class="headerlink" title="2.9.2 单 try 多 catch 代码块 （一）"></a>2.9.2 单 <code>try</code> 多 <code>catch</code> 代码块 （一）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ClassFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i = <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            i = <span class="number">20</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            i = <span class="number">30</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码（重要的部分）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">   descriptor: ([Ljava/lang/String;)V</span><br><span class="line">   flags: (<span class="number">0x0009</span>) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">   Code:</span><br><span class="line">     stack=<span class="number">1</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">        <span class="number">0</span>: iconst_0</span><br><span class="line">        <span class="number">1</span>: istore_1<span class="comment">// i = 0</span></span><br><span class="line">        <span class="number">2</span>: bipush        <span class="number">10</span></span><br><span class="line">        <span class="number">4</span>: istore_1<span class="comment">// i = 10</span></span><br><span class="line">        <span class="number">5</span>: goto          <span class="number">19</span><span class="comment">// 没有异常，跳转 12</span></span><br><span class="line">        <span class="number">8</span>: astore_2<span class="comment">// NullPointerException e</span></span><br><span class="line">        <span class="number">9</span>: bipush        <span class="number">20</span></span><br><span class="line">       <span class="number">11</span>: istore_1<span class="comment">// i = 20</span></span><br><span class="line">       <span class="number">12</span>: goto          <span class="number">19</span></span><br><span class="line">       <span class="number">15</span>: astore_2<span class="comment">// Execption e</span></span><br><span class="line">       <span class="number">16</span>: bipush        <span class="number">30</span></span><br><span class="line">       <span class="number">18</span>: istore_1<span class="comment">// i = 30</span></span><br><span class="line">       <span class="number">19</span>: <span class="keyword">return</span></span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            <span class="number">2</span>     <span class="number">5</span>     <span class="number">8</span>   Class java/lang/NullPointerException</span><br><span class="line">            <span class="number">2</span>     <span class="number">5</span>    <span class="number">15</span>   Class java/lang/Exception</span><br><span class="line">     LocalVariableTable:</span><br><span class="line">       Start  Length  Slot  Name   Signature</span><br><span class="line">           <span class="number">9</span>       <span class="number">3</span>     <span class="number">2</span>     e   Ljava/lang/NullPointerException;</span><br><span class="line">          <span class="number">16</span>       <span class="number">3</span>     <span class="number">2</span>     e   Ljava/lang/Exception;<span class="comment">// slot位置的复用</span></span><br><span class="line">           <span class="number">0</span>      <span class="number">20</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">           <span class="number">2</span>      <span class="number">18</span>     <span class="number">1</span>     i   I</span><br></pre></td></tr></table></figure><ul><li>因为异常出现时，只能进入 <code>Exception table</code> 中一个分支，所以局部变量表 <code>slot 2</code> 位置被共用</li></ul><h5 id="2-9-3-单-try-多-catch-代码块-（二）"><a href="#2-9-3-单-try-多-catch-代码块-（二）" class="headerlink" title="2.9.3 单 try 多 catch 代码块 （二）"></a>2.9.3 单 <code>try</code> 多 <code>catch</code> 代码块 （二）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ClassFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i = <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException | IllegalAccessError e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码（重要的部分）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">   descriptor: ([Ljava/lang/String;)V</span><br><span class="line">   flags: (<span class="number">0x0009</span>) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">   Code:</span><br><span class="line">     stack=<span class="number">1</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">        <span class="number">0</span>: iconst_0</span><br><span class="line">        <span class="number">1</span>: istore_1</span><br><span class="line">        <span class="number">2</span>: bipush        <span class="number">10</span></span><br><span class="line">        <span class="number">4</span>: istore_1</span><br><span class="line">        <span class="number">5</span>: goto          <span class="number">13</span></span><br><span class="line">        <span class="number">8</span>: astore_2</span><br><span class="line">        <span class="number">9</span>: aload_2</span><br><span class="line">       <span class="number">10</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/lang/Throwable.printStackTrace:()V</span></span><br><span class="line">       <span class="number">13</span>: <span class="keyword">return</span></span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            <span class="number">2</span>     <span class="number">5</span>     <span class="number">8</span>   Class java/lang/NullPointerException</span><br><span class="line">            <span class="number">2</span>     <span class="number">5</span>     <span class="number">8</span>   Class java/lang/IllegalAccessError</span><br><span class="line">     LocalVariableTable:</span><br><span class="line">       Start  Length  Slot  Name   Signature</span><br><span class="line">           <span class="number">9</span>       <span class="number">4</span>     <span class="number">2</span>     e   Ljava/lang/Throwable;</span><br><span class="line">           <span class="number">0</span>      <span class="number">14</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">           <span class="number">2</span>      <span class="number">12</span>     <span class="number">1</span>     i   I</span><br></pre></td></tr></table></figure><ul><li>本质上与之前是一样的。</li></ul><h5 id="2-9-4-finally-代码块"><a href="#2-9-4-finally-代码块" class="headerlink" title="2.9.4 finally 代码块"></a>2.9.4 <code>finally</code> 代码块</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ClassFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i = <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            i = <span class="number">20</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            i = <span class="number">30</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>字节码（重要的部分）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: (<span class="number">0x0009</span>) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: iconst_0</span><br><span class="line">         <span class="number">1</span>: istore_1<span class="comment">// i = 0</span></span><br><span class="line">         <span class="number">2</span>: bipush        <span class="number">10</span><span class="comment">// try代码块 -----------------------------</span></span><br><span class="line">         <span class="number">4</span>: istore_1<span class="comment">// i = 10|</span></span><br><span class="line">         <span class="number">5</span>: bipush        <span class="number">30</span><span class="comment">// finally|</span></span><br><span class="line">         <span class="number">7</span>: istore_1<span class="comment">// i = 30|</span></span><br><span class="line">         <span class="number">8</span>: goto          <span class="number">27</span><span class="comment">// 没有异常，跳转 27 ----------------------</span></span><br><span class="line">        <span class="number">11</span>: astore_2<span class="comment">// catch Exception e ---------------------</span></span><br><span class="line">        <span class="number">12</span>: bipush        <span class="number">20</span><span class="comment">//|</span></span><br><span class="line">        <span class="number">14</span>: istore_1<span class="comment">// i = 20|</span></span><br><span class="line">        <span class="number">15</span>: bipush        <span class="number">30</span><span class="comment">// finally|</span></span><br><span class="line">        <span class="number">17</span>: istore_1<span class="comment">// i = 30|</span></span><br><span class="line">        <span class="number">18</span>: goto          <span class="number">27</span><span class="comment">// 没有异常，跳转 27 ----------------------</span></span><br><span class="line">        <span class="number">21</span>: astore_3<span class="comment">// catch any(slot 3) e -------------------</span></span><br><span class="line">        <span class="number">22</span>: bipush        <span class="number">30</span><span class="comment">// finally|</span></span><br><span class="line">        <span class="number">24</span>: istore_1<span class="comment">// i = 30|</span></span><br><span class="line">        <span class="number">25</span>: aload_3<span class="comment">// |</span></span><br><span class="line">        <span class="number">26</span>: athrow<span class="comment">// throw ---------------------------------</span></span><br><span class="line">        <span class="number">27</span>: <span class="keyword">return</span></span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">             <span class="number">2</span>     <span class="number">5</span>    <span class="number">11</span>   Class java/lang/Exception</span><br><span class="line">             <span class="number">2</span>     <span class="number">5</span>    <span class="number">21</span>   any</span><br><span class="line">            <span class="number">11</span>    <span class="number">15</span>    <span class="number">21</span>   any</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">           <span class="number">12</span>       <span class="number">3</span>     <span class="number">2</span>     e   Ljava/lang/Exception;</span><br><span class="line">            <span class="number">0</span>      <span class="number">28</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">2</span>      <span class="number">26</span>     <span class="number">1</span>     i   I</span><br></pre></td></tr></table></figure><ul><li>可以看到 <code>finally</code> 中的代码被复制了 3 份，分别放入 <code>try</code> 流程，<code>catch</code> 流程以及 <code>catch</code> 剩余的异常类型流程</li></ul><h5 id="2-9-5-finally-块中返回值的问题"><a href="#2-9-5-finally-块中返回值的问题" class="headerlink" title="2.9.5 finally 块中返回值的问题"></a>2.9.5 <code>finally</code> 块中返回值的问题</h5><p>我们考虑如下代码，分析其最后的返回值：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> test();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            i = <span class="number">20</span>;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    返回结果为 <code>20</code>。其字节码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">   descriptor: ()I</span><br><span class="line">   flags: (<span class="number">0x0009</span>) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">   Code:</span><br><span class="line">     stack=<span class="number">1</span>, locals=<span class="number">3</span>, args_size=<span class="number">0</span></span><br><span class="line">        <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line">        <span class="number">2</span>: istore_0</span><br><span class="line">        <span class="number">3</span>: iload_0</span><br><span class="line">        <span class="number">4</span>: istore_1<span class="comment">// 思考，为何不直接return，而是将栈顶的10再次存入slot1中呢？</span></span><br><span class="line">        <span class="number">5</span>: bipush        <span class="number">20</span></span><br><span class="line">        <span class="number">7</span>: istore_0</span><br><span class="line">        <span class="number">8</span>: iload_0</span><br><span class="line">        <span class="number">9</span>: ireturn</span><br><span class="line">       <span class="number">10</span>: astore_2</span><br><span class="line">       <span class="number">11</span>: bipush        <span class="number">20</span></span><br><span class="line">       <span class="number">13</span>: istore_0</span><br><span class="line">       <span class="number">14</span>: iload_0</span><br><span class="line">       <span class="number">15</span>: ireturn</span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            <span class="number">3</span>     <span class="number">5</span>    <span class="number">10</span>   any</span><br><span class="line">     LocalVariableTable:</span><br><span class="line">       Start  Length  Slot  Name   Signature</span><br><span class="line">           <span class="number">3</span>      <span class="number">13</span>     <span class="number">0</span>     i   I</span><br></pre></td></tr></table></figure><p>我们再考虑如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> test();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            i = <span class="number">20</span>;</span><br><span class="line">          <span class="comment">// return i;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​    返回结果为 <code>10</code>。其字节码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">   descriptor: ()I</span><br><span class="line">   flags: (<span class="number">0x0009</span>) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">   Code:</span><br><span class="line">     stack=<span class="number">1</span>, locals=<span class="number">3</span>, args_size=<span class="number">0</span></span><br><span class="line">        <span class="number">0</span>: bipush        <span class="number">10</span><span class="comment">// 将10压入栈顶，try ------------------------</span></span><br><span class="line">        <span class="number">2</span>: istore_0<span class="comment">// 将栈顶的10存入slot0(i)中，i=10</span></span><br><span class="line">        <span class="number">3</span>: iload_0<span class="comment">// 将slot0中的10加载到栈顶</span></span><br><span class="line">        <span class="number">4</span>: istore_1<span class="comment">// 将栈顶的10存入slot1中</span></span><br><span class="line">        <span class="number">5</span>: bipush        <span class="number">20</span><span class="comment">// 将20压入栈顶，finally ---------------------</span></span><br><span class="line">        <span class="number">7</span>: istore_0<span class="comment">// 将栈顶的20存入slot0(i)中，i=20</span></span><br><span class="line">        <span class="number">8</span>: iload_1<span class="comment">// 将slot1中的10加载到栈顶，return -------------</span></span><br><span class="line">        <span class="number">9</span>: ireturn<span class="comment">// 返回栈顶元素10</span></span><br><span class="line">       <span class="number">10</span>: astore_2</span><br><span class="line">       <span class="number">11</span>: bipush        <span class="number">20</span></span><br><span class="line">       <span class="number">13</span>: istore_0</span><br><span class="line">       <span class="number">14</span>: aload_2</span><br><span class="line">       <span class="number">15</span>: athrow</span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            <span class="number">3</span>     <span class="number">5</span>    <span class="number">10</span>   any</span><br><span class="line">     LocalVariableTable:</span><br><span class="line">       Start  Length  Slot  Name   Signature</span><br><span class="line">           <span class="number">3</span>      <span class="number">13</span>     <span class="number">0</span>     i   I</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们通过分析以上代码，画出以下流程图：</p><pre class="mermaid">sequenceDiagram    participant e1 as 例1    participant e2 as 例2    Note over e1,e2 :将 10 入栈，栈[10]    Note over e1,e2 :将栈顶元素 10 存入 i，栈[ ]，i=10    e1 -> e2 :try 代码块    Note over e1,e2 :将 i=10 入栈，栈[10]    Note over e1,e2 :⚠️准备 return，但存在 finally 代码块，不能 return。将要返回的元素暂存    Note over e1,e2 :将栈顶元素 10 存入本地变量表中，栈[ ]    e1 -> e2 :finally 代码块    Note over e1,e2 :将 20 入栈，栈[20]    Note over e1,e2 :将栈顶元素 20 存入 i，栈[ ]，i=20    Note over e1 :将 i=20 入栈，栈[20]    Note over e1 :ireturn 栈顶元素 20    Note over e1 :程序结束 ❌    e1 -> e2 :finally 代码块结束，回到 try 中的 return    Note over e2 :恢复 return，将之前暂存的 10 入栈，栈[10, 20]    Note over e2 :ireturn 栈顶元素 10    Note over e2 :程序结束 ❌</pre><blockquote><p>注意⚠️：</p><ul><li>由上我们可知，在 <code>try - catch - finally</code> 代码块中，<code>try</code> 中的 <code>return</code> 会因为 <code>finally</code> 代码块而被“打断”，从而需要暂存，以保护返回的值。</li></ul></blockquote><h4 id="2-10-synchronized-代码块分析"><a href="#2-10-synchronized-代码块分析" class="headerlink" title="2.10 synchronized 代码块分析"></a>2.10 <code>synchronized</code> 代码块分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoSynchronized</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;LOCK!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其字节码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: (<span class="number">0x0009</span>) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span><span class="comment">// new Object</span></span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         <span class="number">4</span>: invokespecial #<span class="number">1</span><span class="comment">// 调用构造方法 &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">7</span>: astore_1<span class="comment">// lock对象的引用 -存到-&gt; slot1(lock) 中</span></span><br><span class="line">         <span class="number">8</span>: aload_1<span class="comment">// lock引用加载到栈[lock_ref]【synchronized开始】</span></span><br><span class="line">         <span class="number">9</span>: dup<span class="comment">// 复制，栈[lock_ref, lock_ref]</span></span><br><span class="line">        <span class="number">10</span>: astore_2<span class="comment">// 栈顶lock对象的引用lock_ref -存到-&gt; slot2 中，栈[lock_ref]</span></span><br><span class="line">        <span class="number">11</span>: monitorenter<span class="comment">// 加锁，栈[]</span></span><br><span class="line">        <span class="number">12</span>: getstatic     #<span class="number">3</span><span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">        <span class="number">15</span>: ldc           #<span class="number">4</span><span class="comment">// String LOCK!</span></span><br><span class="line">        <span class="number">17</span>: invokevirtual #<span class="number">5</span><span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">        <span class="number">20</span>: aload_2<span class="comment">// 将slot2的lock_ref加载到栈，栈[lock_ref]</span></span><br><span class="line">        <span class="number">21</span>: monitorexit<span class="comment">// 解锁，栈[]</span></span><br><span class="line">        <span class="number">22</span>: goto          <span class="number">30</span></span><br><span class="line">        <span class="number">25</span>: astore_3<span class="comment">// 若出现异常，将异常对象的引用存入slot3</span></span><br><span class="line">        <span class="number">26</span>: aload_2<span class="comment">// 将slot2的lock_ref加载到栈，栈[lock_ref]</span></span><br><span class="line">        <span class="number">27</span>: monitorexit<span class="comment">// 解锁，栈[]</span></span><br><span class="line">        <span class="number">28</span>: aload_3<span class="comment">// 将slot3中异常对象的引用加载到栈，栈[exception_ref]</span></span><br><span class="line">        <span class="number">29</span>: athrow<span class="comment">// 抛出异常</span></span><br><span class="line">        <span class="number">30</span>: <span class="keyword">return</span></span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">            <span class="number">12</span>    <span class="number">22</span>    <span class="number">25</span>   any</span><br><span class="line">            <span class="number">25</span>    <span class="number">28</span>    <span class="number">25</span>   any</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">31</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">8</span>      <span class="number">23</span>     <span class="number">1</span>  lock   Ljava/lang/Object;</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注意 ⚠️</p><ul><li>方法级别的 <code>synchronized</code> 不会体现在字节码指令中</li></ul></blockquote><h3 id="3-编译期处理"><a href="#3-编译期处理" class="headerlink" title="3 编译期处理"></a>3 编译期处理</h3><p>所谓的<strong><em><u>语法糖</u></em></strong>，其实就是指 java编译器把 <code>.java 源码</code>编译为 <code>.class 字节码</code> 的过程中，自动生成和转换的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利。</p><blockquote><p>注意⚠️</p><p>以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 <code>jclasslib</code> 等工具。另外，编译器转换的结果直接就是 <code>class 字节码</code>，只是为了便于阅读，给出了几乎等价 的 java 源码方式，并不是编译器还会转换出中间的 java 源码，切记。</p></blockquote><h4 id="3-1-默认构造器"><a href="#3-1-默认构造器" class="headerlink" title="3.1 默认构造器"></a>3.1 默认构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Constructor</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译成 <code>.class</code> 后的等效代码为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Constructor</span> &#123;</span><br><span class="line">  <span class="comment">// 这个无参构造是编译器帮助我们加上的</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Constructor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();<span class="comment">// 即调用父类 Object 的无参构造方法，即调用 java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-自动拆装箱"><a href="#3-2-自动拆装箱" class="headerlink" title="3.2 自动拆装箱"></a>3.2 自动拆装箱</h4><p>这个特性是 JDK5 开始加入的，如下代码举例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BoxingUnboxing</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码在 JDK5 以前的版本是不能通过编译的，基本类型和包装类型还不能自动转化。必须改写成如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BoxingUnboxing</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> Integer.valueOf(<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x.intValue();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显然代码太麻烦了，需要在<u>基本类型</u>和包装类型之间来回转换（尤其是集合类中操作的都是包装类型），因此这些转换的事情在 JDK 5以后都<strong><em><u>由编译器在编译阶段完成</u></em></strong>。即代码片段 1 都会在编译阶段被转换为代码片段 2。</p><h4 id="3-3-范型集合取值"><a href="#3-3-范型集合取值" class="headerlink" title="3.3 范型集合取值"></a>3.3 范型集合取值</h4><p><strong><em><u>泛型</u></em></strong> 也是在 JDK5 开始加入的特性，但 java 在编译泛型代码后会执行<strong><em><u>泛型擦除</u></em></strong>的动作，即<strong>泛型信息在编译为字节码之后就丢失了，实际的类型都当做了 object 类型来处理</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoGeneric</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">10</span>); <span class="comment">// 实际调用的是 List.add(Object o);</span></span><br><span class="line">      </span><br><span class="line">        <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> list.get(<span class="number">0</span>); <span class="comment">// 实际是 Object o = list.get(int index);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以在取值时，编译器真正生成的字节码中，还要额外做一个类型转换的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要将 object 转为 Integer</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> (Integer)list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>如果前面的 <code>x</code> 变量类型修改为 <code>int</code> 基本类型那么最终生成的字节码是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要将 object 转为 Integer，并执行拆箱操作</span></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> ((Integer)list.get(<span class="number">0</span>)).intValue()；</span><br></pre></td></tr></table></figure><p>在 JDK5 以后，以上操作在编译期间自动完成了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: (<span class="number">0x0009</span>) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span><span class="comment">// class java/util/ArrayList</span></span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         <span class="number">4</span>: invokespecial #<span class="number">3</span><span class="comment">// Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">7</span>: astore_1</span><br><span class="line">         <span class="number">8</span>: aload_1</span><br><span class="line">         <span class="number">9</span>: bipush        <span class="number">10</span></span><br><span class="line">        <span class="number">11</span>: invokestatic  #<span class="number">4</span><span class="comment">// Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span></span><br><span class="line">        <span class="number">14</span>: invokeinterface #<span class="number">5</span>,  <span class="number">2</span><span class="comment">// InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z</span></span><br><span class="line">        <span class="number">19</span>: pop</span><br><span class="line">        <span class="number">20</span>: aload_1</span><br><span class="line">        <span class="number">21</span>: iconst_0</span><br><span class="line">        <span class="number">22</span>: invokeinterface #<span class="number">6</span>,  <span class="number">2</span><span class="comment">// InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;</span></span><br><span class="line">        <span class="number">27</span>: checkcast     #<span class="number">7</span><span class="comment">// class java/lang/Integer 强制类型转化，Object -&gt; Integer</span></span><br><span class="line">        <span class="number">30</span>: astore_2</span><br><span class="line">        <span class="number">31</span>: <span class="keyword">return</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">32</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">8</span>      <span class="number">24</span>     <span class="number">1</span>  list   Ljava/util/List;</span><br><span class="line">           <span class="number">31</span>       <span class="number">1</span>     <span class="number">2</span>     x   Ljava/lang/Integer;</span><br><span class="line">      LocalVariableTypeTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">8</span>      <span class="number">24</span>     <span class="number">1</span>  list   Ljava/util/List&lt;Ljava/lang/Integer;&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>擦除的是字节码上的泛型信息，可以看到 <code>LocalVariableTypeTable</code> 仍然保留了方法参数泛型的信息。可以供类型转换时使用。</p><h4 id="3-4-可变参数"><a href="#3-4-可变参数" class="headerlink" title="3.4 可变参数"></a>3.4 可变参数</h4><p>在 Java 5 中提供了变长参数，允许在调用方法时传入不定长度的参数。变长参数是 Java 的一个语法糖，本质上还是基于数组的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(String... args)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(String[] args)</span>;</span><br></pre></td></tr></table></figure><p>在定义方法时，在最后一个形参后加上三点 <strong>…</strong>，就表示该形参可以接受多个参数值，多个参数值被当成数组传入。上述定义有几个要点需要注意：</p><ul><li><p>可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数</p></li><li><p>由于可变参数必须是最后一个参数，所以一个函数最多只能有一个可变参数</p></li><li><p>Java 的可变参数，会被编译器转型为一个数组</p></li><li><p>变长参数在编译为字节码后，在方法签名中就是以数组形态出现的。这两个方法的签名是一致的，不能作为方法的重载。如果同时出现，是不能编译通过的。可变参数可以兼容数组，反之则不成立</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(String...varargs)</span>&#123;&#125;</span><br><span class="line">foo(<span class="string">&quot;arg1&quot;</span>, <span class="string">&quot;arg2&quot;</span>, <span class="string">&quot;arg3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//上述过程和下面的调用是等价的</span></span><br><span class="line">foo(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;arg1&quot;</span>, <span class="string">&quot;arg2&quot;</span>, <span class="string">&quot;arg3&quot;</span>&#125;);</span><br></pre></td></tr></table></figure></li></ul><h4 id="3-5-foreach-循环"><a href="#3-5-foreach-循环" class="headerlink" title="3.5 foreach 循环"></a>3.5 <code>foreach</code> 循环</h4><p><code>foreach</code> 语句是 java5 的新特征之一，在遍历数组、集合方面，<code>foreach</code> 为开发人员提供了极大的方便。</p><p><code>foreach</code> 语法格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(type 元素变量x : 遍历对象obj)&#123; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>以下实例演示了<u><strong><em>数组</em></strong></u>的 <code>for</code> 和 <code>foreach</code> 循环使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoForeach</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] intary = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;; <span class="comment">// int[] intary = new int[]&#123;1,2,3,4&#125;;</span></span><br><span class="line">        forDisplay(intary);</span><br><span class="line">        foreachDisplay(intary);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">forDisplay</span><span class="params">(<span class="type">int</span>[] a)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foreachDisplay</span><span class="params">(<span class="type">int</span>[] data)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a : data) &#123;</span><br><span class="line">            System.out.print(a+ <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于<strong><em><u>集合</u></em></strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoForeach</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">      <span class="keyword">for</span> (Integer i : list) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际被编译器转换为对<strong><em><u>迭代器</u></em></strong>的调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoForeach</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">      <span class="type">Iterator</span> <span class="variable">iter</span> <span class="operator">=</span> list.iterator();</span><br><span class="line">      <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> (Integer) iter.next();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-6-switch-字符串"><a href="#3-6-switch-字符串" class="headerlink" title="3.6 switch 字符串"></a>3.6 <code>switch</code> 字符串</h4><p>从 JDK 7开始，<code>switch</code> 可以作用于字符串和枚举类，这个功能其实也是语法糖，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoSwitch</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span>(str) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;hello&quot;</span>: &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello &quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;world&quot;</span>: &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;World!&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>⚠️注意</p><p><code>switch</code> 配合 <code>string</code> 和 <code>enum</code> 使用时，变量不能为 <code>null</code></p></blockquote><p>会被编译器转换为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoSwitch</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">x</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">switch</span>(str.hashCode()) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">99162322</span>: &#123;<span class="comment">// hello 的hashCode</span></span><br><span class="line">        <span class="keyword">if</span> (str.equals(<span class="string">&quot;Hello &quot;</span>)) &#123;</span><br><span class="line">          x = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">case</span> <span class="number">113318802</span>: &#123;<span class="comment">// world 的hashCode</span></span><br><span class="line">        <span class="keyword">if</span> (str.equals(<span class="string">&quot;World!&quot;</span>)) &#123;</span><br><span class="line">          x = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span>(x) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello &quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;World!&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，执行了两遍 <code>switch</code>，第一遍是根据字符串的 <code>hashCode()</code> 和 <code>equals()</code> 将字符串的转换为相应 <code>byte</code> 类型，第二遍才是利用 <code>byte</code> 执行进行比较。</p><blockquote><p>为什么第一遍时必须既比较 <code>hashCode</code>，又利用 <code>equals</code> 比较呢？</p><p>hashcode 是为了提高效率，减少可能的比较；而 <code>equals</code> 是为了防止 <code>hashCode</code> 冲突，例如 <code>&quot;EM&quot;</code> 和 <code>&quot;C.&quot;</code> 这两个字符串的 <code>hashCode</code> 值都是 <code>2123</code>。</p></blockquote><h4 id="3-7-switch-枚举"><a href="#3-7-switch-枚举" class="headerlink" title="3.7 switch 枚举"></a>3.7 <code>switch</code> 枚举</h4><p><code>switch</code> 枚举的例子如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Gender</span> &#123;</span><br><span class="line">    MALE, FEMALE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoSwitchEnum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span> <span class="params">(Gender g)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (g) &#123;</span><br><span class="line">            <span class="keyword">case</span> MALE:</span><br><span class="line">                System.out.println(<span class="string">&quot;MALE&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> FEMALE:</span><br><span class="line">                System.out.println(<span class="string">&quot;FEMALE&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转换后代码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoSwitchEnum</span> &#123;</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 定义一个合成类（仅jvm 使用，对我们不可见）</span></span><br><span class="line"><span class="comment">  * 用来映射枚举的 ordinal 与数组元素的关系</span></span><br><span class="line"><span class="comment">  * 枚举的 ordinal 表示枚举对象的序号，从0开始</span></span><br><span class="line"><span class="comment">  * 即 MALE 的ordinal()=0, FEMALE的ordinal()=1</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">$MAP</span> &#123;</span><br><span class="line">      <span class="comment">// 数组大小即为枚举元素个数，里面存储case用来对比的数字</span></span><br><span class="line">      <span class="keyword">static</span> <span class="type">int</span>[] map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">      <span class="keyword">static</span> &#123;</span><br><span class="line">        map[Gender.MALE.ordinal()] = <span class="number">1</span>;</span><br><span class="line">        map[Gender.FEMALE.ordinal()] = <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span> <span class="params">(Gender g)</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> $MAP.map[g.ordinal()];</span><br><span class="line">        <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;MALE&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;FEMALE&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-类加载阶段"><a href="#4-类加载阶段" class="headerlink" title="4 类加载阶段"></a>4 类加载阶段</h3><h4 id="4-1-加载"><a href="#4-1-加载" class="headerlink" title="4.1 加载"></a>4.1 加载</h4><ul><li><p>在 Java 类编译成字节码以后，在运行时通过<strong><em><u>类加载器</u></em></strong> 将类的字节码加载到<strong><em><u>方法区</u></em></strong> 中，内部采用 C++ 的<code>instanceKlass</code> 描述 Java 类，它的重要 field 有：</p><ul><li><p><code>_java_mirror</code> 即 Java 的类镜像，例如对 <code>String</code> 来说，就是 <code>String.class</code>，作用是把 <code>instanceKlass</code> 暴露给 Java 使用。对 <code>String</code> 来说， <u><code>String.class</code> 就是 <code>instanceKlass</code> 的类镜像</u>，它们两者间相互持有对方的指针。</p></li><li><p><code>_super</code> 即父类</p></li><li><p><code>_fields</code> 即成员变量</p></li><li><p><code>_methods</code> 即方法</p></li><li><p><code>_constants</code> 即常量池</p></li><li><p><code>_class_loader</code> 即类加载器</p></li><li><p><code>_vtable</code> 虚方法表</p></li><li><p><code>_itable</code> 接口方法表</p></li></ul></li><li><p>如果这个类还有父类没有加载，先加载父类</p></li><li><p>加载和链接可能是交替运行的</p></li></ul><blockquote><p>注意 ⚠️</p><ul><li><code>instanceKlass</code> 这样的“元数据”是存储在方法区（JDK 1.8 后是元空间），但 <code>_java_mirror</code> 是存储在队中的</li><li>可以通过 HSDB 工具查看</li></ul></blockquote><p><img src="/2022/03/22/JVM-1/image-20220823212538798.png" alt="image-20220823212538798" style="zoom:50%;"></p><h4 id="4-2-链接"><a href="#4-2-链接" class="headerlink" title="4.2 链接"></a>4.2 链接</h4><h6 id="1-验证"><a href="#1-验证" class="headerlink" title="(1) 验证"></a>(1) 验证</h6><p>验证 <code>.class</code> 文件是否符合 JVM 的规范，安全性检查。例如如果我们修改 <code>.class</code> 文件的字节码，JVM 会在加载过后验证类的规范性。如果不符合规范，则会报错。</p><h6 id="2-准备"><a href="#2-准备" class="headerlink" title="(2) 准备"></a>(2) 准备</h6><p>准备：为 <code>static</code> 静态变量分配空间，设置默认值</p><ul><li><p><code>static</code> 变量在 JDK 1.7 之前存储于 <code>instanceKlass</code> 末尾，从 JDK 1.7 开始，存储于 <code>_java mirror</code> 末尾</p></li><li><p><code>static</code> 变量分配空间和赋值是两个步骤，分配空间在<u>准备阶段</u>完成，赋值在<u>初始化阶段</u>完成</p></li><li><p>如果 <code>static</code> 变量是 <code>final</code> 的基本类型，那么<u>编译阶段</u>值就确定了，赋值在<u>准备阶段</u>完成</p></li><li><p>如果 <code>static</code> 变量是 <code>final</code> 的，但属于引用类型，那么赋值也会在初始化阶段完成。</p><p>因为引用一个新对象 <code>new Object()</code> 的时候，新对象引用的创建需要在堆中完成，所以需要在初始化阶段赋值。</p></li></ul><h6 id="3-解析"><a href="#3-解析" class="headerlink" title="(3) 解析"></a>(3) 解析</h6><p>将常量池中的符号引用，解析为直接引用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ClassLoad;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="type">D</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">D</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoLoad</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IOException &#123;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> DemoLoad.class.getClassLoader();</span><br><span class="line">        Class&lt;?&gt; c = classLoader.loadClass(<span class="string">&quot;ClassLoad.C&quot;</span>); <span class="comment">// loadClass() 不会导致类的解析和初始化</span></span><br><span class="line">        <span class="comment">// new C();</span></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>个人理解：在上述例子中，我们在通过 <code>loadClass()</code> 加载类的时候，由于 <code>C</code> 类不会被初始化，所以 <code>C</code> 类中引用的 <code>D</code> 类不会被加载，而是只是作为一个“<code>class ClassLoad.D</code>” 存在常量池中，并不是一个类。此所谓“符号引用”，“直接引用”则是 <code>D</code> 类也被加载，有了地址，此时引用的就是一个真实的类了。</p></blockquote><h4 id="4-3-初始化"><a href="#4-3-初始化" class="headerlink" title="4.3 初始化"></a>4.3 初始化</h4><p>初始化就是调用 <code>&lt;clinit&gt;()V</code>，虚拟机会保证这个<strong><em><u>类的构造方法</u></em></strong>的线程安全。</p><p>那么何时初始化呢？概括得说，类初始化是【懒情的】</p><ul><li><u><code>main</code> 方法</u>所在的类，总会被首先初始化</li><li>首次访问这个类的<u>静态变量或静态方法</u>时</li><li>子类初始化，会引发父类的初始化</li><li>子类访问父类的静态变量，只会触发父类的初始化</li><li>执行 <code>Class.forName</code> 时</li><li><code>new</code> 一个对象的时候，会导致该对象的初始化</li></ul><p>不会导致类初始化的情况</p><ul><li>访问类的 <code>static final</code> <u>静态常量</u>（<u>基本类型和字符串</u>） 不会触发初始化</li><li><code>xxx.class</code> 不会触发该类的初始化</li><li>创建该类的数组不会触发初始化</li><li>类加载器的 <code>loadClass</code> 方法</li><li><code>Class.forName</code> 的<code>参数2</code>为 <code>false</code> 时</li></ul><h4 id="4-4-练习"><a href="#4-4-练习" class="headerlink" title="4.4 练习"></a>4.4 练习</h4><h6 id="1"><a href="#1" class="headerlink" title="(1)"></a>(1)</h6><p>从字节码分析，使用 <code>a, b, c</code> 这三个常量是否会导致 <code>E</code> 初始化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ClassLoad;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoLoad2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(E.a); <span class="comment">// 不会</span></span><br><span class="line">        System.out.println(E.b); <span class="comment">// 不会</span></span><br><span class="line">        System.out.println(E.c); <span class="comment">// 会</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">20</span>; <span class="comment">// Integer.valueOf(20);</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init E&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">   descriptor: ()V</span><br><span class="line">   flags: (<span class="number">0x0008</span>) ACC_STATIC</span><br><span class="line">   Code:</span><br><span class="line">     stack=<span class="number">2</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">        <span class="number">0</span>: bipush        <span class="number">20</span></span><br><span class="line">        <span class="number">2</span>: invokestatic  #<span class="number">2</span>                  <span class="comment">// Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span></span><br><span class="line">        <span class="number">5</span>: putstatic     #<span class="number">3</span>                  <span class="comment">// Field c:Ljava/lang/Integer;</span></span><br><span class="line">        <span class="number">8</span>: getstatic     #<span class="number">4</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       <span class="number">11</span>: ldc           #<span class="number">5</span>                  <span class="comment">// String init E</span></span><br><span class="line">       <span class="number">13</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">       <span class="number">16</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure><h6 id="2"><a href="#2" class="headerlink" title="(2)"></a>(2)</h6><p>完成懒惰初始化单例模式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ClassLoad;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125; <span class="comment">// 限制构造方法，其他类不能使用该构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LazyHolder</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">SINGLETON</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;lazy holder init&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoLoad3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// Singleton.test();</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">singleton1</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">singleton2</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        System.out.println(singleton1 == singleton2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-类加载器"><a href="#5-类加载器" class="headerlink" title="5 类加载器"></a>5 类加载器</h3><p>在 JDK 中，类加载器有一定的层级关系。以 JDK 1.8 为例，从顶至底为：</p><div class="table-container"><table><thead><tr><th>名称</th><th>加载哪里的类</th><th>说明</th></tr></thead><tbody><tr><td><code>Bootstrap ClassLoader</code></td><td><code>JAVA_HOME/jre/lib</code></td><td>无法直接访问</td></tr><tr><td><code>Extension ClassLoader</code></td><td><code>JAVA_HOME/jre/lib/ext</code></td><td>上级为 <code>Bootstrap</code>，显示为 <code>null</code></td></tr><tr><td><code>Application ClassLoader</code></td><td><code>classpath</code></td><td>上级为 <code>Extension</code></td></tr><tr><td><code>自定义 ClassLoader</code></td><td>自定义</td><td>上级为 <code>Application</code></td></tr></tbody></table></div><ul><li>类加载器在加载类时需要分层级加载。例如 <code>Application ClassLoader</code> 加载类时会检查该类是否被上级类加载器加载，若没有，则再由 <code>Extension ClassLoader</code> 向上层检查。若都没有，则由 <code>Application ClassLoader</code> 加载。（双亲委派）</li></ul><h4 id="5-1-Bootstrap-ClassLoader"><a href="#5-1-Bootstrap-ClassLoader" class="headerlink" title="5.1 Bootstrap ClassLoader"></a>5.1 <code>Bootstrap ClassLoader</code></h4><p>用 <code>Bootstrap ClassLoader</code> 加载类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ClassLoad;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Klass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BootStrap ClassLoader Klass init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ClassLoad;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoBootstrapClassLoader</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; klass = Class.forName(<span class="string">&quot;ClassLoad.Klass&quot;</span>);</span><br><span class="line">        System.out.println(klass.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xbootclasspath/a:. ClassLoad.DemoBootstrapClassLoader</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BootStrap ClassLoader Klass init</span><br><span class="line">null</span><br></pre></td></tr></table></figure><h4 id="5-2-Extension-ClassLoader"><a href="#5-2-Extension-ClassLoader" class="headerlink" title="5.2 Extension ClassLoader"></a>5.2 <code>Extension ClassLoader</code></h4><p>还是上一节的例子，如果我们使用 <code>.jar</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar .cvf Test_Klass.jar ClassLoad/Klass.class</span><br></pre></td></tr></table></figure><p>将我们打包好的 <code>Test_Klass.class</code> 复制到 Java 安装目录下的 <code>JAVA_HOME/jre/lib/ext</code> 扩展目录下。重新运行程序，我们得到以下输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Extension ClassLoader Klass init</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@18b4aac2</span><br></pre></td></tr></table></figure><h4 id="5-3-双亲委派模式"><a href="#5-3-双亲委派模式" class="headerlink" title="5.3 双亲委派模式"></a>5.3 双亲委派模式</h4><p>所谓双亲委派，就是指调用类加载器的 <code>loadClass()</code> 方法时，查找上级类加载器是否已经加载该类的行为。</p><p>图解如下：</p><p><img src="/2022/03/22/JVM-1/image-20220824100940813.png" alt="image-20220824100940813" style="zoom:50%;"></p><h6 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">          <span class="comment">// 首先检查该类加载器是否已经加载</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                      <span class="comment">// 如果有上级</span></span><br><span class="line">                        c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                      <span class="comment">// 递归调用上级的loadClass()</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                      <span class="comment">// 如果没有上级了(ExtClassLoader)，则委派BootstrapClassLoader</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order to find the class.</span></span><br><span class="line">                    <span class="comment">// 如果每一层都找不到，调用findClass方法（每个类加载器自己扩展）来加载</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats 记录耗时</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="5-4-线程上下文类加载器"><a href="#5-4-线程上下文类加载器" class="headerlink" title="5.4 线程上下文类加载器"></a>5.4 线程上下文类加载器</h4><h4 id="5-5-自定义类加载器"><a href="#5-5-自定义类加载器" class="headerlink" title="5.5 自定义类加载器"></a>5.5 自定义类加载器</h4><p>需要自定义类加载器的场景：</p><ol><li>想加载非 classpath 随意路径中的类文件</li><li>都是通过接口来使用实现，希望解耦时，常用在框架设计</li><li>这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器</li></ol><p>【步骤】</p><ol><li>继承 <code>ClassLoader</code> 父类</li><li>要遵从<strong><em><u>双亲委派机制</u></em></strong>，重写 <code>findClass</code> 方法<ul><li>注意不是重写 <code>loadClass</code> 方法，否则不会走双亲委派机制</li></ul></li><li>读取类文件的字节码</li><li>调用父类的 <code>defineClass</code> 方法来加载类</li><li>使用者调用该类加载器的 <code>loadClass</code> 方法</li></ol><h3 id="6-运行期优化"><a href="#6-运行期优化" class="headerlink" title="6 运行期优化"></a>6 运行期优化</h3><h4 id="6-1-即时编译"><a href="#6-1-即时编译" class="headerlink" title="6.1 即时编译"></a>6.1 即时编译</h4><h5 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a>分层编译</h5><p>我们先考虑一下例子</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoJit1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">200</span>; i++)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j&lt;<span class="number">1000</span> ; j++) &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            System.out.println( i + <span class="string">&quot;\t&quot;</span> + (end-start));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span><span class="number">42542</span></span><br><span class="line">   ...</span><br><span class="line"><span class="number">70</span><span class="number">11958</span></span><br><span class="line"><span class="number">71</span><span class="number">4750</span></span><br><span class="line"><span class="number">72</span><span class="number">4041</span></span><br><span class="line"><span class="number">73</span><span class="number">4167</span></span><br><span class="line">   ...</span><br></pre></td></tr></table></figure><p>我们可以看到，JVM 在执行这些相同的代码时所用的时间并不相同。</p><p>原因是什么呢？</p><p>JVM将执行状态分成了 5个层次：</p><ul><li>0层，解释执行 I (Interpreter)</li><li>1层，使用 C1 即时编译器编译执行 （不带 profiling)</li><li>2层，使用 C1 即时编译器编译执行（带基本的 profiling）</li><li>3层，使用 C1 即时编译器编译执行（带完全的 profiling)</li><li>4层，使用 C2 即时编译器编译执行</li></ul><blockquote><p>profling 是指在运行过程中收集一些程序执行状态的数据，例如<strong><em><u>方法的调用次数</u></em></strong>，<u><strong><em>循环的回边次数</em></strong></u> 等</p></blockquote><p>即时编译器（JIT） 与解释器的区别</p><ul><li>解释器 是将字节码解释为机器码，下次即使遇到相同的字节码，仍会执行重复的解释</li><li>JIT 是将一些字节码编译为机器码，并存入 Code Cache， 下次遇到相同的代码，直接执行，无需再编译</li><li>解释器是将字节码解释为针对所有平台都通用的机器码</li><li>JIT 会根据平台类型，生成平台特定的机器码</li></ul><p>对于占据大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另<br>一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。执行效率上 Interpreter &lt; C1 &lt; C2。目的是为了发现那些热点代码，加以优化。</p><p>这一种优化手段我们称之为【逃逸分析】，发现新建的对象是否逃逸。可以使用如下指令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:-DoEscapeAnalysis</span><br></pre></td></tr></table></figure><p>关闭逃逸分析。</p><p>逃逸分析的作用：</p><p>经过逃逸分析的对象，可以直接在栈空间进行分配，而非堆空间。因为这样的对象不会在其他的方法中被引用，所以它可以被分配在当前栈上，可以随着栈消亡。从而极大的降低了 GC 次数，提升了程序整体的执行效率。</p><h5 id="方法内联-Inlining"><a href="#方法内联-Inlining" class="headerlink" title="方法内联 (Inlining)"></a>方法内联 (Inlining)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> i)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> i * i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果发现 <code>square()</code> 是<strong><em><u>热点方法</u></em></strong>，并旦<strong><em><u>长度不太长</u></em></strong>时，会进行内联，所谓的内联就是把方法内代码拷贝、粘贴到调用者的位置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">9</span> * <span class="number">9</span>):</span><br></pre></td></tr></table></figure><p>还能够进行常量折叠 (constant folding）的优化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">81</span>);</span><br></pre></td></tr></table></figure><p>实验：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoJit2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">600</span>; i++)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j&lt;<span class="number">1000</span> ; j++) &#123;</span><br><span class="line">                x = square(<span class="number">9</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            System.out.println( i + <span class="string">&quot;\t&quot;</span> + x + <span class="string">&quot;\t&quot;</span> + (end-start));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i * i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span><span class="number">81</span><span class="number">26792</span></span><br><span class="line">   ...</span><br><span class="line"><span class="number">78</span><span class="number">81</span><span class="number">6375</span></span><br><span class="line">   ...</span><br><span class="line"><span class="number">410</span><span class="number">81</span><span class="number">42</span></span><br><span class="line"><span class="number">411</span><span class="number">81</span><span class="number">0</span></span><br></pre></td></tr></table></figure><p>可以使用如下指令打印内联信息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:CompileCommand=doninline,包名.类名.方法名// 关闭方法的内联</span><br></pre></td></tr></table></figure><h5 id="JMH"><a href="#JMH" class="headerlink" title="JMH"></a>JMH</h5><p>JMH(Java Microbenchmark Harness)是用于代码微基准测试的工具套件，主要是基于方法层面的基准测试，精度可以达到纳秒级。当你定位到热点方法，希望进一步优化方法性能的时候，就可以使用 JMH 对优化的结果进行量化的分析。</p><p>JMH 比较典型的应用场景如下：</p><ol><li>想准确地知道某个方法需要执行多长时间，以及执行时间和输入之间的相关性</li><li>对比接口不同实现在给定条件下的吞吐量</li><li>查看多少百分比的请求在多长时间内完成</li></ol><p>关于 JMH 工具的具体运用，恕在此不作详解。</p><h2 id="五、JMM-内存模型"><a href="#五、JMM-内存模型" class="headerlink" title="五、JMM 内存模型"></a>五、JMM 内存模型</h2><p>本章节内容单独记录，点击链接以跳转</p><p><a href="https://dave0126.github.io/2022/08/26/JMM-Java-内存模型/">链接：JMM - Java 内存模型</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;JVM-基础学习&quot;&gt;&lt;a href=&quot;#JVM-基础学习&quot; class=&quot;headerlink&quot; title=&quot;JVM 基础学习&quot;&gt;&lt;/a&gt;JVM 基础学习&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#一、JVM-结构&quot;&gt;第一章：JVM 结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#二、JVM-内存结构&quot;&gt;第二章：JVM 内存结构&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#三、JVM-垃圾回收&quot;&gt;第三章：JVM 垃圾回收&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#四、类加载与字节码技术&quot;&gt;第四章：类加载与字节码技术&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;【参考资料】&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;视频课程：&lt;a href=&quot;https://www.bilibili.com/video/BV1yE411Z7AP&quot;&gt;BiliBili - 黑马程序员 JVM 完整教程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://docs.oracle.com/javase/specs/jvms/se8/html/index.html&quot;&gt;The Java® Virtual Machine Specification - Java SE 8 Edition 官方文档&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Java" scheme="https://dave0126.github.io/categories/Java/"/>
    
    
    <category term="Java" scheme="https://dave0126.github.io/tags/Java/"/>
    
    <category term="JVM" scheme="https://dave0126.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>图论 复习笔记</title>
    <link href="https://dave0126.github.io/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/"/>
    <id>https://dave0126.github.io/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/</id>
    <published>2022-01-16T13:08:24.000Z</published>
    <updated>2022-07-05T18:38:22.483Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><a href="https://dave0126.github.io/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/">本文章</a>是根据法国国立高等电力技术、电子学、计算机、水力学与电信学校 (E.N.S.E.E.I.H.T.) 第七学期课程<em>“Graph Theory”</em> 总结而来的课程笔记。碍于本人学识有限，部分叙述难免存在纰漏，请读者注意甄别。</p><span id="more"></span><h3 id="第一部分：基本概念及定义"><a href="#第一部分：基本概念及定义" class="headerlink" title="第一部分：基本概念及定义"></a>第一部分：基本概念及定义</h3><h4 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h4><h5 id="图"><a href="#图" class="headerlink" title="图"></a>图</h5><p>一个有限图 $G = (V,E)$ 由<strong>非空</strong>(non vide) <strong>有限</strong>(fini) <strong>顶点集</strong> (sommets / vertex) $V$</p><script type="math/tex; mode=display">V = \{ v_0, v_1,...,v_{n-1}\}</script><p>和<strong>有限边集</strong>(Arête / Edge) $E$ 组成。</p><script type="math/tex; mode=display">E = \{ e_0, e_1,...,e_{n-1}\}</script><p>其中，每个<strong>边</strong>由一对<strong>顶点</strong> $\{ v_i, v_j\}$ 构成。<strong>顶点数</strong>又被称为图的<strong>阶数</strong>(ordre)。</p><p><strong>相关概念：</strong></p><ul><li>如果 $n = nb(V)$，那么我们称该图 $G = (V,E)$ 是一个 <strong>$n阶图$ (ordre)</strong>;</li><li>如果 $e = \{v_i, v_j\}$，我们说边 $e$ 与顶点 $v_i$ 和  $v_j$ <strong>相关 (incidente)</strong>;</li><li>如果 $e = \{v_i,v_j\}$，我们说 $v_i$ 和 $v_j$ 是<strong>邻接的 (adjacents)</strong>;</li><li>两条<strong>边</strong>是<strong>相邻</strong>的当且仅当它们有一个<strong>共同的顶点</strong>;</li><li>$e = \{v_i, v_i\}$ 是一个<strong>环 (boucle)</strong>;</li><li>两个节点之间可能有多条边的图称为<strong>多重图 (multigraphe)</strong>。</li><li>一个图是<strong>简单的 (simple)</strong>，当且仅当<ul><li>没有<strong>环 (boucle)</strong>，</li><li>两个顶点之间最多有一条边 (无重边);</li></ul></li><li>一个顶点在图中的<strong>度</strong> (<strong>degree</strong>) $δ(v_i)$ 为 与这个顶点 $v_i$ 相<strong>连接的边的数目</strong>;</li><li>如果每个顶点彼此相邻，即每两个顶点间都有边相连，则称该图是<strong>完全(complet)</strong>图;</li></ul><blockquote><p>Q1 : n阶简单完全图的边数是多少？</p><script type="math/tex; mode=display">\# E(n阶简单完全图) = \tfrac{n(n-1)}{2}</script></blockquote><ul><li>无向图中，所有顶点度数之和 $∑deg(v)=2|E|$，即<strong>奇数度的顶点数必是偶数</strong>。</li></ul><blockquote><p>思考：一种“从无到有”的推广假设</p><ol><li>连接两个偶度顶点，这个时候奇度顶点的数量增加2；</li><li>连接两个奇度顶点，这个时候奇度顶点的数量减少2；</li><li>连接一个奇度顶点和一个偶度顶点，奇度顶点的数量不变。</li></ol></blockquote><ul><li><strong>$k$-正则图 (k-regulier)</strong>是指所有顶点的度都为 $k$ 的图;</li></ul><h4 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h4><p>如果一个图 $G = (V,E)$ 的点对(或边)是有序的，那么图 $G$ 就是<strong>有向的(orienté)</strong>。</p><p><strong>相关概念：</strong></p><ul><li>在一个有向弧 $e =(i,j)$ 中，$i$ 被称为 $e$ 的起点(l’origine), $j$ 是 $e$ 的终点( l’arrivée);</li><li>对于顶点$v$，<strong>出度</strong> $δ^+(v)$ 是以 $v$ 为起点的弧的数量;</li><li><strong>入度</strong> $δ^−(v)$ 是以 $v$ 为终点的弧的数量;</li><li>总度数 $δ(v) = δ^+(v) + δ^−(v)$ , $∑_{v \in V} δ(v) = 2 \times nb(E)$。</li></ul><h4 id="子图（sous-graphe）"><a href="#子图（sous-graphe）" class="headerlink" title="子图（sous-graphe）"></a>子图（sous-graphe）</h4><p>由图 $G = (V,E)$ 的顶点 $V$的子集 $V ‘ ⊂ V$ 生成的 $G’ = (V’ , E’ )$ 是 $G$ 的子图。其中 $E’$ 表示 $E$ 的两个端点都在 $V’$ 中的所有边。</p><script type="math/tex; mode=display">G=(V,E) \quad \stackrel{V'⊂V} \longrightarrow \quad G'=(V',E')</script><ul><li>子图：点和边都能在原图中找到</li><li>母图：原图</li><li>真子图：不等于母图的子图</li><li>生成子图：包含所有顶点的子图</li><li>基础简单图：从一个图中去掉所有重边及环后所得的剩余图称为基础简单图</li><li>点导出子图：顶点是原图顶点的子集且加入两端都在子集中的边构成的图</li><li>边导出子图：由原图边集的子集及其所有端点构成的图</li></ul><h5 id="完全子图"><a href="#完全子图" class="headerlink" title="完全子图"></a>完全子图</h5><script type="math/tex; mode=display">IF(子图 \; is\; 完全图)\quad THEN(完全子图)</script><h5 id="团（clique）"><a href="#团（clique）" class="headerlink" title="团（clique）"></a>团（clique）</h5><p>$G$ 的完全子图是 $G$ 的团，当且仅当 $G’$ 不包含在 $G$ 的更大的完全子图中，也就是说 $G’$ 是 $G$ 的极大完全子图。</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-16 16.15.46.png" alt="2022-04-16 16.15.46" style="zoom:40%;"></p><p>由上图所示，1 和 2 就是原图的两个团。其中 1 是最大团。</p><h5 id="最大团"><a href="#最大团" class="headerlink" title="最大团"></a>最大团</h5><p>$G$ 的最大团是指 $G$ 的所有团中，含顶点数最大的团，比如说 1 就是最大团。</p><h4 id="部分图（graphe-partiel）"><a href="#部分图（graphe-partiel）" class="headerlink" title="部分图（graphe partiel）"></a>部分图（graphe partiel）</h4><p>由 $E’ ⊂ E$ 生成的 $G = (V,E)$ 的部分图是图 $G’= (V,E’)$。</p><script type="math/tex; mode=display">G=(V,E) \quad \stackrel{E'⊂E} \longrightarrow \quad G'=(V,E')</script><h4 id="关联矩阵（matrice-d’incidence）"><a href="#关联矩阵（matrice-d’incidence）" class="headerlink" title="关联矩阵（matrice d’incidence）"></a>关联矩阵（matrice d’incidence）</h4><p>设任意图 $G=(V,E)$，其中顶点集 $V=v_1,v_2,…,v_n$，边集 $E=e_1,e_2,…,e_ε$。用 $m_{ij}$ 表示顶点 $v_i$ 与边 $e_j$ 关联的次数，可能取值为 $0,1,2,…$，称所得矩阵 $\mathcal{M}(G)=(m_{ij})_{n×ε}$ 为图G的<strong>关联矩阵</strong></p><p>类似地，有向图 $D$ 的关联矩阵 $\mathcal{M}(D)=(m_{ij})_{n×ε}$的元素 $m_{i×j}$定义为：</p><script type="math/tex; mode=display">m_{ij}=\begin{cases}1 \qquad v_i是有向边a_j的始点\\-1 \qquad v_i是有向边a_j的终点\\0 \qquad v_i是有向边a_j的不关联点\end{cases}</script><h4 id="邻接矩阵（matrice-d’adjacence）"><a href="#邻接矩阵（matrice-d’adjacence）" class="headerlink" title="邻接矩阵（matrice d’adjacence）"></a>邻接矩阵（matrice d’adjacence）</h4><p>设无向图 $G=(V,E)$ ，其中顶点集$V=v_1,v_2,…,v_n$，边集 $E=e_1,e_2,…,e_ε$。用 $a_{ij}$ 表示顶点 $v_i$ 与顶点 $v_j$ 之间的边数，可能取值为 $0,1,2,…$，称所得矩阵 $A=A(G)=(a_{ij})_{n×n}$ 为图$G$ 的邻接矩阵</p><p><strong>若干性质：</strong></p><ul><li>$\mathcal{A}(G)$ 为对称矩阵</li><li>若 $G$ 为无环图，则 $\mathcal{A}(G)$ 中第 $i$ 行（列）的元素之和等于顶点 $v_i$ 的度</li><li>两图 $G$ 和 $H$ <strong>同构</strong>的充要条件是存在置换矩阵 $\mathcal{P}$ 使得 $\mathcal{A}(G) = \mathcal{P}^T\mathcal{A}(H) \mathcal{P}$</li></ul><p>类似地，有向图 $D$ 的邻接矩阵$=\mathcal{A}(D)(a_{ij})_{n×n}$， $a_{ij}$ 表示从始点 $v_i$ 到终点 $v_j$ 的<strong>有向边的条数</strong>，其中 $v_i$ 和 $v_j$ 为 $D$ 的顶点。</p><blockquote><p>示例，求图中有向图的邻接矩阵和关联矩阵（图中边上的数字为<em>边的编号</em>，而非权重）：</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/4-tournament.svg.png" alt="4-tournament.svg" style="zoom:15%;"></p><p>邻接矩阵为：</p><script type="math/tex; mode=display">\begin{bmatrix}0 & 1 & 0 & 1\\0 & 0 & 0 & 1\\1 & 1 & 0 & 0\\0 & 0 & 1 & 0\end{bmatrix}</script><p>关联矩阵为：</p><script type="math/tex; mode=display">\begin{bmatrix}1 & 0 & 0 & -1 & 1 & 0\\-1 & 1 & 0 & 0 & 0 & -1\\0 & 0 & -1 & 1 & 0 & 1\\0 & -1 & 1 & 0 & -1 & 0\end{bmatrix}</script></blockquote><h4 id="加权图（graphe-pondere）"><a href="#加权图（graphe-pondere）" class="headerlink" title="加权图（graphe pondéré）"></a>加权图（graphe pondéré）</h4><p>如果每条弧与<strong>正</strong>的实际权重 (poids) 相关联，则对图进行加权。</p><h3 id="第二部分：连通"><a href="#第二部分：连通" class="headerlink" title="第二部分：连通"></a>第二部分：连通</h3><h4 id="链（Chaine）"><a href="#链（Chaine）" class="headerlink" title="链（Chaîne）"></a>链（Chaîne）</h4><p>长度为 $q ∈ N$ 的链 $(e_1, …, e_q)$ 是 $q$ 个<strong>连续相邻边的序列</strong>。 因此存在一个顶点序列 $(v_1,…,v_{q+1})$，使得 $v_i$ 是 $e_{i-1}$ 和 $e_i$ 的端点。</p><p><strong>相关概念：</strong></p><ul><li>该链被称为连接 顶点 $v_1$ 和 $v_{q+1}$ 的链；</li><li><p><strong>简单链 (simple)</strong>：在边的序列中各边互不相同</p><ul><li>简单链也可称其为 <strong>迹</strong> (trace)</li></ul></li><li><p><strong>基本链 (élémentaire)</strong>：在顶点的序列中各顶点互不相同</p><ul><li>基本简单链可以称其为 <strong>路</strong> (chemin)：序列中的<strong>边</strong>和<strong>顶点</strong>都<strong>不相同</strong></li></ul></li><li><p>如果 $v_1 = v_{q+1}$，则链是<strong>闭合 (fermée)</strong>的；</p></li><li>$q$ 是链的长度。</li></ul><h4 id="环（Cycle）"><a href="#环（Cycle）" class="headerlink" title="环（Cycle）"></a>环（Cycle）</h4><ul><li><p>环是一个<strong>闭合 (fermée)</strong>的单链；</p></li><li><p>两个顶点间的<strong>距离 (Distance)</strong> 是两个顶点间<strong>最短链的长度</strong>；</p></li><li><p>图的<strong>直径 (Diamètre)</strong> 是图的两个顶点之间的<strong>最大距离</strong>。 如果有未连接的顶点，则为 $+∞$（连接性的定义在后面）。</p></li><li><p><u>无环图 $G$ <strong>最多</strong>有 $n-1$ 条边</u></p><blockquote><p>proof：</p><script type="math/tex; mode=display">\# E_{一般无环图} \le \# E_{无环连通图} = n-1</script></blockquote></li><li><p>如果遍历的顶点除了第一个和最后一个之外是互不相同的，则环是<strong>基本的 (élémentaire)</strong>。</p></li></ul><blockquote><p>​    例1：在下图的无向图中，</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-16 18.25.30.png" alt="截屏2022-04-16 18.25.30" style="zoom:30%;"></p><ol><li>链 $(1,2,5,1,3,5,1)$ 是一条<strong>非基本 (non-élémentaire) 闭合 (fermée) 链</strong></li><li>链 $(1,2,5,1,3,)$ 是一条<strong>非基本 (non-élémentaire) 非闭合 (non-fermée) 链</strong></li><li>基本环（基本闭合链）：$(1,2,5,1)$</li><li>非基本环（非基本闭合链）：$(1,2,5,1,3,5,4,1)$</li></ol><p>例2 ：在下图的有向图中，</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-16 18.36.59.png" alt="2022-04-16 18.36.59" style="zoom:33%;"></p><ol><li><strong>基本路径 (chemin: non-fermée)</strong> ：$(1,4,2,3)$</li><li>非基本路径：$(1,3,1,4)$</li><li>基本<strong>环 (circuit)</strong>：$(1,4,2,3,1)$</li><li>非基本<strong>环 (circuit)</strong>：$(1,3,1,4,2,1)$</li></ol></blockquote><h4 id="割点及割边"><a href="#割点及割边" class="headerlink" title="割点及割边"></a>割点及割边</h4><h5 id="割点"><a href="#割点" class="headerlink" title="割点"></a>割点</h5><p>【定义】设连通图 $G=(V,E)$ 中有 $v_i \in V$，如果 $G - v_i$ 的分支数大于 $G$ 的分支数，即在图 $G$ 中删去 $v_i$ 点后 $G$ 不再连通，则我们称 $v_i$ 是 $G$ 的一个割点。</p><ul><li><p>每个非平凡图至少有两个顶点不是割点</p><blockquote><p>证明：</p><p>由于 $G$ 是无环非平凡连通图，所以存在非平凡生成树．非平凡生成树至少两片树叶，它们不能为生成树的割点．显然，它们也不能为 $G$ 的割点．</p><p>注：非平凡树一定有割边，不一定有割点 ($K_2$).</p></blockquote></li><li><p>有割点的图不是哈密顿图</p></li></ul><p>【性质】设连通图 $G=(V,E)$ 中有 $v_i \in V$ ，则下列命题等价</p><ul><li>$v_i$ 是 $G$ 的一个割点</li><li>$∃ v_x,v_y \in V， v_x \ne v_y， v_x 与 v_y 间所有的路均通过 v_i$</li><li>（上一条的普遍推广）$∃ \; V \setminus \{v_i\} 的划分\{U,W\}(U \cap W = \emptyset)，使得\forall u \in U, \forall w \in W: u,w间的路均通过v_i$</li></ul><h5 id="割边（桥）"><a href="#割边（桥）" class="headerlink" title="割边（桥）"></a>割边（桥）</h5><p>设图 $G=(V,E)$ 中有 $e_i \in E$，如果 $G - e_i$ 的分支数大于 $G$ 的分支数，即在图 $G$ 中删去 $e_i$ 点后 $G$ 不再连通，则我们称 $e_i$ 是 $G$ 的一个割边，也称做桥。</p><p>【性质】设连通图 $G=(V,E)$ 中有 $e_i \in E$ ，则下列命题等价</p><ul><li>$e_i$ 是 $G$ 的一个割边</li><li>$∃ e_x,e_y \in E， e_x \ne e_y， e_x 与 e_y 间所有的路均”通过” e_i$</li><li>（上一条的普遍推广）$∃ \; E \setminus \{e_i\} 的划分\{U_E,W_E\}(U_E \cap W_E = \emptyset)，使得\forall u_e \in U, \forall w_e \in W: u_e,w_e间的路均”通过”e_i$</li><li>$e_i$ 不在 $G$ 的任何圈中</li></ul><h4 id="连通度"><a href="#连通度" class="headerlink" title="连通度"></a>连通度</h4><ul><li><p><strong>点连通度</strong>可描述为“<strong>使图不连通或成为平凡图，最少需要删去的点数</strong>”，记作 $\kappa (G)$</p></li><li><p><strong>边连通度</strong>可描述为“<strong>使图不连通或成为平凡图，最少需要删去的边数</strong>”，记作 $\lambda (G)$</p></li></ul><p>【性质】</p><ol><li>对于不连通或平凡图 $G$ ：$\kappa (G) = \lambda (G) = 0$</li><li>对于树 $T$：$\kappa (G) = \lambda (G) = 1$</li><li>对于有割点的图 $G$ ：$\kappa (G) = 1$</li><li>对于有割边（桥）的图 $G$ ：$\lambda (G) = 1$</li><li>对于完全图 $K_p$ ：$\kappa (G) = \lambda (G) = p-1$</li><li>$图G连通 \Leftrightarrow \kappa (G) \ge 1$</li><li>对于一个环（圈）$C_n, n ≥ 3$：$κ(C_n) = 2$</li></ol><p>除了 $\kappa (G)$ 和 $\lambda (G)$ 以外，图的最小度 $\delta (G)$ 也可以用来描述图 $G$ 的连通程度。即</p><script type="math/tex; mode=display">设 G 是 n 阶简单图，若 δ(G) ≥ ⌊\frac{n}{2}⌋，则 G 必连通，且 λ(G) = δ(G)．</script><blockquote><p>证明：</p><p>若 $G$ 不连通，则 $G$ 至少有两个连通分支，从而必有一个分支 H 满足</p><script type="math/tex; mode=display">|V(H)| ≤ ⌊\frac{n}{2}⌋</script><p>因 $G$ 是简单图，从而</p><script type="math/tex; mode=display">∆(H) ≤ ⌊\frac{n}{2}⌋ − 1 < ⌊\frac{n}{2}⌋</script><p>于是</p><script type="math/tex; mode=display">δ(G) ≤ δ(H) ≤ ∆(H) < ⌊\frac{n}{2}⌋</script><p>这与已知矛盾，所以 $G$ 必连通．</p></blockquote><p>【定理】对任意的图 $G=(V,E)$，有</p><script type="math/tex; mode=display">κ(G) ≤ λ(G) ≤ δ(G)</script><h4 id="连通图（Graphe-connexe）"><a href="#连通图（Graphe-connexe）" class="headerlink" title="连通图（Graphe connexe）"></a>连通图（Graphe connexe）</h4><ul><li><p>在一个<strong>无向图</strong> $G$ 中，若从顶点 ${ v_{i}}$ 到顶点 $v_{j}$ 有路径<strong>相连</strong>（当然从 $v_{j}$ 到 $ v_{i}$也一定有路径），则称$ v_{i}$ 和 $v_{j}$ 是<strong>连通 (connexe)</strong>的。</p><ul><li>如果 $G$ 是<strong>有向图</strong>，那么连接 $v_{i}$ 和 $v_{j}$ 的路径中所有的边都必须<strong>同向</strong>。</li></ul></li><li><p>如果图中<strong>任意两点都是连通的</strong>，那么图被称作<strong>连通图</strong>。图的连通性是图的基本性质。<strong>连通度</strong>是指为了让图分解成孤立的子图所要删除的顶点数的最小值。</p></li><li><p><u>设连通图 $G$ 有 $n$ 个顶点，则该图 $G$ <strong>至少</strong>有 $n-1$ 条边</u></p><blockquote><p>Proof:</p><p>A graph with $n$ vertices and no edge has $n$ components. Adding an edge reduces the number of components by <em>at most</em> one. So beginning with a graph with no edge, adding one edge at a time till the graph has $k$ edges results in reducing the number of components by <em>at most</em> $k$. Thus, a graph with $n$ vertices and $k$ edges has <em>at least</em> $n−k$ components. Hence every graph with $n$ vertices and fewer than $n-1$ edges has <em>at least</em> two components, and is disconnected. Therefore every connected graph with $n$ vertices must have <em>at least</em> $n-1$ edges; the path $P_n$ is an example of such a graph</p></blockquote></li></ul><h5 id="弱连通"><a href="#弱连通" class="headerlink" title="弱连通"></a>弱连通</h5><p>一个有向图被称作<strong>弱连通</strong>(<strong>weakly connected</strong>)的，如果将所有有向边替换为无向边之后的无向图是连通的，如果对于任意一对顶点 $u$ ，$v$，或者存在一条从 $u$ 到 $v$ 的有向路径，或者存在一条从 $u$ 到 $v$ 的有向路径，则该图是<strong>单连通</strong>(<strong>unilaterally conncected</strong>)的。</p><script type="math/tex; mode=display">对于任意一对顶点(u,v),\; 存在路径u \to v,\; 不存在路径v\to u</script><h5 id="强连通"><a href="#强连通" class="headerlink" title="强连通"></a>强连通</h5><p>如果对于如果对于任意一对顶点 $u$，$v$，同时存在一条从 $u$ 到 $v$ 的有向路径和一条从 $v$ 到 $u$ 的有向路径，则该图是<strong>强连通</strong>(<strong>strongly connected</strong>)的</p><script type="math/tex; mode=display">对于任意一对顶点(u,v),\; 存在路径u \to v,\; 且存在路径v\to u</script><h5 id="二元关系"><a href="#二元关系" class="headerlink" title="二元关系"></a>二元关系</h5><p>集合 $X$ 与集合 $Y$ 上的二元关系是 $\mathcal{R}=(X,Y,G(\mathcal{R}))$，其中 $G(\mathcal{R})$，称为 $\mathcal{R}$ 的<strong>图</strong>，是笛卡儿积 $X\times Y$ 的子集。若 $(x,y) ∈ G(\mathcal{R})$ ，则称 $x\;与\;y\;有关系于 \mathcal{R}$，并记作 $x\mathcal{R}y$ 或 $\mathcal{R}(x,y)$。</p><p>否则称 $x \; 与 \; y \; 无关系\mathcal{R}$。但经常地我们把关系与其图等同起来，即：若 $\mathcal{R}⊆X×Y$，则 $\mathcal{R}$ 是一个关系。</p><h6 id="关系的性质"><a href="#关系的性质" class="headerlink" title="关系的性质"></a>关系的性质</h6><p>关系的性质主要有以下五种：自反性，反自反性，对称性，反对称性和传递性。</p><ul><li><strong>自反性 (réfexivité)</strong>：在集合 $X$ 上的关系 $\mathcal{R}$ ，如对任意 $x \in E$，有 $(x,x) \in \mathcal{R}$，则称<em>R</em>是自反的。</li></ul><script type="math/tex; mode=display">\forall x \in E,\quad x \mathcal{R} x</script><ul><li>非自反性（自反性的否定的强型式）：在集合 $X$ 上的关系 $\mathcal{R}$ ，如对任意 $x\in X$，有 $(x,x)\notin R$，则称R是非自反的。</li></ul><script type="math/tex; mode=display">\forall x\in A, (x,x)\notin \mathcal{R}</script><ul><li><strong>对称性 (symétrie)</strong>：在集合 $X$ 上的关系 $\mathcal{R}$，如果有 $(x,y) \in \mathcal{R}$ 则必有  $(y,x) \in \mathcal{R}$，则称R是对称的。</li></ul><script type="math/tex; mode=display">\forall (x,y) \in E^2,\quad x \mathcal{R} y \Rightarrow y \mathcal{R} x</script><ul><li>非对称性（对称性的否定的强形式）：</li></ul><script type="math/tex; mode=display">\forall (x,y) \in E^2, \quad (x,y) \in \mathcal{R} \Rightarrow (y,x) \notin \mathcal{R}</script><ul><li>反对称性（不是对称性的否定）：</li></ul><script type="math/tex; mode=display">\forall (x,y) \in E^2, \quad ((x \mathcal{R} y) \land (y \mathcal{R} x) \Rightarrow x=y)</script><ul><li><strong>传递性 (transitivité)</strong>：</li></ul><script type="math/tex; mode=display">\forall (x,y,z) \in E^3, \quad ((x \mathcal{R} y) \land (y \mathcal{R} z) \Rightarrow x \mathcal{R} z</script><p>设 $\mathcal{R}$ 为集合 $E$ 上的关系，下面给出 $\mathcal{R}$ 的五种性质成立的<strong>充要条件</strong>：</p><ol><li>$\mathcal{R}$ 在 $E$ 上自反，当且仅当$I_{E}\subseteq \mathcal{R}$</li><li>$\mathcal{R}$ 在 $E$ 上非自反，当且仅当 $\mathcal{R} \cap I_{E}=\emptyset $</li><li>$\mathcal{R}$ 在 $E$ 上对称，当且仅当 $\mathcal{R} = \mathcal{R} ^{-1}$</li><li>$\mathcal{R}$ 在 $E$ 上反对称，当且仅当 $ \mathcal{R} \cap \mathcal{R}^{-1}\subseteq I_{E}$</li><li>$\mathcal{R}$ 在 $E$ 上非对称，当且仅当 $\mathcal{R} \cap \mathcal{R}^{-1}= \emptyset$</li><li>$\mathcal{R}$ 在 $E$ 上传递，当且仅当 $\mathcal{R} \circ \mathcal{R}\subseteq \mathcal{R}$</li></ol><h6 id="等价关系（-Relation-d’equivalence）"><a href="#等价关系（-Relation-d’equivalence）" class="headerlink" title="等价关系（ Relation d’équivalence）"></a>等价关系（ Relation d’équivalence）</h6><p><strong>等价关系</strong>也称为同值关系（英语：Equivalence relation）即设 $\mathcal{R}$ 是某个集合 $E$ 上的一个二元关系。若 $\mathcal{R}$ 满足以下条件（充分必要）：</p><ol><li>自反性 (réfexivité)：$\forall x \in E, \quad x \mathcal{R} x$</li><li>对称性 (symétrie)：$\forall (x,y) \in E^2, \quad x \mathcal{R} y \Rightarrow y \mathcal{R}x$</li><li>传递性 (transitivité)：$\forall (x,y,z) \in E^3, \quad ((x \mathcal{R} y) \land (y \mathcal{R} z) \Rightarrow x \mathcal{R} z$</li></ol><blockquote><p>例如，设 $E={1,2,…,8}$，定义 $E$上的关系 $\mathcal{R}$ 如下：</p><script type="math/tex; mode=display">x \mathcal{R} y \Longleftrightarrow \forall (x,y) \in E, x \equiv y(mod \; 3)</script><p>其中，$x \equiv y(mod \; 3)$ 叫做 $x$ 与 $y模3$ 同余，即 $x$ 除以3的余数 与 $y$ 除以3的余数相等。例子有$1\mathcal{R} 4$，$2\mathcal{R}5$，$3\mathcal{R}6$。不难验证 $\mathcal{R}$ 为 $E$ 上的等价关系。</p><p>并非所有的二元关系都是等价关系。一个简单的反例是<strong>比较两个数中哪个较大</strong>：</p><ul><li>没有自反性：任何一个数不能比自身为较大 $n\ngtr n$</li><li>没有对称性：如果 $m&gt;n$，就肯定不能有 $n&gt;m$</li></ul></blockquote><h6 id="等价类（Classe-d’equivalence）"><a href="#等价类（Classe-d’equivalence）" class="headerlink" title="等价类（Classe d’équivalence）"></a>等价类（Classe d’équivalence）</h6><p>令 $\mathcal{R}$ 是集合 $E$ 上的等价关系，$x$ 是 $E$ 的元素。我们称 $x$ 的等价类为 $E$ 中与 $x$ 相关的所有元素的集 $[x]$：</p><script type="math/tex; mode=display">[x] = {y ∈ E,x\mathcal{R}y}</script><ul><li><p>设 $\mathcal{R}$ 为集合 $E$ 上的等价关系，两个等价类不相交或相等。</p><blockquote><p>证明：</p><script type="math/tex; mode=display">\begin{aligned} IF (v_k = \{v_j\} \cup \{v_i\}) \quad & THEN(v_i \mathcal{R} v_k,\;v_j \mathcal{R} v_k \Rightarrow v_i \mathcal{R} v_j \Rightarrow [v_i]=[v_j]) \\& ELSE(\{v_j\} \cap \{v_i\} = \emptyset)\end{aligned}</script></blockquote></li><li><p>设 $\mathcal{R}$ 是集合 $E$ 上的等价关系，等价类的集合是 $E$ 的一个部分。</p></li><li>设 $G$ 是一个无向图（或有向图），当且仅当存在一条连接 $v_i$ 到 $v_j$ 的链（分别是从 $v_i$ 到 $v_j$ 的路径和从 $v_j$ 到 $v_i$ 的路径）时，由 $v_i \mathcal{R} v_j$ 在顶点集上定义的关系 $\mathcal{R}$ 到 $v_i$ 是等价关系。</li></ul><h5 id="连通分量（Composantes-connexes）"><a href="#连通分量（Composantes-connexes）" class="headerlink" title="连通分量（Composantes connexes）"></a>连通分量（Composantes connexes）</h5><p><strong>无向图</strong> $G$ 的<strong>极大连通子图</strong>称为 $G$ 的<strong>连通分量</strong>( Connected Component)。任何连通图的连通分量只有一个，即是其自身，非连通的无向图有多个连通分量。对于分量中任意两点 $u,v$，必然可以从 $u$ 走到 $v$，且从 $v$ 走到 $u$。</p><p>如下图所示，</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-17 14.33.24.png" alt="2022-04-17 14.33.24" style="zoom:40%;"></p><h5 id="强连通分量（Composantes-fortement-connexes）"><a href="#强连通分量（Composantes-fortement-connexes）" class="headerlink" title="强连通分量（Composantes fortement connexes）"></a>强连通分量（Composantes fortement connexes）</h5><p><strong>有向图</strong> $G= (V,E)$ 的<strong>极大强连通子图</strong>称为 $G$ 的<strong>强连通分量</strong>，强连通图只有一个强连通分量，即是其自身。非强连通的有向图有多个强连通分量。极大连通分量。一个连通分量加上任何一些点都不是连通分量了，该连通分量就是强连通分量。</p><p>强连通分量的作用： 将任意有向图通过 <u>缩点(将所有连通分量缩成一个点)</u> 转换成有向无环图( $DAG$ )。如下图所示，</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/v2-03765039364c4af19f5f35b7c3433d4c_1440w.jpeg" alt="v2-03765039364c4af19f5f35b7c3433d4c_1440w" style="zoom:70%;"></p><ul><li>前驱：$Pred (S \subseteq V_{ertex}) = \{v’ | v \in S, (v’,v) \in E_{dge}\}$</li><li>后继：$Succ (S \subseteq V_{ertex}) = \{v’ | v \in S, (v,v’) \in E_{dge}\}$</li></ul><p>我们还通过以下方式定义<strong>前驱</strong>和<strong>后继</strong>的自反和传递闭包：</p><ul><li>$Pred^<em> (S \subseteq V_{ertex}) = S \cup Pred^</em> (Pred(S))$</li><li>$Succ^<em> (S \subseteq V_{ertex}) = S \cup Succ^</em> (Succ(S))$</li></ul><h5 id="Demoucron-算法"><a href="#Demoucron-算法" class="headerlink" title="Demoucron 算法"></a>Demoucron 算法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CFG_G &lt;- ∅空集</span><br><span class="line">WHILE (有一个顶点不在 CFC_G 子集的并集中)</span><br><span class="line">DO</span><br><span class="line">选择 v ∈ V 不出现 CFC_G 子集的并集</span><br><span class="line">CFC_v &lt;- SUCC*(&#123;v&#125;) ∩交集 Pred*(&#123;v&#125;)</span><br><span class="line">CFC_G &lt;- CFC_G ∪并集 &#123;CFC_v&#125;</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>例：应用 Demoucron 算法找出下图中的强连通分量：</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-17 15.36.10.png" alt="2022-04-17 15.36.10" style="zoom:45%;"></p><ul><li>$CFC_G = \emptyset$</li><li>$\begin{aligned} CFC_{v_1} &amp; = \{1,2,3,7,5,6,8,4,10,9\}  \quad \leftarrow 顺箭头方向_{Succ} \\ &amp; \quad \cap \; \{ 1,4,5,3,6,2,7,9,10\} \quad \leftarrow 逆箭头方向_{Pred} \\ &amp; = \{ 1,2,3,4,5,6,7,9,10\} \end{aligned}$</li><li>$v_8 \;并不在上一轮的\;CFC_v 中$</li><li>$CFC_G = \{ [1] , [8] \} \rightarrow \{ [8] \}_{seul}$</li></ul><h4 id="树（Arbre）"><a href="#树（Arbre）" class="headerlink" title="树（Arbre）"></a>树（Arbre）</h4><p><strong>树</strong>是一个<strong>无环连通图</strong>。<strong>森林</strong>由<strong>若干个树连接</strong>得来（无环）。</p><ul><li>由 $k$ 颗树组成的森林满足 $m = n − k$，其中 $n$ 为 $G$ 的顶点数，$m$ 为 $G$ 的边数．</li></ul><blockquote><p><strong>Theorem:</strong> </p><script type="math/tex; mode=display">每棵非平凡树至少有两片树叶</script><p>证明 :</p><p>设 $d_1 ≤ d_2 ≤ · · · ≤ dn$ 是树 $T$ 的度序列，因为 $T$ 是连通的，所以树 $T$ 的最小度 $δ(T) = d_1 ≥ 1$. 如果树 $T$ 中至多有一片树叶，那么 $2n − 2 = 2m(T) = \sum_{i=1}^n d_i ≥ 1 + 2(n − 1)$ , 出现矛盾．</p><script type="math/tex; mode=display">n := \text{NB of vertex}\\m := \text{NB of Edge}\\t := \text{NB of vertex with 1 degre}\\\because \text{G is a tree}\quad \therefore \text{G is a connected graph}\\\therefore \sum \delta(v) = 2m = 2(n-1) \quad \text{according to n=m-1} \\\because \sum_{\delta(v) \ge 2} \delta(v) \ge 2(n-t)+t \\\therefore 2(n-1) \ge 2(n-t)+t  \quad \Rightarrow \quad t \ge 2</script></blockquote><p>设 $G$ 是具有 $n$ 个点 $m$ 条边的图，则下列命题<strong>等价</strong>：</p><ol><li>$G$ 是树；</li><li>$G$ <strong>无环</strong>且任意两个不同点之间存在唯一的路；</li><li>$G$ 连通，删去任一边便不连通；</li><li>$G$ <strong>连通</strong>，且 $n = m - 1$；</li><li>$G$ <strong>无圈</strong>，且 $n = m - 1$；</li><li>$G$ 无圈，添加任何一条边可得<strong>唯一</strong>的圈。</li></ol><h5 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h5><p>$G$ 的<strong>生成树</strong>（arbre couvrant）是具有 $G$ 的<strong>全部顶点</strong>，但<strong>边数最少</strong>的<strong>连通子图</strong>。</p><p>若有图 $G=(V_G, E_G)$ 和树 $T = (V_T, E_T)$，有 $V_T = V_G$ 且 $E_T \subset E_G$，那么我们说树 $T$ 是图 $G$ 的生成树。</p><h5 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h5><p>带权图的生成树中，总权重最小的称为<strong>最小生成树</strong>。</p><blockquote><p> 求取最小生成树的算法：一种<strong>贪心算法</strong></p><ol><li>新建图 $G$， $G$ 中拥有原图中相同的节点，但没有边；</li><li>将原图中所有的边<strong>按权值从小到大升序</strong>；</li><li><strong>从权值最小的边开始</strong>，如果这条边连接的两个节点于图 $G$ 中不在同一个连通分量中，则添加这条边到图 $G$ 中；</li><li>重复3，直至图 $G$ 中所有的节点都在同一个连通分量中；</li></ol><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/MST_kruskal_en.gif" alt="MST_kruskal_en" style="zoom:40%;"></p></blockquote><h3 id="第三部分：Euler-图与-Hamilton-图"><a href="#第三部分：Euler-图与-Hamilton-图" class="headerlink" title="第三部分：Euler 图与 Hamilton 图"></a>第三部分：Euler 图与 Hamilton 图</h3><h4 id="欧拉图"><a href="#欧拉图" class="headerlink" title="欧拉图"></a>欧拉图</h4><ul><li><p>无向图</p><ol><li>经过 $G$ 的<strong>所有边</strong>的链被称为 Euler 链</li><li>经过 $G$ 的<strong>所有边</strong>的环（闭合的链）被称为 Euler 回路</li></ol></li><li><p>有向图</p><ol><li>经过 $G$ 的<strong>所有边</strong>的通路被称为 Euler 通路</li><li>经过 $G$ 的<strong>所有边</strong>的回路（闭合的通路）被称为 Euler 回路</li></ol></li><li>存在 Euler 环或 Euler 回路的图叫做 Euler 图。</li></ul><blockquote><p><strong>Theorem</strong></p><p>假定 $G$ 是一个<strong>连通图</strong>，则下列命题等价：</p><ol><li><p>$G$ 是<strong>欧拉图</strong>；</p></li><li><p>$G$ 的每个点的度<strong>都是偶数</strong> 或 <strong>只有 2 个顶点是奇数度，其余均为偶数度</strong>；</p><ul><li><p>连通无向图 $G$ 是欧拉图当且仅当 $G$ 的每个顶点都是偶度顶点</p></li><li><p>连通无向图 $G$ 中存在连接顶点 $u,v$ 的欧拉链当且仅当只有 $u$ 和 $v$ 是奇度顶点</p></li></ul></li><li><p>$G$ 的边集能划分为边不重的环的并。</p></li></ol></blockquote><h5 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h5><ul><li><p>无向图</p><ol><li>连通无向图 $G$ 是欧拉图当且仅当 $G$ 的每个顶点都是偶度顶点</li><li>连通无向图 $G$ 中存在连接顶点 $u,v$ 的欧拉链当且仅当只有 $u$ 和 $v$ 是奇度顶点</li></ol></li><li><p>有向图</p><ol><li><strong>强连通图有向图</strong> $D$ 是<strong>欧拉回路</strong> 当且仅当 $D$ 中的<strong><u>每个顶点的出度数和入读数相同</u></strong></li><li>单向<strong>连通有向图</strong> $D$ 有从顶点 $u$ 到 $v$ 的<strong>欧拉通路</strong>当且仅当 <u>$u$ 的<strong>出度数</strong>比入度数大 1</u>， <u>$v$ 的<strong>入度数</strong>比<strong>出度数</strong>大 1</u>， <u>$D$ 中其他顶点<strong>入度数</strong>和<strong>出度数</strong>相同</u></li></ol></li></ul><h5 id="寻找-Euler-回路算法：Hierholzer-算法"><a href="#寻找-Euler-回路算法：Hierholzer-算法" class="headerlink" title="寻找 Euler 回路算法：Hierholzer 算法"></a>寻找 Euler 回路算法：Hierholzer 算法</h5><p>Hierholzer算法用于在连通图寻找欧拉迹，其流程非常简单。</p><blockquote><p>从一个可能的起点出发，进行<strong>深度优先搜索</strong>，但是每次沿着辅助边从某个顶点移动到另外一个顶点的时候，都需要删除这个辅助边。如果没有可移动的路径，则将所在结点加入到栈中，并返回。</p><p>最后得到的栈中保存的就是整个欧拉闭迹中的顶点。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dfs(node, trace)&#123;</span><br><span class="line"><span class="keyword">while</span>(!node.adj.isEmpty())&#123;</span><br><span class="line"><span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> node.adj.removeLast();</span><br><span class="line">dfs(next, trace);</span><br><span class="line">&#125;</span><br><span class="line">trace.addLast(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="哈密顿图"><a href="#哈密顿图" class="headerlink" title="哈密顿图"></a>哈密顿图</h4><ul><li>无向图：<ol><li>经过 $G$ 的<strong>每个结点一次且仅一次</strong>的链被称为 Hamilton 链</li><li>经过 $G$ 的<strong>每个结点一次且仅一次</strong>的环为 Hamilton 环</li></ol></li><li><p>有向图</p><ol><li>经过 $G$ 的<strong>每个结点一次且仅一次</strong>的链基本通路被称为 Hamilton 通路</li><li>经过 $G$ 的<strong>每个结点一次且仅一次</strong>的基本回路为 Hamilton 回路</li></ol></li><li><p>Hamilton 图：存在 Hamilton 回路 或 Hamilton 环的图叫做 Hamilton 图。</p></li></ul><h5 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h5><ul><li>若存在 $v_i \in V$，当 $v_i$ 的度数 $\delta(v_i) =1$ 且阶数 $n&gt;1$ 时，不为哈密顿图</li><li>若存在 $v_i ∈ V$，当 $v_i$ 的度数 $δ(v) = 2$，那么与 $v_i$ 相关的两条边属于任何哈密顿环。</li><li>$K_n$ 是哈密顿图</li><li>有向完全图中必存在哈密顿通路</li><li>强连通的有向完全图中必存在哈密顿回路</li></ul><h5 id="哈密顿图的判断方法"><a href="#哈密顿图的判断方法" class="headerlink" title="哈密顿图的判断方法"></a>哈密顿图的判断方法</h5><ul><li><p><strong>Theorem (Ore，充分条件)</strong></p><p>对于阶 $n ≥ 3$ 的简单图 $G$，如果 $G$ 中的<strong>任意</strong>两个不相邻顶点 $u$ 与 $v$，都有：</p><script type="math/tex; mode=display">\delta(u) + \delta(v) ≥ n，</script><p>那么 $G$ 是哈密顿图。( 注：上述定理只是充分条件，而非必要条件，例如长度为 5 的圈．)</p><blockquote><p><strong>证明</strong>：</p><p>等效地表明，每个非哈密顿图G都不满足条件。因此，令 $G$ 为非哈密顿图的 $n≥3$ 个顶点上的图，并通过一次不增加哈密顿边数加一个边，由 $G$ 形成 $H$，直到无法再增加边。</p><p>令 $u$ 和 $v$ 为 $H$ 中的任何两个不相邻的顶点。然后将边 $(u, v)$ 添加到 $H$，将创建至少一个新的哈密顿回路，并且在 $H$ 中的此回路中的 $(u,v)$ 以外的边一定会形成哈密顿路径 $v_1, v_2, … v_n$，其中 $u = v_1$，$v = v_n$。</p><p>对于 $2≤i≤n$ 范围内的每个指数 $i$，考虑 $H$ 中从 $v_1$ 到 $v_i$ 和从 $v_(i-1)$ 到 $v_n$ 的两个可能边。在 $H$ 中最多可以存在这两个边之一，否则周期 $v_1,v_2 … v_(i-1), v_n, v_{(n-1)} … v_i$ 将是哈密顿回路。</p><p>因此，入射到 $v_1$ 或 $v_n$ 的边的总数最多等于 $i$ 的选择数，即 $n-1$。因此，$H$不服从属性，这要求该边的总数 $δ(v_1) + δ(v_n)$ 大于或等于 $n$。由于 $G$ 的顶点度最多等于 $H$ 的度数，因此得出 $G$ 也没有服从特性的结论。</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-17 21.58.22.png" alt="2022-04-17 21.58.22" style="zoom:40%;"></p></blockquote></li><li><p><strong>Theorem (Dirac，充分条件)</strong></p><p>对于 $n ≥ 3$ 的简单图 $G$，如果 $G$ 中有：</p><script type="math/tex; mode=display">\delta(G) ≥ \frac{n}{2}</script><p>那么 $G$ 是哈密顿图。( 注：上述定理只是充分条件，而非必要条件，例如长度为 5 的圈．)</p></li></ul><h5 id="二分图（Graphe-biparti）"><a href="#二分图（Graphe-biparti）" class="headerlink" title="二分图（Graphe biparti）"></a>二分图（Graphe biparti）</h5><p>二分图又称作二部图，是图论中的一种特殊模型。 设 $G=(V,E)$ 是一个无向图，如果顶点 $V$ 可分割为两个<strong>互不相交的子集</strong>$A$,$B$)，并且图中的每条边 $(v_i, v_j)$ 所关联的两个顶点 $v_i$ 和 $v_j $ 分别属于这两个不同的顶点集 ($v_i \in A$ , $v_j \in B$)，则称图 $G$ 为一个<strong>二分图</strong>。</p><p>简而言之，就是顶点集 $V$ 可分割为<strong>两个互不相交的子集</strong>，并且图中每条边依附的两个顶点都分属于这两个互不相交的子集，两个<strong>子集内的顶点不相邻</strong>。</p><blockquote><p>如下图，</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-17 21.00.46.png" alt="2022-04-17 21.00.46" style="zoom:40%;"></p><p>完全二分图：$V_1$ 的所有顶点都链接到 $V_2$的任何顶点。互补顶点子集分别有 $p$ 个顶点和 $q$ 个顶点的完全二分图记为 $𝐾_{𝑝,𝑞}$</p></blockquote><p><strong>性质</strong></p><ul><li>如果一个图 $G=(V,E)$ 是二分图，且 $| nb(V_1) - nb(V_2)| &gt; 1$，则 $G$ 即不是哈密顿图，也不是半哈密顿图</li><li>若无向图 $G$ 中有长度为奇数的闭合链，则在 $G$ 中有长度为奇数的圈</li><li>非平凡无向图 $G$ 是二分图当且仅当 $G$ 中的每个圈的长度都是偶数</li></ul><h3 id="第四部分：最短路径问题"><a href="#第四部分：最短路径问题" class="headerlink" title="第四部分：最短路径问题"></a>第四部分：最短路径问题</h3><h4 id="Dijkstra-最短路径算法"><a href="#Dijkstra-最短路径算法" class="headerlink" title="Dijkstra 最短路径算法"></a>Dijkstra 最短路径算法</h4><p>Dijkstra算法是一种经典的基于<strong>贪心</strong>的单源最短路算法，其要求图中的边全部非负。</p><h5 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h5><h6 id="1-算法思想："><a href="#1-算法思想：" class="headerlink" title="1. 算法思想："></a>1. 算法思想：</h6><p>设 $G=(V,E)$ 是一个带权有向图（或无向图），把图中顶点集合 $V$ 分成两组，</p><ol><li>第一组为<strong>已求出最短路径的顶点集合</strong>（用 $S$ 表示，初始时 $S$ 中只有一个<strong>源点</strong>，以后每求得一条最短路径 , 就将加入到集合 $S$ 中，直到全部顶点都加入到 $S$ 中，算法就结束了），</li><li>第二组为<strong>其余未确定最短路径的顶点集合</strong>（用 $U$ 表示），按最短路径长度的递增次序依次把第二组的顶点加入 $S$ 中。在加入的过程中，总保持从源点 $v_0$ 到 $S$ 中各顶点的最短路径长度不大于从源点 $v_0$ 到 $U$ 中任何顶点的最短路径长度。</li></ol><p>此外，每个顶点对应一个距离，$S$ 中的顶点的距离就是从 $v_0$ 到此顶点的最短路径长度，$U$ 中的顶点的距离，是从 $v_0$ 到此顶点只包括S中的顶点为中间顶点的当前最短路径长度。</p><h6 id="2-算法伪代码："><a href="#2-算法伪代码：" class="headerlink" title="2. 算法伪代码："></a>2. 算法伪代码：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">DIJKSTRA(G, w, s)</span><br><span class="line">    // s的当前最短路长度是0，其他节点的当前最短路长度是+∞。</span><br><span class="line">    INITIALIZE-SINGLE-SOURCE(G, s)</span><br><span class="line">    // S是节点集合（V的子集），其中每个节点u都已经求得了全图最短路。</span><br><span class="line">    // 初期所有节点都没求得全图最短路。</span><br><span class="line">    S ← ∅</span><br><span class="line">    // Q是一个节点的优先队列，包含所有尚未求得全图最短路的节点。Q中的节点按照当前最短路的长度从小到大排序。</span><br><span class="line">    // 初期所有节点都没求得全图最短路，所以都在Q中。</span><br><span class="line">    Q ← V[G]</span><br><span class="line">    // 循环直到Q中所有节点都清空（都移动到S），即所有节点都已经求出全图最短路。</span><br><span class="line">    while Q ≠ ∅</span><br><span class="line">        // 从Q中取出当前最短路长度最小的节点u</span><br><span class="line">        // 并认为u的当前最短路就是全图最短路。（这个不是那么显然，后续有说明）</span><br><span class="line">        do u ← EXTRACT-MIN(Q)</span><br><span class="line">            // 将u放进集合S中，即标注为“已求得u的全图最短路”。</span><br><span class="line">            S ← S∪&#123;u&#125;</span><br><span class="line">            // 对于u的每个邻接点v</span><br><span class="line">            for each vertex v∈Adj[u]</span><br><span class="line">                // 更新v的当前最短路。</span><br><span class="line">                // 具体策略是：有一个从s到v的新路径，即“从s走全图最短路到u，再从u到v”。</span><br><span class="line">                // 这个新路径可能比v的当前最短路长，也可能比v的当前最短路短。（这个不那么显然，后续有说明）</span><br><span class="line">                // 如果新路径比v的当前最短路短，就把v的当前最短路替换为这条新路径。</span><br><span class="line">                do RELAX(u, v, w)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="3-算法步骤："><a href="#3-算法步骤：" class="headerlink" title="3. 算法步骤："></a>3. 算法步骤：</h6><ol><li>初始时，$S$ 只包含源点，即 $S＝\{v_0\}$，$v_0$ 的距离为 $0$。$U$ 包含除 $v_0$ 外的其他顶点，即 : $U=\{其余顶点\}$，若 $v_0$ 与 $U$ 中顶点 $v_i$ 有边，则 $(v_0,v_i)$ 正常有权值，若 $v_0$ 不是 $v_i$ 的出边邻接点，则 $(v_0,v_i)$ 权值为 $∞$。</li><li>从 $U$ 中选取一个距离 $v_0$ 最小的顶点 $v_k$ ，把 $v_k$ 加入 $S$ 中（该选定的距离就是 $v_0$ 到 $v_k$ 的最短路径长度）。</li><li>以 $v_k$ 为新考虑的中间点，修改 $U$ 中各顶点的距离；若从源点 $v_0$ 到顶点 $v_i$ 的距离（经过顶点 $v_k$）比原来距离（不经过顶点 $v_k$）短，则修改顶点 $v_i$ 的距离值，修改后的距离值的顶点 $v_k$ 的距离加上边上的权。</li><li>重复步骤 2 和 3，直到所有顶点都包含在 $S$ 中。</li></ol><blockquote><p>例：如下图所示，求出从 0 出发到 4 的最短路径。</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-18 09.34.04.png" alt="2022-04-18 09.34.04" style="zoom:40%;"></p><p><strong>【思路】</strong>：</p><ol><li>每次从没标记的节点中选择距离出发点最近的节点标记、收录到最优路径集合中；</li><li>计算刚加入的节点 A 到临近节点 B 的距离（不包含已标记节点），若 $(节点A的距离 + 节点A到节点B的距离) &lt; 节点B的距离$，则选择更小的那个路径，更新节点B的距离和前驱点pred</li><li>标记完所有的节点</li></ol><p>【解】</p><ol><li>将 [0] 放入集合：</li></ol></blockquote><div class="table-container"><table><thead><tr><th></th><th><u>0</u></th><th>[1]</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>dist</td><td>0</td><td>4</td><td>$∞$</td><td>$∞$</td><td>$∞$</td><td>$∞$</td><td>$∞$</td><td>8</td><td>$∞$</td></tr><tr><td>pred</td><td>\</td><td>0</td><td>\</td><td>\</td><td>\</td><td>\</td><td>\</td><td>0</td><td>\</td></tr></tbody></table></div><blockquote><ol><li>将 [1] 放入集合：</li></ol></blockquote><div class="table-container"><table><thead><tr><th></th><th><u>0</u></th><th><u>1</u></th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>[7]</th><th>8</th></tr></thead><tbody><tr><td>dist</td><td>0</td><td>4</td><td>12</td><td>$∞$</td><td>$∞$</td><td>$∞$</td><td>$∞$</td><td>$8^*$</td><td>$∞$</td></tr><tr><td>pred</td><td>\</td><td>0</td><td>1</td><td>\</td><td>\</td><td>\</td><td>\</td><td>0</td><td>\</td></tr></tbody></table></div><blockquote><p>注意⚠️：* 路径 $0 \to 1 \to 7$ 的距离为 $4+11=15$，而有路径 $0 \to 7$ 的距离为 8，小于前者。所以我们选择路径 $0 \to 7$，并更新表。以下步骤与此类次，不再单独列出。</p><ol><li>将 [7] 放入集合：</li></ol></blockquote><div class="table-container"><table><thead><tr><th></th><th><u>0</u></th><th><u>1</u></th><th>2</th><th>3</th><th>4</th><th>5</th><th>[6]</th><th><u>7</u></th><th>8</th></tr></thead><tbody><tr><td>dist</td><td>0</td><td>4</td><td>12</td><td>$∞$</td><td>$∞$</td><td>$∞$</td><td>9</td><td>8</td><td>15</td></tr><tr><td>pred</td><td>\</td><td>0</td><td>1</td><td>\</td><td>\</td><td>\</td><td>7</td><td>0</td><td>7</td></tr></tbody></table></div><blockquote><ol><li>将 [6] 放入集合：</li></ol></blockquote><div class="table-container"><table><thead><tr><th></th><th><u>0</u></th><th><u>1</u></th><th>2</th><th>3</th><th>4</th><th>[5]</th><th><u>6</u></th><th><u>7</u></th><th>8</th></tr></thead><tbody><tr><td>dist</td><td>0</td><td>4</td><td>12</td><td>$∞$</td><td>$∞$</td><td>11</td><td>9</td><td>8</td><td>15</td></tr><tr><td>pred</td><td>\</td><td>0</td><td>1</td><td>\</td><td>\</td><td>6</td><td>7</td><td>0</td><td>7</td></tr></tbody></table></div><blockquote><ol><li>将 [5] 放入集合：</li></ol></blockquote><div class="table-container"><table><thead><tr><th></th><th><u>0</u></th><th><u>1</u></th><th>[2]</th><th>3</th><th>4</th><th><u>5</u></th><th><u>6</u></th><th><u>7</u></th><th>8</th></tr></thead><tbody><tr><td>dist</td><td>0</td><td>4</td><td>12</td><td>25</td><td>21</td><td>11</td><td>9</td><td>8</td><td>15</td></tr><tr><td>pred</td><td>\</td><td>0</td><td>1</td><td>5</td><td>5</td><td>6</td><td>7</td><td>0</td><td>7</td></tr></tbody></table></div><blockquote><ol><li>将 [2] 放入集合：</li></ol></blockquote><div class="table-container"><table><thead><tr><th></th><th><u>0</u></th><th><u>1</u></th><th><u>2</u></th><th>3</th><th>4</th><th><u>5</u></th><th><u>6</u></th><th><u>7</u></th><th>[8]</th></tr></thead><tbody><tr><td>dist</td><td>0</td><td>4</td><td>12</td><td>19</td><td>21</td><td>11</td><td>9</td><td>8</td><td>14</td></tr><tr><td>pred</td><td>\</td><td>0</td><td>1</td><td>2</td><td>5</td><td>6</td><td>7</td><td>0</td><td>2</td></tr></tbody></table></div><blockquote><ol><li>将 [8] 放入集合：由于与 8 相邻的节点都已经加入集合，所以可以跳过这一步</li></ol></blockquote><div class="table-container"><table><thead><tr><th></th><th><u>0</u></th><th><u>1</u></th><th><u>2</u></th><th>[3]</th><th>4</th><th><u>5</u></th><th><u>6</u></th><th><u>7</u></th><th><u>8</u></th></tr></thead><tbody><tr><td>dist</td><td>0</td><td>4</td><td>12</td><td>19</td><td>21</td><td>11</td><td>9</td><td>8</td><td>14</td></tr><tr><td>pred</td><td>\</td><td>0</td><td>1</td><td>2</td><td>5</td><td>6</td><td>7</td><td>0</td><td>2</td></tr></tbody></table></div><blockquote><ol><li>将 [3] 放入集合：</li></ol></blockquote><div class="table-container"><table><thead><tr><th></th><th><u>0</u></th><th><u>1</u></th><th><u>2</u></th><th><u>3</u></th><th>[4]</th><th><u>5</u></th><th><u>6</u></th><th><u>7</u></th><th>8</th></tr></thead><tbody><tr><td>dist</td><td>0</td><td>4</td><td>12</td><td>19</td><td>21</td><td>11</td><td>9</td><td>8</td><td>14</td></tr><tr><td>pred</td><td>\</td><td>0</td><td>1</td><td>2</td><td>5</td><td>6</td><td>7</td><td>0</td><td>2</td></tr></tbody></table></div><blockquote><ol><li>将 [4] 放入集合：</li></ol></blockquote><div class="table-container"><table><thead><tr><th></th><th><u>0</u></th><th><u>1</u></th><th><u>2</u></th><th><u>3</u></th><th><u>4</u></th><th><u>5</u></th><th><u>6</u></th><th><u>7</u></th><th>8</th></tr></thead><tbody><tr><td>dist</td><td>0</td><td>4</td><td>12</td><td>19</td><td>21</td><td>11</td><td>9</td><td>8</td><td>14</td></tr><tr><td>pred</td><td>\</td><td>0</td><td>1</td><td>2</td><td>5</td><td>6</td><td>7</td><td>0</td><td>2</td></tr></tbody></table></div><blockquote><ol><li>遍历完毕，我们现在就得到了从 0 到该图中所有点的最短路程 (shortest distance)。欲求出 $0 \to 4$ 的路径，我们可以从 4 出发，沿着 pred 的顺序到推出最短路径 (shortest path)，即</li></ol><script type="math/tex; mode=display">4 \leftarrow 5 \leftarrow 6 \leftarrow 7 \leftarrow 0</script><p>对于<strong>有向图</strong>，大体思路与无向图一致，注意边的方向即可，顺方向为可达，逆方向为不可达（即 $∞$ ）</p></blockquote><h3 id="第五部分：平面图-及-图的上色问题"><a href="#第五部分：平面图-及-图的上色问题" class="headerlink" title="第五部分：平面图 及 图的上色问题"></a>第五部分：平面图 及 图的上色问题</h3><h4 id="平面图（Graphe-planire）"><a href="#平面图（Graphe-planire）" class="headerlink" title="平面图（Graphe planire）"></a>平面图（Graphe planire）</h4><ul><li>如下图，如果一个图 $G$ 可以在<strong>平面上</strong>绘制，并且<strong>其边不相交</strong> （边不一定是直线），则称该图是<strong>平面图</strong>。<ul><li>平面图所在的特定平面称为地图（carte）；</li><li>将地图划分为几个区域称为面（face）；<ul><li>内部面：每个区域内部连同边界称为 $G$ 的内部面</li><li>外部面：无界的区域</li><li>注：每个平面图有且仅有一个外部面。 </li></ul></li></ul></li></ul><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-18 13.22.07.png" alt="2022-04-18 13.22.07" style="zoom:35%;"></p><ul><li><p>而如果一个图无论怎样都无法画在平面上，并使得不同的边互不交叠，那么这样的图不是平面图，或者称为非平面图。</p><ul><li>完全图 $K_5$和完全二分图 $K_{3,3}$ (汤玛森图) 是最“小”的非平面图。</li></ul></li><li><p>面的次数：设 $f$ 是 $G$ 的一个面，构成 $f$ 的<strong>边界的边数</strong>（割边算两次）称为 $f$ 的<strong>次数</strong>， 记作 $deg(f)$</p><ul><li>定理：设平面图 $G$ 有 $m$ 条边，$G$ 的所有面的集合为 $\psi$， 则<script type="math/tex; mode=display">\sum _{f \in \psi} deg(f) = 2m</script></li></ul></li><li><p>这实际上是一个研究图的拓扑方面的问题。 更一般地，人们可以问一个图形是否可以在表面 S 上表示的问题</p></li></ul><h5 id="欧拉公式"><a href="#欧拉公式" class="headerlink" title="欧拉公式"></a>欧拉公式</h5><p>设 $G$ 是具有 $n$ 个顶点，$m$ 条边，$f$ 个面，$p$ 个<strong>连通分支</strong>(composantes connexes) 的平面图，则：</p><script type="math/tex; mode=display">f = m-n+1+p \quad 即 \quad 面数=边数-顶点数+1+连通部分的数量</script><p><strong>【欧拉示性数 (Euler characteristic)】</strong>：具有 $n$ 个顶点 $m$ 条边 $f$ 个面的<strong>连通平面图</strong> $G$ 满足：</p><script type="math/tex; mode=display">n-m+f=2,\quad 即 \quad 顶点数-边数+面数=2</script><p>【推论】具有 $n$ 个顶点，$m$ 条边的简单可平面图，若 $n \ge 3$，则 $m \le 3n -6$</p><h5 id="极大可平面图"><a href="#极大可平面图" class="headerlink" title="极大可平面图"></a>极大可平面图</h5><p>【定义】设 $G$ 是简单可平面图，如果在 $G$ 中的<strong>任意两个不相邻的顶点</strong>之间添加一条边所得到的图均<strong>为不可平面图</strong>，则称该图 $G$ 为极大可平面图。</p><ul><li>（必要条件）$G$ 是极大可平面图，则 $G$ 一定是连通图；如果 $G$ 的阶数大于3，则 $G$ 无割边</li><li>设 $G$ 是至少有3个顶点的平面图，则 $G$ 是极大平面图的<strong>充要条件</strong>是 $G$ 中<strong>各个面的次数均为3</strong> 且 <strong>为简单图</strong></li><li>设 $G$ 是具有 $n$ 个顶点，$m$ 条边，$f$ 个面的极大平面图，则 $m=3n-6$，$f =2n-4$</li></ul><h4 id="图的顶点着色"><a href="#图的顶点着色" class="headerlink" title="图的顶点着色"></a>图的顶点着色</h4><p>【独立集】（Independent ensemble）是图论中的概念。一个独立集（也称为<strong>稳定集</strong>stable ensemble）是一个图中一些<strong>两两不相邻的顶点所形成的集合</strong>。换句话说，独立集 $S$ 由图中若干顶点组成，且 $S$ 中任两个顶点之间没有边。我们用 $\alpha (G)$ 表示稳定即的个数。</p><p>【着色】在一个图 $G$ 中，任意<strong>相邻的两个顶点不能着相同的颜色</strong>（即一条边两端的顶点不能着相同的颜色；也即当一个图的顶点可分为 $n$ 个独立集时，可着 $n$ 个颜色）。我们用 $\gamma (G)$ 表示颜色的个数。</p><p>如果一个图所需颜色 $\gamma (G)$ 的最小数量是 $k$，则我们称该图是 $k-点可着色的$ </p><ul><li>常见的图的着色所需颜色的数量：<ul><li>$\gamma (K_p) = p$</li><li>$\gamma (具有2n个顶点的环) = 2$</li><li>$\gamma (具有2n+1个顶点的环) = 3$</li><li>$\gamma (Tree) = 2$</li></ul></li></ul><blockquote><p>例：</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-18 15.10.59.png" alt="2022-04-18 15.10.59" style="zoom:40%;"></p><p>上图 $G$ 所示的独立集为 $\{0\},\quad  \{1\}, \quad \{2,3,4\}$</p><p>$\alpha (G) = 3$ , $\gamma (G) = 3$</p></blockquote><h5 id="色数的上下界"><a href="#色数的上下界" class="headerlink" title="色数的上下界"></a>色数的上下界</h5><h6 id="下界-1"><a href="#下界-1" class="headerlink" title="下界 (1)"></a>下界 (1)</h6><script type="math/tex; mode=display">\gamma (G) \ge \frac {nb(V)}{nb(V) - min_{v \in V} \delta(v)}</script><p>其中，</p><ul><li><p>$min_{v \in V} \delta(v)$ 是图 $G$ 中<strong>拥有最小度的顶点 $v$ 的度数</strong>，即 在一个图中，拥有最少相邻顶点的顶点 $v$ 的度数；</p></li><li><p>$nb(V) - min_{v \in V} \delta(v) - 1$ 是与顶点 $v$ <strong>不邻接的顶点数</strong>，而此时就可以知道<strong>最多的同色顶点数</strong>是 $nb(V) - min_{v \in V} \delta(v)$ </p></li><li>总共色数是 $\gamma (G)$ ，其与最多的同色顶点数 $nb(V) - min_{v \in V} \delta(v)$ 相乘，应该<strong>小于等于</strong>顶点数 $nb(V)$ ，即 $\gamma (G) \times nb(V) - min_{v \in V} \delta(v) \le nb(V)$</li><li>整理可得出上式</li></ul><h6 id="下界-2"><a href="#下界-2" class="headerlink" title="下界 (2)"></a>下界 (2)</h6><script type="math/tex; mode=display">\gamma (G) \ge \#(最大团_{(clique)}中的顶点数)</script><h6 id="上界-1"><a href="#上界-1" class="headerlink" title="上界 (1)"></a>上界 (1)</h6><script type="math/tex; mode=display">\gamma (G) \le max_{v \in V} \delta(v) + 1</script><p>其中，</p><ul><li>$max_{v \in V} \delta(v)$ 是图 $G$ 中<strong>拥有最大度的顶点 $v$ 的度数</strong>，也可写作 $\Delta (G)$ 。即 在一个图中，拥有最多相邻顶点的顶点 $v$ 的度数；</li></ul><blockquote><p>证明：（数学归纳法）</p><ul><li><p>当 $n=1或2$ 时，结论显然成立；</p></li><li><p>假设有 $p$ 个顶点时结论成立，当有 $p+1$ 个顶点时，假设 $v_i$ 是 $G$ 中的任意一个顶点。我们可以将 $v_i$ 顶点从 $G$ 中删去，得到 $G_1$，则 $G_1$ 的阶数为 $p$。$G_1$ 是 $G$ 的子图，所以 $G_1$ 的最大度不可能超过 $G$ 的最大度。由假设我们应该有</p><script type="math/tex; mode=display">\gamma (G_1)\quad \le \quad\Delta (G_1) + 1 \quad \le \quad\Delta (G) + 1</script><ul><li>当将 $G_1$ 还原成 $G$ 时，由于 $v$ 至多与 $G_1$ 中 $\Delta (G)$ 个顶点相邻， 而在 $G_1$ 的点着色中，$\Delta (G)$ 个顶点至多用了  $\Delta (G)$ 种颜色，于是在 $\Delta (G) + 1$ 种颜色中至少存在一种颜色给 $v$ 着色，使 $v$ 与相邻的顶点着不同的颜色 </li></ul></li></ul><p>Proof:</p><p>We use <u>induction</u> on the number of vertices in the graph, which we denote by $n$. Let $P(n)$ be the proposition that an <code>n-vertex</code> graph with maximum degree $\Delta(G)$ at most $k$ is $(k + 1)$-colorable.</p><p><strong>Base case (n = 1):</strong></p><ol><li>A <code>1-vertex</code> graph has maximum degree $0$ and is <code>1-colorable</code>, so $P (1)$ is true.</li></ol><p><strong>Inductive step:</strong></p><ol><li>Now assume that $P (n)$ is true, and let $G$ be an <code>(n + 1)-vertex</code> graph with maximum degree  $\Delta(G)$ at most $k$.</li><li>Remove a vertex $v$ (and all edges incident to it), leaving an <code>n-vertex</code> subgraph, $H$. The maximum degree of $H$, $\Delta H$ is at most $k$, and so $H$ is <code>(k + 1)-colorable</code>  by our assumption $P (n)$.</li><li>Now add back vertex $v$. We can assign $v$ a color (from the set of $k + 1$ colors) that is different from all its <u>adjacent vertices</u>, since there are at most $k$ vertices adjacent to $v$ and so at least one of the $k + 1$ colors is still available.</li><li>Therefore, $G$ is <code>(k + 1)-colorable</code>. This completes the inductive step, and the theorem follows by <u>induction</u>.</li></ol></blockquote><h6 id="上界-2-上界-1-的收紧"><a href="#上界-2-上界-1-的收紧" class="headerlink" title="上界 (2): 上界 (1) 的收紧"></a>上界 (2): 上界 (1) 的收紧</h6><p>【Brooks定理】</p><p>设连通图即不是完全图 $K_n(n \ge 3)$，也不是长度为奇数的环，则</p><script type="math/tex; mode=display">\gamma (G) \le \Delta (G)</script><h6 id="上界-3"><a href="#上界-3" class="headerlink" title="上界 (3)"></a>上界 (3)</h6><script type="math/tex; mode=display">\gamma (G) \le n + 1 - \alpha(G)</script><h4 id="图的边着色"><a href="#图的边着色" class="headerlink" title="图的边着色"></a>图的边着色</h4><p>在一个图 $G$ 中，任意<strong>相邻的两个边不能着相同的颜色</strong>（即与同一个顶点链接的边不能着相同的颜色）。我们用 $\gamma (G)$ 表示颜色的个数。</p><p>如果一个图对边着色所需颜色 $\gamma’ (G)$ 的最小数量是 $k$，则我们称该图是 $k-边可着色的$ </p><p>【性质】（维津定理）设G是简单图，则</p><script type="math/tex; mode=display">\Delta (G) \le \gamma'(G) \le \Delta (G) +1</script><h4 id="图的面着色"><a href="#图的面着色" class="headerlink" title="图的面着色"></a>图的面着色</h4><p>连通的<strong>无桥</strong>平面图的平面嵌入及其所有的面称为<strong>平面地图</strong>或<strong>地图</strong>，平面地图的面称为<strong>国家</strong>。若两个国家的边界至少有一条公共边，则称这两个国家是<strong>相邻</strong>的。</p><p>在一个平面地图 $G$ 中，任意<strong>相邻的两个面不能着相同的颜色</strong>。我们用 $\gamma^* (G)$ 表示颜色的个数。</p><p>如果一个地图所需颜色 $\gamma^* (G)$ 的最小数量是 $k$，则我们称该图是 $k-面可着色的$ </p><p>【定理】地图 $G$ 是 $k-面可着色的$ 当且仅当 他的对偶图 $G^*$ 是 $k-点可着色的$</p><p>【五色定理】任何一个平面图都是 $5-面可着色的$</p><blockquote><p>证明：</p></blockquote><h3 id="第六部分：网络流问题"><a href="#第六部分：网络流问题" class="headerlink" title="第六部分：网络流问题"></a>第六部分：网络流问题</h3><p>回顾第二部分的连通部分</p><h4 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h4><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-18 20.34.52.png" alt="2022-04-18 20.34.52" style="zoom:40%;"></p><p>在生活中，经常会遇到一类问题：我们有一个如上图所示的抽象的供水管网，有起点和终点，我们需要求解关于这个供水管网的一系列性能问题。那么我们可以将其网络模型视为一种有向图 $D$，而网络上的流可视为边上的权，所以我们可以将该问题建模为</p><script type="math/tex; mode=display">D=(V,E,\omega)</script><p> 其中：</p><ul><li>$s,t \in V$，$s$ 为原点 (source)，$t$ 为目的点 (target)</li><li>$\omega$ 为 $A \to R$ 的映射。任何一条边 $x \in A$，$\omega (x)$ 为边 $x$ 的容量 (Capacity)</li></ul><p>【名词解释】</p><ul><li>流量 (Flow)：<strong>实际</strong>在模型中管线里的<strong>流量</strong>，流量不能超过容量</li><li>容量 (Capacity)：模型中边的权重，为该条<strong>边</strong>所能够承受的<strong>最大流量</strong></li><li><p>残差 (Residual)：又称空闲量，指“该条边在当前流量下还可以继续承受的流量”，即 $R_{esidual} = C_{apacity} - F_{low}$</p></li><li><p>最大流 (Maximum Flow)：在当前模型中能流过的最大总流量</p></li><li>最小割</li></ul><h5 id="最大流问题"><a href="#最大流问题" class="headerlink" title="最大流问题"></a>最大流问题</h5><h6 id="简单算法"><a href="#简单算法" class="headerlink" title="简单算法"></a>简单算法</h6><p>我们根据原图 (左) 创建一个残差图 (右)，其中空闲量 $R_{esidual} = C_{apacity} - F_{low}$，初始时 $F_{low}$ 均为 $0$；</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-18 20.50.35.png" alt="2022-04-18 20.50.35" style="zoom:30%;"></p><p>【第一轮循环】</p><div class="table-container"><table><thead><tr><th style="text-align:center">节点</th><th style="text-align:center">$v_1$</th><th style="text-align:center">$v_2$</th><th style="text-align:center">$v_4$</th><th style="text-align:center">t</th></tr></thead><tbody><tr><td style="text-align:center">[前序,方向,权重]</td><td style="text-align:center">[s,+,4]</td><td style="text-align:center">[S,+,2]</td><td style="text-align:center">[$v_2$,+,2]</td><td style="text-align:center">[$v_4$,+,3]</td></tr></tbody></table></div><p>我们在残差图中找出一条从起点 $s$ 到终点 $t$ 的简单路径，其中不能有回路。例如，我们已经找到了一条最右边的路径 $s \stackrel{2}\longrightarrow v_2 \stackrel{2}\longrightarrow v_4 \stackrel{3}\longrightarrow t $ 。由于短板效应，该条路径最多只能输送 $2$ ，所以三条边的路径的残差量都会 $-2$，即 $s \stackrel{0}\longrightarrow v_2 \stackrel{0}\longrightarrow v_4 \stackrel{1}\longrightarrow t $。</p><p>当某一条边的饱和 (Staturated) 即残差量为 $0$ 时，就将其从残差图中<strong>移除</strong>。第一轮循环结束。</p><p>【第二轮循环】</p><div class="table-container"><table><thead><tr><th style="text-align:center">节点</th><th style="text-align:center">$v_1$</th><th style="text-align:center">$v_4$</th><th style="text-align:center">$v_3$</th><th style="text-align:center">t</th></tr></thead><tbody><tr><td style="text-align:center">[前序,方向,权重]</td><td style="text-align:center">[s,+,4]</td><td style="text-align:center">[$v_1$,+,4]</td><td style="text-align:center">[$v_1$,+,2]</td><td style="text-align:center">[$v_3$,+,3]</td></tr></tbody></table></div><p>如下图所示，我们找到了一条从起点 $s$ 到终点 $t$ 的简单路径：$s \stackrel{4}\longrightarrow v_1 \stackrel{2}\longrightarrow v_3 \stackrel{3}\longrightarrow t $ ，</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-18 21.07.49.png" alt="2022-04-18 21.07.49" style="zoom:30%;"></p><p>由于短板效应，该条路径最多只能输送 $2$ ，所以三条边的路径的残差量都会 $-2$，即 $s \stackrel{2}\longrightarrow v_1 \stackrel{0}\longrightarrow v_3 \stackrel{1}\longrightarrow t $。更新残差图。第二轮循环结束。</p><p>【第三次循环】</p><div class="table-container"><table><thead><tr><th style="text-align:center">节点</th><th style="text-align:center">$v_1$</th><th style="text-align:center">$v_4$</th><th style="text-align:center">t</th></tr></thead><tbody><tr><td style="text-align:center">[前序,方向,权重]</td><td style="text-align:center">[s,+,2]</td><td style="text-align:center">[$v_1$,+,4]</td><td style="text-align:center">[$v_4$,+,1]</td></tr></tbody></table></div><p>如下图所示，我们找到了一条从起点 $s$ 到终点 $t$ 的简单路径：$s \stackrel{2}\longrightarrow v_1 \stackrel{4}\longrightarrow v_4 \stackrel{1}\longrightarrow t $ ，</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-18 21.14.31.png" alt="2022-04-18 21.14.31" style="zoom:30%;"></p><p>由于短板效应，该条路径最多只能输送 $1$ ，所以三条边的路径的残差量都会 $-1$，即 $s \stackrel{1}\longrightarrow v_1 \stackrel{3}\longrightarrow v_4 \stackrel{0}\longrightarrow t $。更新残差图。第三轮循环结束。</p><p>【第四次循环】</p><div class="table-container"><table><thead><tr><th style="text-align:center">节点</th><th style="text-align:center">$v_1$</th><th style="text-align:center">$v_2$</th><th style="text-align:center">$v_4$</th><th style="text-align:center">t</th></tr></thead><tbody><tr><td style="text-align:center">[前序,方向,权重]</td><td style="text-align:center">[s,+,1]</td><td style="text-align:center">[$v_1$,+,1]</td><td style="text-align:center">[$v_1$,+,3]</td><td style="text-align:center">[$v_3$,+,1]</td></tr></tbody></table></div><p>如下图所示，我们<strong>无法找到</strong>一条从起点 $s$ 到终点 $t$ 的简单路径，终止程序。</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-18 21.17.50.png" alt="2022-04-18 21.17.50" style="zoom:30%;"></p><p>用最后一次循环结果更新的残差 (Residual) 图与原图 (Capacity) 比较，得出流量 (Flow) 图，即 $F_{low} = C_{apacity} - R_{esidual}$，如下图所示。</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-18 21.24.55.png" alt="2022-04-18 21.24.55" style="zoom:25%;"></p><p>其中，边上的权重为 $[F_{low}/C_{apacity}]$ ，我们也可以从图中看出，网络中的总流量 (Amount of Flow) $= 2+3 = 5$</p><ul><li><p>注意⚠️：这种简单的算法<strong>不能保证</strong>结果的最优性，即总流量不一定是<strong>最大流</strong>。如下图所示的图的总流量就不是最大流，</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-18 21.37.51.png" alt="2022-04-18 21.37.51" style="zoom:25%;"></p><p>而图中红色的路径是阻塞流 (Blocking Flow)，即在当前流量下无法增加其他从源点到终点流，<strong>最大流也是一种阻塞流</strong>。</p></li></ul><h6 id="Ford-Fulkerson-算法"><a href="#Ford-Fulkerson-算法" class="headerlink" title="Ford-Fulkerson 算法"></a>Ford-Fulkerson 算法</h6><p>Ford-Fulkerson 算法一定能找到最大流，其与之前的简单算法的区别是：添加了一个<strong>回溯路径</strong>，一旦选择了“不好的”路径，就会撤销这个路径，沿着回溯路径回到源点。</p><p>【算法描述】</p><p>我们根据原图 (左) 创建一个残差图 (右)，其中空闲量 $R_{esidual} = C_{apacity} - F_{low}$，初始时 $F_{low}$ 均为 $0$；</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-18 20.50.35.png" alt="2022-04-18 20.50.35" style="zoom:30%;"></p><p>【第一轮循环】</p><div class="table-container"><table><thead><tr><th style="text-align:center">节点</th><th style="text-align:center">$v_1$</th><th style="text-align:center">$v_2$</th><th style="text-align:center">$v_4$</th><th style="text-align:center">t</th></tr></thead><tbody><tr><td style="text-align:center">[前序,方向,权重]</td><td style="text-align:center">[s,+,4]</td><td style="text-align:center">[S,+,2]</td><td style="text-align:center">[$v_1$,+,4]</td><td style="text-align:center">[$v_4$,+,3]</td></tr><tr><td style="text-align:center">backtracking path (next)</td><td style="text-align:center">[S,-,0]</td><td style="text-align:center">[S,-,0]</td><td style="text-align:center">[$v_1$,-,0]</td><td style="text-align:center">[$v_4$,-,0]</td></tr></tbody></table></div><p>我们在残差图中找出一条从起点 $s$ 到终点 $t$ 的简单路径，其中不能有回路。例如，我们已经找到了一条路径 $s \stackrel{4}\longrightarrow v_1 \stackrel{4}\longrightarrow v_4 \stackrel{3}\longrightarrow t $ 。由于短板效应，该条路径最多只能输送 $3$ ，所以三条边的路径的残差量都会 $-3$，即 $s \stackrel{1}\longrightarrow v_1 \stackrel{1}\longrightarrow v_4 \stackrel{0}\longrightarrow t  $。更新残差图。</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-18 21.54.44.png" alt="2022-04-18 21.54.44" style="zoom:30%;"></p><p>如上图所示，添加一条绿色的<strong>回溯路径</strong>，每个边的权都为 $3$： $t \stackrel{3}\longrightarrow v_4\stackrel{3}\longrightarrow v_1 \stackrel{3}\longrightarrow s$    。第一轮循环结束。</p><p>【第二轮循环】</p><div class="table-container"><table><thead><tr><th style="text-align:center">节点</th><th style="text-align:center">$v_1$</th><th style="text-align:center">$v_2$</th><th style="text-align:center">$v_3$</th><th style="text-align:center">t</th></tr></thead><tbody><tr><td style="text-align:center">[前序,方向,权重]</td><td style="text-align:center">[S,+,1]</td><td style="text-align:center">[S,+,2]</td><td style="text-align:center">[$v_1$,+,2]</td><td style="text-align:center">[$v_3$,+,3]</td></tr><tr><td style="text-align:center">backtracking path</td><td style="text-align:center">[S,-,3]</td><td style="text-align:center">[S,-,0]</td><td style="text-align:center">[$v_1$,-,0]</td><td style="text-align:center">[$v_3$,-,0]</td></tr></tbody></table></div><p>如下图所示，我们找到了一条从起点 $s$ 到终点 $t$ 的简单路径：$s \stackrel{1}\longrightarrow v_1 \stackrel{2}\longrightarrow v_3 \stackrel{3}\longrightarrow t $ ，</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-18 21.55.35.png" alt="2022-04-18 21.55.35" style="zoom:30%;"></p><p>由于短板效应，该条路径最多只能输送 $1$ ，所以三条边的路径的残差量都会 $-1$，即 $s \stackrel{0}\longrightarrow v_1 \stackrel{1}\longrightarrow v_3 \stackrel{2}\longrightarrow t $。更新残差图。</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-18 22.00.24.png" alt="2022-04-18 22.00.24" style="zoom:30%;"></p><p>如上图所示，添加一条绿色的<strong>回溯路径</strong>，每个边的权都为 $1$： $t \stackrel{1}\longrightarrow v_3\stackrel{1}\longrightarrow v_1 \stackrel{1}\longrightarrow s$，并于之前的回溯路径合并。第二轮循环结束。</p><p>【第三轮循环】</p><div class="table-container"><table><thead><tr><th style="text-align:center">节点</th><th style="text-align:center">$v_1$</th><th style="text-align:center">$v_2$</th><th style="text-align:center">$v_4$</th><th style="text-align:center">$v_3$</th><th style="text-align:center">t</th></tr></thead><tbody><tr><td style="text-align:center">[前序,方向,权重]</td><td style="text-align:center">[S,+,0]</td><td style="text-align:center">[S,+,2]</td><td style="text-align:center">[$v_2$,+,2] / [$v_1$,+,1]</td><td style="text-align:center">[$v_1$,+,1]</td><td style="text-align:center">[$v_3$,+,2]</td></tr><tr><td style="text-align:center">backtracking path</td><td style="text-align:center">[S,-,4]</td><td style="text-align:center">[S,-,0]</td><td style="text-align:center">[$v_2$,-,0] / [$v_1$,-,1]</td><td style="text-align:center">[$v_1$,-,1]</td><td style="text-align:center">[$v_3$,-,1]</td></tr></tbody></table></div><p>如果此时我们将绿色的回溯路径去掉，我们就不能在起点和终点之间找到一条路径。Ford-Fulkerson 算法的关键就在于这些回溯路径。如下图所示，我们考虑回溯路径，我们找到了一条从起点 $s$ 到终点 $t$ 的简单路径：$s \stackrel{2}\longrightarrow v_2 \stackrel{2}\longrightarrow v_4 \stackrel{3^*}\longrightarrow v_1 \stackrel{1}\longrightarrow v_3 \stackrel{2}\longrightarrow t$ ，</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-18 22.15.53.png" alt="2022-04-18 22.15.53" style="zoom:25%;"></p><p>由于短板效应，该条路径最多只能输送 $1$ ，所以三条边的路径的残差量都会 $-1$，即 $s \stackrel{1}\longrightarrow v_2 \stackrel{1}\longrightarrow v_4 \stackrel{2^*}\longrightarrow v_1 \stackrel{0}\longrightarrow v_3 \stackrel{1}\longrightarrow t$。更新残差图。</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-18 22.18.14.png" alt="2022-04-18 22.18.14" style="zoom:25%;"></p><p>如上图所示，添加一条绿色的<strong>回溯路径</strong>，每个边的权都为 $1$： $t \stackrel{1}\longrightarrow v_3 \stackrel{1}\longrightarrow v_1 \stackrel{1^*}\longrightarrow v_4 \stackrel{1}\longrightarrow v_2 \stackrel{1}\longrightarrow s$，并于之前的回溯路径合并。第三轮循环结束。</p><p>【第四轮循环】</p><p>如第三轮循环末的图所示，没有任何路径通往红色区域 $v_3 \stackrel{1}\longrightarrow t$，说明现在不存在其他路径从起点流向终点，所以终止程序。</p><p>用最后一次循环结果更新的残差 (Residual) 图<strong>去除所有回溯路径</strong>与原图 (Capacity) 比较，得出流量 (Flow) 图，即 $F_{low} = C_{apacity} - R_{esidual}$，如下图所示。</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-18 22.25.31.png" alt="2022-04-18 22.25.31" style="zoom:25%;"></p><p>其中，边上的权重为 $[F_{low}/C_{apacity}]$ ，我们也可以从图中看出，网络中的总流量 (Amount of Flow) $= 2+3 = 5$，最大流的大小也等于 $5$。</p><ul><li>注意⚠️：Ford-Fulkerson 算法的时间复杂度较高。仍然有其他算法可以更快速的求解该问题，如 <a href="https://www.bilibili.com/video/BV1uQ4y197Le/">Edmonds-Karp 算法</a> 和 <a href="https://www.bilibili.com/video/BV1j64y1R7yK/">Dinic’s 算法</a>（详见B站视频讲解），在此不再赘述。</li></ul><h5 id="最小割问题"><a href="#最小割问题" class="headerlink" title="最小割问题"></a>最小割问题</h5><p>我们先回顾一下之前之前学习的割，可类比与今天的网络流中最小割问题。</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-18 20.34.52.png" alt="2022-04-18 20.34.52" style="zoom:40%;"></p><p>在如上图所示的网络流中，有向图 $D=(V,E,\omega)$</p><p>其中：</p><ul><li>$s,t \in V$，$s$ 为原点 (source)，$t$ 为目的点 (target)</li><li>$\omega$ 为 $A \to R$ 的映射。任何一条边 $x \in A$，$\omega (x)$ 为边 $x$ 的容量 (Capacity)</li></ul><p>【定义】S-T Cut：将所有的顶点分为两个集合 $S$ 和 $T$</p><ul><li>$S \cup P = V$ 并且 $S \cap P = \emptyset$</li><li>$s \in S$ 并且 $t \in T$</li><li>二元组集合 $(S,T)$ 被称作 “S-T Cut”</li></ul><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-18 22.56.54.png" alt="2022-04-18 22.56.54" style="zoom:30%;"></p><p>如上图所示，我们去除图中红色的边，使得<strong>不存在任意一套路径可以从起点 $s$ 到终点 $t$</strong> 。去除这些边后，定点集 $V$ 就会分裂成两部分 $_{Subset}S$ 和 $_{Subset}T$。<u>然而这样的集合划分<strong>并不唯一</strong></u>。</p><p>【注意⚠️】图中有一条边 $v_4 \stackrel{4}\longrightarrow s$ 连通  $_{Subset}S$ 和 $_{Subset}T$，但是即使有这条边的存在，依然<strong>不存在任意一套路径可以从起点 $s$ 到终点 $t$</strong> 。所以我们不用去管他。</p><ul><li>容量 $Capacity(S,T)$ 是所有从集合 $_{Subset}S$ 通向集合 $_{Subset}T$ 的<strong>边的权重之和</strong>，<ul><li>上图中左边的容量 $Capacity_左(S,T) = 2+1 =3$，</li><li>右边的“S-T Cut”容量 $Capacity_右(S,T) = 2+2+2 = 6$</li></ul></li></ul><p>【最小割】：Minimum S-T Cut (Min-Cut)，是在所有“S-T Cut” 中容量最小的那个。目标是用最小的“力气”（权）就可以截断水流（起点 $s$ 不到终点 $t$）。</p><h5 id="最大流-最小割问题"><a href="#最大流-最小割问题" class="headerlink" title="最大流 - 最小割问题"></a>最大流 - 最小割问题</h5><p>对于一个网络流问题，<strong>最大流的流量</strong> 就<strong>等于</strong> <strong>最小割的容量</strong>，即</p><script type="math/tex; mode=display">Max \;flow = Min\;cut</script><p>我们可以将 <strong>寻找最小割的问题</strong> 等价转化为 <strong>寻找最大流问题</strong>：</p><p>在 <strong>寻找最大流问题</strong> 中，在最后一次迭代中<strong>去除回溯路径</strong>的<strong>残差图</strong> (Residual Graph) 中，从起点 $s$ 出发，找到所有能达到的节点，将它们放入集合 $_{Subset}S$，将剩下的所有节点放入集合 $_{Subset}T$。这样就得到了最小割的二元组 $(S,T)$。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;图论&quot;&gt;&lt;a href=&quot;#图论&quot; class=&quot;headerlink&quot; title=&quot;图论&quot;&gt;&lt;/a&gt;图论&lt;/h2&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://dave0126.github.io/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/&quot;&gt;本文章&lt;/a&gt;是根据法国国立高等电力技术、电子学、计算机、水力学与电信学校 (E.N.S.E.E.I.H.T.) 第七学期课程&lt;em&gt;“Graph Theory”&lt;/em&gt; 总结而来的课程笔记。碍于本人学识有限，部分叙述难免存在纰漏，请读者注意甄别。&lt;/p&gt;</summary>
    
    
    
    <category term="课程笔记" scheme="https://dave0126.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="图论" scheme="https://dave0126.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="课程笔记" scheme="https://dave0126.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>数据结构及常见算法- 复习总结</title>
    <link href="https://dave0126.github.io/2021/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95-%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>https://dave0126.github.io/2021/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95-%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/</id>
    <published>2021-10-28T07:17:15.000Z</published>
    <updated>2022-08-28T19:27:43.376Z</updated>
    
    <content type="html"><![CDATA[<p>内容检索</p><ol><li><a href="#0-数据结构与算法设计">数据结构和算法概述</a></li><li><a href="#1-算法分析">算法分析</a></li><li><a href="#2-排序算法">排序算法</a></li><li>线性表(#)</li><li>符号表(#)</li><li>树(#)</li><li>堆(#)</li><li>优先队列(#)</li><li>并查集(#)</li><li>图(#)</li></ol><span id="more"></span><h2 id="0-数据结构与算法设计"><a href="#0-数据结构与算法设计" class="headerlink" title="0 数据结构与算法设计"></a>0 数据结构与算法设计</h2><p>数据结构是一门研究非数值计算的程序设计问题的操作对象，以及它们之间的关系和操作问题的学科。即<u>数据结构就是把数据元素按照一定的关系组织起来的集合，用来组织和存储数据。</u></p><h3 id="0-1-数据结构分类"><a href="#0-1-数据结构分类" class="headerlink" title="0.1 数据结构分类"></a>0.1 数据结构分类</h3><p>传统上，我们可以把数据结构分为<strong><em><u>逻辑结构</u></em></strong>和<strong><em><u>物理结构</u></em></strong>两大类。</p><h5 id="逻辑结构分类"><a href="#逻辑结构分类" class="headerlink" title="逻辑结构分类:"></a>逻辑结构分类:</h5><p>逻辑结构是从具体问题中抽象出来的模型，是抽象意义上的结构，按照对象中数据元素之间的相互关系分类，也是我们后面课题中需要关注和讨论的问题。</p><h6 id="a-【集合结构】："><a href="#a-【集合结构】：" class="headerlink" title="(a) 【集合结构】："></a>(a) 【集合结构】：</h6><p>集合结构中数据元素除了属于同一个集合外，他们之间没有任何其他的关系。</p><p><img src="/2021/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95-%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/image-20220828093321336.png" alt="image-20220828093321336" style="zoom:40%;"></p><h6 id="b-【线性结构】："><a href="#b-【线性结构】：" class="headerlink" title="(b)【线性结构】："></a>(b)【线性结构】：</h6><p>线性结构中的数据元素之间存在一对一的关系</p><p><img src="/2021/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95-%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/image-20220828093430990.png" alt="image-20220828093430990" style="zoom:40%;"></p><h6 id="c-【树形结构】："><a href="#c-【树形结构】：" class="headerlink" title="(c)【树形结构】："></a>(c)【树形结构】：</h6><p>树形结构中的数据元素之间存在一对多的层次关系</p><p><img src="/2021/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95-%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/image-20220828093555849.png" alt="image-20220828093555849" style="zoom:40%;"></p><h6 id="d-【图形结构】："><a href="#d-【图形结构】：" class="headerlink" title="(d)【图形结构】："></a>(d)【图形结构】：</h6><p>图形结构的数据元素是多对多的关系</p><p><img src="/2021/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95-%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/image-20220828093628509.png" alt="image-20220828093628509" style="zoom:40%;"></p><h5 id="物理结构分类"><a href="#物理结构分类" class="headerlink" title="物理结构分类:"></a>物理结构分类:</h5><p>逻辑结构在计算机中真正的表示方式(又称为映像)称为物理结构，也可以叫做存储结构。常见的物理结构有<strong><em><u>顺序存储结构</u></em></strong>、<strong><em><u>链式存储结构</u></em></strong>。</p><h6 id="a-【顺序存储结构】："><a href="#a-【顺序存储结构】：" class="headerlink" title="(a)【顺序存储结构】："></a>(a)【顺序存储结构】：</h6><p>把数据元素放到地址连续的存储单元里面，其数据间的逻辑关系和物理关系是一致的 ，比如我们常用的数组就是顺序存储结构。</p><p><img src="/2021/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95-%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/image-20220828093840520.png" alt="image-20220828093840520" style="zoom:50%;"></p><ul><li>优点：得益于它的数据元素放到地址连续的存储单元里，所以<strong><em><u>查找</u></em></strong>和<strong><em><u>更新</u></em></strong>速度快</li><li>缺点：如果向这种结构中间<strong><em><u>插入</u></em></strong>或<strong><em><u>删除</u></em></strong>某个元素，需要移动该元素后面的所有元素。</li></ul><h6 id="b-【链式存储结构】："><a href="#b-【链式存储结构】：" class="headerlink" title="(b)【链式存储结构】："></a>(b)【链式存储结构】：</h6><p>把数据元素存放在任意的存储单元里面，这组存储单元可以是连续的也可以是不连续的。此时，数据元素之间并不能反映元素间的逻辑关系，因此在链式存储结构中引进了一个<strong><em><u>指针</u></em></strong>存放数据元素的地址，这样通过地址就可以找到相关联数据元素的位置。</p><p><img src="/2021/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95-%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/image-20220828094416257.png" alt="image-20220828094416257" style="zoom:40%;"></p><h3 id="0-2-算法"><a href="#0-2-算法" class="headerlink" title="0.2 算法"></a>0.2 算法</h3><p>算法是指<u>解题方案的准确而完整的描述</u>，是一系列解决问题的清晰指令，算法代表着用系统的方法解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。</p><p>在程序中，我们也可以用不同的算法解决相同的问题，而不同的算法的成本也是不相同的。</p><blockquote><p>总体上，一个优秀的算法追求以下两个目标:</p><ol><li>花最少的时间完成需求; </li><li>占用最少的内存空间完成需求;</li></ol></blockquote><p>【例1】计算 1 到 100 的和。 </p><p>第一种解法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">  <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> n=<span class="number">100</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(<span class="string">&quot;sum=&quot;</span> + sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种解法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> n=<span class="number">100</span>;</span><br><span class="line">  sum = (n+<span class="number">1</span>)*n/<span class="number">2</span>;</span><br><span class="line">  System.out.println(<span class="string">&quot;sum=&quot;</span>+sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很明显，第二种算法完成需求，花费的时间更少一些。</p><p>【例2】计算 10 的阶乘</p><p>第一种解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//测试，计算10的阶乘</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> fun1(<span class="number">10</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//计算n的阶乘</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">fun1</span><span class="params">(<span class="type">long</span> n)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n==<span class="number">1</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n*fun1(n-<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种解法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="comment">//测试，计算10的阶乘</span></span><br><span class="line">    <span class="type">long</span> <span class="variable">result</span> <span class="operator">=</span> fun2(<span class="number">10</span>);</span><br><span class="line">    System.out.println(result);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">//计算n的阶乘</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">long</span> <span class="title function_">fun2</span><span class="params">(<span class="type">long</span> n)</span>&#123;</span><br><span class="line">    <span class="type">int</span> result=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">long</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">      result*=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一种解法，使用递归完成需求，<code>fun1</code>方法会执行 10 次，并且第一次执行未完毕，调用第二次执行，第二次执行未完毕，调用第三次执行…… 最终，最多的时候，需要在栈内存同时开辟 10 块内存分别执行 10 个 <code>fun1</code> 方法。</p><p>第二种解法，使用 <code>for</code> 循环完成需求，<code>fun2</code> 方法只会执行一次，最终，只需要在栈内存开辟一块内存执行 <code>fun2</code> 方法 即可。</p><p>很明显，第二种算法完成需求，占用的内存空间更小。</p><h2 id="1-算法分析"><a href="#1-算法分析" class="headerlink" title="1 算法分析"></a>1 算法分析</h2><p>前面我们已经介绍了，研究算法的最终目的就是如何花更少的时间，如何占用更少的内存去完成相同的需求，并且也通过案例演示了不同算法之间时间耗费和空间耗费上的差异，但我们并不能将时间占用和空间占用量化，因此，接下来我们要学习有关算法时间耗费和算法空间耗费的描述和分析。</p><p>有关算法时间耗费分析，我们称之为算法的时间复杂度分析，有关算法的空间耗费分析，我们称之为算法的空间复杂度分析。</p><h4 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><p>我们要计算算法时间耗费情况，首先我们得度量算法的执行时间，那么如何度量呢?</p><h5 id="【事后分析估算方法】"><a href="#【事后分析估算方法】" class="headerlink" title="【事后分析估算方法】"></a>【事后分析估算方法】</h5><p>比较容易想到的方法就是我们把算法执行若干次，然后用计时器计时。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">  <span class="type">long</span> <span class="variable">strat</span> <span class="operator">=</span> System.currentTomeMillis();</span><br><span class="line">  <span class="comment">// TODO 待测试程序</span></span><br><span class="line">  <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.currentTomeMillis();</span><br><span class="line">  <span class="type">long</span> <span class="variable">excuteTime</span> <span class="operator">=</span> end - start;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种统计方法主要是通过设计好的测试程序和测试数据，利用计算机计时器对不同的算法编制的程序的运行时间进行比较，从而确定算法效率的高低。</p><p>但是这种方法有很大的缺陷：必须依据算法实现编制好的测试程序，通常要花费大量时间和精力，测试完了如果发现测试的是非常糟糕的算法，那么之前所做的事情就全部白费了，并且<u>不同的测试环境（硬件环境）</u>的差别 导致测试的结果差异也很大。</p><h5 id="【事前分析估算方法】"><a href="#【事前分析估算方法】" class="headerlink" title="【事前分析估算方法】"></a>【事前分析估算方法】</h5><p>在计算机程序编写前，依据统计方法对算法进行估算，经过总结，我们发现一个高级语言编写的程序程序在计算机上运行所消耗的时间取决于下列因素:</p><ol><li>算法采用的策略和方案；</li><li>编译产生的代码质量；</li><li>问题的输入规模(所谓的问题输入规模就是输入量的多少)；</li><li>机器执行指令的速度。</li></ol><p>由此可见，抛开这些与计算机硬件、软件有关的因素，一个程序的运行时间依赖于<strong><em><u>算法的好坏</u></em></strong>和<strong><em><u>问题的输入规模</u></em></strong>。如果算法固定，那么该算法的执行时间就只和问题的输入规模有关系了。</p><p>我么再次以之前的求和案例为例，进行分析。</p><p>第一种解法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">  <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 执行1次</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 执行1次</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;  <span class="comment">// 执行 n+1 次</span></span><br><span class="line">    sum += i; <span class="comment">// 执行n次</span></span><br><span class="line">  &#125;</span><br><span class="line">  System.out.println(<span class="string">&quot;sum=&quot;</span> + sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二种解法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 执行1次</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>; <span class="comment">// 执行1次</span></span><br><span class="line">  sum = (n+<span class="number">1</span>)*n/<span class="number">2</span>; <span class="comment">// 执行1次</span></span><br><span class="line">  System.out.println(<span class="string">&quot;sum=&quot;</span>+sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，当输入规模为 n 时，</p><ul><li>第一种算法执行了$1+1+(n+1)+n=2n+3$ 次；</li><li>第二种算法执行了 $1+1+1=3$ 次</li></ul><p>如果我们把第一种算法的循环体看做是一个整体，<u>忽略结束条件的判断</u>，那么其实这两个算法运行时间的差距就是 $n$ 和 $1$ 的差距。</p><p>为什么循环判断在【算法1】里执行了 n+1 次，看起来是个不小的数量，但是却可以忽略呢？</p><p>我们研究算法复杂度，侧重的是当输入规模不断增大时，算法的增长量的一个抽象（规律），而不是精确地知道需要执行多少次，最重要的就是把<strong><em><u>核心操作的次数</u></em></strong>和输入规模关联起来。</p><p><img src="/2021/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95-%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/image-20220828102017852.png" alt="image-20220828102017852" style="zoom:40%;"></p><p>关于输入规模 $n$ 的多项式中，随着算法输入规模的增长，<strong><em><u>常数项</u></em></strong>和<strong><em><u>最高次幂的常数系数</u></em></strong>可以被<strong><em><u>忽略</u></em></strong>，我们只关心<strong><em><u>最高次幂</u></em></strong>。</p><blockquote><p>算法函数中最高次幂越小，算法效率越高。</p></blockquote><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><h5 id="大-O-记法"><a href="#大-O-记法" class="headerlink" title="大 O 记法"></a>大 O 记法</h5><p> 在进行算法分析时，语句总的执行次数 $T(n)$ 是关于问题规模 $n$ 的函数，进而分析 $T(n)$ 随着 $n$ 的变化情况并确定 $T(n)$ 的<strong><em><u>量级</u></em></strong>。算法的<u>时间复杂度</u>，就是算法的<u>时间量度</u>，记作：</p><script type="math/tex; mode=display">T(n)=O(f(n))</script><p>它表示随着问题规模 $n$ 的增大，算法执行时间的增长率和 $f(n)$ 的增长率相同，称作算法的渐近时间复杂度，简称时间复杂度，其中 $f(n)$ 是问题规模 $n$ 的某个函数。</p><p>在这里，我们需要明确一个事情：$执行次数=执行时间$ 用大写 $O()$ 来体现算法时间复杂度的记法，我们称之为大O记法。</p><p>一般情况下，随着输入规模 $n$ 的增大，$T(n)$ 增长最慢的算法为最优算法。 </p><blockquote><p>有一个存储了n个随机数字的数组，请从中查找出指定的数字。</p></blockquote><p>【最好情况】查找的第一个数字就是期望的数字，那么算法的时间复杂度为 $O(1)$</p><p>【最坏情况】 查找的最后一个数字，才是期望的数字，那么算法的时间复杂度为 $O(n)$</p><p>【平均情况】 任何数字查找的平均成本是 $O(n/2)$</p><p>最坏情况是一种保证，在应用中，这是一种最基本的保障，即使在最坏情况下，也能够正常提供服务，所以，除非特别指定，我们提到的<u>运行时间都指的是最坏情况下的运行时间</u>。</p><h5 id="常数阶-O-1"><a href="#常数阶-O-1" class="headerlink" title="常数阶 $O(1)$"></a>常数阶 $O(1)$</h5><p>一般不涉及循环操作的都是常数阶，因为它不会随着 n 的增长而增加操作次数。例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> <span class="number">100</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n + <span class="number">2</span>;</span><br><span class="line">  System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码，不管输入规模 n 是多少，都执行 2 次，根据大O推导法则，常数用 1 来替换，所以上述代码的时间复杂度为 $O(1)$</p><h5 id="线性阶-O-n"><a href="#线性阶-O-n" class="headerlink" title="线性阶 $O(n)$"></a>线性阶 $O(n)$</h5><p>一般含有非嵌套循环涉及线性阶（单层 <code>for</code> 循环），线性阶就是随着输入规模的扩大，对应计算次数呈直线增长，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">   System.out.println(i); </span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码，它的循环的时间复杂度为 $O(n)$，因为循环体中的代码需要执行 n 次。</p><h5 id="平方阶-O-n-2"><a href="#平方阶-O-n-2" class="headerlink" title="平方阶 $O(n^2)$"></a>平方阶 $O(n^2)$</h5><p> 一般嵌套循环（双层 <code>for</code> 循环）属于这种时间复杂度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  </span><br><span class="line"> <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=n ; i++) &#123;</span><br><span class="line">   <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>; j &lt;=n ; j++) &#123;</span><br><span class="line">     System.out.println(i + <span class="string">&quot;\t&quot;</span> + j);</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码，$n=100$，也就是说，外层循环每执行一次，内层循环就执行 100 次，那总共程序想要从这两个循环 中出来，就需要执行 $100 \times100$ 次，也就是 n 的平方次，所以这段代码的时间复杂度是 $O(n^2)$.</p><h5 id="立方阶-O-n-3"><a href="#立方阶-O-n-3" class="headerlink" title="立方阶 $O(n^3)$"></a>立方阶 $O(n^3)$</h5><p>一般三层嵌套循环属于这种时间复杂度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;=n ; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt;=n ; j++) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> i; m &lt;=n ; j++) &#123;</span><br><span class="line">        System.out.println(i,j,m);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码，$n=100$，也就是说，外层循环每执行一次，中间循环循环就执行 100 次，中间循环每执行一次，最内层循环需要执行 100 次，那总共程序想要从这三个循环中出来，就需要执行 $100\times 100\times 100$次，也就是 $n^3$，所以这段代码的时间复杂度是 $O(n^3)$</p><h5 id="对数阶-O-log-n"><a href="#对数阶-O-log-n" class="headerlink" title="对数阶 $O(log \;n)$"></a>对数阶 $O(log \;n)$</h5><p>如下列程序所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">int</span> i=<span class="number">1</span>,</span><br><span class="line">  n=<span class="number">100</span>; </span><br><span class="line">  <span class="keyword">while</span>(i&lt;n)&#123;</span><br><span class="line">    i = i*<span class="number">2</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>由于每次 $i\times 2$ 之后，就距离 n 更近一步，假设有 x 个 2 相乘后大于 n，则会退出循环。由于是 $2^x=n$，得到 $x=log(2)n$，而我们在分析算法时间复杂时只关注增长率，从而可以忽略底数，所以这个循环的时间复杂度为 $O(log \;n)$。</p><p>下面是对常见时间复杂度的一个总结：</p><div class="table-container"><table><thead><tr><th style="text-align:center">描述</th><th style="text-align:center">增长的数量级</th><th style="text-align:center">说明</th><th style="text-align:center">举例</th></tr></thead><tbody><tr><td style="text-align:center">常数级别</td><td style="text-align:center">$O(1)$</td><td style="text-align:center">普通语句</td><td style="text-align:center">将两个数相加</td></tr><tr><td style="text-align:center">对数级别</td><td style="text-align:center">$O(log \; n)$</td><td style="text-align:center">二分策略</td><td style="text-align:center">二分查找</td></tr><tr><td style="text-align:center">线性级别</td><td style="text-align:center">$O(n)$</td><td style="text-align:center">单层循环</td><td style="text-align:center">找出最大元素</td></tr><tr><td style="text-align:center">线性对数级别</td><td style="text-align:center">$O(nlog\;n)$</td><td style="text-align:center">分治思想</td><td style="text-align:center">归并排序</td></tr><tr><td style="text-align:center">平方级别</td><td style="text-align:center">$O(n^2)$</td><td style="text-align:center">双层循环</td><td style="text-align:center">检查所有元素对</td></tr><tr><td style="text-align:center">立方级别</td><td style="text-align:center">$O(n^3)$</td><td style="text-align:center">三层循环</td><td style="text-align:center">检查所有三元组</td></tr><tr><td style="text-align:center">指数级别</td><td style="text-align:center">$O(2^n)$</td><td style="text-align:center">穷举查找</td><td style="text-align:center">检查所有子集</td></tr></tbody></table></div><p>他们的复杂程度从低到高依次为：</p><script type="math/tex; mode=display">O(1)<O(log\;n)<O(n)<O(nlog\;n)<O(n^2)<O(n^3)</script><p>我们的算法，尽可能的追求的是$O(1)$，$O(log \; n)$，$O(n)$，$O(nlog\;n)$ 这几种时间复杂度，而如果发现算法的时间复杂度为平方阶、 立方阶或者更复杂的，那我们可以分为这种算法是不可取的，需要优化。</p><h4 id="函数调用的时间复杂度分析"><a href="#函数调用的时间复杂度分析" class="headerlink" title="函数调用的时间复杂度分析"></a>函数调用的时间复杂度分析</h4><p>之前，我们分析的都是单个函数内，算法代码的时间复杂度，接下来我们分析函数调用过程中时间复杂度。</p><p>【案例一】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">int</span> n=<span class="number">100</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    show(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">  System.out.println(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>main</code> 方法中，有一个 <code>for</code> 循环，循环体调用了 <code>show</code> 方法，由于 <code>show</code> 方法内部只执行了一行代码，所以 <code>show</code> 方法的时间复杂度为 $O(1)$，那 <code>main</code> 方法的时间复杂度就是 $O(n)$</p><p>【案例二】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">int</span> n=<span class="number">100</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    show(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span> i)</span> &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">    System.out.println(i);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 <code>main</code> 方法中，有一个 <code>for</code> 循环，循环体调用了 <code>show</code> 方法，由于 <code>show</code> 方法内部也有一个 <code>for</code> 循环，所以 <code>show</code> 方法的时间复杂度为 $O(n)$，那 <code>main</code> 方法的时间复杂度就是 $O(n^2)$</p><p>【案例三】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; <span class="comment">// O(2n^2)</span></span><br><span class="line">  <span class="type">int</span> n=<span class="number">100</span>;</span><br><span class="line">  show(n); <span class="comment">// O(n)</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123; <span class="comment">// O(n)</span></span><br><span class="line">    show(i); <span class="comment">// O(n^2)</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">      System.out.println(j); <span class="comment">// O(n^2)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">show</span><span class="params">(<span class="type">int</span> i)</span> &#123; <span class="comment">// O(n)</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; i; i++) &#123;</span><br><span class="line">    System.out.println(i); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在 <code>show</code>方法中，有一个 <code>for</code> 循环，所以show方法的时间复杂度为 $O(n)$</li><li>在 <code>main</code>方法中，<code>show(n)</code> 这行代码内部执行的次数为 n，第一个 <code>for</code> 循环内调用了 <code>show</code> 方法，所以其执行次数为 $n^2$<ul><li>第二个嵌套 <code>for</code> 循环内只执行了一行代码， 所以其执行次数为 $n^2$</li><li>那么 <code>main</code> 方法总执行次数为 $n+n^2+n^2=2n^2+n$。</li></ul></li><li>根据大 O 推导规则，去掉 n 保留最高阶项，并去掉最高阶项的常数因子2，所以最终 <code>main</code> 方法的时间复杂度为 $O(n^2)$</li></ul><h4 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h4><h5 id="Java-中常见内存占用"><a href="#Java-中常见内存占用" class="headerlink" title="Java 中常见内存占用"></a>Java 中常见内存占用</h5><ul><li>基本数据类型内存占用情况</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">数据类型</th><th style="text-align:center">内存占用字节数</th></tr></thead><tbody><tr><td style="text-align:center"><code>byte</code></td><td style="text-align:center">1</td></tr><tr><td style="text-align:center"><code>short</code></td><td style="text-align:center">2</td></tr><tr><td style="text-align:center"><code>int</code></td><td style="text-align:center">4</td></tr><tr><td style="text-align:center"><code>long</code></td><td style="text-align:center">8</td></tr><tr><td style="text-align:center"><code>float</code></td><td style="text-align:center">4</td></tr><tr><td style="text-align:center"><code>double</code></td><td style="text-align:center">8</td></tr><tr><td style="text-align:center"><code>boolean</code></td><td style="text-align:center">1</td></tr><tr><td style="text-align:center"><code>char</code></td><td style="text-align:center">2</td></tr></tbody></table></div><ul><li>计算机访问内存的方式都是一次一个字节</li></ul><p><img src="/2021/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95-%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/image-20220828112100412.png" alt="image-20220828112100412" style="zoom:50%;"></p><ul><li><p>一个引用（机器地址）需要 <strong><em><u>8 个字节</u></em></strong>表示：</p><p>例如: <code>Date date = new Date()</code>，则 <code>date</code> 这个变量需要占用 8个字节来表示</p></li><li><p>创建一个对象，比如 <code>new Date()</code>，除了 <code>Date</code>对象内部存储的数据（例如年月日等信息）占用的内存，该对象本身也有内存开销，<u>每个对象的自身开销是 <strong><em>16 个字节</em></strong>，用来保存对象的头信息</u>。</p></li><li>一般内存的使用，如果不够 8 个字节，都会被<strong><u><em>自动填充为 8 字节</em></u></strong></li><li><strong><em><u>Java 中数组</u></em></strong> 被限定为对象，他们一般都会因为记录长度而需要额外的内存，一个原始数据类型的数组一般需要 <strong><em><u>24字节</u></em></strong>的头信息(16个自己的对象开销，<strong><u><em>4字节用于保存长度以及4个填充字节</em></u></strong>)再加上保存值所需的内存。</li></ul><h4 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h4><p>了解了 Java 的内存最基本的机制，就能够有效帮助我们估计大量程序的内存使用情况。</p><p>算法的空间复杂度计算公式记作</p><script type="math/tex; mode=display">S(n)=O(f(n))</script><p>其中 $n$ 为输入规模，$f(n)$ 为语句关于 $n$ 所占存储空间的函数。 </p><blockquote><p>【案例一】：对指定的数组元素进行反转，并返回反转的内容。</p></blockquote><p>算法一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] reverseList1(<span class="type">int</span>[] arr)&#123;</span><br><span class="line">  <span class="type">int</span> n=arr.length; <span class="comment">// 申请4个字节</span></span><br><span class="line">  <span class="type">int</span> temp; <span class="comment">// 申请4个字节</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span>(<span class="type">int</span> start=<span class="number">0</span>,end=n-<span class="number">1</span>; start&lt;=end; start++,end--)&#123;</span><br><span class="line">    temp=arr[start];</span><br><span class="line">    arr[start]=arr[end];</span><br><span class="line">    arr[end]=temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>不管传入的数组大小为多少，始终额外申请 $4+4=8$ 个字节;</li></ul><p>算法二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span>[] reverse2(<span class="type">int</span>[] arr)&#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> arr.length; <span class="comment">// 申请4个字节</span></span><br><span class="line">  <span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[n]; <span class="comment">// 申请n*4个字节+数组自身头信息开销24个字节</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> n-<span class="number">1</span>; i &gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">    temp[n-<span class="number">1</span>-i]=arr[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>$4+4n+24=4n+28$</li></ul><p>根据大 O 推导法则，</p><ul><li>算法一的空间复杂度为 $O(1)$；</li><li>算法二的空间复杂度为 $O(n)$</li></ul><p>所以从空间占用的角度讲，算法一要优于算法二。</p><h2 id="2-排序算法"><a href="#2-排序算法" class="headerlink" title="2 排序算法"></a>2 排序算法</h2><h4 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序 Bubble Sort"></a>冒泡排序 Bubble Sort</h4><p>冒泡排序(Bubble Sort)，是一种计算机科学领域的较简单的排序算法。 </p><p>排序前：<code>&#123;3,43,38,5,47,15,36,26,27,2,44,4,50,19,38&#125;</code></p><p>排序后：<code>&#123;2,3,4,5,15,19,26,27,36,38,44,46,47,48,50&#125;</code></p><p>【排序原理】</p><ol><li>比较相邻的元素。如果前一个元素比后一个元素大，就交换这两个元素的位置。</li><li>对每一对相邻元素做同样的工作，从开始第一对元素到结尾的最后一对元素。最终最后位置的元素就是最大值。</li></ol><p>【动画演示】</p><p><img src="/2021/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95-%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/20191120141001101.gif" alt="20191120141001101" style="zoom:80%;"></p><p>【代码示例】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] bubbleSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; arr.length-i-<span class="number">1</span>; j++) &#123;   <span class="comment">// 因为操作 arr[j] 与 arr[j+1] 比较，这里的边界是 arr.length-i-1</span></span><br><span class="line">      <span class="keyword">if</span> (arr[j] &gt; arr[j + <span class="number">1</span>]) &#123; <span class="comment">// 比较 与 交换数值</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[j];</span><br><span class="line">        arr[j] = arr[j + <span class="number">1</span>];</span><br><span class="line">        arr[j + <span class="number">1</span>] = temp;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【复杂度分析】</p><p>冒泡排序使用了双层 <code>for</code> 循环，其中内层循环的循环体是真正完成排序的代码。所以， 我们分析冒泡排序的时间复杂度，主要分析一下内层循环体的执行次数即可。</p><p>在最坏情况下，也就是假如要排序的元素为 <code>&#123;50,48,47,46,44,38,36,27,26,19,15,5,4,3,2&#125;</code> 逆序，那么：</p><p>元素比较的次数为：$(n-1)+(n-2)+(n-3)+…+2+1=((n-1)+1)*(n-1)/2=n^2/2-n/2$</p><p>元素交换的次数为：$(n-1)+(n-2)+(n-3)+…+2+1=((n-1)+1)*(n-1)/2=n^2/2-n/2$</p><p>总执行次数为：$(n^2/2-n/2)+(n^2/2-n/2)=n^2-n$</p><p>按照大 O 推导法则，保留函数中的最高阶项。那么最终<strong><em><u>冒泡排序的时间复杂度</u></em></strong> 为：</p><script type="math/tex; mode=display">O(n^2)</script><h4 id="选择排序-Selection-Sort"><a href="#选择排序-Selection-Sort" class="headerlink" title="选择排序 Selection Sort"></a>选择排序 Selection Sort</h4><p>选择排序是一种更加简单直观的排序方法。</p><p>排序前：<code>&#123;3,43,38,5,47,15,36,26,27,2,44,4,50,19,38&#125;</code></p><p>排序后：<code>&#123;2,3,4,5,15,19,26,27,36,38,44,46,47,48,50&#125;</code></p><p>【排序原理】</p><ol><li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始（末尾）位置；</li><li>然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾（起始）；</li><li>以此类推，直到所有元素均排序完毕。（拿出最大或最小，然后在剩余中再拿最大或最小）</li></ol><p>【动画演示】</p><p><img src="/2021/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95-%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/12585785-b67fc46afdc20cc1.gif" alt="12585785-b67fc46afdc20cc1" style="zoom:80%;"></p><p>【代码示例】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] selectionSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="type">int</span> minIndex, temp;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">iny</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        minIndex = i;<span class="comment">// 假设本轮循环的初始索引是最小数的索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i + <span class="number">1</span>; j &lt; length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[j] &lt; arr[minIndex]) &#123;     <span class="comment">// 寻找最小的数</span></span><br><span class="line">                minIndex = j;                 <span class="comment">// 将最小数的索引保存</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">// 将【最小数的索引】与【本轮循环的初始索引】交换</span></span><br><span class="line">        temp = arr[i];</span><br><span class="line">        arr[i] = arr[minIndex];</span><br><span class="line">        arr[minIndex] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>【复杂度分析】</p><p>选择排序使用了双层 <code>for</code> 循环，其中外层循环完成了数据交换，内层循环完成了数据比较。所以我们分别统计数据交换次数和数据比较次数：</p><p>元素比较的次数为：$(n-1)+(n-2)+(n-3)+…+2+1=((n-1)+1)*(n-1)/2=n^2/2-n/2$</p><p>元素交换的次数为：$n-1$</p><p>总执行次数为：$(n^2/2-n/2)+(n-1)=n^2/2+n/2-1$</p><p>按照大 O 推导法则，保留函数中的最高阶项。那么最终<strong><em><u>选择排序的时间复杂度</u></em></strong> 为：</p><script type="math/tex; mode=display">O(n^2)</script><h4 id="插入排序-Insertion-sort"><a href="#插入排序-Insertion-sort" class="headerlink" title="插入排序 Insertion sort"></a>插入排序 Insertion sort</h4><p>插入排序(Insertion sort)是一种简单直观且稳定的排序算法。它的工作原理是<strong><em><u>通过构建有序序列</u></em></strong>，对于未排序数据，在已排序序列中<strong><em><u>从后向前</u></em></strong>扫描，找到相应位置并<strong><em><u>插入</u></em></strong>。</p><p>排序前：<code>&#123;3,43,38,5,47,15,36,26,27,2,44,4,50,19,38&#125;</code></p><p>排序后：<code>&#123;2,3,4,5,15,19,26,27,36,38,44,46,47,48,50&#125;</code></p><p>【排序原理】</p><blockquote><p>插入排序把所有的元素分为两组，【已经排序】的和【未排序】的</p></blockquote><ol><li>从第一个元素开始，该元素可以认为已经被排序；</li><li>取出下一个元素，在已经排序的元素序列中<strong><em><u>从后向前</u></em></strong>扫描；</li><li>如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li>重复步骤3，直到找到已排序的元素小于或者等于新元素的位置；</li><li>将新元素插入到该位置后；</li><li>重复步骤2~5。</li></ol><p>【动画演示】</p><p><img src="/2021/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95-%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/849589-20171015225645277-1151100000.gif" alt="849589-20171015225645277-1151100000" style="zoom:80%;"></p><p>【代码示例】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">insertionSort</span><span class="params">(<span class="type">int</span>[] arr)</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="type">int</span> preIndex, current;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt; length; i++) &#123;</span><br><span class="line">        preIndex = i - <span class="number">1</span>;</span><br><span class="line">        current = arr[i];</span><br><span class="line">        <span class="keyword">while</span> (preIndex &gt;= <span class="number">0</span> &amp;&amp; arr[preIndex] &gt; current) &#123;</span><br><span class="line">            arr[preIndex + <span class="number">1</span>] = arr[preIndex];</span><br><span class="line">            preIndex--;</span><br><span class="line">        &#125;</span><br><span class="line">        arr[preIndex + <span class="number">1</span>] = current;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【复杂度分析】</p><p>插入排序使用了双层循环，其中内层循环的循环体是真正完成排序的代码。所以，我们分析插入排序的时间复杂度，主要分析一下内层循环体的执行次数即可。</p><p>在最坏情况下，也就是假如要排序的元素为 <code>&#123;50,48,47,46,44,38,36,27,26,19,15,5,4,3,2&#125;</code> 逆序，那么：</p><p>元素比较的次数为：$(n-1)+(n-2)+(n-3)+…+2+1=((n-1)+1)*(n-1)/2=n^2/2-n/2$</p><p>元素交换的次数为：$(n-1)+(n-2)+(n-3)+…+2+1=((n-1)+1)*(n-1)/2=n^2/2-n/2$</p><p>总执行次数为：$(n^2/2-n/2)+(n^2/2-n/2)=n^2-n$</p><p>按照大 O 推导法则，保留函数中的最高阶项。那么最终<strong><em><u>插入排序的时间复杂度</u></em></strong> 为：</p><script type="math/tex; mode=display">O(n^2)</script><h4 id="希尔排序-Shell-Sort"><a href="#希尔排序-Shell-Sort" class="headerlink" title="希尔排序 Shell Sort"></a>希尔排序 Shell Sort</h4><p>之前我们学习的冒泡排序，选择排序还有插入排序，他们在最坏情况下的时间复杂度都是 $O(n^2)$，而平方阶通过我们之前学习算法分析我们知道，随着输入规模的增大，时间成本将急剧上升。所以这些基本排序方法不能处理更大规模的问题，接下来我们学习一些高级的排序算法，争取降低算法的时间复杂度最高阶幂。</p><p>希尔排序 (Shell Sort) 是插入排序的一种，又称“缩小增量排序”，是<strong><em><u>插入排序的更高效的改进版本</u></em></strong>。</p><p>排序前：<code>&#123;9,1,2,5,7,4,8,6,3,5&#125;</code></p><p>排序后：<code>&#123;1,2,3,4,5,5,6,7,8,9&#125;</code></p><p>【排序原理】</p><ol><li>选定一个增长量 <code>gap</code>，按照增长量 <code>gap</code> 作为数据分组的依据，对数据进行分组；</li><li>对分好组的每一组数据完成插入排序；</li><li>减小增长量，最小减为 1，重复第 2 步操作。</li></ol><p>【增长量 <code>gap</code>】的值采用以下规则：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始gap等于数组长度的一半</span></span><br><span class="line"><span class="comment">// 每次迭代后gap的大小都是原来的1/2</span></span><br><span class="line"><span class="comment">// 直到gap=1</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> gap=array.length; gap&gt;<span class="number">0</span> ; gap=gap/<span class="number">2</span>) &#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> 内层的插入排序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【算法图解】</p><p><img src="/2021/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95-%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/100-1705399.png" alt="100" style="zoom:40%;"></p><p>【代码示例】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] shellSort(<span class="type">int</span>[] arr) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> arr.length;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">gap</span> <span class="operator">=</span> length/<span class="number">2</span>; gap &gt; <span class="number">0</span>; gap = gap/<span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 注意：这里和图片展示的不一样，实际操作是多个分组交替执行</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> gap; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; <span class="comment">// j与有序数组的末尾索引有关</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">current</span> <span class="operator">=</span> arr[i];</span><br><span class="line">            <span class="keyword">while</span>(j - gap &gt;= <span class="number">0</span> &amp;&amp; current &lt; arr[j - gap]) &#123;</span><br><span class="line">                 arr[j] = arr[j - gap];</span><br><span class="line">                 j = j - gap;</span><br><span class="line">            &#125;</span><br><span class="line">            arr[j] = current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【复杂度分析】</p><p><strong>希尔排序</strong>是在<strong>插入排序</strong>的基础上进行的一中改进的算法。</p><p><strong>希尔排序是将一个原序列分成几个子序列</strong>，<strong>对于每个子序列来所都进行一次插入排序</strong>，<strong>而依据不同的子序列划分大小</strong>，<strong>最后子序列为1时</strong>，此时插入排序跟原来的插入排序就是一模一样的了，只不过现在的队列比原来的要有序的多。</p><p>所以希尔排序就是将原序列进行了一些整理，将其变得有序一些，而我们都知道，对于插入排序这个 $O(n^2)$ 级别的算法来说，越是有序的序列，它所需要的时间越少，甚至在某些情况下可以逼近 $O(n)$，这就是希尔排序对于插入排序的改良。所以<strong><em><u>希尔排序的时间复杂度</u></em></strong> 为：</p><script type="math/tex; mode=display">O(n) < O(f(n)) < O(n^2), \text{平均为 }O(n^{1.25})</script><h4 id="归并排序-Merge-Sort"><a href="#归并排序-Merge-Sort" class="headerlink" title="归并排序 Merge Sort"></a>归并排序 Merge Sort</h4><p>归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用<strong><em><u>分治法</u></em></strong>的一个非常典型的应用。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为二路归并。</p><p>排序前：<code>&#123;8,4,5,7,1,3,6,2&#125;</code></p><p>排序后：<code>&#123;1,2,3,4,5,6,7,8&#125;</code></p><p>【排序原理】</p><ol><li><strong><em><u>「分」</u></em></strong>尽可能的一组数据拆分成两个元素相等的子组，并对每一个子组继续拆分，直到拆分后的每个子组的元素个数是 1为止；</li><li><strong><em><u>「治」</u></em></strong>将相邻的两个子组进行<strong><em><u>排序并合并</u></em></strong>成一个有序的大组；</li><li>不断的重复步骤 2，直到最终只有一个组为止。</li></ol><p>【算法图解】</p><p><img src="/2021/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95-%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/image-20220828185746123.png" alt="image-20220828185746123" style="zoom:50%;"></p><p>【代码示例】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (array == <span class="literal">null</span> || array.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">  sort(array, <span class="number">0</span>, array.length - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">sort</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line"><span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> left + ((right - left)/<span class="number">2</span>);</span><br><span class="line">sort(array, left, mid);<span class="comment">// 对左侧子序列进行递归排序</span></span><br><span class="line">sort(array, mid + <span class="number">1</span>, right);<span class="comment">// 对右侧子序列进行递归排序</span></span><br><span class="line">merge(array, left, mid, right);<span class="comment">// 合并</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">merge</span><span class="params">(<span class="type">int</span>[] array, <span class="type">int</span> left, <span class="type">int</span> mid, <span class="type">int</span> right)</span> &#123;</span><br><span class="line"><span class="type">int</span>[] temp = <span class="keyword">new</span> <span class="title class_">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">  <span class="comment">// 【归并的关键】就在于以下三个指针的操作</span></span><br><span class="line"><span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;<span class="comment">// 指针：指向temp[]第一个元素</span></span><br><span class="line"><span class="type">int</span> <span class="variable">p1</span> <span class="operator">=</span> left; <span class="comment">// 指针：指向左子组第一个元素</span></span><br><span class="line"><span class="type">int</span> <span class="variable">p2</span> <span class="operator">=</span> mid + <span class="number">1</span>;<span class="comment">// 指针：指向右子组第一个元素</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 1.比较左右两部分的元素，哪个小，把那个元素填入temp[]中</span></span><br><span class="line"><span class="keyword">while</span> (p1 &lt;= mid &amp;&amp; p2 &lt;= right) &#123;</span><br><span class="line">temp[i++] = (array[p1] &lt; array[p2]) ? array[p1++] : array[p2++];</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 2.上面的循环退出后，把剩余的元素依次填入到temp中。以下两个while只有一个会执行</span></span><br><span class="line"><span class="keyword">while</span> (p1 &lt;= mid) &#123;</span><br><span class="line">temp[i++] = array[p1++]; <span class="comment">// 如果p1的指针没有到mid，将剩余的元素放入temp[]</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (p2 &lt;= right) &#123;</span><br><span class="line">temp[i++] = array[p2++]; <span class="comment">// 如果p2的指针没有到rigth，将剩余的元素放入temp[]</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">// 3.把最终的排序的结果复制给原数组</span></span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">array[left + i] = temp[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【复杂度分析】</p><p>归并排序是分治思想的最典型的例子。</p><p><img src="/2021/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95-%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/image-20220828202350528.png" alt="image-20220828202350528" style="zoom:50%;"></p><p>树状图来描述归并，如果一个数组有 8 个元素，那么它将每次除以 2 找最小的子数组，共拆分 $log(8)$ 次，值为 3，所以树共有 3 层。那么自顶向下第 $k$ 层有 $2^k$ 个子数组，每个数组的长度为 $2^{(3-k)}$，归并最多需要 $2^{(3-k)}$ 次比较。因此每层的比较次数为 $2^k \times 2^{(3-k)}=2^3$，那么 3 层总共为 $3\times 2^3$。</p><p>假设元素的个数为 $n$，那么使用归并排序拆分的次数为 $log_2(n)$，所以共 $log_2(n)$层，那么使用 $log_2(n)$ 替换上面 $3\times 2^3$中的 3 这个层数，最终得出的归并排序的时间复杂度为：$log_2(n)<em> 2^{log_2(n)}=log_2(n)</em>n$。根据大 O 推导法则，忽略底数，最终<strong><em><u>归并排序的时间复杂度</u></em></strong>为</p><script type="math/tex; mode=display">O(nlog\;n);</script><p>【归并排序的缺点】</p><p>需要申请额外的数组空间 <code>temp[]</code>，导致空间复杂度提升，是典型的<strong><em><u>以空间换时间</u></em></strong>的操作。</p><blockquote><p>希尔排序和归并排序在处理大批量数据时差别不是很大。</p></blockquote><h4 id="快速排序-Quick-Sort"><a href="#快速排序-Quick-Sort" class="headerlink" title="快速排序 Quick Sort"></a>快速排序 Quick Sort</h4><p>快速排序是<u>对冒泡排序的一种改进</u>。</p><p>它的基本思想是：通过一趟排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><p>排序前：<code>&#123;8,4,5,7,1,3,6,2&#125;</code></p><p>排序后：<code>&#123;1,2,3,4,5,6,7,8&#125;</code></p><p>【排序原理】</p><p>快速排序使用分治法来把一个串（list）分为两个子串（sub-lists）。具体算法描述如下：</p><ol><li>首先设定一个分界值，通过该分界值将数组分成左右两部分；</li><li>将大于或等于分界值的数据放到到数组右边，小于分界值的数据放到数组的左边。此时<u>左边部分</u>中各元素都<u>小于或等于</u>分界值，而<u>右边部分</u>中各元素都<u>大于或等于</u>分界值；</li><li>然后，左边和右边的数据可以独立排序。对于左侧的数组数据，又可以取一个分界值，将该部分数据分成左右两部分，同样在左边放置较小值，右边放置较大值。右侧的数组数据也可以做类似处理；</li><li>重复上述过程，可以看出，这是一个递归定义。通过递归将左侧部分排好序后，再递归排好右侧部分的顺序。当左侧和右侧两个部分的数据排完序后，整个数组的排序也就完成了。</li></ol><p>【算法图解】</p><p><img src="/2021/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95-%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/image-20220828204245003.png" alt="image-20220828204245003" style="zoom:45%;"></p><p>【代码示例】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">initQuickSort</span><span class="params">(<span class="type">int</span> arr[])</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> arr.length - <span class="number">1</span>;</span><br><span class="line">  <span class="type">int</span>[] result = quickSort(arr, left, right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span>[] quickSort(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right) &#123;</span><br><span class="line">  <span class="type">int</span> partitionIndex;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (left &lt; right) &#123;</span><br><span class="line">    partitionIndex = partition(arr, left, right);</span><br><span class="line">    quickSort(arr, left, partitionIndex-<span class="number">1</span>);</span><br><span class="line">    quickSort(arr, partitionIndex+<span class="number">1</span>, right);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;<span class="comment">// 分区操作</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">pivot</span> <span class="operator">=</span> left;<span class="comment">// 设定基准值（pivot）</span></span><br><span class="line">  <span class="type">int</span> <span class="variable">index</span> <span class="operator">=</span> pivot + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> index; i &lt;= right; i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &lt; arr[pivot]) &#123;</span><br><span class="line">      swap(arr, i, index);</span><br><span class="line">      index++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  swap(arr, pivot, index - <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> index-<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span>[] arr, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">  <span class="type">int</span> <span class="variable">temp</span> <span class="operator">=</span> arr[i];</span><br><span class="line">  arr[i] = arr[j];</span><br><span class="line">  arr[j] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>【快速排序和归并排序的区别】<br>快速排序是另外一种分治的排序算法，它将一个数组分成两个子数组，将两部分独立的排序。快速排序和归并排序是互补的：</p><ul><li>归并排序将数组分成两个子数组分别排序，并将有序的子数组归并从而将整个数组排序，而快速排序的方式则是当两个数组都有序时，整个数组自然就有序了。</li><li>在归并排序中，一个数组被等分为两半，归并调用发生在处理整个数组之前，在快速排序中，切分数组的位置取决于数组的内容，递归调用发生在处理整个数组之后。</li></ul><p>【时间复杂度分析】</p><p>快速排序的一次切分从两头开始交替搜索，直到 <code>left</code> 和 <code>right</code> 重合（仅扫描一遍）。因此，一次切分算法的时间复杂度为$O(n)$，但整个快速排序的时间复杂度和切分的次数相关。</p><ul><li>最优情况：每一次切分选择的基准数字刚好将当前序列等分（在序列中间）。如果我们把数组的切分看做是一个树，那么上图就是它的最优情况的图示，共切分了 $log\;n$次，所以，最优情况下快 速排序的时间复杂度为 $O(nlog\;n)$；</li></ul><p><img src="/2021/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95-%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/image-20220828210705412.png" alt="image-20220828210705412" style="zoom:45%;"></p><ul><li>每一次切分选择的基准数字是当前序列中最大数或者最小数，这使得每次切分都会有一个子组，那么总 共就得切分 n 次。所以，最坏情况下，快速排序的时间复杂度为 $O(n^2)$；</li></ul><p><img src="/2021/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95-%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/image-20220828210804852.png" alt="image-20220828210804852" style="zoom:50%;"></p><ul><li>平均情况：每一次切分选择的基准数字不是最大值和最小值，也不是中值，这种情况我们也可以用数学归纳法证明，快速排序的时间复杂度为 $O(nlog\;n)$</li></ul><script type="math/tex; mode=display">O(nlog\;n) < O(f(n)) < O(n^2), \text{平均为 }O(nlog\;n)</script><h4 id="计数排序-Counting-Sort"><a href="#计数排序-Counting-Sort" class="headerlink" title="计数排序 Counting Sort"></a>计数排序 Counting Sort</h4><p>计数排序不是基于比较的排序算法，其核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><p>【排序原理】</p><ol><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为 <code>i</code> 的元素出现的次数，存入数组 <code>int[] C</code> 的第 <code>i</code> 项；</li><li>对所有的计数累加（从 <code>C[]</code> 中的第一个元素开始，每一项和前一项相加）；</li><li>反向填充目标数组：将每个元素 <code>i</code> 放在新数组的第 <code>C[i]</code> 项，每放一个元素就将 <code>C[i]</code> 减去 1。</li></ol><p>【动画演示】</p><p><img src="/2021/10/28/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%8F%8A%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95-%E5%A4%8D%E4%B9%A0%E6%80%BB%E7%BB%93/849589-20171015231740840-6968181.gif" alt="849589-20171015231740840-6968181" style="zoom:80%;"></p><p>【代码示例】</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">countingSort</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (array == <span class="literal">null</span> || array.length &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">length</span> <span class="operator">=</span> array.length;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> <span class="variable">max</span> <span class="operator">=</span> array[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">min</span> <span class="operator">=</span> array[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (max &lt; array[i]) &#123;</span><br><span class="line">                max = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (min &gt; array[i]) &#123;</span><br><span class="line">                min = array[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最大最小元素之间范围[min, max]的长度</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">offset</span> <span class="operator">=</span> max - min + <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 1. 计算频率，在需要的数组长度上额外加1</span></span><br><span class="line">        <span class="type">int</span>[] count = <span class="keyword">new</span> <span class="title class_">int</span>[offset + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">// 使用加1后的索引，有重复的该位置就自增</span></span><br><span class="line">            count[array[i] - min + <span class="number">1</span>]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2. 频率 -&gt; 元素的开始索引</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; offset; i++) &#123;</span><br><span class="line">            count[i + <span class="number">1</span>] += count[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3. 元素按照开始索引分类，用到一个和待排数组一样大临时数组存放数据</span></span><br><span class="line">        <span class="type">int</span>[] aux = <span class="keyword">new</span> <span class="title class_">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            <span class="comment">// 填充一个数据后，自增，以便相同的数据可以填到下一个空位</span></span><br><span class="line">            aux[count[array[i] - min]++] = array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 4. 数据回写</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">            array[i] = aux[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>【算法分析】</p><p>当输入的元素是 n 个 0～k 之间的整数时，它的运行时间是 $O(n + k)$。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组 <code>C[]</code> 的长度取决于待排序数组中数据的范围（等于待排序数组的最大值与最小值的差加上 1 ），这使得计数排序对于数据范围很大的数组，需要大量时间和内存。</p><p>根据大 O 推导法则，最终<strong><em><u>计数排序的时间复杂度</u></em></strong>为</p><script type="math/tex; mode=display">O(n)</script>]]></content>
    
    
    <summary type="html">&lt;p&gt;内容检索&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;#0-数据结构与算法设计&quot;&gt;数据结构和算法概述&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#1-算法分析&quot;&gt;算法分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#2-排序算法&quot;&gt;排序算法&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;线性表(#)&lt;/li&gt;
&lt;li&gt;符号表(#)&lt;/li&gt;
&lt;li&gt;树(#)&lt;/li&gt;
&lt;li&gt;堆(#)&lt;/li&gt;
&lt;li&gt;优先队列(#)&lt;/li&gt;
&lt;li&gt;并查集(#)&lt;/li&gt;
&lt;li&gt;图(#)&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="Java" scheme="https://dave0126.github.io/categories/Java/"/>
    
    
    <category term="数据结构" scheme="https://dave0126.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="算法" scheme="https://dave0126.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
