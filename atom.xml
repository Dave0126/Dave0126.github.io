<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lost N Found</title>
  
  
  <link href="https://dave0126.github.io/atom.xml" rel="self"/>
  
  <link href="https://dave0126.github.io/"/>
  <updated>2022-03-31T13:28:02.436Z</updated>
  <id>https://dave0126.github.io/</id>
  
  <author>
    <name>Guohao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Transition System(变迁系统) 与 TLA+ (一)</title>
    <link href="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/"/>
    <id>https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/</id>
    <published>2022-03-29T08:59:58.000Z</published>
    <updated>2022-03-31T13:28:02.436Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Transition-System-变迁系统-与-TLA"><a href="#Transition-System-变迁系统-与-TLA" class="headerlink" title="Transition System(变迁系统) 与 TLA+"></a>Transition System(变迁系统) 与 TLA+</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>本文章是根据法国国立高等电力技术、电子学、计算机、水力学与电信学校 (E.N.S.E.E.I.H.T) 第八学期课程“Système de transition”总结而来的课程笔记。碍于本人学识有限，部分叙述难免存在纰漏，请读者注意甄别。</p><span id="more"></span><h4 id="变迁系统"><a href="#变迁系统" class="headerlink" title="变迁系统"></a>变迁系统</h4><p>在计算机科学和控制理论中，“变迁系统”用数学的方法描述离散系统的行为。变迁系统主要由“状态”和状态之间的“状态迁移”组成。 有标号的变迁系统可以从已定义的标签集合中选择相应标签来标记状态迁移，而且相同的标签可能被应用在多个状态迁移上。 变迁系统也可以是无标记的，此时也可以认为标签集合中只有单一标签元素，从而省略了状态迁移上的标签记号。</p><p>变迁系统在数学定义上和<strong>有向图</strong>一致，但与<strong>有限状态自动机</strong>有一定不同。</p><p>变迁系统的特点有：</p><ul><li>系统状态的集合不一定是有限的或可数的；</li><li>状态迁移的集合不一定是有限的或可数的；</li><li>变迁系统并不需要给出“开始”状态或“最终”状态；</li><li>变迁系统可以表示为<strong>有向图</strong>，有限状态自动机则不能。</li></ul><p>资料来源于<a href="https://zh.wikipedia.org/wiki/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F">维基百科：变迁系统</a></p><h4 id="TLA"><a href="#TLA" class="headerlink" title="TLA+"></a>TLA+</h4><h5 id="形式化验证"><a href="#形式化验证" class="headerlink" title="形式化验证"></a>形式化验证</h5><p>形式化验证技术想要解决的核心问题是：软件总是可能存在 Bug 的，而测试始终无法涵盖所有可能性，特别是对于并发系统及分布式系统来说，就算单元测试达到了 100% 分支覆盖率，也不能肯定的说这个系统在线程安全，一致性等方面不会出问题。那如何更好的来验证我们的程序是否符合预期呢？</p><p>形式化验证就旨在使用严谨的数学证明方法来证明某一算法是正确的。</p><h5 id="TLA-1"><a href="#TLA-1" class="headerlink" title="TLA+"></a>TLA+</h5><p><strong>T</strong>emporal <strong>L</strong>ogic of <strong>A</strong>ctions <strong>+</strong>是由<em>Leslie Lamport</em>开发的一种【形式化验证语言】。它用于设计、建模、记录和验证程序，尤其是并发系统和分布式系统。TLA +被描述为可完全测试的伪代码，其用途类似于为软件系统绘制蓝图。</p><p>由于 TLA+ 写的代码并不是用来实际运行的，故一般将其代码称为模型（Model）而非程序（Program）。</p><h4 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h4><ol><li><a href="https://learntla.com/">Learn TLA+</a></li><li><a href="https://lamport.azurewebsites.net/video/videos.html">L. Lamport 关于TLA+的视频</a></li><li><a href="https://lamport.azurewebsites.net/tla/tla.html">其他资源</a></li></ol><h3 id="第一部分：Transition-System"><a href="#第一部分：Transition-System" class="headerlink" title="第一部分：Transition System"></a>第一部分：Transition System</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><h5 id="变迁系统-1"><a href="#变迁系统-1" class="headerlink" title="变迁系统"></a>变迁系统</h5><p>变迁系统是一个三元组$⟨S,I,R⟩$:</p><ul><li>$S$ 是状态集。包含 <strong>终结状态</strong> 和 <strong>非终结状态</strong></li><li>$I \subseteq S$ 是一个 <strong>初始状态</strong></li><li>$R \subseteq S \times S$ 是状态对之间的（转换）关系。$(s,s’) \in R$​ 表示系统从状态 $s$ 到状态$s’$ 的转换</li></ul><p>例：</p><script type="math/tex; mode=display">S = {S_0, S_1, S_2, S_3,S_4}</script><script type="math/tex; mode=display">I = {S_0}</script><script type="math/tex; mode=display">R = \{(S_0,S_0), (S_0,S_1), (S_0,S_2), (S_2,S_3), (S_3,S_4), (S_4,S_3)\}</script><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29 13.16.51-8552669.png" alt="2022-03-29 13.16.51" style="zoom:67%;"></p><h5 id="序列（Sequence）"><a href="#序列（Sequence）" class="headerlink" title="序列（Séquence）"></a>序列（Séquence）</h5><p>$S$ 是状态集：</p><ul><li>$S^*$ 是 $S$ 上的有限序列集；</li><li>$S^w$ 是 $S$ 上的无限数据集；</li><li>$\sigma _i$ 是序列 $\sigma$ 从 0 开始的第 $i$个元素。</li><li>序列 $S$ 用以下形式表示：$⟨s1 → s2 → …⟩$</li><li>$⟨⟩$ 表示空序列；</li></ul><p>对于一个有限序列$\sigma$ ：</p><ul><li>$\sigma^*$ 是由任意的 $\sigma $ 重复产生的有限序列集。</li><li>$\sigma^+ \triangleq \sigma^* \backslash \{ ⟨⟩ \}$</li><li>$\sigma^w$  是由任意的 $\sigma $ 重复产生的无限序列集。</li></ul><h5 id="有限轨迹（Traces-finies）"><a href="#有限轨迹（Traces-finies）" class="headerlink" title="有限轨迹（Traces finies）"></a>有限轨迹（Traces finies）</h5><p>令 $⟨S, I, R⟩$ 是一个变迁系统。我们称有限迹为有限序列$\sigma \in S^*$ 使得</p><ul><li><p>$\sigma = ⟨s_0 → s_1 → … → s_{n-1} → s_n ⟩$</p></li><li><p>$\forall i \in [0 … n[:(s_i, s_{i-1}) \in R$</p></li></ul><h5 id="最大有限轨迹（Traces-finies-maximales）"><a href="#最大有限轨迹（Traces-finies-maximales）" class="headerlink" title="最大有限轨迹（Traces finies maximales）"></a>最大有限轨迹（Traces finies maximales）</h5><p>当有限轨迹$⟨s_0 → s_1 → … → s_{n-1} → s_n ⟩ \in S^*$ 时，我们称它是最大的。$s_n$没有后继状态，即$\forall s \in S:(s_n, s) \notin R$</p><h5 id="无限轨迹（Trace-infinies）"><a href="#无限轨迹（Trace-infinies）" class="headerlink" title="无限轨迹（Trace infinies）"></a>无限轨迹（Trace infinies）</h5><p>令 $⟨S, I, R⟩$ 是一个变迁系统，并且$s_0 \in S$。我们称从 $s_0$开始到元素 $tr \in S^w$ 的无限序列为</p><ul><li><p>$tr = ⟨s_0 → s_1 → s_2 → … ⟩$</p></li><li><p>$\forall i \in \mathbb{N}:(s_i, s_{i+1}) \in R$</p></li></ul><h5 id="来自状态的轨迹（Traces-issues-d’un-etat）"><a href="#来自状态的轨迹（Traces-issues-d’un-etat）" class="headerlink" title="来自状态的轨迹（Traces issues d’un état）"></a>来自状态的轨迹（Traces issues d’un état）</h5><p>令 $⟨S, I, R⟩$ 是一个变迁系统，并且$s \in S$。</p><ul><li>$Traces(s) $ 是从状态$s$ 开始的最大无限或有限轨迹的集合。</li></ul><h5 id="执行（Executions）"><a href="#执行（Executions）" class="headerlink" title="执行（Exécutions）"></a>执行（Exécutions）</h5><p>令 $⟨S, I, R⟩$ 是一个变迁系统，</p><p>一次执行 $σ = ⟨s_0 →…⟩ $ 是满足 $s_0 ∈ I $ 的最大无限或有限轨迹。</p><ul><li>$Exec(S)$ 是 $S = \bigcup_{s_0 \in I} Traces(s_0)$ 的执行集。</li><li>如果 $I = ∅$，则我们有一个（也是唯一一个）空执行$ ⟨⟩$。</li></ul><h5 id="练习一"><a href="#练习一" class="headerlink" title="练习一"></a>练习一</h5><h6 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h6><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29 13.16.51-8552669.png" alt="2022-03-29 13.16.51" style="zoom:67%;"></p><p>$s_0 → s_0 → s_2 → s_3$ 是一段非最大的有限轨迹。</p><ol><li>$Traces(s_1) = ⟨s_1⟩$</li><li>$Traces(s_3) = ⟨(s_3 → s_4)^w⟩$</li><li>$Traces(s_2) = ⟨s_2 → (s_3 → s_4)^w⟩$</li><li>$Traces(s_0) = ⟨{s_0}^w⟩, ⟨{s_0}^+ → s_1⟩, ⟨s_0 → s_2 → (s_3 → s_4)^w⟩$</li><li>$Exec(S) = Traces(s_0)$</li></ol><h6 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h6><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29 13.28.06-8553323.png" alt="2022-03-29 13.28.06" style="zoom:67%;"></p><ol><li>$Traces(s_2) = ⟨s_2 → s_4⟩, ⟨(s_2 → s_3 → s_0 → s_1)^w⟩, ⟨(s_2 → s_3 → s_0 → s_1)^* → s_2 → s_4⟩$</li><li>$Traces(s_0) = ⟨(s_0 → s_1 → s_2 → s_3⟩^w, ⟨s_0 → s_1 → (s_2 → s_3 → s_0 → s_1)^* → s_2 → s_4⟩$</li><li>$Exec(S) = Traces(s_0)$</li></ol><h6 id="例三"><a href="#例三" class="headerlink" title="例三"></a>例三</h6><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29 13.48.33-8554538.png" alt="2022-03-29 13.48.33" style="zoom:67%;"></p><ol><li>$Traces(s_2) = ⟨(s_2 → s_3)^w⟩, ⟨(s_2 → s_3)^* → s_2 → s_4⟩$</li><li>$Traces(s_0) = ⟨(s_0 → (s_2 → s_3)^w⟩, ⟨(s_0 → (s_2 → s_3)^* → s_2 → s_4⟩$</li><li>$Traces(s_1) = ⟨(s_1 → (s_3 → s_2)^w⟩, ⟨(s_1 → (s_3 → s_2)^+ → s_4⟩$</li><li>$Exec(S) = Traces(s_0) \cup Traces(s_1)$</li></ol><h5 id="可访问状态（Etats-accessibles）"><a href="#可访问状态（Etats-accessibles）" class="headerlink" title="可访问状态（Etats accessibles）"></a>可访问状态（Etats accessibles）</h5><p>令 $⟨S, I, R⟩$ 是一个变迁系统。</p><ul><li>$s ∈ S$ 是一个可访问状态 $\triangleq $ 有一个通过 $s$ 的执行（或等价的，有一个以 $s$ 结尾的执行前缀）;</li><li>$Acc(S)$ 是 $S$ 的可访问状态集。</li></ul><h5 id="执行图（Graphe-des-Executions）"><a href="#执行图（Graphe-des-Executions）" class="headerlink" title="执行图（Graphe des Exécutions）"></a>执行图（Graphe des Exécutions）</h5><p>令 $⟨S, I, R⟩$ 是一个变迁系统。</p><p>执行图是有向图，其中：</p><ul><li>顶点集是 $Acc(S)$；</li><li>有向边的集合是 $R$，仅限于可访问状态。</li></ul><p>因此它是$ ⟨S ∩ Acc(S), R ∩ (Acc(S) × Acc(S))⟩ $ 的图。</p><h5 id="被标记的变迁系统（Systeme-de-Transitions-etiquete-）"><a href="#被标记的变迁系统（Systeme-de-Transitions-etiquete-）" class="headerlink" title="被标记的变迁系统（Systeme de Transitions étiqueté ）"></a>被标记的变迁系统（Systeme de Transitions étiqueté ）</h5><p>被标记的变迁系统 是一个五元组$⟨S、I、R、L、Etiq⟩$：</p><ul><li>$S$：状态集。</li><li>$I ⊆ S$：初始状态集。</li><li>$R ⊆ S × S$：状态对之间的转换关系。</li><li>$L$：标签集。</li><li>$Etiq$：将标签与每个转换(transition) 相关联的函数：$Etiq ∈ R → L$。带</li></ul><p>被标记的变迁系统 非常接近自动机。但是没有 terminal state + infinity execution。</p><p>被标记的变迁系统 $⟨S, I, R, L, Etiq⟩$ <strong>等价于</strong>由如下定义的 未标记系统$⟨S’, I’, R’⟩$ ：</p><ul><li>$S’ = (L \cup \{ \epsilon \}) \times S$</li><li>$I’ = \{ \epsilon \} \times I$</li><li>$R’ = \{ ( ⟨I,s⟩, ⟨I’,s’⟩ )| (s, s’) \in R \land I’ = Etiq(s,s’)\}$</li></ul><p>转换(transition) $s_1 \xrightarrow{a} s_2 $ 可变成 $ ⟨$_$,s_1⟩ \to ⟨a,s_2⟩$，其中 _ 是任何标签。</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29 15.18.04.png" alt="2022-03-29 15.18.04" style="zoom:50%;"></p><p>可变为</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29 15.19.07-8559976.png" alt="2022-03-29 15.19.07" style="zoom:50%;"></p><h5 id="变迁系统-不等于-自动机"><a href="#变迁系统-不等于-自动机" class="headerlink" title="变迁系统 不等于 自动机"></a>变迁系统 不等于 自动机</h5><ul><li>转换没有标签：Pas d’étiquette sur les transitions (ou comme si)</li><li>转换不是由环境引起的：Une transition n’est pas causée par l’environnement</li><li>没有终结状态：Pas d’états terminaux</li><li>可能有许多的有限状态：Nombre d’états infini possible</li><li>可能有无限的执行：Exécution infinie possible</li></ul><h4 id="表示形式"><a href="#表示形式" class="headerlink" title="表示形式"></a>表示形式</h4><h5 id="显式的表示"><a href="#显式的表示" class="headerlink" title="显式的表示"></a>显式的表示</h5><p>在执行图(Graphe d’exécution) 中显式地给出，例如以图像形式或通过顶点和边的集合。仅适用于<strong>状态和转换数量有限</strong>的变迁系统。</p><h5 id="隐式的表示"><a href="#隐式的表示" class="headerlink" title="隐式的表示"></a>隐式的表示</h5><p>基于变量的变迁系统的三元组$ ⟨V, Init,Trans⟩ $ 中，</p><ul><li>$V = \{ v_1, …, v_n\}$：有限的的变量集；</li><li>$Init(v_1, …, v_n)$ ：定义初始状态并与变量 $v_i$ 相关的谓词（系数）</li><li>$Trans(v_1, …, v_n, {v_1}’, …, {v_n}’)$：谓词定义转换，涉及表示当前状态的变量 $v_i$ 和表示后续状态的变量 ${v_i}’$。</li></ul><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><h6 id="有界计数器"><a href="#有界计数器" class="headerlink" title="有界计数器"></a>有界计数器</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; N) &#123;</span><br><span class="line">i = i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在显式的表示中，$N = 5$:</li></ol><script type="math/tex; mode=display">⟨(0, 1, 2, 3, 4, 5), \{ 0\}, \{ (0,1), (1,2), (2,3), (3,4), (4,5)\}⟩</script><p>​    执行图(Graphe d’exécution)为</p><script type="math/tex; mode=display">0 \to 1 \to 2 \to 3 \to 4 \to5</script><ol><li>隐式的表示为：</li></ol><ul><li>$V \triangleq i \in \mathbb{N}$</li><li>$Init \triangleq i = 0$</li><li>$Trans \triangleq i &lt; N \land i’ = i+1$ 或 $Trans \triangleq i’ \leq N \land i’-i=1$ </li></ul><h6 id="循环计数器"><a href="#循环计数器" class="headerlink" title="循环计数器"></a>循环计数器</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">i = (i+<span class="number">1</span>) % N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在显式的表示中，$N = 4$:</li></ol><script type="math/tex; mode=display">⟨(0, 1, 2, 3, 4), \{ 0\}, \{ (0,1), (1,2), (2,3), (3,4), (4,0)\}⟩</script><p>​    执行图(Graphe d’exécution)为</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29 16.53.51-8565663.png" alt="2022-03-29 16.53.51" style="zoom:40%;"></p><ol><li>隐式的表示为：</li></ol><ul><li>$V \triangleq i \in \mathbb{N}$</li><li>$Init \triangleq i = 0$</li><li>$Trans \triangleq i’ = (i+1) \mod N $ </li></ul><h6 id="振荡整数"><a href="#振荡整数" class="headerlink" title="振荡整数"></a>振荡整数</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">i &gt; <span class="number">0</span> -&gt; i = i - <span class="number">1</span>;</span><br><span class="line">or</span><br><span class="line">  i &lt; N -&gt; i = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在显式的表示中，$N = 5$:</li></ol><script type="math/tex; mode=display">⟨(0, 1, 2, 3, 4, 5), \{ 0\}, \{ (0,1), (1,2), (2,3), (3,4), (4,5), (5,4), (4,3), (3,2), (2,1)\}⟩</script><p>​    执行图(Graphe d’exécution)为</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29 17.02.57.png" alt="2022-03-29 17.02.57" style="zoom:40%;"></p><ol><li>隐式的表示为：</li></ol><ul><li>$V \triangleq i \in \mathbb{N}$</li><li>$Init \triangleq i = 0$</li><li>$Trans \triangleq (i &gt; 0 \land i’=i-1) \lor (i &lt; N \land i’=i+1) $ 或 $Trans \triangleq \left| i’ -i \right| = 1 \land 0 \leq i’ \leq N$</li></ul><h5 id="表示形式所对应的变迁系统"><a href="#表示形式所对应的变迁系统" class="headerlink" title="表示形式所对应的变迁系统"></a>表示形式所对应的变迁系统</h5><p>对于符号描述$⟨V, Init,Trans⟩$，对应的变迁系统是$⟨S, I, R⟩$，其中：</p><ul><li>$S = \prod_{i \in 1..n} D_i$ ，其中$D_1,…,D_n$ 是变量 $v_1, …, v_n$ 的域（类型）</li><li>$I = \{ (v_1,…,v_n) | Init(v_1, …, v_n)\}$</li><li>$R = \{ ((v_1, …, v_n),({v_1}’, …, {v_n}’)) | Trans(v_1, …, v_n,{v_1}’, …, {v_n}’)\}$</li></ul><h5 id="状态谓词（Predicat-d’etat）"><a href="#状态谓词（Predicat-d’etat）" class="headerlink" title="状态谓词（Prédicat d’état）"></a>状态谓词（Prédicat d’état）</h5><p>状态谓词是与隐式表示的系统的（状态）变量有关的谓词。</p><p>状态谓词可以看作是 S 的一部分的特征函数。</p><h5 id="转换谓词（Predicat-de-transition）"><a href="#转换谓词（Predicat-de-transition）" class="headerlink" title="转换谓词（Prédicat de transition）"></a>转换谓词（Prédicat de transition）</h5><p>转换谓词是与已启动和未启动（状态）变量相关的谓词。</p><p>转换谓词可以看作是 $S × S$ 子集的特征函数。</p><h5 id="实例：谓词"><a href="#实例：谓词" class="headerlink" title="实例：谓词"></a>实例：谓词</h5><p>$V \triangleq n \in \mathbb{N} $ </p><p>$Init \triangleq -5 \leq n \leq 5$</p><p>$Trans \triangleq n \neq 1 \land ((n’ = n/2 \land n \equiv 0[2]) \lor (n’ = (3n+1)/2 \land n \equiv 1[2]))$</p><ul><li><p>Prédicat d’état : $ Init, n &lt; 20 $</p></li><li><p>Prédicat de transition : $Trans, n’ − n &gt; 3$</p></li></ul><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><h5 id="阻塞（Blocage）"><a href="#阻塞（Blocage）" class="headerlink" title="阻塞（Blocage）"></a>阻塞（Blocage）</h5><h6 id="死锁（Interblocage）"><a href="#死锁（Interblocage）" class="headerlink" title="死锁（Interblocage）"></a>死锁（Interblocage）</h6><p>一个系统有一个死锁  $\triangleq$  存在一个可访问的状态，没有关系 R 的后继。等效地，如果执行（execution）有限，系统就会出现死锁。</p><p>对于建模经典顺序程序的系统，死锁相当于终止。</p><h5 id="可复位（Reinitialisable）"><a href="#可复位（Reinitialisable）" class="headerlink" title="可复位（Réinitialisable）"></a>可复位（Réinitialisable）</h5><p>一个系统可以从任何可访问的状态重置  $\triangleq$  有一个有限轨迹导致一个初始状态。</p><p>这个属性意味着在任何时候，都有一系列的转换（transitions）返回到系统的初始状态，从而重新启动。 这样的系统只有无限的执行。</p><h5 id="重复（Begaiement）"><a href="#重复（Begaiement）" class="headerlink" title="重复（Bégaiement）"></a>重复（Bégaiement）</h5><p>重复状态  $\triangleq$  状态有一个循环：$(s,s) ∈ R$。</p><p>一个重复变迁系统  $\triangleq$  任何状态都有一个到自身的循环：$Id ⊆ R$。</p><p><strong>用处</strong></p><ol><li>我们可以在 $s_0$ 中停留任意时间后进入 $s_1$。</li></ol><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29 17.55.30.png" alt="2022-03-29 17.55.30" style="zoom:50%;"></p><ol><li>无限的执行：在无重复系统中，任何没有后继者的状态都有一个独特的后继者：它自己。</li><li>终止状态时（或死锁）$… \to s_i$  就相当于  $… \to {s_i}^w$</li><li>可以组成几个变迁系统。</li></ol><h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><h5 id="自由组合"><a href="#自由组合" class="headerlink" title="自由组合"></a>自由组合</h5><p>变迁系统 $⟨V,I,T⟩$  由带有重复的 $⟨V_1, I_1,T_1⟩$ 和 $⟨V_2, I_2, T_2⟩ $ 组成， 其中：</p><ul><li>$V \triangleq V_1 \cup V_2$ ：变量$V_1$和$V_2$的并集</li><li>$I \triangleq I_1 \land I_2$ ：每个子系统都从它的一个初始状态开始</li><li>$ T \triangleq T_1 ∧ T_2 $ ：每个子系统都根据其转换（transition）演变</li></ul><p>由于 $T_1$ 和 $T_2$ 中有循环的状态，因此 $T_1 ∧ T_2$ 意味着我们可以单独执行 $T_1$ 的转换和 $T_2$ 的循环，反之亦然，甚至可以与 $T_2$ 同时执行 $T_1$。</p><p>例：</p><script type="math/tex; mode=display">\left(    \begin{matrix}        V_1 \triangleq i \in \mathbb{N}\\        I_1 \triangleq i = 0 \\        T_1 \triangleq            \begin{cases}                i'=i+1\\        \lor \ i'=i\\            \end{cases}\\    \end{matrix}\right)\otimes\left(    \begin{matrix}        V_2 \triangleq j \in \mathbb{N}\\        I_2 \triangleq j = 0 \\        T_2 \triangleq            \begin{cases}                j'=j+1\\        \lor \ j'=j\\            \end{cases}\\    \end{matrix} \right)\to\left(    \begin{matrix}        V \triangleq i,j \in \mathbb{N}\\        I \triangleq i=0 \land j=0\\        T \triangleq            \begin{cases}                i'=i+1 \land j' = j\\        \lor \ (i'=i \land j'=j+1)\\        \lor \ (i'=i+1 \land j'=j+1)\\        \lor \ (i'=i \land j'=j)            \end{cases}\\    \end{matrix}\right)</script><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30 20.56.29.png" alt="2022-03-30 20.56.29" style="zoom:40%;"></p><h5 id="严格同步的组合"><a href="#严格同步的组合" class="headerlink" title="严格同步的组合"></a>严格同步的组合</h5><p>变迁系统 $⟨S,I,R,L⟩$  由标记为 $⟨S_1,I_1,R_1,L_1⟩$ 和  $⟨S_2,I_2,R_2,L_2⟩$ 严格同步地组成， 其中：</p><ul><li>$S \triangleq S_1 \times S_2$ ：状态对</li><li>$I \triangleq I_1 \times I_2$ ：每个子系统都从它的一个初始状态开始</li><li>$R \triangleq \{ ((s_1, s_2), ({s_1}’, {s_2}’)) | (s_1, {s_1}’) \in R_1 \land (s_2, {s_2}’) \in R_2 \land Etiq((s_1, {s_1}’)) = Etiq((s_2, {s_2}’)) \}$ ：这两个子系统严格根据带有相同标签转换</li><li>$ L \triangleq L_1 \cap L_2 $ </li></ul><p>例：</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30 21.14.36.png" alt="2022-03-30 21.14.36" style="zoom:45%;"></p><ol><li>Synchronizé strict avec LIFO 2 éléments (pile)</li></ol><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30 21.16.51.png" alt="2022-03-30 21.16.51" style="zoom:45%;"></p><p>​    Donne：</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30 21.18.02.png" alt="2022-03-30 21.18.02" style="zoom:40%;"></p><ol><li>Synchronizé strict avec FIFO 2 éléments (file)</li></ol><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30 21.22.31.png" alt="2022-03-30 21.22.31" style="zoom:45%;"></p><p>​    Donne:</p><p>​    <img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30 21.23.35.png" alt="2022-03-30 21.23.35" style="zoom:40%;"></p><h5 id="Synchronise-ouvert-的组合"><a href="#Synchronise-ouvert-的组合" class="headerlink" title="Synchronisé ouvert 的组合"></a>Synchronisé ouvert 的组合</h5><p>变迁系统 $⟨S,I,R,L⟩$  由标记为 $⟨S_1,I_1,R_1,L_1⟩$ 和  $⟨S_2,I_2,R_2,L_2⟩$ 同步地组成， 其中：</p><ul><li><p>$S \triangleq S_1 \times S_2$ ：状态对</p></li><li><p>$I \triangleq I_1 \times I_2$ ：每个子系统都从它的一个初始状态开始</p></li><li><script type="math/tex; mode=display">R \triangleq \begin{cases}    ((s_1, s_2), ({s_1}', {s_2}')) | (s_1, {s_1}') \in R_1 \land (s_2, {s_2}') \in R_2 \land Etiq((s_1, {s_1}')) = Etiq((s_2, {s_2}'))\\    ((s_1, s_2), ({s_1}', {s_2})) | (s_1, {s_1}') \in R_1 \land Etiq((s_1, {s_1}')) \notin L_2\\    ((s_1, s_2), ({s_1}, {s_2}')) | (s_2, {s_2}') \in R_2 \land Etiq((s_2, {s_2}')) \notin L_1\end{cases}</script></li><li><p>$ L \triangleq L_1 \cap L_2 $ </p></li></ul><p>例：</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30 21.42.35.png" alt="2022-03-30 21.42.35" style="zoom:50%;"></p><p>Synchronizé strict avec LIFO 2 éléments (pile)</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30 21.16.51-8669562.png" alt="2022-03-30 21.16.51" style="zoom:45%;"></p><p>Donne：</p><ul><li>strict：</li></ul><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30 21.42.56.png" alt="2022-03-30 21.42.56" style="zoom:50%;"></p><ul><li><p>ouvert</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30 21.43.21.png" alt="2022-03-30 21.43.21" style="zoom:45%;"></p></li></ul><h3 id="第二部分：Action"><a href="#第二部分：Action" class="headerlink" title="第二部分：Action"></a>第二部分：Action</h3><p>在《概述》中，我们提到<strong>T</strong>emporal <strong>L</strong>ogic of <strong>A</strong>ctions <strong>+</strong>是由<em>Leslie Lamport</em>开发的一种<strong>【形式化验证语言】</strong>。</p><p>本章我们会简单介绍这种语言。</p><h4 id="规约-Specification"><a href="#规约-Specification" class="headerlink" title="规约 Specification"></a>规约 Specification</h4><h5 id="规约的结构"><a href="#规约的结构" class="headerlink" title="规约的结构"></a>规约的结构</h5><p>一个TLA+的Model里应该包含的元素有：</p><ul><li>常数 Constant</li><li>变量 Variable（状态 = 变量的值）</li><li>Init. State 由状态谓词定义的一组初始状态 </li><li>动作 Action = 连接两个状态的转换谓词：<ol><li>当前状态，未启动的变量</li><li>到达状态，主要变量</li></ol></li><li>由动作的析取构造的过渡谓词（≈无限重复动作）</li></ul><p>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">---------------- MODULE example ----------------</span><br><span class="line">EXTENDS Naturals</span><br><span class="line">VARIABLE x</span><br><span class="line"></span><br><span class="line">\* 初始状态 Init是初始化谓词（initial predicate）</span><br><span class="line">Init == x \in 0..2\* 等价于x属于自然数 并且 0 &lt;= x &lt; 3</span><br><span class="line"></span><br><span class="line">\* 动作</span><br><span class="line">Plus == x&#x27;=x+1</span><br><span class="line">Sub == x&gt;0 /\ x&#x27;=x-1</span><br><span class="line">Next == Plus \/ Sub\* Next是Next-state动作（action）</span><br><span class="line">Spec == Init /\ [] [ Next ]_&lt;&lt;x&gt;&gt;</span><br></pre></td></tr></table></figure><p>上述规约语言等价于下述变迁系统</p><ul><li>$V \triangleq x \in \mathbb{N}$</li><li>$I \triangleq 0 \le x \le 2$</li><li>$R \triangleq \begin{cases} x’ = x+1\\ \lor x&gt;0 \land x’=x-1\\ \lor x’=x \end{cases}$</li></ul><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30 23.53.48.png" alt="2022-03-30 23.53.48" style="zoom:40%;"></p><h5 id="常量-Constantes"><a href="#常量-Constantes" class="headerlink" title="常量 Constantes"></a>常量 Constantes</h5><ul><li>显式常量：0、1、true、false、“string”</li><li>命名常量：$_{CONSTANT} \ N$，通常伴随着属性：$_{ASSUME}\ N \in Nat \land N \ge 2$</li></ul><h5 id="表达式-Expression"><a href="#表达式-Expression" class="headerlink" title="表达式 Expression"></a>表达式 Expression</h5><p>一切可以公理化的东西：</p><ul><li>逻辑表达式：$¬， ∧， ∨， ∀x ∈ S:p(x)， ∃x ∈ S:p(x)$</li><li>算术表达式：$+，-，&gt;，…$</li><li>集合表达式： $∈$，$∪$，$∩$，$⊂$，$\{e1, e2, . . . , en\}$，$n..m$，$\{x ∈ S : p(x)\}$，$\{f (x) : x ∈ S\}$，$_{UNION}\  S$，$_{SUBSET} \ S$</li><li>$_{IF}$ … $_{THEN}$ … $_{ELSE}$ …</li><li>从 X 到 Y 的函数</li><li>元组、序列等</li></ul><h5 id="集合运算符-Operateurs-ensemblistes"><a href="#集合运算符-Operateurs-ensemblistes" class="headerlink" title="集合运算符 Operateurs ensemblistes"></a>集合运算符 Operateurs ensemblistes</h5><ul><li>$\{e_1, …,e_n\}$ ： 扩展成集合</li><li>$n ..m$ ： $i \in Nat : n \le i \le m$</li><li>$\{ x \in S : p(x)\}$ ：S 中满足性质 p 的元素集合<ul><li>例1，$\{ n \in 1..10 : n\%2=0\} = \{2,4,6,8,10\} $ </li><li>例2，$\{ n \in Nat : n\%2=1\} = \{所有的奇数\} $ </li></ul></li><li>$\{ f(x) :x \in S\} $ ：所有$f(x)$ 的值的集合<ul><li>例1，$\{ 2*n: n \in 1..5\} = \{2,4,6,8,10\} $ </li><li>例2，$\{2*n+1 : n \in Nat\} = \{所有的奇数\} $ </li></ul></li><li>$_{UNION}\ S$ ：S 的元素的并集<ul><li>$_{UNION} \{ \{ 1,2\},  \{ 3,4\}\} =  \{ 1,2,3,4\}$</li></ul></li><li>$_{SUBSET}\ S$：S的所有子集的集合<ul><li>$_{SUBSET} \{ 1,2\} = \{ \{\}, \{1\}, \{ 2\}, \{ 1,2\}\}$</li></ul></li></ul><h4 id="动作-Action"><a href="#动作-Action" class="headerlink" title="动作 Action"></a>动作 Action</h4><h5 id="操作符-Action-Operators"><a href="#操作符-Action-Operators" class="headerlink" title="操作符 Action Operators"></a>操作符 Action Operators</h5><ul><li>$e’$ :  The value of e in the final state of a step (迭代器中e的更新值)</li><li>$[A]_e$ : $[A ∨ (e’ = e)]$ </li><li>$⟨A⟩_e$ : $[A ∧ (e’ \ne e)]$</li><li>$_{ENABLE} \ A$ : [An A step is possible]</li><li>$_{UNCHANGED}\ E$ : $[e’ = e]$</li><li>$A · B$ : [Composition of actions]</li></ul><p>动作 = 转换谓词 = 包含常量、变量和引发变量的布尔表达式。</p><p>动作 不等于 任务</p><ul><li><p>$\begin{aligned} &amp; x’=x+1\\   &amp; \equiv x’-x=1\\   &amp; \equiv x=x’-1\\  &amp; \equiv (x&gt;1 \land x’/x=1 \land x’\%x=1) \lor (1=x \land 2=x’) \lor (x=0 \land x’ \in \{y \in Nat:y+1=2*y\})\\ \end{aligned}$</p></li><li><p>Other types of actions:</p><ul><li>$x’ &gt; x$ 或 $x’ ∈ \{x + 1, x + 2, x + 3\}$（不确定性）</li><li>$x’ ∈ \{y ∈ \mathbb{N}: ∃z ∈ N: z ∗ y = x ∧ z \% 2 = 0\}$（不可评估）</li><li>$x’ = y ∧ y’ = x$（多个变量）</li></ul></li></ul><h5 id="由连词组成的动作"><a href="#由连词组成的动作" class="headerlink" title="由连词组成的动作"></a>由连词组成的动作</h5><ol><li>仅与起始状态有关的状态谓词</li><li>确定性转移谓词 $var’ = . . .$ 或 非确定性转移谓词 $var’ ∈ …$</li></ol><p>例：$x &lt; 10 ∧ x’ = x + 1$，而不是 $x′ = x + 1 ∧ x’ &lt; 11$ 或 $x′ - x = 1 ∧ x’ &lt; 11$</p><h5 id="重复（Begaiement）-1"><a href="#重复（Begaiement）-1" class="headerlink" title="重复（Bégaiement）"></a>重复（Bégaiement）</h5><h6 id="Begaiement"><a href="#Begaiement" class="headerlink" title="Bégaiement"></a>Bégaiement</h6><p>$[\mathcal{A}]_f \triangleq \mathcal{A} ∨ f’ = f$ ，其中 $f$ 是变量元组。</p><p>示例：</p><p>$\begin{aligned} {[x’=x+1]_{⟨x,y⟩}} &amp; = {(x’=x+1 ∨ (⟨x, y⟩’=⟨x,y⟩))} \\     &amp; = {(x’= x+1 ∨ (x’=x ∧ y’=y))} \\ \end{aligned}$</p><h6 id="Non-Begaiement"><a href="#Non-Begaiement" class="headerlink" title="Non Bégaiement"></a>Non Bégaiement</h6><p>$[\mathcal{A}]_f \triangleq \mathcal{A} ∨ f’ \ne f$ ，其中 $f$ 是变量元组。</p><h6 id="无约束变量-Variables-non-contraintes"><a href="#无约束变量-Variables-non-contraintes" class="headerlink" title="无约束变量 Variables non contraintes"></a>无约束变量 Variables non contraintes</h6><p>$\begin{aligned} {(x′=x+1)} &amp; = {(x’=x+1 \land y’= 任何值 )} \\     &amp; \ne {(x’=x+1 \land y’=y)} \\ \end{aligned}$</p><h6 id="UNCHANGED"><a href="#UNCHANGED" class="headerlink" title="UNCHANGED"></a>UNCHANGED</h6><p>$_{UNCHANGED}\ e \triangleq e’ = e$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">---------------- MODULE AlternatingBit ----------------</span><br><span class="line">EXTENDS Naturals</span><br><span class="line">CONSTANT Data</span><br><span class="line">VARIABLE val, ready, ack</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">\* 初始状态 Init是初始化谓词（initial predicate）</span><br><span class="line">Init == /\ val \in Data</span><br><span class="line">/\ ready \in &#123;0,1&#125;</span><br><span class="line">/\ ack = ready</span><br><span class="line"></span><br><span class="line">Send == /\ ready = ack</span><br><span class="line">/\ val&#x27; \in Data</span><br><span class="line">/\ ready&#x27; = 1 - ready</span><br><span class="line">/\ UNCHANGED ack</span><br><span class="line"></span><br><span class="line">Receive == /\ ready # ac k</span><br><span class="line">/\ ack&#x27; = 1 - ack</span><br><span class="line">/\ UNCHANGED &lt;&lt;val, ready&gt;&gt;</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">Next == Send \/ Receive\* Next是Next-state动作（action）</span><br><span class="line">Spec == Init /\ [] [ Next ]_&lt;&lt;val, ready, ack&gt;&gt;</span><br><span class="line">=========================================================</span><br></pre></td></tr></table></figure><h4 id="函数-Function"><a href="#函数-Function" class="headerlink" title="函数 Function"></a>函数 Function</h4><p>“映射(mapping) ”意义上的函数，对应：</p><ul><li>$X \to Y$ : 从 X 到 Y 的一组函数。</li><li>$f \in [X \to Y]$ : X 在 Y 中的 f 函数</li><li>$f[x]$ : x 处的 f 值。</li></ul><p>一个函数就是一个值。<br>一个包含函数的变量可以改变它的值⇒“函数改变”。</p><h5 id="符号的定义-Definition-of-symbol"><a href="#符号的定义-Definition-of-symbol" class="headerlink" title="符号的定义 Definition of symbol"></a>符号的定义 Definition of symbol</h5><p>$f[x \in Nat]$ : 关于x的表达式。例 : $Inc[x \in Nat] \triangleq x+1$</p><h5 id="值的定义-Definition-of-value"><a href="#值的定义-Definition-of-value" class="headerlink" title="值的定义 Definition of value"></a>值的定义 Definition of value</h5><p>$[x \in S \mapsto expr]$. 例 : $x \in 1..4 \mapsto 2*x$</p><h5 id="表-Table"><a href="#表-Table" class="headerlink" title="表 Table"></a>表 Table</h5><p>函数 $t ∈ [X → Y ]$ 其中 X 是整数区间。</p><h5 id="定义域-Domain"><a href="#定义域-Domain" class="headerlink" title="定义域 Domain"></a>定义域 Domain</h5><p>$_{DOMAIN}\ f$ : f 的定义域</p><h5 id="值域-Codomaine"><a href="#值域-Codomaine" class="headerlink" title="值域 Codomaine"></a>值域 Codomaine</h5><p>$Codomain(f) \triangleq \{ f[x]:x \in _{DOMAIN}f\}$</p><h5 id="EXCEPT"><a href="#EXCEPT" class="headerlink" title="EXCEPT"></a>EXCEPT</h5><p>$[a \ _{EXCEPT}\ ![i] =v] \triangleq [j\in _{DOMAIN} \ a \mapsto _{IF}\ j=i\ _{THEN}\ v\ _{ELSE}\ a[j]]$</p><p>例：$[a’ = a \ _{EXCEPT}\ ![2] =8] \not\equiv (a[2]’ =8)$</p><h5 id="IncF"><a href="#IncF" class="headerlink" title="IncF"></a>IncF</h5><p>IncF 是数学意义上的函数定义，等价于 $IncF \triangleq [x ∈ Nat \mapsto x + 1]$</p><ul><li>它的定义域：$_{DOMAIN}\ IncF$</li><li>它的值域：$ \{IncF[x] : x ∈ _{DOMAIN}IncF\}$</li><li>$IncF \in [X \mapsto Y]$</li></ul><h5 id="IncO"><a href="#IncO" class="headerlink" title="IncO"></a>IncO</h5><p>IncO 是运算符(Operator) 的定义</p><ul><li>写因式分解：类似于一个宏，其文本可以替换</li><li>没有定义域 和 值域</li><li>$IncO ∈ [X → Y ]$ 没有意义</li></ul><h5 id="记录-Record"><a href="#记录-Record" class="headerlink" title="记录 Record"></a>记录 Record</h5><p>记录是 $[X → Y]$ 的函数，其中 X 是一组字符串。</p><p>简写作：<br>$[“qwerty” \mapsto 1, “asdfgh” \mapsto 2] = [qwerty \mapsto 1,asdfgh \mapsto 2]$$</p><p>$rec[“qwerty”] = rec.qwerty$</p><h5 id="递归定义-Definition-recursive"><a href="#递归定义-Definition-recursive" class="headerlink" title="递归定义 Définition récursive"></a>递归定义 Définition récursive</h5><p>定义（函数或运算符）时，可以给出递归定义：</p><ul><li>函数：$fact[n \in Nat] \triangleq _{IF}\ n=0\ _{THEN}\ 1\ _{ELSE}\ n*fact(n-1)$</li><li>运算符：$fact(n) \triangleq _{IF}\ n=0\ _{THEN}\ 1\ _{ELSE}\ n*fact(n-1)$</li></ul><p>从理论上讲，必须证明这些定义的有效性。</p><h5 id="n元组-n-Tuple"><a href="#n元组-n-Tuple" class="headerlink" title="n元组 n-Tuple"></a>n元组 n-Tuple</h5><p>符号：⟨a, b, c⟩。</p><ul><li>n元组是定义域函数= $\{1,. . .,n\} :⟨a, b, c⟩[3] = c$</li><li>用于表示关系：$\{⟨x, y⟩ ∈ X × Y: R(x, y)\}$。示例：$\{⟨a, b⟩ ∈ Nat × Nat:a=2*b\}$。</li></ul><h5 id="序列-Sequence"><a href="#序列-Sequence" class="headerlink" title="序列 Sequence"></a>序列 Sequence</h5><p>$\begin{aligned} Seq(T) &amp; \triangleq _{UNION} \{[1..n → T]: n ∈ Nat\}\\ &amp; \triangleq 包含 T 的有限序列集 \end{aligned}$</p><p>运算符：$Len(s)$，$s ◦ t$（连接），$Append(s,e)$，$Head(s)$，$Tail(s)$。</p><h5 id="局部定义-Local-Definition"><a href="#局部定义-Local-Definition" class="headerlink" title="局部定义 Local Definition"></a>局部定义 Local Definition</h5><p>$LET$</p><ul><li><p>表达式： $_{LET}\ v \triangleq e\ _{IN}\ f$</p><p>等效于表达式 $f$，其中所有的符号 $v$ 的都被 $e$ 替换。例子：$_{LET}\ i \triangleq g(x)\ _{IN}\ f (i)≡ f (g(x))$</p></li></ul><p>例：</p><p>$Pythagore(x, y, z) \triangleq _{LET}\ square(n) \triangleq n∗n\ _{IN}\ square(x) + square(y) = square(z)$</p><h5 id="选择-CHOOSE"><a href="#选择-CHOOSE" class="headerlink" title="选择 CHOOSE"></a>选择 CHOOSE</h5><ul><li><p>$_{CHOOSE}\ x \in S:p$ ：确定性任意选择集合 S 中满足谓词 p 的元素。</p></li><li><p>$max[S \in _{SUBSET}\ Nat] \triangleq\ _{CHOOSE}\ m \in S:(\forall p \in S : m \ge p)$</p></li></ul><p>对于集合 S 和属性 p，选择的元素在所有执行过程中始终相同。 它不是一个随机选择器，它在每次调用时都给出一个不同的元素。所以$_{CHOOSE}\ x \in S:p = _{CHOOSE}\ x \in S:p$。</p><p><strong>规约</strong></p><ul><li><p>$(x =\ _{CHOOSE}\ n : n ∈ Nat) ∧ \Box [x’=_{CHOOSE}\ n : n ∈ Nat]_{⟨x⟩}$</p><p>有一个独特的执行：$ x = c → x = c → …$其中 c 是一个不确定的整数（由选择指定）。</p></li><li><p>$(x ∈ Nat) ∧ \Box [x’ ∈ Nat]_{⟨x⟩}$</p><p>有无限次执行，其中一些在每个状态中 x 是不同的，另一些在 x 是恒定的，另一些在 x 中循环</p></li></ul><h3 id="第三部分"><a href="#第三部分" class="headerlink" title="第三部分"></a>第三部分</h3>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Transition-System-变迁系统-与-TLA&quot;&gt;&lt;a href=&quot;#Transition-System-变迁系统-与-TLA&quot; class=&quot;headerlink&quot; title=&quot;Transition System(变迁系统) 与 TLA+&quot;&gt;&lt;/a&gt;Transition System(变迁系统) 与 TLA+&lt;/h2&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;本文章是根据法国国立高等电力技术、电子学、计算机、水力学与电信学校 (E.N.S.E.E.I.H.T) 第八学期课程“Système de transition”总结而来的课程笔记。碍于本人学识有限，部分叙述难免存在纰漏，请读者注意甄别。&lt;/p&gt;</summary>
    
    
    
    <category term="TLA+" scheme="https://dave0126.github.io/categories/TLA/"/>
    
    
    <category term="系统" scheme="https://dave0126.github.io/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发多线程编程 (JUC) (三)</title>
    <link href="https://dave0126.github.io/2022/03/28/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-3/"/>
    <id>https://dave0126.github.io/2022/03/28/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-3/</id>
    <published>2022-03-28T20:37:36.000Z</published>
    <updated>2022-03-28T20:44:51.888Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-并发多线程编程"><a href="#Java-并发多线程编程" class="headerlink" title="Java 并发多线程编程"></a>Java 并发多线程编程</h2><p>视频课程: <a href="https://www.bilibili.com/video/BV16J411h7Rd?p=50">BiliBili - 黑马程序员Java并发编程 JUC</a></p><p>笔记参考: <a href="https://nyimac.gitee.io/2020/06/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发 - Nyima’s Blog</a></p><ul><li>注：本课程笔记基于JDK8，采用lsf4j打印日志</li></ul><span id="more"></span><h3 id="4-共享模型之内存"><a href="#4-共享模型之内存" class="headerlink" title="4 共享模型之内存"></a>4 共享模型之内存</h3><p>上一章讲解的 Monitor 主要关注的是访问共享变量时，保证临界区代码的原子性</p><p>这一章我们将进一步学习共享变量在多线程间的【可见性】问题与多条指令执行时的【有序性】问题</p><h4 id="4-1-Java-内存模型"><a href="#4-1-Java-内存模型" class="headerlink" title="4.1 Java 内存模型"></a>4.1 Java 内存模型</h4><p>JMM 即 Java Memory Model，它定义了<strong>主存（共享内存）、工作内存（线程私有）</strong>抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、 CPU 指令优化等。</p><p><strong>JMM体现在以下几个方面</strong></p><ul><li>原子性 - 保证指令不会受到线程上下文切换的影响</li><li>可见性 - 保证指令不会受 cpu 缓存的影响</li><li>有序性 - 保证指令不会受 cpu 指令并行优化的影响</li></ul><p>更新中。。。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Java-并发多线程编程&quot;&gt;&lt;a href=&quot;#Java-并发多线程编程&quot; class=&quot;headerlink&quot; title=&quot;Java 并发多线程编程&quot;&gt;&lt;/a&gt;Java 并发多线程编程&lt;/h2&gt;&lt;p&gt;视频课程: &lt;a href=&quot;https://www.bilibili.com/video/BV16J411h7Rd?p=50&quot;&gt;BiliBili - 黑马程序员Java并发编程 JUC&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;笔记参考: &lt;a href=&quot;https://nyimac.gitee.io/2020/06/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/&quot;&gt;Java并发 - Nyima’s Blog&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注：本课程笔记基于JDK8，采用lsf4j打印日志&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="JUC" scheme="https://dave0126.github.io/categories/JUC/"/>
    
    
    <category term="Java" scheme="https://dave0126.github.io/tags/Java/"/>
    
    <category term="JUC" scheme="https://dave0126.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发多线程编程 (JUC) (二)</title>
    <link href="https://dave0126.github.io/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/"/>
    <id>https://dave0126.github.io/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/</id>
    <published>2022-03-26T14:38:56.000Z</published>
    <updated>2022-03-28T20:48:00.059Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-并发多线程编程"><a href="#Java-并发多线程编程" class="headerlink" title="Java 并发多线程编程"></a>Java 并发多线程编程</h2><p>视频课程: <a href="https://www.bilibili.com/video/BV16J411h7Rd?p=50">BiliBili - 黑马程序员Java并发编程 JUC</a></p><p>笔记参考: <a href="https://nyimac.gitee.io/2020/06/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发 - Nyima’s Blog</a></p><ul><li>注：本课程笔记基于JDK8，采用lsf4j打印日志</li></ul><span id="more"></span><h3 id="3-共享模型-之-管程"><a href="#3-共享模型-之-管程" class="headerlink" title="3 共享模型 之 管程"></a>3 共享模型 之 管程</h3><h4 id="3-1-共享带来的问题"><a href="#3-1-共享带来的问题" class="headerlink" title="3.1 共享带来的问题"></a>3.1 共享带来的问题</h4><p>JAVA代码中的体现</p><p>两个线程对初始值为0的全局静态变量, 一个做自增操作, 一个做自减操作, 各执行5000次, 最终的结果是0吗?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">5000</span>; i++)&#123;</span><br><span class="line">      counter++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">5000</span>; i++)&#123;</span><br><span class="line">      counter--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  t1.start();</span><br><span class="line">  t2.start();</span><br><span class="line">  t1.join();</span><br><span class="line">  t2.join();</span><br><span class="line">  </span><br><span class="line">  Log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, counter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果大概率不为<code>0</code></p><pre class="mermaid">sequenceDiagram    participant 线程1    participant 线程2    participant 静态变量 i    静态变量 i ->> 线程2 :getstatic i 读取0    线程2 ->> 线程2 :iconst_1 准备常数 1    线程2 ->> 线程2 :isub 减法, 线程内 i= -1    线程2 -x 静态变量 i :!!!还没来得及将i的结果写入    线程2 -->> 线程1 :上下文切换    线程1 ->> 线程1 :iconst_1 准备常数 1    线程1 ->> 线程1 :iadd 加法, 线程内 i= 1    线程1 ->> 静态变量 i :putstatic i 写入 1    线程1 -->> 线程2 :上下文切换    线程2 ->> 静态变量 i :putstatic i 写入 -1</pre><p>最终结果为<code>-1</code>.</p><h5 id="3-1-1-临界区-Critical-Section"><a href="#3-1-1-临界区-Critical-Section" class="headerlink" title="3.1.1 临界区 Critical Section"></a>3.1.1 临界区 Critical Section</h5><ul><li>一个程序运行多个线程本身是没有问题的</li><li>问题出在多个线程访问共享资源<ul><li>多个线程读共享资源其实也没有问题</li><li>在多个线程对共享资源读写操作时发生指令交错，就会出现问题</li></ul></li><li>一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为<strong>临界区</strong></li></ul><p>例如，下面代码中的临界区</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 临界资源</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> </span><br><span class="line"><span class="comment">// 临界区 </span></span><br><span class="line">&#123;   </span><br><span class="line">    counter++; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> </span><br><span class="line"><span class="comment">// 临界区 </span></span><br><span class="line">&#123; </span><br><span class="line">    counter--; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-1-2-竞态条件-Race-Condition"><a href="#3-1-2-竞态条件-Race-Condition" class="headerlink" title="3.1.2 竞态条件 Race Condition"></a>3.1.2 竞态条件 Race Condition</h5><p>多个线程在<strong>临界区</strong>内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了<strong>竞态条件</strong></p><h4 id="3-2-Synchronized-解决方案"><a href="#3-2-Synchronized-解决方案" class="headerlink" title="3.2 Synchronized 解决方案"></a>3.2 Synchronized 解决方案</h4><h5 id="3-2-1-解决手段"><a href="#3-2-1-解决手段" class="headerlink" title="3.2.1 解决手段"></a>3.2.1 解决手段</h5><p>为了避免临界区的竞态条件发生，有多种手段可以达到目的。</p><ul><li>【阻塞式】的解决方案：synchronized，Lock</li><li>【非阻塞式】的解决方案：原子变量</li></ul><p>本次课使用阻塞式的解决方案：<strong>synchronized</strong>，来解决上述问题，即俗称的<strong>【对象锁】</strong>，它采用互斥的方式让同一 时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住(blocked)。这样就能保证拥有锁 的线程可以安全的执行临界区内的代码，不用担心线程上下文切换</p><h5 id="3-2-2-Synchronized-语法"><a href="#3-2-2-Synchronized-语法" class="headerlink" title="3.2.2 Synchronized 语法"></a>3.2.2 Synchronized 语法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(Object) &#123; <span class="comment">// 例如, 当线程1持有锁时, 线程2被阻塞; 等待线程1释放锁</span></span><br><span class="line"><span class="comment">//临界区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line"><span class="comment">//创建一个公共对象，作为对象锁的对象</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;    </span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;            </span><br><span class="line">        <span class="keyword">synchronized</span> (room) &#123; <span class="comment">// 上锁</span></span><br><span class="line">        counter++;            </span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;    </span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;       </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;         </span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123; <span class="comment">// 上锁</span></span><br><span class="line">            counter--;          </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    t1.start();    </span><br><span class="line">    t2.start(); </span><br><span class="line">    t1.join();   </span><br><span class="line">    t2.join();    </span><br><span class="line">    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,counter); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序流程如下图: </p><pre class="mermaid">sequenceDiagram    participant 线程1    participant 线程2    participant 静态变量 i    participant 🔒锁对象    线程2 ->> 🔒锁对象 :尝试获取锁    Note over 🔒锁对象,线程2 :拥有锁    静态变量 i ->> 线程2 :getstatic i 读取0    线程2 ->> 线程2 :iconst_1 准备常数 1    线程2 ->> 线程2 :isub 减法, 线程内 i= 0-1 = -1    线程2 -->> 线程1 :上下文切换    线程1 ->> 🔒锁对象 :尝试获取锁, 但是被阻塞(BLOCKED)    线程1 -->> 线程2 :上下文切换    线程2 ->> 静态变量 i :putstatic i 写入 -1    Note over 🔒锁对象,线程2 :拥有锁    线程2 ->> 🔒锁对象 :释放锁, 并唤醒阻塞的线程    Note over 🔒锁对象,线程1 :拥有锁    静态变量 i ->> 线程1 :getstatic i 读取-1    线程1 ->> 线程1 :iconst_1 准备常数 1    线程1 ->> 线程1 :iadd 加法, 线程内 i= -1+1 = 0    线程1 ->> 静态变量 i :putstatic i 写入 0    Note over 🔒锁对象,线程1 :拥有锁    线程1 ->> 🔒锁对象 :释放锁, 并唤醒阻塞的线程</pre><p><strong>思考</strong></p><p>Synchronized 实际是用<strong>对象锁</strong>保证了<strong>临界区内代码的原子性</strong>, 临界区内的代码对外是不可分割的, 不会被线程切换所打断. </p><p>将上一个代码块的例子解藕, 使其资源类和任务类分开:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Room</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">      counter++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">      counter--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCounter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">  <span class="type">Room</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Room</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;            </span><br><span class="line">      room.increment();</span><br><span class="line">    &#125;    </span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;       </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">          room.decrement();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    t1.start();    </span><br><span class="line">    t2.start(); </span><br><span class="line">    t1.join();   </span><br><span class="line">    t2.join();    </span><br><span class="line">    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,room.getCounter()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-2-3-Synchronized-在方法上"><a href="#3-2-3-Synchronized-在方法上" class="headerlink" title="3.2.3 Synchronized 在方法上"></a>3.2.3 Synchronized 在方法上</h5><p>我们必须知道, <strong><code>Synchronized</code> 锁住的始终是对象</strong>. 以下两个例子看似是与方法有关, 实则依然是为对象加锁.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1. 在成员方法上*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123; <span class="comment">// 锁住this对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*2. 在静态方法上*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Test.class) &#123; <span class="comment">// 锁住Test类对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li><code>sleep()</code> 方法不会释放锁</li></ul><h4 id="3-3-变量的线程安全分析"><a href="#3-3-变量的线程安全分析" class="headerlink" title="3.3 变量的线程安全分析"></a>3.3 变量的线程安全分析</h4><h5 id="3-3-1-成员变量和静态变量的线程安全分析"><a href="#3-3-1-成员变量和静态变量的线程安全分析" class="headerlink" title="3.3.1 成员变量和静态变量的线程安全分析"></a>3.3.1 成员变量和静态变量的线程安全分析</h5><ul><li>如果没有变量没有在线程间共享，那么变量是安全的</li><li>如果变量在线程间共享<ul><li>如果只有读操作，则线程安全</li><li>如果有读写操作，则这段代码是临界区，需要考虑线程安全</li></ul></li></ul><h5 id="3-3-2-局部变量线程安全分析"><a href="#3-3-2-局部变量线程安全分析" class="headerlink" title="3.3.2 局部变量线程安全分析"></a>3.3.2 局部变量线程安全分析</h5><p>1) 局部变量【局部变量被初始化为基本数据类型】是<strong>安全</strong>的</p><ol><li><strong>局部变量引用的对象未必</strong>是安全的</li></ol><ul><li>如果局部变量引用的对象没有引用线程共享的对象，那么是线程安全的</li><li>如果局部变量引用的对象引用了一个线程共享的对象，那么要考虑线程安全的</li></ul><ol><li>局部变量是线程安全的——每个方法都在对应线程的栈中创建栈帧，不会被其他线程共享</li></ol><p><img src="/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/20200608144636.png" alt="20200608144636" style="zoom:75%;"></p><ol><li>如果局部变量<a href="https://dave0126.github.io/2022/03/22/JVM-2/#1-3-%E4%BA%94%E7%A7%8D%E5%BC%95%E7%94%A8">引用的对象</a>被共享，且执行了读写操作，则<strong>线程不安全</strong></li></ol><p><img src="/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/20200608144649.png" alt="20200608144649" style="zoom:60%;"></p><ol><li>如果是局部变量，则会在<a href="https://dave0126.github.io/2022/03/22/JVM-1/#4-%E5%A0%86">堆</a>中创建对应的对象，不会存在线程安全问题。</li></ol><p><img src="/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/20200608144702.png" alt="20200608144702" style="zoom:60%;"></p><h5 id="3-3-3-常见线程安全类"><a href="#3-3-3-常见线程安全类" class="headerlink" title="3.3.3 常见线程安全类"></a>3.3.3 常见线程安全类</h5><ul><li>String</li><li>Integer</li><li>StringBuffer</li><li>Random</li><li>Vector</li><li>Hashtable</li><li>java.util.concurrent 包下的类 </li></ul><p>这里说它们是线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的。也可以理解为</p><ul><li>它们的每个方法是原子的</li><li>但多个方法组合在一起就不是原子的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Hashtable</span> <span class="variable">table</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line"><span class="comment">// thread1, thread2</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"> <span class="keyword">if</span> (table.get(<span class="string">&quot;key&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">  table.put(<span class="string">&quot;key&quot;</span>,value1)</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"> <span class="keyword">if</span> (table.get(<span class="string">&quot;key&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">  table.put(<span class="string">&quot;key&quot;</span>,value2)</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre class="mermaid">sequenceDiagram    participant 线程1    participant 线程2    participant table    线程1 ->> table :get("key") == null    线程2 ->> table :get("key") == null    线程2 ->> table :put("key", value2)    线程1 ->> table :put("key", value1)</pre><h5 id="3-3-4-不可变类线程安全性"><a href="#3-3-4-不可变类线程安全性" class="headerlink" title="3.3.4 不可变类线程安全性"></a>3.3.4 不可变类线程安全性</h5><p>String、Integer 等都是<strong>不可变类</strong>，因为其内部的状态不可以改变，因此它们的方法都是线程安全的</p><p><strong>思考:</strong></p><p>Q 问: String 有 replace，substring 等方法可以改变值，那么这些方法又是如何保证线程安全的呢？</p><p>A 答: 这是因为这些方法的返回值都<strong>创建了一个新的对象</strong>，而不是直接改变String、Integer对象本身。</p><h5 id="3-3-5-习题"><a href="#3-3-5-习题" class="headerlink" title="3.3.5 习题"></a>3.3.5 习题</h5><p>找出临界区代码，加锁</p><ul><li>买票：BiliBili - 黑马程序员全面深入学习Java并发编程，JUC并发编程全套教程 <a href="https://www.bilibili.com/video/BV16J411h7Rd?p=71">买票问题</a></li><li>转账：BiliBili - 黑马程序员全面深入学习Java并发编程，JUC并发编程全套教程 <a href="https://www.bilibili.com/video/BV16J411h7Rd?p=74">转账问题</a></li></ul><h4 id="3-4-Monitor"><a href="#3-4-Monitor" class="headerlink" title="3.4 Monitor"></a>3.4 Monitor</h4><h5 id="3-4-1-Monitor原理"><a href="#3-4-1-Monitor原理" class="headerlink" title="3.4.1 Monitor原理"></a>3.4.1 Monitor原理</h5><p>Monitor 又称为监视器或<strong>管程</strong>, 是Synchronized实现的底层原理, 由<strong>操作系统提供</strong></p><p>每个Java对象都会关联一个Monitor对象, 如果使用synchronized关键字给对象上锁 (重量级) 之后, 该对象与Monitor关联.</p><p><img src="/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/20200608144917.png" alt="20200608144917"></p><ul><li>刚开始时, Monitor 的 Owner 为 null</li><li>当线程执行到临界区代码时，如果使用了synchronized，会先查询synchronized中所指定的对象(obj)<strong>是否绑定了Monitor</strong>。<ul><li>如果<strong>没有绑定</strong>，则会先去去与Monitor绑定，并且将Owner设为当前线程。</li><li>如果已经绑定，则会去查询该Monitor是否已经有了Owner<ul><li>如果没有，则Owner与将当前线程绑定</li><li>如果有，则放入EntryList，进入阻塞状态(blocked)</li></ul></li></ul></li><li>当Monitor的Owner将临界区中代码执行完毕后，Owner便会被清空，此时EntryList中处于<strong>阻塞</strong>状态的线程会被<strong>叫醒并竞争</strong>，此时的竞争是<strong>非公平的</strong></li><li><strong>注意</strong>：<ul><li>对象在使用了synchronized后与Monitor绑定时，会将对象头中的<strong>Mark Word</strong>置为Monitor指针。</li><li>每个对象都会绑定一个<strong>唯一的Monitor</strong>，如果synchronized中所指定的对象(obj)<strong>不同</strong>，则会绑定<strong>不同</strong>的Monitor</li></ul></li></ul><h5 id="3-4-2-轻量级锁"><a href="#3-4-2-轻量级锁" class="headerlink" title="3.4.2 轻量级锁"></a>3.4.2 轻量级锁</h5><p><strong>轻量级锁使用场景：</strong>当一个对象被多个线程所访问，但访问的时间是<strong>错开的（不存在竞争）</strong>，此时就可以使用<strong>轻量级锁</strong>来优化。</p><p>因为重量级锁由操作系统提供, 使用时系统开销较大, 所以在使用 synchronized 时优先使用轻量级锁</p><p>轻量级锁对使用者是透明的, 即语法依然是<code>synchronized</code>, 优先使用轻量级锁, 如若失败则改用其他类型</p><ul><li>创建<strong>锁记录</strong>（Lock Record）对象，每个线程的栈帧都会包含一个锁记录对象，内部可以存储锁定对象的mark word(不再一开始就使用Monitor)</li></ul><p><img src="/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/20200608144942.png" alt="20200608144942" style="zoom:75%;"></p><ul><li>让锁记录中的Object reference指向锁对象（Object），并尝试用cas去替换Object中的mark word，将此mark word放入lock record中保存</li></ul><p><img src="/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/20200608144950.png" alt="20200608144950" style="zoom:75%;"></p><ul><li>如果cas替换成功，则将Object的对象头替换为<strong>锁记录的地址</strong>和<strong>状态 00（轻量级锁状态）</strong>，并由该线程给对象加锁</li></ul><p><img src="/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/20200608144957.png" alt="20200608144957" style="zoom:75%;"></p><ul><li><p>如果cas失败, 有两种情况:</p><ul><li>如果是其他线程已经持有了该Object的轻量级锁, 这时表明有竞争, 进入下一小节的<strong>锁膨胀</strong>过程</li><li>如果是自己执行了synchronized<strong>锁重入</strong>, 那么再添加一条Lock Record 作为重入的计数</li></ul><p><img src="/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/image-20220326175731138-8313862.png" alt="image-20220326175731138" style="zoom:75%;"></p></li><li><p>当退出Synchronized (解锁) 时, 如果有取值为null的锁记录, 表示有重入, 这时重置锁记录, 表示重入计数 -1</p></li></ul><p><img src="/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/20200608144957.png" alt="20200608144957" style="zoom:75%;"></p><ul><li>当退出Synchronized (解锁)锁记录的值为不为null时, 这时使用cas将 Mark Word 的值恢复给对象头<ul><li>成功, 则解锁成功</li><li>失败, 说明轻量级锁进行了锁膨胀或者已经升级为重量级锁, 进入重量级锁解锁流程</li></ul></li></ul><h5 id="3-4-3-锁膨胀"><a href="#3-4-3-锁膨胀" class="headerlink" title="3.4.3 锁膨胀"></a>3.4.3 锁膨胀</h5><ul><li>如果一个线程在给一个对象加轻量级锁时，<strong>cas替换操作失败</strong>（因为此时其他线程已经给对象加了轻量级锁），此时该线程就会进入<strong>锁膨胀</strong>过程</li></ul><p><img src="/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/20200608145004.png" alt="20200608145004" style="zoom:75%;"></p><ul><li>此时便会给对象加上重量级锁 (使用Monitor)<ul><li>将对象头的Mark Word改为Monitor的地址，并且状态改为01(重量级锁)</li><li>并且该线程放入Monitor 的 EntryList中，并进入阻塞状态(blocked)</li></ul></li></ul><p><img src="/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/20200608145148.png" alt="20200608145148" style="zoom:75%;"></p><ul><li>当线程退出同步块解锁时, 使用cas将 Mark Word 的值恢复给对象头, 失败. 这是会进入重量级解锁流程, 即按照Monitor地址找到Monitor对象, 设置Owner 为 null, 唤醒EntryList中的BLOCKED线程</li></ul><h5 id="3-4-4-自旋优化"><a href="#3-4-4-自旋优化" class="headerlink" title="3.4.4 自旋优化"></a>3.4.4 自旋优化</h5><p><strong>重量级锁</strong>竞争时，还可以使用自旋来优化(在多核心cpu中才有意义)，如果当前线程在<strong>自旋成功</strong>（使用锁的线程退出了同步块，<strong>释放了锁</strong>，即当前线程可以直接成为新的Owner），这时就可以避免线程进入阻塞状态。</p><h6 id="自旋成功的情况"><a href="#自旋成功的情况" class="headerlink" title="自旋成功的情况"></a>自旋成功的情况</h6><pre class="mermaid">sequenceDiagram    participant t1 as 线程1(cpu1)    participant obj as Obj    participant t2 as 线程2    Note over obj :10 (重量级锁)    t1 ->> +obj :访问同步块， 获取 Monitor    t1 ->> obj :成功加锁    Note over obj :10 (重量级锁) 重量级锁指针    t2 -x obj :访问同步块， 获取 Monitor    t2 ->> t2 :自旋重试    Note over t1 :执行临界区代码块    t2 ->> t2 :自旋重试    obj ->> -t1 :成功解锁    Note over obj :01 (无锁)    t2 ->> +obj :成功加锁    Note over obj :10 (重量级锁) 重量级锁指针    Note over t2 :执行临界区代码块    obj ->> -t2 : 成功解锁</pre><h6 id="自旋重试失败的情况"><a href="#自旋重试失败的情况" class="headerlink" title="自旋重试失败的情况"></a>自旋重试失败的情况</h6><pre class="mermaid">sequenceDiagram    participant t1 as 线程1(cpu1)    participant obj as Obj    participant t2 as 线程2    Note over obj :10 (重量级锁)    t1 ->> +obj :访问同步块， 获取 Monitor    t1 ->> obj :成功加锁    Note over obj :10 (重量级锁) 重量级锁指针    t2 -x obj :访问同步块， 获取 Monitor    t2 ->> t2 :自旋重试    Note over t1 :执行临界区代码块    t2 ->> t2 :自旋重试    t2 ->> t2 :自旋重试    t2 ->> t2 :自旋重试    Note over t2 :阻塞    obj ->> -t1 :成功解锁    Note over obj :01 (无锁)</pre><h5 id="3-4-5-偏向锁"><a href="#3-4-5-偏向锁" class="headerlink" title="3.4.5 偏向锁"></a>3.4.5 偏向锁</h5><p>轻量级锁在没有竞争时，每次<strong>重入</strong>（该线程执行的方法中再次锁住该对象）操作仍需要cas替换操作，这样是会使性能降低的。</p><p>所以引入了<strong>偏向锁</strong>对性能进行优化：在<strong>第一次</strong>cas时会将<strong>线程的ID</strong>写入对象的Mark Word中。此后发现这个线程ID就是自己的，就表示没有竞争，就不需要再次cas，以后只要不发生竞争，这个对象就归该线程所有。</p><p>（相当于在临界资源上刻上进程的名字， 该资源归此进程所有）</p><h6 id="偏向状态"><a href="#偏向状态" class="headerlink" title="偏向状态"></a>偏向状态</h6><ul><li>Normal：一般状态，没有加任何锁，前面62位保存的是对象的信息，<strong>最后2位为状态（01），倒数第三位表示是否使用偏向锁（未使用：0）</strong></li><li>Biased：偏向状态，使用偏向锁，前面54位保存的当前线程的ID，<strong>最后2位为状态（01），倒数第三位表示是否使用偏向锁（使用：1）</strong></li><li>Lightweight：使用轻量级锁，前62位保存的是锁记录的指针，<strong>最后两位为状态（00）</strong></li><li>Heavyweight：使用重量级锁，前62位保存的是Monitor的地址指针，<strong>后两位为状态(10)</strong></li></ul><p><img src="/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/20200608145101.png" alt="img" style="zoom:75%;"></p><ul><li>如果开启了偏向锁（默认开启），在创建对象时，对象的Mark Word后三位应该是101</li><li>但是偏向锁默认是<strong>有延迟</strong>的，不会再程序一启动就生效，而是会在程序运行一段时间（几秒之后），才会对创建的对象设置为偏向状态</li><li>如果没有开启偏向锁，对象的Mark Word后三位应该是001</li></ul><h6 id="撤销偏向"><a href="#撤销偏向" class="headerlink" title="撤销偏向"></a>撤销偏向</h6><p>以下几种情况会使对象的偏向锁失效</p><ul><li>调用对象的hashCode方法</li><li>多个线程使用该对象</li><li><strong>调用了wait/notify方法</strong>（调用wait方法会导致锁膨胀而使用<strong>重量级锁</strong>）</li></ul><h6 id="批量重偏向"><a href="#批量重偏向" class="headerlink" title="批量重偏向"></a>批量重偏向</h6><ul><li>如果对象虽然被多个线程访问，但是线程间不存在竞争，这时偏向T1的对象仍有机会重新偏向T2<ul><li>重偏向会重置Thread ID</li></ul></li><li>当撤销超过20次后（超过阈值），JVM会觉得是不是偏向错了，这时会在给对象加锁时，重新偏向至加锁线程。</li></ul><h6 id="批量撤销"><a href="#批量撤销" class="headerlink" title="批量撤销"></a>批量撤销</h6><p>当撤销偏向锁的阈值超过40以后，就会将<strong>整个类的对象都改为不可偏向的</strong></p><h4 id="3-5-Wait-Notify"><a href="#3-5-Wait-Notify" class="headerlink" title="3.5 Wait / Notify"></a>3.5 Wait / Notify</h4><p><img src="/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/20200608144917.png" alt="20200608144917" style="zoom:75%;"></p><ul><li><p>Owner线程发现执行条件不满足，锁对象调用<code>wait()</code>方法（obj.wait），就会使当前线程进入WaitSet中，变为<code>WAITING</code>状态。</p></li><li><p>处于<code>BLOCKED</code>和<code>WAITING</code>状态的线程都为阻塞</p><p>状态，CPU都不会分给他们时间片。但是有所区别：</p><ul><li><strong><code>BLOCKED</code>状态的线程是在竞争对象</strong>时，发现Monitor的Owner已经是别的线程了，此时就会进入EntryList中，并处于BLOCKED状态</li><li><strong><code>WAITING</code>状态的线程是获得了对象的锁</strong>，但是自身因为某些原因需要进入阻塞状态时，锁对象调用了<code>wait()</code>方法而进入了WaitSet中，处于<code>WAITING</code>状态</li></ul></li><li><p>BLOCKED状态的线程会在锁被释放的时候被唤醒，但是处于<code>WAITING</code>状态的线程只有被锁对象调用了<code>notify()</code>或<code>notifyAll()</code>方法(obj.notify/obj.notifyAll)，才会被唤醒。</p></li></ul><h5 id="3-5-1-API介绍"><a href="#3-5-1-API介绍" class="headerlink" title="3.5.1 API介绍"></a>3.5.1 API介绍</h5><ol><li><code>obj.wait()</code>：让进入Monitor的线程到waitSet等待</li><li><code>obj.wait(long timeout)</code> 让进入obj监视器的线程到waitSet<strong>等待 timeout时间长度</strong>，继续执行</li><li><code>obj.notify()</code>：在object上正在waitSet等待的线程中<strong>挑一个</strong>唤醒</li><li><code>obj.notifyAll()</code>：在object上正在waitSet等待的线程<strong>全部</strong>唤醒</li></ol><p>注意⚠️：他们都是线程之间进行协作的手段，都属于Object对象的方法。<strong>必须获得此对象的锁</strong>，才能调用这几个方法。<strong>只有当对象被锁以后，才能调用wait和notify方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span> ();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span> (() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.wait(); <span class="comment">// 让线程t1在lock上一直等待下去</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span> (() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.wait(); <span class="comment">// 让线程t2在lock上一直等待下去</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123; <span class="comment">// 主线程</span></span><br><span class="line">        lock.notify(); <span class="comment">// 随机唤醒一个</span></span><br><span class="line">        lock.notifyAll(); <span class="comment">// 唤醒所有</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-5-2-wait-和sleep-的区别"><a href="#3-5-2-wait-和sleep-的区别" class="headerlink" title="3.5.2 wait() 和sleep()的区别"></a>3.5.2 wait() 和sleep()的区别</h5><ul><li><p>不同点：</p><ol><li>从API角度：sleep是Thread的静态方法，wait是所有对象（Object）的方法</li><li>sleep不用与synchronized一起用，wait需要与synchronized一起用</li><li>sleep<strong>不会释放锁</strong>，wait在等待时<strong>会释放锁</strong></li></ol></li><li><p>相同点：</p><ol><li>进入的线程状态都是TIMED_WAITING</li></ol></li></ul><p>为了解决wait的虚假唤醒，代码结构如下：(while)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">   <span class="keyword">while</span> (条件不成立) &#123;</span><br><span class="line">       lock.wait();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个线程</span></span><br><span class="line"><span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">    lock.notify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestCorrectPosture&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCorrectPostureStep4</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasCigarette</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasTakeout</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">                <span class="keyword">while</span> (!hasCigarette) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        room.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">                <span class="keyword">if</span> (hasCigarette) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没干成活...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                log.debug(<span class="string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);</span><br><span class="line">                <span class="keyword">while</span> (!hasTakeout) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没外卖，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        room.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);</span><br><span class="line">                <span class="keyword">if</span> (hasTakeout) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没干成活...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小女&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                hasTakeout = <span class="literal">true</span>;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖到了噢！&quot;</span>);</span><br><span class="line">                room.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;送外卖的&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-6-同步模式-之-保护性暂停"><a href="#3-6-同步模式-之-保护性暂停" class="headerlink" title="3.6 同步模式 之 保护性暂停"></a>3.6 同步模式 之 保护性暂停</h4><p>即Guarded Suspension，用于一个线程等待另一个线程的执行结果时。如下图。</p><p><img src="/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/image-20220327195520317-8403730.png" alt="image-20220327195520317" style="zoom:67%;"></p><p>要点：</p><ul><li>有一个结果想从一个线程传递到另一个线程，可以让他们关联同一个GuardedObject</li><li>如果有结果不断的从一个结果到另一个结果，那么可以使用<strong>消息队列</strong>（见消费者/生产者）</li><li>JDK中，<code>join()</code>的实现、<code>future</code>的实现，采用的就是该模式</li><li>因为要等待另一方的结果，因此归类到该模式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="string">&quot;hello thread!&quot;</span>;</span><br><span class="line"><span class="type">Guarded</span> <span class="variable">guarded</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Guarded</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// thread 1</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;想要得到结果&quot;</span>);</span><br><span class="line"><span class="keyword">synchronized</span> (guarded) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;结果是：&quot;</span>+guarded.getResponse());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;得到结果&quot;</span>);</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//thread 2</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;设置结果&quot;</span>);</span><br><span class="line"><span class="keyword">synchronized</span> (guarded) &#123;</span><br><span class="line">guarded.setResponse(hello);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Guarded</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 要返回的结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Object response;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//优雅地使用wait/notify</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getResponse</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//如果返回结果为空就一直等待，避免虚假唤醒</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line"><span class="keyword">while</span>(response == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.wait();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setResponse</span><span class="params">(Object response)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.response = response;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line"><span class="comment">//唤醒休眠的线程</span></span><br><span class="line"><span class="built_in">this</span>.notifyAll();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Guarded&#123;&quot;</span> +</span><br><span class="line"><span class="string">&quot;response=&quot;</span> + response +</span><br><span class="line"><span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>带超时判断的暂停</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改上面代码块中的 getResponse() 方法</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getResponse</span><span class="params">(<span class="type">long</span> time)</span> &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line"><span class="comment">//获取开始时间</span></span><br><span class="line"><span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="comment">//用于保存已经等待了的时间</span></span><br><span class="line"><span class="type">long</span> <span class="variable">passedTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(response == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//看经过的时间-开始时间是否超过了指定时间</span></span><br><span class="line"><span class="type">long</span> <span class="variable">waitTime</span> <span class="operator">=</span> time -passedTime;</span><br><span class="line"><span class="keyword">if</span>(waitTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">//等待剩余时间</span></span><br><span class="line"><span class="built_in">this</span>.wait(waitTime);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取当前时间</span></span><br><span class="line">passedTime = System.currentTimeMillis()-currentTime</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-6-1-join-：使用保护性暂停模式"><a href="#3-6-1-join-：使用保护性暂停模式" class="headerlink" title="3.6.1 join()：使用保护性暂停模式"></a>3.6.1 join()：使用保护性暂停模式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis - now;</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay);</span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="3-6-2-扩展-Future"><a href="#3-6-2-扩展-Future" class="headerlink" title="3.6.2 扩展 - Future"></a>3.6.2 扩展 - Future</h5><p>图中的Future就好比居民楼一楼的信箱（每个信箱都有自己的编号），左边的t0，t2，t4就好比等待邮件的居民，右侧的t1，t3，t5就好比邮递员。</p><p>如果需要再多个雷之间使用GuardedObject对象，作为参数传递不是很方便，因此设计一个用来解耦的中间类，这样不仅可以解耦【结果等待者】和【结果生产者】，还能够同时支持多个任务的处理。</p><p><img src="/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/image-20220327202425832-8405470.png" alt="image-20220327202425832" style="zoom:67%;"></p><h4 id="3-7-异步模式-之-生产者-消费者"><a href="#3-7-异步模式-之-生产者-消费者" class="headerlink" title="3.7 异步模式 之 生产者/消费者"></a>3.7 异步模式 之 生产者/消费者</h4><h5 id="3-7-1-要点"><a href="#3-7-1-要点" class="headerlink" title="3.7.1 要点"></a>3.7.1 要点</h5><ul><li>与前面的保护性暂停中的 Guardobject 不同，不需要产生结果和消费结果的线程一一对应</li><li>消费队列可以用来平衡生产和消费的线程资源</li><li>生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据</li><li>消息队列是有容量限制的，满时不会再加入数据（生产者阻塞），空时不会再消耗数据（消费者阻塞）</li><li>JDK 中各种阻塞队列，采用的就是这种模式</li></ul><p><img src="/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/image-20220327204404520-8406649.png" alt="image-20220327204404520"></p><p>如上图所示，左边的三个线程是生产者，右边的是消费者。</p><h5 id="3-7-2-实现"><a href="#3-7-2-实现" class="headerlink" title="3.7.2 实现"></a>3.7.2 实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MessageQueue</span> &#123;</span><br><span class="line">  <span class="comment">// 消息的队列集合</span></span><br><span class="line">  <span class="keyword">private</span> LinkedList&lt;Message&gt;list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">  <span class="comment">// 队列容量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> capcity;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Message <span class="title function_">take</span><span class="params">()</span> &#123; <span class="comment">// 取消息</span></span><br><span class="line">  <span class="comment">// 检查队列是否为空</span></span><br><span class="line">    <span class="keyword">synchronized</span>(list)&#123;</span><br><span class="line">      <span class="keyword">while</span>(list.isEmply())&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;消息队列为空，消费者等待\n&quot;</span>);</span><br><span class="line">          list.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 从队列头获取消息并返回</span></span><br><span class="line">      <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> list.removeFrist();</span><br><span class="line">      System.out.println(<span class="string">&quot;已经消费一个消息\n&quot;</span> +message);</span><br><span class="line">      list.notifyAll();</span><br><span class="line">      <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Message message)</span> &#123; <span class="comment">// 存消息</span></span><br><span class="line">    <span class="comment">// 检查队列是否已满</span></span><br><span class="line">    <span class="keyword">synchronized</span>(list)&#123;</span><br><span class="line">      <span class="keyword">while</span>(list.size() == capcity) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;消息队列已满，生产者等待\n&quot;</span>);</span><br><span class="line">          list.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将消息加入队列尾部</span></span><br><span class="line">      list.addLast(message);</span><br><span class="line">      System.out.println(<span class="string">&quot;已经生产了一个消息：\n&quot;</span> +message);</span><br><span class="line">      list.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">  <span class="keyword">private</span> Object value;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Message</span> <span class="params">(<span class="type">int</span> id, Object value)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.id;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Message: id:&quot;</span>+id+<span class="string">&quot;, value:&quot;</span>+value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(<span class="number">2</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">      queue.put(<span class="keyword">new</span> <span class="title class_">Message</span>(id, <span class="string">&quot;value&quot;</span>+id));</span><br><span class="line">    &#125;, <span class="string">&quot;生产者&quot;</span>+i).start();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">      <span class="type">Message</span> <span class="variable">massage</span> <span class="operator">=</span> queue.take();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="string">&quot;消费者&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-8-Park-amp-Unpark"><a href="#3-8-Park-amp-Unpark" class="headerlink" title="3.8 Park &amp; Unpark"></a>3.8 Park &amp; Unpark</h4><h5 id="3-8-1-基本使用"><a href="#3-8-1-基本使用" class="headerlink" title="3.8.1 基本使用"></a>3.8.1 基本使用</h5><p><strong>park/unpark都是LockSupport类中的的方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暂停线程运行</span></span><br><span class="line">LockSupport.park;</span><br><span class="line"></span><br><span class="line"><span class="comment">//恢复线程运行</span></span><br><span class="line">LockSupport.unpark(thread);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;park&quot;</span>);</span><br><span class="line">      <span class="comment">//暂停线程运行</span></span><br><span class="line">LockSupport.park();</span><br><span class="line">System.out.println(<span class="string">&quot;resume&quot;</span>);</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">thread.start();</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;unpark&quot;</span>);</span><br><span class="line">    <span class="comment">//恢复线程运行</span></span><br><span class="line">LockSupport.unpark(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-8-2-特点"><a href="#3-8-2-特点" class="headerlink" title="3.8.2 特点"></a>3.8.2 特点</h5><p><strong>与wait/notify的区别</strong></p><ul><li>wait，notify 和 notifyAll 必须配合<strong>Object Monitor</strong>一起使用，而park，unpark不必</li><li>park ，unpark 是以<strong>线程为单位</strong>来<strong>【阻塞】</strong>和<strong>【唤醒】</strong>线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么【精确】</li><li>park &amp; unpark 可以<strong>先 unpark</strong>，而 wait &amp; notify 不能先 notify</li><li><strong>park不会释放锁</strong>，而wait会释放锁</li></ul><h5 id="3-8-3-原理"><a href="#3-8-3-原理" class="headerlink" title="3.8.3 原理"></a>3.8.3 原理</h5><p>每个线程都有一个自己的<strong>Park对象</strong>，并且该对象<code>_counter</code>,  <code>_cond</code>, <code>_mutex</code>组成</p><ul><li><p>先调用park再调用unpark时</p><ol><li>先调用park<ul><li>线程运行时，会将Park对象中<code>_counter</code>的值设为0；</li><li>调用park时，会先查看<code>_counter</code>的值是否为0，如果为0，则将线程放入阻塞队列<code>_cond</code>中</li><li>放入阻塞队列中后，会<strong>再次</strong>将<code>_counter</code>设置为0</li></ul></li></ol><p><img src="/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/20200608145250.png" alt="20200608145250" style="zoom:70%;"></p><ol><li>然后调用unpark<ul><li>调用unpark方法后，会将<code>_counter</code>的值设置为1</li><li>去唤醒阻塞队列<code>_cond</code>中的线程</li><li>线程继续运行并将<code>_counter</code>的值设为0</li></ul></li></ol><p><img src="/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/20200608145303.png" alt="20200608145303" style="zoom:60%;"></p></li><li><p>先调用unpark，再调用park</p><ol><li><p>调用unpark</p><ul><li>会将<code>_counter</code>设置为1（运行时0）</li></ul></li><li><p>调用park方法</p><ul><li>查看<code>_counter</code>是否为0</li><li>因为unpark已经把<code>_counter</code>设置为1，所以此时将<code>_counter</code>设置为0，但<strong>不放入</strong>阻塞队列<code>_cond</code>中</li></ul></li></ol></li></ul><p><img src="/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/20200608145313.png" alt="20200608145313" style="zoom:60%;"></p><h4 id="3-9-线程状态转换"><a href="#3-9-线程状态转换" class="headerlink" title="3.9 线程状态转换"></a>3.9 线程状态转换</h4><p><img src="/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/20200608144621-8409900.png" alt="20200608144621" style="zoom:75%;"></p><h5 id="情况一：NEW-gt-RUNNABLE"><a href="#情况一：NEW-gt-RUNNABLE" class="headerlink" title="情况一：NEW --&gt; RUNNABLE"></a>情况一：<code>NEW --&gt; RUNNABLE</code></h5><ul><li>当调用了<code>t.start()</code>方法时，由<code>NEW</code> –&gt; <code>RUNNABLE</code></li></ul><h5 id="情况二：RUNNABLE-lt-gt-WAITING"><a href="#情况二：RUNNABLE-lt-gt-WAITING" class="headerlink" title="情况二：RUNNABLE &lt;--&gt; WAITING"></a>情况二：<code>RUNNABLE &lt;--&gt; WAITING</code></h5><ul><li>当调用了t 线程用 <code>synchronized(obj)</code> 获取了对象锁后<ul><li>调用 <code>obj.wait()</code> 方法时，t 线程从 <code>RUNNABLE</code> –&gt;<code>WAITING</code></li><li>调用 <code>obj.notify()</code> ， <code>obj.notifyAll()</code> ，<code>t.interrupt()</code> 时<ul><li>竞争锁成功，t 线程从 <code>WAITING</code> –&gt; <code>RUNNABLE</code></li><li>竞争锁失败，t 线程从 <code>WAITING</code> –&gt; <code>BLOCKED</code></li></ul></li></ul></li></ul><h5 id="情况三：RUNNABLE-lt-gt-WAITING"><a href="#情况三：RUNNABLE-lt-gt-WAITING" class="headerlink" title="情况三：RUNNABLE &lt;--&gt; WAITING"></a>情况三：<code>RUNNABLE &lt;--&gt; WAITING</code></h5><ul><li><p>当前线程</p><p>调用 <code>t.join()</code> 方法时，当前线程从 <code>RUNNABLE</code> –&gt; <code>WAITING</code></p><ul><li>注意是<strong>当前线程</strong>在t 线程对象的监视器上等待</li></ul></li><li><p>t 线程<strong>运行结束</strong>，或调用了<strong>当前线程</strong>的 <code>interrupt()</code> 时，当前线程从 <code>WAITING</code> –&gt; <code>RUNNABLE</code></p></li></ul><h5 id="情况四：-RUNNABLE-lt-gt-WAITING"><a href="#情况四：-RUNNABLE-lt-gt-WAITING" class="headerlink" title="情况四： RUNNABLE &lt;--&gt; WAITING"></a>情况四： <code>RUNNABLE &lt;--&gt; WAITING</code></h5><ul><li>当前线程调用 <code>LockSupport.park()</code> 方法会让当前线程从 <code>RUNNABLE</code> –&gt; <code>WAITING</code></li><li>调用 <code>LockSupport.unpark(目标线程)</code> 或调用了线程 的 <code>interrupt()</code> ，会让目标线程从 <code>WAITING</code> –&gt; <code>RUNNABLE</code></li></ul><h5 id="情况五：-RUNNABLE-lt-gt-TIMED-WAITING"><a href="#情况五：-RUNNABLE-lt-gt-TIMED-WAITING" class="headerlink" title="情况五： RUNNABLE &lt;--&gt; TIMED_WAITING"></a>情况五： <code>RUNNABLE &lt;--&gt; TIMED_WAITING</code></h5><p>t 线程用 <code>synchronized(obj)</code> 获取了对象锁后</p><ul><li>调用 <code>obj.wait(long n)</code> 方法时，t 线程从 <code>RUNNABLE</code> –&gt; <code>TIMED_WAITING</code></li><li>t 线程等待时间超过了 n 毫秒，或调用 <code>obj.notify()</code>， <code>obj.notifyAll()</code> ，<code>t.interrupt()</code> 时<ul><li>竞争锁成功，t 线程从 <code>TIMED_WAITING</code> –&gt; <code>RUNNABLE</code></li><li>竞争锁失败，t 线程从 <code>TIMED_WAITING</code> –&gt; <code>BLOCKED</code></li></ul></li></ul><h5 id="情况六：RUNNABLE-lt-gt-TIMED-WAITING"><a href="#情况六：RUNNABLE-lt-gt-TIMED-WAITING" class="headerlink" title="情况六：RUNNABLE &lt;--&gt; TIMED_WAITING"></a>情况六：<code>RUNNABLE &lt;--&gt; TIMED_WAITING</code></h5><ul><li>当前线程调用 <code>t.join(long n)</code> 方法时，当前线程从 <code>RUNNABLE</code> –&gt; <code>TIMED_WAITING</code><ul><li>注意是当前线程在t 线程对象的监视器上等待</li></ul></li><li>当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 <code>interrupt()</code> 时，当前线程从 <code>TIMED_WAITING</code> –&gt; <code>RUNNABLE</code></li></ul><h5 id="情况七：RUNNABLE-lt-gt-TIMED-WAITING"><a href="#情况七：RUNNABLE-lt-gt-TIMED-WAITING" class="headerlink" title="情况七：RUNNABLE &lt;--&gt; TIMED_WAITING"></a>情况七：<code>RUNNABLE &lt;--&gt; TIMED_WAITING</code></h5><ul><li>当前线程调用 <code>Thread.sleep(long n)</code>，当前线程从 <code>RUNNABLE</code> –&gt; <code>TIMED_WAITING</code></li><li>当前线程等待时间超过了 n 毫秒，当前线程从 <code>TIMED_WAITING</code> –&gt; <code>RUNNABLE</code></li></ul><h5 id="情况八：RUNNABLE-lt-gt-TIMED-WAITING"><a href="#情况八：RUNNABLE-lt-gt-TIMED-WAITING" class="headerlink" title="情况八：RUNNABLE &lt;--&gt; TIMED_WAITING"></a>情况八：<code>RUNNABLE &lt;--&gt; TIMED_WAITING</code></h5><ul><li>当前线程调用 <code>LockSupport.parkNanos(long nanos)</code> 或 <code>LockSupport.parkUntil(long millis)</code> 时，当前线 程从 <code>RUNNABLE</code>–&gt; <code>TIMED_WAITING</code></li><li>调用 <code>LockSupport.unpark(目标线程)</code> 或调用了线程 的 <code>interrupt()</code> ，或是等待超时，会让目标线程从 <code>TIMED_WAITING</code> –&gt; <code>RUNNABLE</code></li></ul><h5 id="情况九：RUNNABLE-lt-gt-BLOCKED"><a href="#情况九：RUNNABLE-lt-gt-BLOCKED" class="headerlink" title="情况九：RUNNABLE &lt;--&gt; BLOCKED"></a>情况九：<code>RUNNABLE &lt;--&gt; BLOCKED</code></h5><ul><li>t 线程用 <code>synchronized(obj)</code> 获取了对象锁时如果<strong>竞争失败</strong>，从 <code>RUNNABLE</code> –&gt; <code>BLOCKED</code></li><li>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 <code>BLOCKED</code> 的线程重新竞争，如果其中 t 线程竞争 成功，从 <code>BLOCKED</code> –&gt; <code>RUNNABLE</code> ，其它<strong>失败</strong>的线程仍然 <code>BLOCKED</code></li></ul><h5 id="情况十：-RUNNABLE-lt-gt-TERMINATED"><a href="#情况十：-RUNNABLE-lt-gt-TERMINATED" class="headerlink" title="情况十： RUNNABLE &lt;--&gt; TERMINATED"></a>情况十： <code>RUNNABLE &lt;--&gt; TERMINATED</code></h5><p>当前线<strong>程所有代码运行完毕</strong>，进入 <code>TERMINATED</code></p><h4 id="3-10-多把锁"><a href="#3-10-多把锁" class="headerlink" title="3.10 多把锁"></a>3.10 多把锁</h4><p><strong>将锁的粒度细分</strong></p><p>例如一套房子中有多个房间，书房和卧室的功能毫不相干。所以我们可以把锁分别加在卧室和书房上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BigRoom</span> &#123;</span><br><span class="line">    <span class="comment">//额外创建对象来作为锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">studyRoom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">bedRoom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-11-线程的活跃性"><a href="#3-11-线程的活跃性" class="headerlink" title="3.11 线程的活跃性"></a>3.11 线程的活跃性</h4><h5 id="3-11-1-死锁"><a href="#3-11-1-死锁" class="headerlink" title="3.11.1 死锁"></a>3.11.1 死锁</h5><p>有这样的情况：一个线程需要<strong>同时获取多把锁</strong>，这时就容易发生死锁</p><p>如：</p><ul><li><code>t1线程</code> 获得 <code>A对象锁</code>，接下来想获取 <code>B对象的锁</code></li><li><code>t2线程</code> 获得 <code>B对象锁</code>，接下来想获取 <code>A对象的锁</code></li></ul><p>在并发环境下，各进程因竞争资源而造成的一种<strong>互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象</strong>，就是死锁。</p><p>每个人都占有一个资源，同时又在等待另一个人手里的资源。发生“死锁”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">Object</span> <span class="variable">A</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">final</span> <span class="type">Object</span> <span class="variable">B</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;TODO&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;TODO&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="发生死锁的必要条件"><a href="#发生死锁的必要条件" class="headerlink" title="发生死锁的必要条件"></a>发生死锁的必要条件</h6><ul><li><p><strong>死锁产生的必要条件：</strong></p><ol><li><p>互斥条件：只有对必须互斥使用的资源的争抢才会产生死锁。</p></li><li><p>不可剥夺条件：进程所获得的资源在未使用完之前，不能<strong>由其他进程强行夺走</strong></p></li><li><p>请求和保持条件：进程已经<strong>保持了至少一个资源</strong>，但<strong>又提出了新的资源请求</strong>，而该资源又被其他进程占有，此时请求进程被阻塞，但又<strong>对自己已有的资源保持不放</strong></p></li><li><p>循环等待条件：存在一种进程</p><p>资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</p><ul><li><strong>死锁 -&gt; 一定有循环等待； 循环等待 不一定 发生死锁</strong></li></ul></li></ol></li><li><p><strong>预防死锁：</strong> 破坏<strong>死锁产生的必要条件</strong>，即可预防死锁。</p></li></ul><h6 id="避免死锁的方法"><a href="#避免死锁的方法" class="headerlink" title="避免死锁的方法"></a>避免死锁的方法</h6><p>在线程使用锁对象时<strong>，顺序加锁</strong>即可避免死锁。线程1按顺序获得A，B对象的锁：</p><pre class="mermaid">sequenceDiagram    participant t1 as 线程1    participant t2 as 线程2    participant obj1 as 对象1    participant obj2 as 对象2    t1 -->> obj1 : 尝试获取锁    Note over t1,obj1 :拥有锁    t2 --x obj1 : 尝试获取锁（失败）    t2 -->> obj1 : 阻塞    t1 -->> obj2 : 尝试获取锁    Note over t1,obj2 :拥有锁</pre><h5 id="3-11-2-活锁"><a href="#3-11-2-活锁" class="headerlink" title="3.11.2 活锁"></a>3.11.2 活锁</h5><p>活锁出现在两个线程<strong>互相改变对方的结束条件</strong>，后谁也无法结束。</p><h6 id="避免活锁的方法"><a href="#避免活锁的方法" class="headerlink" title="避免活锁的方法"></a>避免活锁的方法</h6><p>在线程执行时，中途给予<strong>不同的间隔时间</strong>即可。</p><h6 id="死锁与活锁的区别"><a href="#死锁与活锁的区别" class="headerlink" title="死锁与活锁的区别"></a>死锁与活锁的区别</h6><ul><li>死锁是因为线程互相持有对象想要的锁，并且都不释放，最后到时<strong>线程阻塞</strong>，<strong>停止运行</strong>的现象。</li><li>活锁是因为线程间修改了对方的结束条件，而导致代码<strong>一直在运行</strong>，却一直<strong>运行不完</strong>的现象。</li></ul><h5 id="3-11-3-饥饿"><a href="#3-11-3-饥饿" class="headerlink" title="3.11.3 饥饿"></a>3.11.3 饥饿</h5><p>某些线程因为优先级太低，导致一直无法获得资源的现象。</p><p>为了避免死锁而使用顺序加锁时，可能会出现饥饿现象</p><h5 id="3-11-4-死锁、饥饿和死循环的异同点"><a href="#3-11-4-死锁、饥饿和死循环的异同点" class="headerlink" title="3.11.4 死锁、饥饿和死循环的异同点"></a>3.11.4 死锁、饥饿和死循环的异同点</h5><div class="table-container"><table><thead><tr><th></th><th>共同点</th><th>区别</th></tr></thead><tbody><tr><td>死锁</td><td>都是进程无法顺利向前推进的现象</td><td>死锁一定是“循环等待对方手里的资源”导致的，因此如果有死锁现象，那<strong>至少有两个或两个以上的进程同时发生死锁</strong>。另外，发生死锁的进程一定处于阻塞态</td></tr><tr><td>饥饿</td><td><strong>可能只有一个进程发生饥饿</strong>。发生饥饿的进程可能是阻塞态（如长期得不到需要的IO设备），也可能是就绪态（长期得不到处理机）</td><td></td></tr><tr><td>死循环</td><td>可能只有一个进程发生死循环。死循环可以是运行态，只不过无法继续推进。死锁和饥饿是由于操作系统分配资源的策略不合理导致的，而死循环是由代码逻辑错误导致的。<strong>死锁和饥饿是管理者(操作系统)的问题，死循环是被管理者的问题。</strong></td></tr></tbody></table></div><h5 id="3-11-5-预防死锁-静态策略"><a href="#3-11-5-预防死锁-静态策略" class="headerlink" title="3.11.5 预防死锁 - 静态策略"></a>3.11.5 预防死锁 - 静态策略</h5><h6 id="3-11-5-1-资源分配图（Graphe-d’allocation）"><a href="#3-11-5-1-资源分配图（Graphe-d’allocation）" class="headerlink" title="3.11.5.1 资源分配图（Graphe d’allocation）"></a>3.11.5.1 资源分配图（Graphe d’allocation）</h6><ul><li>两种结点<ul><li>进程结点：对应一个进程</li><li>资源结点：对应一类资源，一类资源可能有多个。（一般用矩形代表资源结点，矩形中的小圆圈代表该类资源的数量）</li></ul></li><li>两种边：<ul><li>进程结点 -&gt; 资源结点：<strong>请求边</strong>，表示进程<strong>想申请几个资源</strong>（一条边代表一个）</li><li>资源结点 -&gt; 进程结点：<strong>分配边</strong>，表示<strong>已经为进程分配了几个资源</strong></li></ul></li></ul><pre class="mermaid">graph LR  A(P1) --> B  B[R2:2] --> C  C(P2) --> D  D[R1:3] --> C  D --> A  D --> A</pre><p>如果系统中剩余的可用资源数足够满足进程的需求，那么这个进程暂时是不会阻塞的，可以顺利地执行下去。</p><pre class="mermaid">graph LR;  A(P1)   B[R2:2] --> C  C(P2) --> D  D[R1:3] --> C</pre><p>如果这个进程执行结束了把资源归还系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去。<br>相应的，这些被激活的进程执行完了之后又会归还一些资源，这样可能又会激活另外一些阻塞的进程….</p><pre class="mermaid">graph TB;  A(P1)   B[R2:2]  C(P2)  D[R1:3]</pre><p>如果按上述过程分析，最终<strong>能消除所有边</strong>，就称这个图是<strong>可完全简化的</strong>。此时一定<strong>没有发生死锁</strong>（相当于能找到一个安全序列）</p><p>另一个例子：</p><pre class="mermaid">graph LR;  A(P1)  B[R2:2]  C(P2)  D[R1:3]  E(P3)  E --> B  A --> B  A --> B  B --> C  C --> D  D --> C  D --> A  D --> A</pre><p>如果最终<strong>不能消除所有边</strong>，那么此时就是<strong>发生了死锁</strong>。 <strong>最终没有被消除的边所连的进程就发生了死锁</strong>。</p><h6 id="3-11-5-2-死锁的解除"><a href="#3-11-5-2-死锁的解除" class="headerlink" title="3.11.5.2 死锁的解除"></a>3.11.5.2 死锁的解除</h6><p>用死锁检测算法化简资源分配图后，还连着边的那此进程就是死锁进程。 解除死锁的主要方法有：</p><ol><li>资源剥夺法。挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</li><li>撤销进程法（或称终止进程法）。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源，这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，己经接近结束了，旦被终止可谓功亏一篑，以后还得从头再来。</li><li>进程回退法。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统耍记录进程的历史信息，设置还原点</li></ol><h5 id="3-11-6-避免死锁-动态策略"><a href="#3-11-6-避免死锁-动态策略" class="headerlink" title="3.11.6 避免死锁 - 动态策略"></a>3.11.6 避免死锁 - 动态策略</h5><h6 id="3-11-6-1-安全序列"><a href="#3-11-6-1-安全序列" class="headerlink" title="3.11.6.1 安全序列"></a>3.11.6.1 安全序列</h6><p>所谓<strong>安全序列</strong>，就是值如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是<strong>安全状态</strong>。当然，<strong>安全序列可能有多个</strong>。<br>如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了<strong>不安全状态</strong>。这就意味着之后<strong>可能</strong>所有进程都无法顺利的进行下去。当然，如果有进程提前归还了一些资源，那系统也<strong>有可能重新回到安全状态</strong>，不过我们在分配资源之前总是要考虑到最坏的情况。</p><p>因此可以<strong>在资源分配之前前预判这次分配是否会导致系统进入不安全状态</strong>，一次决定是否答应资源分配的请求。这也是“<strong>银行家算法</strong>”的核心思想。</p><h6 id="3-11-6-2-银行家算法"><a href="#3-11-6-2-银行家算法" class="headerlink" title="3.11.6.2 银行家算法"></a>3.11.6.2 银行家算法</h6><p>假设系统中有<code>n</code>个进程，<code>m</code>种资源每个进程在运行前先声明对各种资源的最大需求数，则可用一个<code>n*m</code>的矩阵（可用二维数组实现） 表示所有进程对各种资源的最大需求数。不妨称为<strong>最大需求矩阵</strong> <code>Max</code>， <code>Max[i,j] = K</code> 表示进程<code>P_i</code>最多需要K个资源<code>R_j</code>。同理，系统可以用一个<code>n*m</code> 的<strong>分配矩阵 Allocation</strong> 表示对所有进程的资源分配情况。<code>Max - Allocation = Need</code> 矩阵，表示各进程最多还需要多少各类资源。<br>另外，还要用一个长度为<code>m</code>的一维数组 <code>Available(...)</code> 表示当前系统中<strong>还有多少可用资源</strong><br>某进程pi向系统申请资源，可用1个长度为<code>m</code>的一维数组 <code>Request(...)</code>， 表示<strong>本次申请的各种资源量</strong>。</p><div class="table-container"><table><thead><tr><th>进程</th><th>最大需求(Max 矩阵)</th><th>已分配(Allocation 矩阵)</th><th>最多还需要(Need 矩阵)</th></tr></thead><tbody><tr><td>P0</td><td>(7,5,3)</td><td>(0,1,0)</td><td>(7,4,3)</td></tr><tr><td>P1</td><td>(3,2,2)</td><td>(2,0,0)</td><td>(1,2,2)</td></tr><tr><td>P2</td><td>(9,0,2)</td><td>(3,0,2)</td><td>(6,0,0)</td></tr><tr><td>P3</td><td>(2,2,2)</td><td>(2,1,1)</td><td>(0,1,1)</td></tr><tr><td>P4</td><td>(4,3,3)</td><td>(0,0,2)</td><td>(4,3,1)</td></tr></tbody></table></div><p>可用<strong>银行家算法</strong>预判本次分配是否会导致系统进入不安全状态：</p><ol><li>如果 <code>Request_i[j] &lt; Need[i,j] (0 &lt;= j &lt; m)</code>便转向②：否则认为出错</li><li>如果 <code>Request_i[j] &lt; Available[i,j] (0 &lt;= j &lt; m)</code>，便转向③：否则表示尚无足够资源，p必须等待</li><li>系统试探着把资源分配给进程Pi，并修改相应的数据（并非真的分配，修改数值只是为了做预判)：<ul><li><code>Available = Available - Request_j;</code></li><li><code>Allocation[i,j] = Allocation[i,j] + Request_i[j];</code></li><li><code>Need[i,j] = Need[i,j] - Request_i[j]</code></li></ul></li><li>操作系统执行<strong>安全性算法</strong>，检查此次资源分配后，系统是<strong>否处于安全状态</strong>。若安全，才正式分配;否则，恢复相应数据，让进程阻塞等待。</li></ol><p>银行家算法步骤：</p><ol><li>检查此次申请是否超过了之前声明的最大需求数</li><li>检查此时系统剩余的可用资源是否还能满足这次请求</li><li>试探着分配，更改各数据结构</li><li>用安全性算法检查此次分配是否会导致系统进入不安全状态</li></ol><p>安全性算法步骤： 检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该讲程持有的资源全部回收。 不断重复上述过程，看最终是否能让所有进程都加入安全序列。</p><h4 id="3-12-ReentrantLock-可重入锁"><a href="#3-12-ReentrantLock-可重入锁" class="headerlink" title="3.12 ReentrantLock (可重入锁)"></a>3.12 ReentrantLock (可重入锁)</h4><p><strong>和synchronized相比具有的的特点</strong></p><ul><li>可被别的线程中断</li><li>可以设置超时时间</li><li>可以设置为公平锁 (先到先得)</li><li>支持多个条件变量( 具有<strong>多个</strong>waitSet)</li></ul><h5 id="3-12-1-基本语法"><a href="#3-12-1-基本语法" class="headerlink" title="3.12.1 基本语法"></a>3.12.1 基本语法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取ReentrantLock对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//需要执行的代码</span></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//释放锁</span></span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-12-2-可重入"><a href="#3-12-2-可重入" class="headerlink" title="3.12.2 可重入"></a>3.12.2 可重入</h5><ul><li>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁</li><li>如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">    method1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123; </span><br><span class="line">    lock.lock(); <span class="comment">// 锁的重入</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;execute method1&quot;</span>); </span><br><span class="line">        method2(); <span class="comment">// 调用method2</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">finally</span> &#123; </span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123; </span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;execute method2&quot;</span>); </span><br><span class="line">        method3(); <span class="comment">// 调用method3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; </span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span> &#123; </span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;execute method3&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; </span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">17:59:11.862 [main] c.TestReentrant - execute method1</span><br><span class="line">17:59:11.865 [main] c.TestReentrant - execute method2</span><br><span class="line">17:59:11.865 [main] c.TestReentrant - execute method3</span><br></pre></td></tr></table></figure><h5 id="3-12-3-可打断"><a href="#3-12-3-可打断" class="headerlink" title="3.12.3 可打断"></a>3.12.3 可打断</h5><p>被动避免死等。</p><p>如果某个线程处于阻塞状态，可以调用其interrupt方法让其停止阻塞，获得锁失败</p><p><strong>简而言之</strong>就是：处于阻塞状态的线程，被打断了就不用阻塞了，直接停止运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); </span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;启动...&quot;</span>); </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有竞争，那么此方法就会获得lock对象锁</span></span><br><span class="line">        <span class="comment">// 如果有竞争就进入阻塞队列，可以被其他进程用 interrupt 方法打断</span></span><br><span class="line">        lock.lockInterruptibly(); <span class="comment">// 可中断锁</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace(); </span><br><span class="line">        log.debug(<span class="string">&quot;等锁的过程中被打断&quot;</span>); </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获得了锁&quot;</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">lock.lock(); </span><br><span class="line">log.debug(<span class="string">&quot;获得了锁&quot;</span>); </span><br><span class="line">t1.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    t1.interrupt(); <span class="comment">// 执行中断</span></span><br><span class="line">    log.debug(<span class="string">&quot;执行打断&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">finally</span> &#123; </span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">18:02:40.520 [main] c.TestInterrupt - 获得了锁 </span><br><span class="line">18:02:40.524 [t1] c.TestInterrupt - 启动... </span><br><span class="line">18:02:41.530 [main] c.TestInterrupt - 执行打断</span><br><span class="line">java.lang.InterruptedException</span><br><span class="line">    at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchr onizer.java:898)</span><br><span class="line">    at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchron izer.java:1222)</span><br><span class="line">    at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:335) at cn.itcast.n4.reentrant.TestInterrupt.lambda$main$0(TestInterrupt.java:17)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">18:02:41.532 [t1] c.TestInterrupt - 等锁的过程中被打断</span><br></pre></td></tr></table></figure><p>注意如果是不可中断模式，那么即使使用了 <code>interrupt</code> 也不会让等待中断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;启动...&quot;</span>);</span><br><span class="line">    lock.lock(); <span class="comment">// 普通锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获得了锁&quot;</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">lock.lock(); </span><br><span class="line">log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    t1.interrupt(); <span class="comment">// 执行中断</span></span><br><span class="line">    log.debug(<span class="string">&quot;执行打断&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">finally</span> &#123; </span><br><span class="line">    log.debug(<span class="string">&quot;释放了锁&quot;</span>); </span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">18:06:56.261 [main] c.TestInterrupt - 获得了锁</span><br><span class="line">18:06:56.265 [t1] c.TestInterrupt - 启动...</span><br><span class="line">18:06:57.266 [main] c.TestInterrupt - 执行打断 // 这时 t1 并没有被真正打断, 而是仍继续等待锁</span><br><span class="line">18:06:58.267 [main] c.TestInterrupt - 释放了锁</span><br><span class="line">18:06:58.267 [t1] c.TestInterrupt - 获得了锁</span><br></pre></td></tr></table></figure><h5 id="3-12-4-锁超时"><a href="#3-12-4-锁超时" class="headerlink" title="3.12.4 锁超时"></a>3.12.4 锁超时</h5><p>主动避免死等</p><p>使用<strong>lock.tryLock</strong>方法会返回获取锁是否成功。如果成功则返回true，反之则返回false。</p><p>并且tryLock方法可以<strong>指定等待时间</strong>，参数为：<code>tryLock(long timeout, TimeUnit unit)</code>, 其中<code>timeout</code>为最长等待时间，<code>TimeUnit</code>为时间单位</p><p><strong>简而言之</strong>就是：获取失败了、获取超时了或者被打断了，不再阻塞，直接停止运行</p><p>例：不设置等待时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); </span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;启动...&quot;</span>); </span><br><span class="line">    <span class="keyword">if</span> (!lock.tryLock()) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获取立刻失败，返回&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; </span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line">log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">t1.start(); </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    sleep(<span class="number">2</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">18:15:02.918 [main] c.TestTimeout - 获得了锁</span><br><span class="line">18:15:02.921 [t1] c.TestTimeout - 启动...</span><br><span class="line">18:15:02.921 [t1] c.TestTimeout - 获取立刻失败，返回</span><br></pre></td></tr></table></figure><p>例：设置等待时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//判断获取锁是否成功，最多等待1秒</span></span><br><span class="line"><span class="keyword">if</span>(!lock.tryLock(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;获取失败&quot;</span>);</span><br><span class="line"><span class="comment">//获取失败，不再向下执行，直接返回</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="comment">//被打断，不再向下执行，直接返回</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;得到了锁&quot;</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// TODO : 临界区代码</span></span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">t1.start();</span><br><span class="line"><span class="comment">//打断等待</span></span><br><span class="line">t1.interrupt();</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-12-5-公平锁"><a href="#3-12-5-公平锁" class="headerlink" title="3.12.5 公平锁"></a>3.12.5 公平锁</h5><p>在线程获取锁失败，进入阻塞队列时，<strong>先进入</strong>的会在锁被释放后<strong>先获得</strong>锁。这样的获取方式就是<strong>公平</strong>的。但会降低并发度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认是不公平锁，需要在创建时指定为公平锁</span></span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="type">boolean</span> fair);</span><br></pre></td></tr></table></figure><h5 id="3-12-6-条件变量"><a href="#3-12-6-条件变量" class="headerlink" title="3.12.6 条件变量"></a>3.12.6 条件变量</h5><p>synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入waitSet 等待</p><p>ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持<strong>多个</strong>条件变量的，这就好比</p><ul><li>synchronized 是那些不满足条件的线程都在一间休息室等消息</li><li>而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒</li></ul><p>使用要点：</p><ul><li><code>await()</code> 前需要<strong>获得锁</strong></li><li><code>await()</code> 执行后，会释放锁，进入 conditionObject 等待</li><li>await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁</li><li>竞争 lock 锁成功后，从 await 后继续执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">// 创建新的条件变量（休息室）</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">condition1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">condition2</span> <span class="operator">=</span> lock.newCondition(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line"></span><br><span class="line">    condition1.await(); <span class="comment">// 进入“休息室”等待</span></span><br><span class="line"></span><br><span class="line">    condition1.signal(); <span class="comment">// 从“休息室”唤醒</span></span><br><span class="line"></span><br><span class="line">    condition1.signalAll();<span class="comment">// 从“休息室”唤醒所有</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestCorrectPosture&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCorrectPostureStep4</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasCigarette</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasTakeout</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">ROOM</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">  <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">waitCigaretteSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Condition</span>();</span><br><span class="line">  <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">waitTakeOutSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Condition</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            ROOM.lock();</span><br><span class="line">          <span class="keyword">try</span>&#123;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">                <span class="keyword">while</span> (!hasCigarette) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        waitCigaretteSet.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              ROOM.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            ROOM.lock();</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);</span><br><span class="line">                <span class="keyword">while</span> (!hasTakeout) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没外卖，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        waitTakeOutSet.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              ROOM.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小女&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            ROOM.lock();</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">                hasTakeout = <span class="literal">true</span>;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖到了噢！&quot;</span>);</span><br><span class="line">                waitTakeOutSet.signal();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              ROOM.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;送外卖的&quot;</span>).start();</span><br><span class="line">      </span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            ROOM.lock();</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">                hasTakeout = <span class="literal">true</span>;</span><br><span class="line">                log.debug(<span class="string">&quot;烟到了噢！&quot;</span>);</span><br><span class="line">                waitCigaretteSet.signal();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              ROOM.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;送烟的&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">15:34:20.249 c.Test24[小女] - 外卖送到没？ [false]</span><br><span class="line">15:34:20.260 c.Test24[小女] - 没外卖，先歇会！</span><br><span class="line">15:34:20.303 c.Test24[小南] - 有烟没？[false]</span><br><span class="line">15:34:20.303 c.Test24[小南] - 没烟，先歇会！</span><br><span class="line">15:34:21.238 c.Test24[小女] - 可以开始干活了</span><br><span class="line">15:34:22.241 c.Test24[小南] - 可以开始干活了</span><br></pre></td></tr></table></figure><h4 id="3-13-同步模式-之-顺序控制"><a href="#3-13-同步模式-之-顺序控制" class="headerlink" title="3.13 同步模式 之 顺序控制"></a>3.13 同步模式 之 顺序控制</h4><h5 id="3-13-1-固定运行顺序"><a href="#3-13-1-固定运行顺序" class="headerlink" title="3.13.1 固定运行顺序"></a>3.13.1 固定运行顺序</h5><p>比如先打印“2”，再打印“1”</p><h6 id="wait-notify-方法"><a href="#wait-notify-方法" class="headerlink" title="wait / notify 方法"></a><code>wait / notify 方法</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="comment">//判断先执行的内容是否执行完毕</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">Boolean</span> <span class="variable">t2Runned</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line"><span class="keyword">while</span> (!t2Runned) &#123; <span class="comment">// 判断 2 是否打印过</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">LOCK.wait();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">t2Runned = <span class="literal">true</span>;</span><br><span class="line">LOCK.notify(); <span class="comment">//执行完毕，唤醒所有等待线程</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="park-unpark方法"><a href="#park-unpark方法" class="headerlink" title="park / unpark方法"></a><code>park / unpark方法</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span> (() -&gt; &#123;</span><br><span class="line">    LockSupport.park();</span><br><span class="line">    System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">  &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">  </span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span> (() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    LockSupport.unpark(t1);</span><br><span class="line">  &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-13-2-交替输出"><a href="#3-13-2-交替输出" class="headerlink" title="3.13.2 交替输出"></a>3.13.2 交替输出</h5><p>线程 1 输出a 5次，线程2输出b 5次，线程3 输出c 5次。现在要求输出 abcabcabcabcabc 怎么实现？</p><h6 id="wait-notify-方法-1"><a href="#wait-notify-方法-1" class="headerlink" title="wait / notify 方法"></a><code>wait / notify 方法</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">输出内容等待标记下一个标记</span></span><br><span class="line"><span class="comment">a12</span></span><br><span class="line"><span class="comment">b23</span></span><br><span class="line"><span class="comment">c31</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WaitSymbol</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> flag; <span class="comment">// 等待标记</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> loopNum; <span class="comment">// 循环次数</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">WaitSymbol</span> <span class="params">(<span class="type">int</span> flag, <span class="type">int</span> loopNum)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.flag = flag;</span><br><span class="line">    <span class="built_in">this</span>.loopNum = loopNum;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str, <span class="type">int</span> waitFlag, <span class="type">int</span> nextFlag)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;loopNum; i++) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(flag != waitFlag) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(str);</span><br><span class="line">        flag = nextFlag;</span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">WaitSymbol</span> <span class="variable">ws</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitSymbol</span>(<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span> (() -&gt; &#123;</span><br><span class="line">    ws.print(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">  </span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span> (() -&gt; &#123;</span><br><span class="line">    ws.print(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">  &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">  </span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span> (() -&gt; &#123;</span><br><span class="line">    ws.print(<span class="string">&quot;c&quot;</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;, <span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abcabcabcabcabc</span><br></pre></td></tr></table></figure><h6 id="ReentrantLock-方法"><a href="#ReentrantLock-方法" class="headerlink" title="ReentrantLock 方法"></a><code>ReentrantLock 方法</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AwaitSignal</span> <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">loopNum</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">AwaitSignal</span> <span class="params">(<span class="type">int</span> loopNum)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loopNum = loopNum;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 参数1：打印内容参数2：进入哪一间休息室参数3：下一间休息室</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str, Condition current, Condition next)</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;loopNumber; i++) &#123;</span><br><span class="line">lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">current.await();</span><br><span class="line">System.out.print(str);</span><br><span class="line">next.signal();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">AwaitSignal</span> <span class="variable">awaitSignal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AwaitSignal</span>();</span><br><span class="line"><span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">conditionA</span> <span class="operator">=</span> awaitSignal.newCondition();</span><br><span class="line"><span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">conditionB</span> <span class="operator">=</span> awaitSignal.newCondition();</span><br><span class="line"><span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">conditionC</span> <span class="operator">=</span> awaitSignal.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">awaitSignal.print(<span class="string">&quot;a&quot;</span>, conditionA, conditionB);</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">awaitSignal.print(<span class="string">&quot;b&quot;</span>, conditionB, conditionC);</span><br><span class="line">&#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">awaitSignal.print(<span class="string">&quot;c&quot;</span>, conditionC, conditionA);</span><br><span class="line">&#125;, <span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">awaitSignal.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;开始...&quot;</span>);</span><br><span class="line">conditionA.signal(); <span class="comment">// 唤醒一个等待的线程</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">awaitSignal.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abcabcabcabcabc</span><br></pre></td></tr></table></figure><h6 id="park-unpark-方法"><a href="#park-unpark-方法" class="headerlink" title="park / unpark 方法"></a><code>park / unpark 方法</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ParkUnpark</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> loopNum;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ParkUnpark</span><span class="params">(<span class="type">int</span> loopNum)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loopNum = loopNum;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str, thread next)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;loopNum; i++) &#123;</span><br><span class="line">      LockSupport.park();</span><br><span class="line">      System.out.print(str);</span><br><span class="line">      LockSupport.unpark(next);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Thread t1;</span><br><span class="line"><span class="keyword">static</span> Thread t2;</span><br><span class="line"><span class="keyword">static</span> Thread t3;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">ParkUnpark</span> <span class="variable">pu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParkUnpark</span>(<span class="number">5</span>);</span><br><span class="line">  t1 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    pu.print(<span class="string">&quot;a&quot;</span>, t2);</span><br><span class="line">  &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">t2 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    pu.print(<span class="string">&quot;b&quot;</span>, t3);</span><br><span class="line">  &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">t3 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    pu.run(<span class="string">&quot;c&quot;</span>, t1);</span><br><span class="line">  &#125;, <span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line">  </span><br><span class="line">  LockSupport.unpark(t1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abcabcabcabcabc</span><br></pre></td></tr></table></figure><h4 id="3-14-经典问题：哲学家就餐问题"><a href="#3-14-经典问题：哲学家就餐问题" class="headerlink" title="3.14 经典问题：哲学家就餐问题"></a>3.14 经典问题：哲学家就餐问题</h4><p><img src="/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/image-20220327221126928.png" alt="image-20220327221126928" style="zoom:50%;"></p><p>圆桌上坐着5名哲学家，每两个哲学家之问的桌上摆一根筷子，桌子的中间是一碗米饭。哲学们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时才试图拿起左、右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐。当进餐完毕后，放下筷子继续思考。</p><ol><li>关系分析。系统中有5个哲学家进程，5位哲学家<strong>与左右邻居对其中间筷子的访问</strong>是<strong>互斥关系</strong></li><li>整理思路。这个问题中只有互斥关系，但与之前遇到的问题不同的事，每个哲学家进程需要同时持有两个临界资源才能开始吃饭。如何<strong>避免临界资源分配不当造成的死锁现象</strong>，是哲学家问题的精髓。</li><li>信号量设置。定义互斥信号量数组<code>chopstick [5] = &#123;1,1,1,1,1&#125;</code>用于实现对5个筷子的互斥访问。并对哲学家按<code>0~4</code>编号，哲学家<code>i</code>左边的筷子编号为<code>i</code>，右边的筷子编号为<code>(i+1) % 5</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Semaphore chopstick[<span class="number">5</span>] = <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">Semaphore</span> <span class="variable">mutex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line">Philosoph_i () &#123;    <span class="comment">// i号哲学家进程</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        chopstick[i].down();            <span class="comment">// 拿起左边筷子</span></span><br><span class="line">        chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>].down();      <span class="comment">// 拿起右边筷子</span></span><br><span class="line">        吃饭；</span><br><span class="line">        chopstick[i].up();              <span class="comment">// 放下左边筷子</span></span><br><span class="line">        chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>].up();        <span class="comment">// 放下右边筷子</span></span><br><span class="line">        思考；</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    这种情况下，所有哲学家都会拿起左边的筷子，会造成死锁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>这种情况下，所有哲学家都会拿起左边的筷子，会造成 <strong>死锁</strong>。这种解决方案不合理。</p><p><strong>如何防止死锁的发生呢？</strong></p><ol><li>可以对哲学家进程施加一些限制条件，比如最多允许<strong>四个哲学家同时进餐</strong>。这样可以<strong>保证至少有一个哲学家是可以拿到左右两只筷子</strong>的</li><li>要求<strong>奇数号哲学家先拿左边的筷子，然后再拿右边的筷子</strong>，而<strong>偶数号哲学家刚好相反</strong>。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一支后再等待另一只的情况。</li><li>当且仅当一个哲学家<strong>左右两只筷子都可用时才允许他挂起筷子</strong>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Semaphore chopstick[<span class="number">5</span>] = <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">Semaphore</span> <span class="variable">mutex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>); <span class="comment">// 互斥地取筷子</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    实现方法3.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Philosoph_i () &#123;    <span class="comment">// i号哲学家进程</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        mutex.down();                   <span class="comment">// 拿两个筷子的锁</span></span><br><span class="line">        chopstick[i].down();            <span class="comment">// 拿起左边筷子</span></span><br><span class="line">        chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>].down();      <span class="comment">// 拿起右边筷子</span></span><br><span class="line">        mutex.up();</span><br><span class="line">        吃饭；</span><br><span class="line">        chopstick[i].up();              <span class="comment">// 放下左边筷子</span></span><br><span class="line">        chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>].up();        <span class="comment">// 放下右边筷子</span></span><br><span class="line">        思考；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>这些<strong>进程之间只存在互斥关系</strong>，但是与之前接触到的互斥关系不同的是，每个进程都需要同时持有两个临界资源，因此就有“死锁”问题的隐患。</li><li>如果在考试中遇到了一个进程需要同时持有<strong>多个临界资源的情况</strong>，应该<strong>参考哲学家问题的思想</strong>，分析题中给出的进程之间<strong>是否会发生循环等待，是否会发生死锁</strong>。</li><li>可以参考哲学家就餐问题解决死锁的三种思路</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Java-并发多线程编程&quot;&gt;&lt;a href=&quot;#Java-并发多线程编程&quot; class=&quot;headerlink&quot; title=&quot;Java 并发多线程编程&quot;&gt;&lt;/a&gt;Java 并发多线程编程&lt;/h2&gt;&lt;p&gt;视频课程: &lt;a href=&quot;https://www.bilibili.com/video/BV16J411h7Rd?p=50&quot;&gt;BiliBili - 黑马程序员Java并发编程 JUC&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;笔记参考: &lt;a href=&quot;https://nyimac.gitee.io/2020/06/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/&quot;&gt;Java并发 - Nyima’s Blog&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注：本课程笔记基于JDK8，采用lsf4j打印日志&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="JUC" scheme="https://dave0126.github.io/categories/JUC/"/>
    
    
    <category term="Java" scheme="https://dave0126.github.io/tags/Java/"/>
    
    <category term="JUC" scheme="https://dave0126.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发多线程编程 (JUC) (一)</title>
    <link href="https://dave0126.github.io/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/"/>
    <id>https://dave0126.github.io/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/</id>
    <published>2022-03-23T20:13:13.000Z</published>
    <updated>2022-03-27T20:25:31.735Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-并发多线程编程"><a href="#Java-并发多线程编程" class="headerlink" title="Java 并发多线程编程"></a>Java 并发多线程编程</h2><p>视频课程: <a href="https://www.bilibili.com/video/BV16J411h7Rd?p=1">BiliBili - 黑马程序员Java并发编程 JUC</a></p><p>笔记参考: <a href="https://nyimac.gitee.io/2020/06/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发 - Nyima’s Blog</a></p><ul><li>注：本课程笔记基于JDK8，采用lsf4j打印日志</li></ul><span id="more"></span><h3 id="1-线程与进程"><a href="#1-线程与进程" class="headerlink" title="1 线程与进程"></a>1 线程与进程</h3><h4 id="1-1-进程"><a href="#1-1-进程" class="headerlink" title="1.1 进程"></a>1.1 进程</h4><ul><li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来<strong>加载指令、管理内存、管理 IO 的</strong>。</li><li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。</li><li>进程就可以视为<strong>程序的一个实例</strong>（程序是静态的，进程是动态的）。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器 等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）</li></ul><h4 id="1-2-线程"><a href="#1-2-线程" class="headerlink" title="1.2 线程"></a>1.2 线程</h4><ul><li>一个进程可以分为一到多个线程。</li><li><strong>一个线程就是一个指令流</strong>，将指令流中的一条条指令以一定的顺序交给 CPU 执行 。</li><li>Java 中，线程作为最小<strong>调度单位</strong>（执行指令），进程作为<strong>资源分配</strong>的最小单位。 在 windows 中进程是不活动的，只是作 为线程的容器</li></ul><h4 id="1-3-两者对比"><a href="#1-3-两者对比" class="headerlink" title="1.3 两者对比"></a>1.3 两者对比</h4><ul><li><strong>进程基本上相互独立的</strong>，而<strong>线程存在于进程内</strong>，是进程的一个子集</li><li>进程拥有共享的资源，如内存空间等，供其<strong>内部的线程共享</strong><ul><li>进程间通信较为复杂 同一台计算机的进程通信称为 IPC（Inter-process communication）</li><li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP</li></ul></li><li>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量</li><li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</li></ul><h5 id="1-3-1-进程和线程的切换"><a href="#1-3-1-进程和线程的切换" class="headerlink" title="1.3.1 进程和线程的切换"></a>1.3.1 进程和线程的切换</h5><h6 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h6><p>内核为每一个进程维持一个上下文。<strong>上下文就是内核重新启动一个被抢占的进程所需的状态。</strong>包括以下内容：</p><ul><li>通用目的寄存器</li><li>浮点寄存器</li><li>程序计数器</li><li>用户栈</li><li>状态寄存器</li><li>内核栈</li><li>各种内核数据结构：比如描绘地址空间的<strong>页表</strong>，包含有关当前进程信息的<strong>进程表</strong>，以及包含进程已打开文件的信息的<strong>文件表</strong></li></ul><h6 id="进程切换和线程切换的主要区别"><a href="#进程切换和线程切换的主要区别" class="headerlink" title="进程切换和线程切换的主要区别"></a>进程切换和线程切换的主要区别</h6><p>最主要的一个区别在于<strong>进程切换涉及虚拟地址空间的切换而线程不会</strong>。因为每个进程都有自己的虚拟地址空间，而<strong>线程是共享所在进程的虚拟地址空间的</strong>，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换</p><p>页表查找是一个很慢的过程，因此通常使用cache来缓存常用的地址映射，这样可以加速页表查找，这个cache就是快表TLB（translation Lookaside Buffer，用来加速页表查找）。由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么<strong>当进程切换后页表也要进行切换，页表切换后TLB就失效了</strong>，cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致TLB失效，因为线程线程无需切换地址空间，因此我们通常说线程切换要比较进程切换快</p><p>而且还可能出现<strong>缺页中断</strong>，这就需要操作系统将需要的内容调入内存中，若内存已满则还需要将不用的内容调出内存，这也需要花费时间</p><h6 id="为什么TLB能加快访问速度"><a href="#为什么TLB能加快访问速度" class="headerlink" title="为什么TLB能加快访问速度"></a><strong>为什么TLB能加快访问速度</strong></h6><p>快表可以避免每次都对页号进行地址的有效性判断。快表中保存了对应的物理块号，可以直接计算出物理地址，无需再进行有效性检查</p><h4 id="1-4-并行与并发"><a href="#1-4-并行与并发" class="headerlink" title="1.4 并行与并发"></a>1.4 并行与并发</h4><ol><li><p>单核cpu 下，线程实际还是<strong>串行执行</strong>的。操作系统中有一个组件叫做任务调度器，将cpu 的时间片（windows 下时间片最小约为 15 毫秒）分给不同的线程使用，只是由于 cpu在线程间（时间片很短）的切换非常快，人类感觉是<strong>同时运行</strong>的。总结为一句话就是：“<strong>微观串行，宏观并行</strong>”<br>一般会将这种<strong>线程轮流使用 CPU</strong>的做法称为并发，Concurrent。</p></li><li><p>多核cpu下，每个核心都可以调度运行线程，此时线程间是可以<strong>并行</strong>(Parallel)的。</p></li></ol><p><strong>并发</strong>(Concurrent) 是一个CPU在不同的时间去不同线程中执行指令。</p><p><strong>并行</strong>(Parallel)是多个CPU同时处理不同的线程。</p><h4 id="1-5-应用"><a href="#1-5-应用" class="headerlink" title="1.5 应用"></a>1.5 应用</h4><h5 id="1-5-1-应用之异步调用（案例1）"><a href="#1-5-1-应用之异步调用（案例1）" class="headerlink" title="1.5.1 应用之异步调用（案例1）"></a>1.5.1 应用之异步调用（案例1）</h5><p>以<strong>调用方角度</strong>来讲，如果</p><ul><li>需要等待结果返回，才能继续运行就是同步</li><li>不需要等待结果返回，就能继续运行就是异步</li></ul><p>注意：同步在多线程中还有另外一层意思，即让多个线程步调一致</p><h6 id="1-设计"><a href="#1-设计" class="headerlink" title="1) 设计"></a>1) 设计</h6><p>多线程可以让方法执行变为异步的（即不要巴巴干等着）比如说读取磁盘文件时，假设读取操作花费了 5 秒钟，如果没有线程调度机制，这 5 秒 cpu 什么都做不了，其它代码都得暂停…</p><p>一般来讲，大文件的读写、耗时较长的工作可以异步执行</p><h6 id="2-结论"><a href="#2-结论" class="headerlink" title="2) 结论"></a>2) 结论</h6><ul><li>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程</li><li>tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞</li><li>tomcat 的工作线程 ui 程序中，开线程进行其他操作，避免阻塞 ui 线程</li></ul><h5 id="1-5-2-应用之提高效率（案例1）"><a href="#1-5-2-应用之提高效率（案例1）" class="headerlink" title="1.5.2 应用之提高效率（案例1）"></a>1.5.2 应用之提高效率（案例1）</h5><p>充分利用多核 cpu 的优势，提高运行效率。想象下面的场景，执行3个计算，最后将计算结果汇总。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">计算 1 花费10ms</span><br><span class="line">计算 2 花费11ms</span><br><span class="line">计算 3 花费9ms</span><br><span class="line">汇总需要1ms</span><br></pre></td></tr></table></figure><p>如果是串行执行，那么总共花费的时间是 <code>10 + 11 + 9 + 1 = 31ms</code></p><ul><li>但如果是四核 cpu，各个核心分别使用线程1 执行计算1，线程2执行计算2，线程3执行计算3，那么3个线程是并行的，花费时间只取决于最长的那个线程运行的时间，即<code>11ms</code> 。最后加上汇总时间，只会花费<code>12ms</code>。</li></ul><p><strong>注意</strong>：需要在多核cpu 才能提高效率，单核仍然时是轮流执行</p><h6 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h6><ol><li>单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用 cpu ，不至于一个线程总占用 cpu，别的线程没法干活</li><li>多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的<ul><li>有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任 务都能拆分（参考后文的【阿姆达尔定律】）</li><li>也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义</li></ul></li><li>IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一 直等待 IO 结束，没能充分利用线程。所以才有后面的【非阻塞 IO】和【异步 IO】优化。</li></ol><h3 id="2-Java-线程"><a href="#2-Java-线程" class="headerlink" title="2 Java 线程"></a>2 Java 线程</h3><h4 id="2-1-创建和运行线程"><a href="#2-1-创建和运行线程" class="headerlink" title="2.1 创建和运行线程"></a>2.1 创建和运行线程</h4><h5 id="方法一：直接使用构造器创建一个线程"><a href="#方法一：直接使用构造器创建一个线程" class="headerlink" title="方法一：直接使用构造器创建一个线程"></a>方法一：直接使用构造器创建一个线程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateThread</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        Log.debug(<span class="string">&quot;my thread running...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">myThread.start();  <span class="comment">// 启动线程</span></span><br><span class="line">    Log.debug(<span class="string">&quot;main thread running...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用继承方式的好处是，在<code>run()</code>方法内获取当前线程直接使用this就可以了，无须使用<code>Thread.currentThread()</code>方法；</p><p>不好的地方是Java不支持多继承，如果继承了Thread类，那么就不能再继承其他类。另外任务与代码没有分离，当多个线程执行一样的任务时需要多份任务代码</p><h5 id="方法二：使用Runnable配合Thread-推荐"><a href="#方法二：使用Runnable配合Thread-推荐" class="headerlink" title="方法二：使用Runnable配合Thread(推荐)"></a>方法二：使用Runnable配合Thread(推荐)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//创建线程任务</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Runnable running&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//将Runnable对象传给Thread</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">t.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过实现Runnable接口，并且实现<code>run()</code>方法。好处是<strong>将任务和线程分离</strong>，更为灵活。在创建线程时作为参数传入该类的实例即可。</p><h5 id="方法二的简化：使用lambda表达式简化操作"><a href="#方法二的简化：使用lambda表达式简化操作" class="headerlink" title="方法二的简化：使用lambda表达式简化操作"></a>方法二的简化：使用lambda表达式简化操作</h5><p>当<strong>只有一个抽象方法的接口</strong>可以用<code>@FunctionalInterface</code>注解。当有该注解时，可以<strong>使用lambda来简化操作</strong></p><p>所以方法二中的代码可以被简化为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//创建线程任务</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="comment">//直接写方法体即可</span></span><br><span class="line">System.out.println(<span class="string">&quot;Runnable running&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Hello Thread&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//将Runnable对象传给Thread</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">t.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在IDEA中，可以在<code>Runnable</code>上使用<code>Alt + Enter</code>自动转换成lambda表达式。</p><h6 id="Thread-与-Runnable-的关系"><a href="#Thread-与-Runnable-的关系" class="headerlink" title="Thread 与 Runnable 的关系"></a>Thread 与 Runnable 的关系</h6><p>分析 Thread 的源码，理清它与 Runnable 的关系</p><ul><li>方法1 是把线程和任务合并在了一起</li><li>方法2 是把线程和任务分开了</li><li>用 Runnable 更容易与线程池等高级 API 配合 用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</li></ul><h5 id="方法三：使用FutureTask与Thread结合"><a href="#方法三：使用FutureTask与Thread结合" class="headerlink" title="方法三：使用FutureTask与Thread结合"></a>方法三：使用FutureTask与Thread结合</h5><p>使用<strong>FutureTask</strong>可以用泛型指定<strong>线程的返回值</strong>类型（<strong>Runnable的run方法没有返回值</strong>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">//需要传入一个Callable对象</span></span><br><span class="line">FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Integer&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;线程执行!&quot;</span>);</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">r1.start();</span><br><span class="line"><span class="comment">//获取线程中方法执行后的返回结果</span></span><br><span class="line">System.out.println(task.get());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>使用<strong>继承方式的好处是方便传参</strong>，你可以在子类里面添加成员变量，通过set方法设置参数或者通过构造函数进行传递，而如果使用Runnable方式，则只能使用主线程里面被声明为final的变量。</p><p><strong>不好的地方是Java不支持多继承</strong>，如果继承了Thread类，那么子类不能再继承其他类，而Runable则没有这个限制。<strong>前两种方式都没办法拿到任务的返回结果，但是Futuretask方式可以</strong></p><h4 id="2-2-原理之线程运行"><a href="#2-2-原理之线程运行" class="headerlink" title="2.2 原理之线程运行"></a>2.2 原理之线程运行</h4><h5 id="2-2-1-栈与栈帧"><a href="#2-2-1-栈与栈帧" class="headerlink" title="2.2.1 栈与栈帧"></a>2.2.1 栈与栈帧</h5><p><a href="https://dave0126.github.io/2022/03/22/JVM-1/#2-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88">Java Virtual Machine Stacks</a> （Java 虚拟机栈） 我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？</p><ul><li>其实就是线程，每个线程启动后，虚拟机就会为其分配一块<strong>栈内存</strong></li><li>每个栈由多个栈帧（Frame）组成，对应着每次<strong>方法调用时所占用的内存</strong></li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li></ul><h5 id="2-2-2-线程上下文切换"><a href="#2-2-2-线程上下文切换" class="headerlink" title="2.2.2 线程上下文切换"></a>2.2.2 线程上下文切换</h5><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p><ul><li>线程的 cpu 时间片用完</li><li>垃圾回收 有更高优先级的线程需要运行</li><li>线程自己调用了 <code>sleep</code>、<code>yield</code>、<code>wait</code>、<code>join</code>、<code>park</code>、<code>synchronized</code>、<code>lock</code> 等方法</li></ul><p>当 Context Switch 发生时，需要由操作系统<strong>保存当前线程的状态</strong>，并<strong>恢复另一个线程的状态</strong>，Java 中对应的概念 就是程序计数器（Program Counter Register），它的作用是记住下一条 JVM 指令的执行地址，是线程私有的</p><ul><li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li><li>Context Switch 频繁发生会影响性能</li></ul><h4 id="2-3-常见方法"><a href="#2-3-常见方法" class="headerlink" title="2.3 常见方法"></a>2.3 常见方法</h4><div class="table-container"><table><thead><tr><th><strong>方法名</strong></th><th><strong>功能说明</strong></th><th style="text-align:left"><strong>注意</strong></th></tr></thead><tbody><tr><td><code>start()</code></td><td>启动一个新线程，在新线程上运行<code>run()</code>方法中的代码</td><td style="text-align:left"><code>start()</code> 方法只是让线程进入就绪，里面代码不一定立刻运行（CPU 的时间片还没分给它）。每个线程对象的<strong><code>start()</code>方法只能调用一次</strong>，如果调用了多次会出现 IllegalThreadStateException</td></tr><tr><td><code>run()</code></td><td>新线程启动后会调用的方法</td><td style="text-align:left">如果在构造 Thread 对象时传递了 Runnable 参数，则线程启动后会调用 Runnable 中的<code>run()</code> 方法，否则默认不执行任何操作。但可以创建 Thread 的子类对象，来覆盖默认行为</td></tr><tr><td><code>join()</code></td><td>等待线程运行结束</td><td style="text-align:left"></td></tr><tr><td><code>join(long n)</code></td><td>等待线程运行结束最多等待n毫秒</td><td style="text-align:left"></td></tr><tr><td><code>getId()</code></td><td>获取线程长整型的id</td><td style="text-align:left">id唯一</td></tr><tr><td><code>getName()</code></td><td>获取线程名</td><td style="text-align:left"></td></tr><tr><td><code>setName(String)</code></td><td>修改线程名</td><td style="text-align:left"></td></tr><tr><td><code>getPriority()</code></td><td>获取线程优先级</td><td style="text-align:left"></td></tr><tr><td><code>setPriority(int)</code></td><td>设置线程优先级</td><td style="text-align:left">java中规定线程优先级是1~10的整数，较大的优先级能提高该线程被 CPU 调度的机率</td></tr><tr><td><code>getState()</code></td><td>获取线程状态</td><td style="text-align:left">Java中线程状态使用6个enum表示：NEW，RUNNABLE，BLOCKED，WATING，TIMED_WAITING，TERMINATED</td></tr><tr><td><code>isInterrupted()</code></td><td>判断是否被打断</td><td style="text-align:left">不会清除打断标记</td></tr><tr><td><code>isAlive()</code></td><td>线程是否存活（还没有运行完毕）</td><td style="text-align:left"></td></tr><tr><td><code>interrupt()</code></td><td>打断线程</td><td style="text-align:left">如果被打断线程正在 sleep, wait, join 会导致被打断的线程抛出 InterruptedException，并<strong>清除打断标记</strong>；如果打断的正在运行的线程，则会<strong>设置打断标记</strong>；park 的线程被打断，也会<strong>设置打断标记</strong></td></tr><tr><td><code>currentThread()</code></td><td>获取当前正在执行的线程</td><td style="text-align:left"></td></tr><tr><td><code>sleep(long n)</code></td><td>让当前执行的线程休眠n毫秒，休眠时让出 cpu 的时间片给其它线程</td><td style="text-align:left">不会释放<strong>锁</strong>操作</td></tr><tr><td><code>yield()</code></td><td>提线程调度器让出当前线程对CPU的使用</td><td style="text-align:left">主要是为了测试和调试</td></tr></tbody></table></div><h5 id="2-3-1-start-vs-run"><a href="#2-3-1-start-vs-run" class="headerlink" title="2.3.1 start() vs run()"></a>2.3.1 start() vs run()</h5><p>被创建的Thread对象直接调用重写的<code>run()</code>方法时， run方法是在<strong>主线程</strong>中被执行的，而不是在我们所创建的线程中执行。</p><p>所以如果想要在所创建的线程中执行<code>run()</code>方法，<strong>需要使用Thread对象的start()方法。</strong></p><h5 id="2-3-2-sleep-vs-yield"><a href="#2-3-2-sleep-vs-yield" class="headerlink" title="2.3.2 sleep() vs yield()"></a>2.3.2 sleep() vs yield()</h5><h6 id="sleep-使线程阻塞"><a href="#sleep-使线程阻塞" class="headerlink" title="sleep (使线程阻塞)"></a><strong>sleep</strong> (使线程阻塞)</h6><ol><li><p>调用 <code>sleep()</code> 会让当前线程从 <strong>Running 进入 Timed Waiting 状态（阻塞）</strong>，可通过<code>state()</code>方法查看</p></li><li><p>其它线程可以使用 <strong><code>interrupt()</code></strong> 方法打断正在睡眠的线程，这时 <code>sleep()</code> 方法会抛出 InterruptedException</p></li><li><p>睡眠结束后的线程未必会立刻得到执行(Runnable状态)</p></li><li><p>建议用 <strong>TimeUnit 的 <code>sleep()</code></strong> 代替 Thread 的 <code>sleep()</code> 来获得更好的可读性 。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//休眠一秒</span></span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//休眠一分钟</span></span><br><span class="line">TimeUnit.MINUTES.sleep(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ol><h6 id="yield-（让出当前线程）"><a href="#yield-（让出当前线程）" class="headerlink" title="yield （让出当前线程）"></a>yield （让出当前线程）</h6><ol><li>调用 yield 会让当前线程从 <strong>Running 进入 Runnable 就绪状态</strong>（仍然有可能被执行），然后调度执行其它线程</li><li>具体的实现依赖于操作系统的任务调度器</li></ol><h6 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h6><ul><li><p>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它</p></li><li><p>如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</p></li><li><p>设置方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread1.setPriority(Thread.MAX_PRIORITY); <span class="comment">//设置为优先级int(1~10)</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">Runnable</span> <span class="variable">task1</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;----&gt; task1&quot;</span> + count++);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="type">Runnable</span> <span class="variable">task2</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">      Thread.yield();</span><br><span class="line">      System.out.println(<span class="string">&quot;----&gt; task1&quot;</span> + count++);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task1, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task1, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  t1.start();</span><br><span class="line">  t2.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果应为 t1打印的count 远大于 t2打印的count</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="2-3-3-join"><a href="#2-3-3-join" class="headerlink" title="2.3.3 join()"></a>2.3.3 join()</h5><pre class="mermaid">graph TDA1[main]--瞬间完成-->E1[r=0]E1 --> B1[t1.join]A1 --> C1[t1.start]C1 --1s后---> D1[r=10]D1 --t1结束--> B1B1 --> R1[res: r=10]</pre><p><code>join()</code>的底层原理就是<code>wait()</code>。</p><p>用于等待某个线程结束。哪个线程内调用join()方法，就等待哪个线程结束，然后再去执行其他线程。</p><p>如在主线程中调用ti.join()，则是主线程等待t1线程结束</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>();</span><br><span class="line"><span class="comment">//等待thread线程执行结束</span></span><br><span class="line">thread.join();</span><br><span class="line"><span class="comment">//最多等待1000ms,如果1000ms内线程执行完毕，则会直接执行下面的语句，不会等够1000ms</span></span><br><span class="line">thread.join(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h5 id="2-3-4-interrupt"><a href="#2-3-4-interrupt" class="headerlink" title="2.3.4 interrupt()"></a>2.3.4 interrupt()</h5><p>用于打断<strong>阻塞</strong>(sleep wait join…)的线程。 处于<strong>阻塞状态</strong>的线程，CPU不会给其分配时间片。</p><ul><li>如果一个线程在在运行中被打断，打断标记会被置为<code>true</code>。</li><li>如果是打断因<code>sleep(), wait(), join()</code>方法而被阻塞的线程，会将打断标记会被清空，置为<code>false</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于查看打断标记，返回值被boolean类型</span></span><br><span class="line">t1.isInterrupted();</span><br></pre></td></tr></table></figure><p>正常运行的线程在被打断后，<strong>不会停止</strong>，会继续执行。如果要让线程在被打断后停下来，需要<strong>使用打断标记来判断</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throw</span> InterruptedException&#123;</span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  t1.start();</span><br><span class="line">  </span><br><span class="line">  Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  Log.debug(<span class="string">&quot;interrupted&quot;</span>);</span><br><span class="line">  t1.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="interrupt-的应用——两阶段终止模式"><a href="#interrupt-的应用——两阶段终止模式" class="headerlink" title="interrupt() 的应用——两阶段终止模式"></a>interrupt() 的应用——两阶段终止模式</h6><p>当我们在执行线程一时，想要终止线程二，这是就需要使用interrupt方法来<strong>优雅</strong>的停止线程二（料理后事: 释放锁和临界资源等）。</p><ol><li><p>错误思路</p><ul><li><code>stop()</code>：该方法会直接杀死线程，若线程对临界区资源上锁，则永远解锁，其他线程也无法获取锁。</li><li><code>suspend()</code>暂停线程 和 <code>resume()</code>恢复线程, 原因同<code>stop()</code></li><li><code>System.exit(int)</code>：该方法会直接<strong>停止进程</strong>。</li></ul></li><li><p>两阶段终止模式</p></li></ol><pre class="mermaid">graph TDA["while(true)"]B{是否被打断?}C[料理后事]D[睡眠2s]E(结束循环)F[执行监控记录]G[设置打断标记]A --> BB --yes--> CB --no--> DC --> ED --无异常--> FD --有异常--> GF --> AG --> A</pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  两阶段终止模式（Two Phase Termination）：在进程T1中终止进程T2</span></span><br><span class="line"><span class="comment">    在终止进程T2之前让T2释放锁和临界资源</span></span><br><span class="line"><span class="comment">    不用stop（） 和 System.exit（）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TwoPhaseTermination</span> &#123;</span><br><span class="line">    <span class="comment">// 监控线程</span></span><br><span class="line">    privite Thread monitor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动监控线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        monitor = <span class="keyword">new</span> <span class="title class_">Thread</span> (() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                <span class="keyword">if</span> (current.isInterrupted()) &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    TODO 释放锁和临界资源</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;释放锁和临界资源&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>); <span class="comment">// 情况1</span></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                        TODO 正常功能的代码块</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="comment">// 情况2</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="comment">// 若sleep时被打断，会捕获错误e，此时的isInterrupted标记为false，程序会重复执行。所以有以下操作</span></span><br><span class="line">                    current.interrupt(); <span class="comment">// 重新设置isInterrupted打断标记, true -&gt; false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        monitor.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止监控线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        monitor.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-5-主线程与守护线程"><a href="#2-3-5-主线程与守护线程" class="headerlink" title="2.3.5 主线程与守护线程"></a>2.3.5 主线程与守护线程</h5><ul><li><p>主线程: 当JAVA进程中有多个线程在执行时，只有当所有非守护线程都执行完毕后，JAVA进程才会结束。</p></li><li><p>守护线程: <strong>但当非守护线程全部执行完毕后，守护线程无论是否执行完毕，也会一同结束。</strong>(垃圾回收线程)</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将线程设置为守护线程, 默认为false</span></span><br><span class="line">monitor.setDaemon(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h4 id="2-4-线程的状态"><a href="#2-4-线程的状态" class="headerlink" title="2.4 线程的状态"></a>2.4 线程的状态</h4><h5 id="2-4-1-五种状态-操作系统层面"><a href="#2-4-1-五种状态-操作系统层面" class="headerlink" title="2.4.1 五种状态(操作系统层面)"></a>2.4.1 五种状态(操作系统层面)</h5><p><img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/20200608144606.png" alt="20200608144606" style="zoom:75%;"></p><ol><li>【初始状态】：在<strong>语言层面创建了线程对象</strong>，但未与操作系统线程关联</li><li>【可运行状态】：（就需状态），已与操作系统线程关联，可由cpu调度执行</li><li>【运行状态】：获得cpu时间片，正在执行。<ul><li>当cpu时间片用完，由【运行状态】转为【可运行状态】，导致线程的上下文切换</li></ul></li><li>【阻塞状态】：该状态下的线程不会占用cpu，会导致线程的上下文切换<ul><li>等阻塞操作结束，系统唤醒阻塞状态，切换至【可运行状态】</li></ul></li><li>【终止状态】</li></ol><h5 id="2-4-2-六种状态-JAVA-API层面"><a href="#2-4-2-六种状态-JAVA-API层面" class="headerlink" title="2.4.2 六种状态(JAVA API层面)"></a>2.4.2 六种状态(JAVA API层面)</h5><p><img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/20200608144621.png" alt="20200608144621" style="zoom:75%;"></p><p>详见<a href="https://dave0126.github.io//2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/#3-9-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2">第三章 3.9【线程状态转换】</a></p><ol><li><p>【NEW】：线程被创建，还没有调用<code>strat()</code>方法</p></li><li><p>【RUNNABLE】：调用了<code>start()</code>方法后。该状态涵盖了<strong>操作系统层面</strong>的<em>【可运行状态】、【运行状态】和【阻塞状态】</em></p></li><li><p>三种“java中的阻塞状态”：后面会在状态转换一节详述。</p><p>(1) 【BLOCKED】：</p><p>(2)【WAITING】：<code>join()</code></p><p>(3)【TIMED_WAITING】：<code>sleep()</code></p></li><li><p>【TERMINATED】：代码运行结束</p></li></ol><h4 id="2-5-习题"><a href="#2-5-习题" class="headerlink" title="2.5 习题"></a>2.5 习题</h4><h5 id="2-5-1-统筹方法（烧水泡茶）"><a href="#2-5-1-统筹方法（烧水泡茶）" class="headerlink" title="2.5.1 统筹方法（烧水泡茶）"></a>2.5.1 统筹方法（烧水泡茶）</h5><p>阅读华罗庚《统筹方法》，给出烧水泡茶的多线程解决方案，提示：</p><ul><li>参考图二，用两个线程（两个人协作）模拟烧水泡茶过程<ul><li>文中办法乙、丙都相当于任务串行</li><li>而图一相当于启动了 4 个线程，有点浪费</li></ul></li><li>用<code>sleep(n)</code>模拟洗茶壶、洗水壶等耗费的时间</li></ul><p>附：华罗庚《统筹方法》</p><hr><p>统筹方法，是一种安排工作进程的数学方法。它的实用范围极广泛，在企业管理和基本建设中，以及关系复杂的科研项目的组织与管理中，都可以应用。</p><p>怎样应用呢？主要是把工序安排好。</p><p>比如，想泡壶茶喝。当时的情况是：开水没有；水壶要洗，茶壶、茶杯要洗;火已生了，茶叶也有了。<br>怎么办？</p><ul><li>办法甲：洗好水壶，灌上凉水，放在火上；在等待水开的时间里，洗茶壶、洗茶杯、 拿茶叶；等水开了，泡茶喝。</li><li>办法乙：先做好一些准备工作，洗水壶，洗茶壶茶杯，拿茶叶；一切就绪，灌水烧水；坐待水开了，泡茶喝。</li><li>办法丙：洗净水壶，灌上凉水，放在火上，坐待水开；水开了之后，急急忙忙找茶叶，洗茶壶茶杯，泡茶喝。</li></ul><p>哪一种办法省时间？我们能一眼看出，第一种办法好，后两种办法都窝了工。</p><p>这是小事，但这是引子，可以引出生产管理等方面有用的方法来。</p><p>水壶不洗，不能烧开水，因而洗水壶是烧开水的前提。没开水、没茶叶、不洗茶壶茶杯，就不能泡茶，因而这些又是泡茶的前提。它们的相互关系，可以用下图来表示：</p><pre class="mermaid">graph LR;A[洗水壶 1min]--> B[烧开水 15mins];B--> R[泡茶];C[洗茶壶 1min]--> R;D[洗茶杯 1min]--> R;E[拿茶叶 1min]--> R;</pre><p>从这个图上可以一眼看出，办法甲总共要16分钟（而办法乙、丙需要20分钟）。如果要缩短工时．提高工作效率，应当主要抓烧开水这个环节，而不是抓拿茶叶等环节。同时，洗茶壶茶杯、拿茶叶总共不过3分钟，大可利用“等水开”的时间来做。</p><p>是的，这好像是废话，卑之无甚高论。有如走路要用两条腿走，吃饭要一口一口吃，这些道理谁都懂得。但稍有变化，临事而迷的情况，常常是存任的。在近代工业的错综夏杂的工艺过程中，往往就不是像泡茶喝这么简单了。任务多了，几百几千，甚至有好几万个任务。关系多了，错综复杂，千头万绪，往往出现 “万事俱备，只欠东风” 的情况。由于一两个零件没完成，耽误了一台复杂机器的出厂时间。或往往因为抓的不是关键，连夜三班，急急忙忙，完成这一环节之后，还得等待旁的环节才能装配。</p><p>洗茶壶，洗茶杯，拿茶叶，或先或后，关系不大，而且同是一个人的活儿，因币可以合并成为：</p><pre class="mermaid">graph LR;A[洗水壶 1min]--> B[烧开水 15mins];B--> R[泡茶];C[洗茶壶, 洗茶杯, 拿茶叶 3mins]--> R;</pre><p>看来这是“小题大做”，但在工作环节太多的时候，这样做就非常必要了。</p><p>这里讲的主要是时间方面的事，但在具体生产实践中，还有其他方面的许多事。这种方法里然不一定能直接解决所有问题，但是，我们利用这种方法来考虑问题，也是不无裨益的。</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pubilc <span class="keyword">static</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    Log.debug(<span class="string">&quot;洗水壶&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    Log.debug(<span class="string">&quot;烧开水&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">15000</span>);</span><br><span class="line">  &#125;, <span class="string">&quot;小明&quot;</span>);</span><br><span class="line">    </span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    Log.debug(<span class="string">&quot;洗茶壶&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    Log.debug(<span class="string">&quot;洗茶杯&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    Log.debug(<span class="string">&quot;拿茶叶&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">     t1.join(); <span class="comment">// 由 小王 来泡茶 </span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="string">&quot;小王&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  t1.start();</span><br><span class="line">  t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">19:19:37.547[小明]c.TestMakeTea -洗茶壶</span><br><span class="line">19:19:37.547[小王]c.TestMakeTea - 洗水壶</span><br><span class="line">19:19:38.552[小明]c.TestMakeTea - 洗茶杯</span><br><span class="line">19:19:38.552[小王]c.TestMakeTea - 烧开水</span><br><span class="line">19:19:49.553[小明]c.TestMakeTea - 拿茶叶</span><br><span class="line">19:19:53.553[小明]c.TestMakeTea -泡茶</span><br></pre></td></tr></table></figure><p>解法1的缺陷：</p><ul><li>上面模拟的是小明等小王的水烧开了，小明泡茶，如果反过来要实现小王等小明的茶叶拿来了，小王泡茶呢？代码最好能适应两种情况</li><li>上面的两个线程其实是各执行各的，如果要模拟小王把水壶交给小明泡茶，或模拟小明把茶叶交给小王泡茶</li></ul><h4 id="2-6-小结"><a href="#2-6-小结" class="headerlink" title="2.6 小结"></a>2.6 小结</h4><p>本章的重点在于掌握</p><ul><li>线程创建</li><li>线程重要api， 如<code>start, run, sleep, join, interrupt</code>等</li><li>线程状态</li><li>应用方面<ul><li>异步调用：主线程执行期间，其它线程异步执行耗时操作</li><li>提高效率：并行计算，缩短运算时间</li><li>同步等待：join</li><li>统筹规划：合理使用线程，得到最优效果</li></ul></li><li>原理方面<ul><li>线程运行流程：栈、栈帧、上下文切换、程序计数器</li><li>Thread 两种创建方式 的源码</li></ul></li><li>模式方面<ul><li>两阶段终止</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Java-并发多线程编程&quot;&gt;&lt;a href=&quot;#Java-并发多线程编程&quot; class=&quot;headerlink&quot; title=&quot;Java 并发多线程编程&quot;&gt;&lt;/a&gt;Java 并发多线程编程&lt;/h2&gt;&lt;p&gt;视频课程: &lt;a href=&quot;https://www.bilibili.com/video/BV16J411h7Rd?p=1&quot;&gt;BiliBili - 黑马程序员Java并发编程 JUC&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;笔记参考: &lt;a href=&quot;https://nyimac.gitee.io/2020/06/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/&quot;&gt;Java并发 - Nyima’s Blog&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注：本课程笔记基于JDK8，采用lsf4j打印日志&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="JUC" scheme="https://dave0126.github.io/categories/JUC/"/>
    
    
    <category term="Java" scheme="https://dave0126.github.io/tags/Java/"/>
    
    <category term="JUC" scheme="https://dave0126.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Java 虚拟机 - JVM 第二讲</title>
    <link href="https://dave0126.github.io/2022/03/22/JVM-2/"/>
    <id>https://dave0126.github.io/2022/03/22/JVM-2/</id>
    <published>2022-03-22T21:36:23.000Z</published>
    <updated>2022-03-23T22:59:50.384Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM-基础学习"><a href="#JVM-基础学习" class="headerlink" title="JVM 基础学习"></a>JVM 基础学习</h1><p>视频课程: <a href="https://www.bilibili.com/video/BV1yE411Z7AP?p=48">BiliBili - 黑马程序员JVM完整教程: JVM垃圾回收</a></p><h2 id="三、JVM-垃圾回收"><a href="#三、JVM-垃圾回收" class="headerlink" title="三、JVM 垃圾回收"></a>三、JVM 垃圾回收</h2><h3 id="0-主要内容大纲"><a href="#0-主要内容大纲" class="headerlink" title="0 主要内容大纲"></a>0 主要内容大纲</h3><ol><li>如何判断对象可以回收</li><li>垃圾回收算法</li><li>分代垃圾回收</li><li>垃圾回收器</li><li>垃圾回收调优</li></ol><span id="more"></span><h3 id="1-如何判断对象可以被回收"><a href="#1-如何判断对象可以被回收" class="headerlink" title="1 如何判断对象可以被回收"></a>1 如何判断对象可以被回收</h3><h4 id="1-1-引用计数法"><a href="#1-1-引用计数法" class="headerlink" title="1.1 引用计数法"></a>1.1 引用计数法</h4><p>只要一个对象被其他变量所引用，那我们就让这个对象的计数加1，如果被引用两次，该计数就为2。如果某个变量不再引用这个对象，该对象的引用计数减1。当计数为0时，表示没有变量引用这个对象了，则可作为垃圾回收掉。</p><p><img src="/2022/03/22/JVM-2/20200608150750 (1).png" alt="20200608150750 (1)" style="zoom:75%;"></p><ul><li>弊端：在例如上图的循环引用时，两个对象的计数都为1，导致两个对象都无法被释放</li></ul><h4 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2 可达性分析算法"></a>1.2 可达性分析算法</h4><p>首先先要确定根对象。那么什么是根对象呢？就是那些肯定不能被当成垃圾回收的对象。</p><p>在垃圾回收之前，我们先扫描堆内存中的所有对象，检查对象是否被根对象直接或者间接的引用。若是，则不能被回收；反之则可以被回收。</p><ul><li>JVM中的垃圾回收器通过<strong>可达性分析</strong>来探索所有存活的对象</li><li>扫描堆中的对象，看能否沿着GC Root对象（根对象）为起点的引用链找到该对象，如果<strong>找不到，则表示可以回收</strong></li><li>可以作为GC Root的对象：<ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。　</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li></ul></li></ul><h4 id="1-3-五种引用"><a href="#1-3-五种引用" class="headerlink" title="1.3 五种引用"></a>1.3 五种引用</h4><p><img src="/2022/03/22/JVM-2/20200608150800.png" alt="20200608150800"></p><h5 id="1-3-1-强引用"><a href="#1-3-1-强引用" class="headerlink" title="1.3.1 强引用"></a>1.3.1 强引用</h5><p>如上图，实线箭头表示强引用。日常使用中的引用都属于强引用。例如，new一个对象，使用“=”将该对象赋值给一个变量，那么这个变量就强引用该对象。</p><p>只有GC Root<strong>都不引用</strong>该对象时，才会回收<strong>强引用</strong>对象</p><ul><li>如上图B、C对象都不引用A1对象时，A1对象才会被回收</li></ul><h5 id="1-3-2-软引用-SoftReference"><a href="#1-3-2-软引用-SoftReference" class="headerlink" title="1.3.2 软引用 (SoftReference)"></a>1.3.2 软引用 (SoftReference)</h5><p>当内存空间有限时，一些不重要的资源可以用软引用。</p><p>只要A2、A3两个对象没有被直接的强引用所引用，当垃圾回收发生时，都有可以被回收。</p><p>当GC Root指向软引用对象（垃圾回收）时，在<strong>内存不足时</strong>，会<strong>回收软引用所引用的对象</strong>。（先回收一次，如果内存还不够，回收软引用所引用的对象）</p><ul><li>如上图如果B对象不再引用A2对象且内存不足时，软引用所引用的A2对象就会被回收</li></ul><p>案列1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoSortReference1</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">_4M</span> <span class="operator">=</span> <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="comment">//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span></span><br><span class="line">List&lt;SoftReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 强引用</span></span><br><span class="line">SoftReference&lt;<span class="type">byte</span>[]&gt; ref= <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[_4M]); <span class="comment">// 软引用</span></span><br><span class="line">    <span class="comment">// List list --强--&gt; SoftReference ref --软--&gt; byte[_4M]</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在垃圾回收时发现内存不足，在回收软引用所指向的对象时，<strong>软引用本身不会被清理</strong></p><p>如果想要<strong>清理软引用</strong>，需要使<strong>用引用队列</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoSortReference2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">_4M</span> <span class="operator">=</span> <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//使用引用队列，用于移除引用为空的软引用对象</span></span><br><span class="line">ReferenceQueue&lt;<span class="type">byte</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;(); <span class="comment">// 引用队列</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span></span><br><span class="line">List&lt;SoftReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 强引用</span></span><br><span class="line">SoftReference&lt;<span class="type">byte</span>[]&gt; ref= <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[_4M]); <span class="comment">// 软引用</span></span><br><span class="line">    <span class="comment">// List list --强--&gt; SoftReference ref --软--&gt; byte[_4M]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历引用队列，如果有元素，则取出</span></span><br><span class="line">Reference&lt;? <span class="keyword">extends</span> <span class="title class_">byte</span>[]&gt; poll = queue.poll(); <span class="comment">// poll(), 取出最先放入队列的元素，返回类型Reference</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span>(poll != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//引用队列不为空，则从集合中移除该元素</span></span><br><span class="line">list.remove(poll);</span><br><span class="line"><span class="comment">//移动到引用队列中的下一个元素</span></span><br><span class="line">poll = queue.poll();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>大概思路为：</strong>查看引用队列中有无软引用，如果有，则将该软引用从存放它的集合中移除（这里为一个list集合）</p><h5 id="1-3-3-弱引用-WeakReferrnce"><a href="#1-3-3-弱引用-WeakReferrnce" class="headerlink" title="1.3.3 弱引用 (WeakReferrnce)"></a>1.3.3 弱引用 (WeakReferrnce)</h5><p>只有弱引用引用该对象时，在垃圾回收时，<strong>无论内存是否充足</strong>，都会回收弱引用所引用的对象</p><ul><li>如上图如果B对象不再引用A3对象，则A3对象会被回收</li></ul><p><strong>弱引用的使用和软引用类似</strong>，只是将 <strong>SoftReference 换为了 WeakReference</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoWeakReference1</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">_4M</span> <span class="operator">=</span> <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="comment">//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是弱引用</span></span><br><span class="line">List&lt;WeakReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 强引用</span></span><br><span class="line">WeakReference&lt;<span class="type">byte</span>[]&gt; ref= <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[_4M]); <span class="comment">// 弱引用</span></span><br><span class="line">    <span class="comment">// List list --强--&gt; WeakReference ref --弱--&gt; byte[_4M]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用引用队列，用于移除引用为空的软引用对象</span></span><br><span class="line">ReferenceQueue&lt;<span class="type">byte</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;(); <span class="comment">// 引用队列</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历引用队列，如果有元素，则取出</span></span><br><span class="line">Reference&lt;? <span class="keyword">extends</span> <span class="title class_">byte</span>[]&gt; poll = queue.poll(); <span class="comment">// poll(), 取出最先放入队列的元素，返回类型Reference</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span>(poll != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//引用队列不为空，则从集合中移除该元素</span></span><br><span class="line">list.remove(poll);</span><br><span class="line"><span class="comment">//移动到引用队列中的下一个元素</span></span><br><span class="line">poll = queue.poll();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-3-4-虚引用-PhantomReference"><a href="#1-3-4-虚引用-PhantomReference" class="headerlink" title="1.3.4 虚引用 (PhantomReference)"></a>1.3.4 虚引用 (PhantomReference)</h5><p>必须配合引用队列一同使用。当虚（终结器）引用被创建时，会关联一个引用队列。</p><p>当虚引用对象所引用的对象被回收以后，虚引用对象就会被放入引用队列中，调用虚引用的方法</p><ul><li>虚引用的一个体现是<strong>释放直接内存所分配的内存</strong>，当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean()方法来释放直接内存</li><li>如上图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象Cleaner放入引用队列中，然后调用它的clean方法来释放直接内存</li></ul><h5 id="1-3-5-终结器引用-FinalReference"><a href="#1-3-5-终结器引用-FinalReference" class="headerlink" title="1.3.5 终结器引用 (FinalReference)"></a>1.3.5 终结器引用 (FinalReference)</h5><p>所有的对象都继承自Object类，Object类有一个finalize()方法。当某个对象不再被其他的对象所引用时，会先将终结器引用对象放入引用队列中(处理这个引用队列的<em>FinalizeHandler线程</em>优先级很低)，然后根据终结器引用对象找到它所引用的对象，然后调用该对象的finalize()方法。调用以后，该对象就可以被垃圾回收了。</p><ul><li>如上图，B对象不再引用A4对象。这是终结器对象就会被放入引用队列中，引用队列会根据它，找到它所引用的对象。然后调用被引用对象的finalize()方法。调用以后，该对象就可以被垃圾回收了</li></ul><h3 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2 垃圾回收算法"></a>2 垃圾回收算法</h3><h4 id="2-1-标记-清除-算法-Mark-Sweep"><a href="#2-1-标记-清除-算法-Mark-Sweep" class="headerlink" title="2.1 标记 - 清除 算法 (Mark - Sweep)"></a>2.1 标记 - 清除 算法 (Mark - Sweep)</h4><p><img src="/2022/03/22/JVM-2/20200608150813.png" alt="20200608150813" style="zoom:67%;"></p><p><strong>定义</strong>：标记清除算法顾名思义，是指在虚拟机执行垃圾回收的过程中，先采用标记算法确定可回收对象（图中为没有GC Root引用的块），然后垃圾收集器根据标识清除相应的内容，给堆内存腾出相应的空间。</p><ul><li>这里的腾出内存空间并不是将内存空间的字节清0，而是记录下这段内存的起始结束地址，下次分配内存的时候，会直接<strong>覆盖</strong>这段内存。同理于操作系统中的内存管理</li></ul><p>优点：垃圾回收速度快</p><p><strong>缺点</strong>：<strong>容易产生大量的内存碎片</strong>，可能无法满足大对象的内存分配，一旦导致无法分配对象，那就会导致jvm启动gc，一旦启动gc，我们的应用程序就会暂停，这就导致应用的响应速度变慢。同理于操作系统中的内存碎片。</p><h4 id="2-2-标记-整理-算法-Mark-Compact"><a href="#2-2-标记-整理-算法-Mark-Compact" class="headerlink" title="2.2 标记 - 整理 算法 (Mark - Compact)"></a>2.2 标记 - 整理 算法 (Mark - Compact)</h4><p><img src="/2022/03/22/JVM-2/20200608150827.png" alt="20200608150827"></p><p><strong>标记-整理</strong> 会将不被GC Root引用的对象回收，清理其占用的内存空间。然后整理剩余的对象（将其地址向前移动，使内存更为紧凑，连续空间更多），可以<strong>有效避免因内存碎片而导致的问题</strong>，但是因为整体需要消耗一定的时间，所以<strong>效率较低</strong></p><h4 id="2-3-复制-算法-Copy"><a href="#2-3-复制-算法-Copy" class="headerlink" title="2.3 复制 算法 (Copy)"></a>2.3 复制 算法 (Copy)</h4><p>将内存分为等大小的两个区域，FROM和TO（TO中为空）。</p><p>先将被GC Root引用的对象从FROM放入TO中，再回收不被GC Root引用的对象。然后交换FROM和TO。这样也可以避免内存碎片的问题，但是会<strong>占用双倍的内存空间</strong>。</p><ol><li>如下图，先采用标记算法确定可回收对象（图中为没有GC Root引用的块）</li></ol><p><img src="/2022/03/22/JVM-2/20200608150842.png" alt="20200608150842" style="zoom:75%;"></p><ol><li>将FROM区域中存活的对象复制到TO区域</li></ol><p><img src="/2022/03/22/JVM-2/20200608150856.png" alt="20200608150856" style="zoom:75%;"></p><ol><li>此时由于FROM区域中全是垃圾，全部清空</li></ol><p><img src="/2022/03/22/JVM-2/20200608150907.png" alt="20200608150907" style="zoom:75%;"></p><ol><li>交换 FROM 区域 和 TO 区域 的位置</li></ol><p><img src="/2022/03/22/JVM-2/20200608150919.png" alt="20200608150919" style="zoom:75%;"></p><h3 id="3-分代垃圾回收机制"><a href="#3-分代垃圾回收机制" class="headerlink" title="3 分代垃圾回收机制"></a>3 分代垃圾回收机制</h3><p><img src="/2022/03/22/JVM-2/20200608150931.png" alt="20200608150931"></p><p>如上图，我们将堆内存划分成两个部分，一个是左边的YoungGeneration新生代 (新生代又分为伊甸园Edin、幸存区FROM 和 幸存区TO 三个部分)，另一个是老年代OldGeneration。</p><p>Java中，长时间使用的对象放在老年代中，用完就可以丢弃的对象放在新生代中。这样就可以根据对象的存活时间的不同特点进行不用的回收策略。老年代中的垃圾回收很久发生一次，而新生代中回收更频繁。</p><h4 id="3-1-分代回收流程"><a href="#3-1-分代回收流程" class="headerlink" title="3.1 分代回收流程"></a>3.1 分代回收流程</h4><ol><li>新创建的对象都被放在了<strong>新生代的伊甸园</strong>中，伊甸园逐渐就会被占满。</li></ol><p><img src="/2022/03/22/JVM-2/20200608150939.png" alt="20200608150939"></p><p><img src="/2022/03/22/JVM-2/20200608150946.png" alt="20200608150946"></p><ol><li><p>当伊甸园中的内存不足时，就会进行一次垃圾回收，这时新生代的垃圾回收叫做 <strong>Minor GC</strong></p><p>(1) Minor GC触发后，采用“可达性分析算法”，沿着以GC Root对象（根对象）为起点的引用链，采用“标记算法”确定可回收对象；</p><p>(2) 标记完成后，采用“复制算法”将<strong>伊甸园和幸存区FROM</strong>存活的对象<strong>先</strong>复制到 <strong>幸存区 TO</strong>中， 并让其<strong>寿命加1</strong>；</p><p>(3) 根据复制算法，我们将交换 幸存区FROM 和 幸存区TO 的位置</p><p><img src="/2022/03/22/JVM-2/20200608150955.png" alt="20200608150955"></p></li></ol><p><img src="/2022/03/22/JVM-2/20200608151002.png" alt="20200608151002"></p><ol><li><p>再次创建对象，若新生代的伊甸园又满了，则会<strong>再次触发 Minor GC</strong>（会触发 <strong>“Stop the world”</strong>， 暂停其他用户线程，只让垃圾回收线程工作）；</p><p>这时不仅会回收伊甸园中的垃圾，<strong>还会回收幸存区中的垃圾</strong>，再将活跃对象复制到幸存区TO中；</p><p>回收以后会交换两个幸存区，并让幸存区中的对象<strong>寿命加1</strong></p></li></ol><p><img src="/2022/03/22/JVM-2/20200608151010.png" alt="20200608151010"></p><ol><li>如果幸存区中的对象的<strong>寿命超过某个阈值</strong>（最大为15，4bit），就会<strong>晋升到老年代</strong>中</li></ol><p><img src="/2022/03/22/JVM-2/20200608151018.png" alt="20200608151018"></p><ol><li>如果新生代老年代中的内存都满了，就会先触发Minor GC，再触发<strong>Full GC</strong> (整体清理)，也会触发“Stop the world”，时间更长，以扫描<strong>新生代和老年代中</strong>所有不再使用的对象并回收</li><li>如果老年代的内存也不够，内存分配失败，触发 <code>java.lang.OutOfMemoryError</code>。</li></ol><p><img src="/2022/03/22/JVM-2/IMG_FB5339E468EB-1.jpeg" alt="IMG_FB5339E468EB-1"></p><h4 id="3-2-相关虚拟机参数"><a href="#3-2-相关虚拟机参数" class="headerlink" title="3.2 相关虚拟机参数"></a>3.2 相关虚拟机参数</h4><div class="table-container"><table><thead><tr><th style="text-align:left">含义</th><th style="text-align:left">参数</th></tr></thead><tbody><tr><td style="text-align:left">堆初始大小</td><td style="text-align:left"><code>-Xms</code></td></tr><tr><td style="text-align:left">堆最大大小</td><td style="text-align:left"><code>-Xmx</code> 或 <code>-XX:MaxHeapSize=size</code></td></tr><tr><td style="text-align:left">新生代大小</td><td style="text-align:left"><code>-Xmn</code> 或 <code>-XX:NewSize=size + XX:MaxNewSize=size</code></td></tr><tr><td style="text-align:left">幸存区比例（动态）</td><td style="text-align:left"><code>-XX:InitialSurvivorRatio=ratio</code> 和 <code>-XX:+UseAdaptiveSizePolicy</code></td></tr><tr><td style="text-align:left">幸存区比例</td><td style="text-align:left"><code>-XX:SurvivorRatio=ratio</code></td></tr><tr><td style="text-align:left">晋升阈值</td><td style="text-align:left"><code>-XX:MaxTenuringThreshold=threshold</code></td></tr><tr><td style="text-align:left">晋升详情</td><td style="text-align:left"><code>-XX:+PrintTenuringDistribution</code></td></tr><tr><td style="text-align:left">GC详情</td><td style="text-align:left"><code>-XX:+PrintGCDetails -verbose:gc</code></td></tr><tr><td style="text-align:left">FullGC 前 MinorGC</td><td style="text-align:left"><code>-XX:+ScavengeBeforeFullGC</code></td></tr><tr><td style="text-align:left"></td></tr></tbody></table></div><h4 id="3-3-GC分析"><a href="#3-3-GC分析" class="headerlink" title="3.3  GC分析"></a>3.3  GC分析</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line">def new generationtotal 9216K, used 2309K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">edenspace 8192K,28% used [0x00000000fec00000, 0x00000000fee41460, 0x00000000ff400000)</span><br><span class="line">fromspace 1024K, 0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)</span><br><span class="line">tospace 1024K, 0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)</span><br><span class="line">tenured generationtotal 10240K, used 0K [0x00000000ff600000, 0x00000000ff600200, 0x0000000100000000)</span><br><span class="line"> the space 10240K, 0% used [0x00000000ff600000, 0x00000000ff600000, 0x00000000ff600200, 0x0000000100000000)</span><br><span class="line">Metaspaceused 3279K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">class spaceused 359K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure><h5 id="3-3-1-大对象处理策略"><a href="#3-3-1-大对象处理策略" class="headerlink" title="3.3.1 大对象处理策略"></a>3.3.1 大对象处理策略</h5><p>当遇到一个<strong>较大的对象</strong>时，就算新生代的<strong>伊甸园</strong>为空，也<strong>无法容纳该对象</strong>时，会将该对象<strong>直接晋升为老年代</strong></p><h5 id="3-3-2-线程内存溢出"><a href="#3-3-2-线程内存溢出" class="headerlink" title="3.3.2 线程内存溢出"></a>3.3.2 线程内存溢出</h5><p>某个线程的内存溢出了而抛异常 (<code>java.lang.OutOfMemoryError</code>)，不会让其他的线程结束运行，原因如下：</p><ul><li>当一个线程<strong>抛出OOM异常后</strong>，<strong>它所占据的内存资源会全部被释放掉</strong>，从而不会影响其他线程的运行，<strong>其他进程依然正常</strong></li></ul><h3 id="4-垃圾回收器"><a href="#4-垃圾回收器" class="headerlink" title="4 垃圾回收器"></a>4 垃圾回收器</h3><p>更新中…</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;JVM-基础学习&quot;&gt;&lt;a href=&quot;#JVM-基础学习&quot; class=&quot;headerlink&quot; title=&quot;JVM 基础学习&quot;&gt;&lt;/a&gt;JVM 基础学习&lt;/h1&gt;&lt;p&gt;视频课程: &lt;a href=&quot;https://www.bilibili.com/video/BV1yE411Z7AP?p=48&quot;&gt;BiliBili - 黑马程序员JVM完整教程: JVM垃圾回收&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;三、JVM-垃圾回收&quot;&gt;&lt;a href=&quot;#三、JVM-垃圾回收&quot; class=&quot;headerlink&quot; title=&quot;三、JVM 垃圾回收&quot;&gt;&lt;/a&gt;三、JVM 垃圾回收&lt;/h2&gt;&lt;h3 id=&quot;0-主要内容大纲&quot;&gt;&lt;a href=&quot;#0-主要内容大纲&quot; class=&quot;headerlink&quot; title=&quot;0 主要内容大纲&quot;&gt;&lt;/a&gt;0 主要内容大纲&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;如何判断对象可以回收&lt;/li&gt;
&lt;li&gt;垃圾回收算法&lt;/li&gt;
&lt;li&gt;分代垃圾回收&lt;/li&gt;
&lt;li&gt;垃圾回收器&lt;/li&gt;
&lt;li&gt;垃圾回收调优&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://dave0126.github.io/categories/JVM/"/>
    
    
    <category term="Java" scheme="https://dave0126.github.io/tags/Java/"/>
    
    <category term="JVM" scheme="https://dave0126.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java 虚拟机 - JVM 第一讲</title>
    <link href="https://dave0126.github.io/2022/03/22/JVM-1/"/>
    <id>https://dave0126.github.io/2022/03/22/JVM-1/</id>
    <published>2022-03-22T20:52:44.000Z</published>
    <updated>2022-03-23T22:59:48.864Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM-基础学习"><a href="#JVM-基础学习" class="headerlink" title="JVM 基础学习"></a>JVM 基础学习</h1><p>视频课程: <a href="https://www.bilibili.com/video/BV1yE411Z7AP">BiliBili - 黑马程序员JVM完整教程</a></p><p>Java Virtual Machine - java 程序的运行环境(Java 二进制字节码的运行环境)</p><p><strong>好处:</strong></p><ul><li>可以提供一个跨平台的一致的运行环境, 达到平台无关性;</li><li>提供内存管理, 垃圾回收功能;</li></ul><p>JRE = JVM + 基础类库<br>JDK = JVM + 基础类库 + 编译工具</p><span id="more"></span><h2 id="一、JVM-结构"><a href="#一、JVM-结构" class="headerlink" title="一、JVM 结构"></a>一、JVM 结构</h2><p><img src="/2022/03/22/JVM-1/1.png" alt="arch"></p><h2 id="二、JVM-内存结构"><a href="#二、JVM-内存结构" class="headerlink" title="二、JVM 内存结构"></a>二、JVM 内存结构</h2><ol><li>程序计数器 (Program Counter Register)</li><li>虚拟机栈 (JVM Stacks)</li><li>本地方法栈 (Native Method Stacks)</li><li>堆 (Heap)</li><li>方法区 (Method Area)</li></ol><h3 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1 程序计数器"></a>1 程序计数器</h3><p>作用: 在指令的执行中, 记住<strong>下一条JVM指令的执行地址</strong>. 在物理上可使用<strong>寄存器</strong>实现.</p><p>特点:</p><ul><li>线程私有. 在多线程下, 线程间切换时需要保存当前环境, 需要用到程序计数器记住下一条JVM指令的执行地址</li><li>不会存在内存溢出.</li></ul><h3 id="2-虚拟机栈"><a href="#2-虚拟机栈" class="headerlink" title="2 虚拟机栈"></a>2 虚拟机栈</h3><h4 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h4><p>回忆数据结构中“栈”的结构: 先进后出</p><p>虚拟机栈是<strong>线程运行需要的内存空间</strong>, <strong>一个栈由多个栈帧组成</strong>. 一个栈帧对应一次方法的调用, <strong>栈帧(Frame)</strong>即<strong>每个方法运行时需要的内存(参数、局部变量、返回地址等)</strong>.</p><ul><li>每个线程只能有一个活动栈帧,对应着当前正在执行的那个方法.</li></ul><p>可以在idea用debug模式下的“Debugger”视图中看到栈和栈帧.</p><p><strong>思考:</strong></p><ul><li>在函数的调用中, <ol><li>先把主调函数入栈, 调用被调函数, 紧接着被调函数入栈, 活动栈帧为被调函数;</li><li>等被调函数返回返回值时, 被调函数出栈, 活动栈帧为主调函数.</li></ol></li><li>垃圾回收不涉及栈内存, 因为每次执行后栈内存都会被清空(出栈)</li><li>栈内存越大, 线程数越小 (默认 1024KB)</li></ul><h4 id="2-2-栈内存溢出"><a href="#2-2-栈内存溢出" class="headerlink" title="2.2 栈内存溢出"></a>2.2 栈内存溢出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.StackOverflowError</span><br></pre></td></tr></table></figure><ol><li>栈帧过多导致内存溢出<ul><li>想象一下, 在不断的调用方法时, 一直入栈没有出栈, 直到某一次调用时无法分配新的栈帧内存. e.g.无递归终止条件的<strong>递归调用</strong></li></ul></li><li>栈帧过大导致内存溢出, 栈帧 &gt; 栈内存</li></ol><h4 id="2-3-线程运行诊断"><a href="#2-3-线程运行诊断" class="headerlink" title="2.3 线程运行诊断"></a>2.3 线程运行诊断</h4><p>JDK 自带一个工具“JStack“命令, 用于定位CPU占用过多的Java线程(TID). 根据线程id(TID)找到有问题的线程,即可能有问题的代码行数. 也可以发现<strong>有死锁的进程</strong>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack 进程id(PID)</span><br></pre></td></tr></table></figure><h3 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3 本地方法栈"></a>3 本地方法栈</h3><p>不是由Java代码编写的方法, 由于java语言限制, 不能直接和os底层“打交道”, 所以需要c/c++语言编写的方法直接与底层os“打交道”, 而java代码可以使用本地方法调用来调用这些方法.<br>本地方法使用的内存就是本地方法栈.</p><ul><li>e.g. <code>hashCode()</code>, <code>wait()</code>, <code>notify()</code>, <code>notifyAll()</code> 等</li><li>由 <code>native</code> 修饰</li></ul><h3 id="4-堆"><a href="#4-堆" class="headerlink" title="4 堆"></a>4 堆</h3><p>线程共享的区域</p><h4 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h4><ul><li>通过 <code>new</code> 关键字 -&gt; 创建一个堆, 都会使用堆的内存</li></ul><p>特点:</p><ul><li><strong>线程共享</strong>, 堆中对象都要考虑线程安全问题</li><li>有垃圾回收机制, 当对象不再被时, 其占用的内存会被回收</li></ul><h4 id="4-2-堆内存溢出"><a href="#4-2-堆内存溢出" class="headerlink" title="4.2 堆内存溢出"></a>4.2 堆内存溢出</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 创建堆</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            list.add(a);</span><br><span class="line">            a = a + a; <span class="comment">// Hello, HelloHello, HelloHelloHelloHello, ....</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-堆内存诊断"><a href="#4-3-堆内存诊断" class="headerlink" title="4.3 堆内存诊断"></a>4.3 堆内存诊断</h4><p>java常用工具:</p><ol><li>jps 工具<ul><li>查看当前系统中有哪些java进程</li></ul></li><li>jmap 工具 <ul><li>查看某一时刻下,堆内存的占用情况</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ jps</span><br><span class="line">$ jmap -heap 进程id(PID)</span><br></pre></td></tr></table></figure><ol><li>jconsole 工具<ul><li>图形界面的, 多功能的检查工具, 可以连续监测</li></ul></li><li>jvisualvm 工具 (需要自行下载)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;1....&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">    <span class="type">byte</span>[] array = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>];  <span class="comment">// 堆中内存占用新增10MB</span></span><br><span class="line">    System.out.println(<span class="string">&quot;2....&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">    array = <span class="literal">null</span>;</span><br><span class="line">    System.gc();                                <span class="comment">// 垃圾回收</span></span><br><span class="line">    System.out.println(<span class="string">&quot;3....&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5 方法区"></a>5 方法区</h3><h4 id="5-1-定义"><a href="#5-1-定义" class="headerlink" title="5.1 定义"></a>5.1 定义</h4><p>方法区是JVM中<strong>所有线程共享</strong>的区域.</p><p>存储了<strong>与类结构相关的信息</strong>: </p><ul><li>成员变量(field)</li><li>方法的数据(method data)</li><li>方法的代码(code of method)</li><li>构造器的代码(code of constructor)</li><li>运行时常量池(run-time constant pool)</li></ul><p>方法区在JVM启动时创建, 逻辑上是堆的一部分.</p><h4 id="5-2-组成"><a href="#5-2-组成" class="headerlink" title="5.2 组成"></a>5.2 组成</h4><p>JDK1.6 与 JDK1.8<br><img src="/2022/03/22/JVM-1/IMG_6B2CE85A4DCA-1.jpeg" alt="methodArea"></p><h4 id="5-3-方法区的内存溢出"><a href="#5-3-方法区的内存溢出" class="headerlink" title="5.3 方法区的内存溢出"></a>5.3 方法区的内存溢出</h4><ul><li>永久代内存溢出（JDK 1.8以前）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: PermGen space</span><br><span class="line">-XX:MaxPermSize=8m</span><br></pre></td></tr></table></figure><ul><li>元空间内存溢出（JDK 1.8以后）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Metaspace</span><br><span class="line">-XX:MaxMetaspaceSize=8m</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123; <span class="comment">// 类加载器: 可以用来加载类的二进制字节码, 动态加载</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Demo</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++, j++) &#123;</span><br><span class="line">                <span class="type">ClassWriter</span> <span class="variable">cw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(<span class="number">0</span>); <span class="comment">// ClassWriter作用是生成类的二进制字节码</span></span><br><span class="line">                <span class="comment">// 版本号, public, 类名:1~10000, 包名:null, 父类: 继承自&quot;java/lang/Object&quot;, 接口名:null</span></span><br><span class="line">                cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, <span class="string">&quot;Class&quot;</span> + i, <span class="literal">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">                <span class="comment">//返回 byte[]</span></span><br><span class="line">                <span class="type">byte</span>[] code = cw.toByteArray();</span><br><span class="line">                <span class="comment">// 只执行类的加载, 而不链接</span></span><br><span class="line">                test.defineClass(<span class="string">&quot;Class&quot;</span> + i, code, <span class="number">0</span>, code.length); <span class="comment">// class 对象</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有可能的溢出场景：实际生产中，动态产生并加载类时容易产生这种内存溢出</p><ol><li>Spring框架 中的cglib字节码技术，AOP的核心 - 生成动态代理类</li><li>Mybatis框架 中的cglib字节码技术</li></ol><h4 id="5-4-运行时常量池"><a href="#5-4-运行时常量池" class="headerlink" title="5.4 运行时常量池"></a>5.4 运行时常量池</h4><p>编译后的二进制字节码包含: 类基本信息、常量池、类方法定义、虚拟机指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -v &lt;xxx.class&gt; // -v 显示反编译后的详细信息</span><br></pre></td></tr></table></figure><p>例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后的详细信息: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">Classfile /学习笔记/JVM学习笔记/test.class</span><br><span class="line">  Last modified 2022年3月6日; size 413 bytes</span><br><span class="line">  SHA-256 checksum 7ab757ee2d78f0e76a52ba8b03b43fee2fe9d7994d74bc7d133b2e309ceed8f3</span><br><span class="line">  Compiled from <span class="string">&quot;test.java&quot;</span></span><br><span class="line">public class <span class="built_in">test</span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 59</span><br><span class="line">  flags: (0x0021) ACC_PUBLIC, ACC_SUPER// 访问修饰符</span><br><span class="line">  this_class: <span class="comment">#21                         // test</span></span><br><span class="line">  super_class: <span class="comment">#2                         // 父类:java/lang/Object</span></span><br><span class="line">  interfaces: 0, fields: 0, methods: 2, attributes: 1</span><br><span class="line">Constant pool:// 常量池</span><br><span class="line">   <span class="comment">#1 = Methodref          #2.#3          // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   <span class="comment">#2 = Class              #4             // java/lang/Object</span></span><br><span class="line">   <span class="comment">#3 = NameAndType        #5:#6          // &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   <span class="comment">#4 = Utf8               java/lang/Object</span></span><br><span class="line">   <span class="comment">#5 = Utf8               &lt;init&gt;</span></span><br><span class="line">   <span class="comment">#6 = Utf8               ()V</span></span><br><span class="line">   <span class="comment">#7 = Fieldref           #8.#9          // java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   <span class="comment">#8 = Class              #10            // java/lang/System</span></span><br><span class="line">   <span class="comment">#9 = NameAndType        #11:#12        // out:Ljava/io/PrintStream;</span></span><br><span class="line">  <span class="comment">#10 = Utf8               java/lang/System</span></span><br><span class="line">  <span class="comment">#11 = Utf8               out</span></span><br><span class="line">  <span class="comment">#12 = Utf8               Ljava/io/PrintStream;</span></span><br><span class="line">  <span class="comment">#13 = String             #14            // Hello World</span></span><br><span class="line">  <span class="comment">#14 = Utf8               Hello World</span></span><br><span class="line">  <span class="comment">#15 = Methodref          #16.#17        // java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">  <span class="comment">#16 = Class              #18            // java/io/PrintStream</span></span><br><span class="line">  <span class="comment">#17 = NameAndType        #19:#20        // println:(Ljava/lang/String;)V</span></span><br><span class="line">  <span class="comment">#18 = Utf8               java/io/PrintStream</span></span><br><span class="line">  <span class="comment">#19 = Utf8               println</span></span><br><span class="line">  <span class="comment">#20 = Utf8               (Ljava/lang/String;)V</span></span><br><span class="line">  <span class="comment">#21 = Class              #22            // test</span></span><br><span class="line">  <span class="comment">#22 = Utf8               test</span></span><br><span class="line">  <span class="comment">#23 = Utf8               Code</span></span><br><span class="line">  <span class="comment">#24 = Utf8               LineNumberTable</span></span><br><span class="line">  <span class="comment">#25 = Utf8               main</span></span><br><span class="line">  <span class="comment">#26 = Utf8               ([Ljava/lang/String;)V</span></span><br><span class="line">  <span class="comment">#27 = Utf8               SourceFile</span></span><br><span class="line">  <span class="comment">#28 = Utf8               test.java</span></span><br><span class="line">&#123;</span><br><span class="line">  public <span class="built_in">test</span>();// 当程序没有构造方法时, 编译器会自动生成一个无参的构造方法</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (0x0001) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial <span class="comment">#1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         4: <span class="built_in">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 1: 0</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);// main方法</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: (0x0009) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">      // 虚拟机指令<span class="comment">#n: 对应着常量池中的变量</span></span><br><span class="line">         0: getstatic     <span class="comment">#7                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         3: ldc           <span class="comment">#13                 // String Hello World 加载引用地址</span></span><br><span class="line">         5: invokevirtual <span class="comment">#15                 // Method java/io/PrintStream.println:(Ljava/lang/String;方法的参数类型)V 虚拟方法调用</span></span><br><span class="line">         8: <span class="built_in">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">        line 4: 8</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;test.java&quot;</span></span><br></pre></td></tr></table></figure><ul><li>以上的例子表明, <strong>常量池</strong>就是一张常量表, 虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量(如字符串、整型、bool类型等)等信息</li><li>运行时常量池, 就是当该类被加载时, 它的常量池信息会放入运行常量池, 地址会替换为真正的内存地址</li></ul><h4 id="5-5-StringTable串池"><a href="#5-5-StringTable串池" class="headerlink" title="5.5 StringTable串池"></a>5.5 StringTable串池</h4><p>特征：</p><ul><li><p>常量池中的信息，都会被加载到运行时常量池中。这时a b ab都是常量池中的符号，<strong>还不是 java字符串对象</strong></p></li><li><p>常量池中的字符串仅是符号，只有<strong>在被第一次引用到时才会转化为对象</strong>，ldc</p></li><li><p>StringTable在内存结构上是哈希表，不能扩容</p></li><li><p>利用串池的机制，来避免重复创建字符串对象</p></li><li><p>字符串<strong>变量</strong>拼接的原理是<strong>StringBuilder</strong></p></li><li><p>字符串<strong>常量</strong>拼接的原理是<strong>编译器优化</strong></p></li><li><p>可以使用<strong>intern方法</strong>，主动将串池中还没有的字符串对象放入串池中</p><p><strong>注意</strong>：无论是串池还是堆里面的字符串，都是对象</p></li></ul><h5 id="5-5-1-串池"><a href="#5-5-1-串池" class="headerlink" title="5.5.1 串池"></a>5.5.1 串池</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableStudy</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>; </span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">ab</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常量池中的信息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0: ldc           <span class="comment">#2                  // String a</span></span><br><span class="line">2: astore_1// 把 a符号 变成 “a”字符串对象</span><br><span class="line">3: ldc           <span class="comment">#3                 // String b</span></span><br><span class="line">5: astore_2// 把 b符号 变成 “b”字符串对象</span><br><span class="line">6: ldc           <span class="comment">#4                  // String ab</span></span><br><span class="line">8: astore_3// 把 ab符号 变成 “ab”字符串对象</span><br><span class="line">9: <span class="built_in">return</span></span><br></pre></td></tr></table></figure><ol><li><p>当执行到 ldc #2 时，会把符号 a 变为 “a” 字符串对象，<strong>并放入串池中</strong>（hashtable结构 不可扩容）</p></li><li><p>当执行到 ldc #3 时，会把符号 b 变为 “b” 字符串对象，并放入串池中</p></li><li><p>当执行到 ldc #4 时，会把符号 ab 变为 “ab” 字符串对象，并放入串池中</p></li><li><p>最终<strong>StringTable [“a”, “b”, “ab”]</strong></p><p><strong>注意</strong>：字符串对象的创建都是<strong>懒惰的</strong>，只有当运行到那一行字符串且在串池中不存在的时候（如 ldc #2）时，该字符串才会被创建并放入串池中。</p></li></ol><h5 id="5-5-2-串池：拼接变量字符串对象创建字符串"><a href="#5-5-2-串池：拼接变量字符串对象创建字符串" class="headerlink" title="5.5.2 串池：拼接变量字符串对象创建字符串"></a>5.5.2 串池：拼接变量字符串对象创建字符串</h5><p>使用拼接<strong>字符串变量对象</strong>创建字符串的过程: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableStudy</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">ab</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">ab2</span> <span class="operator">=</span> a+b;  <span class="comment">// 拼接字符串对象来创建新的字符串 new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toSrting()</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(ab == ab2); <span class="comment">// 结果为false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">    stack=2, locals=5, args_size=1</span><br><span class="line">       0: ldc           <span class="comment">#2                  // String a</span></span><br><span class="line">       2: astore_1</span><br><span class="line">       3: ldc           <span class="comment">#3                  // String b</span></span><br><span class="line">       5: astore_2</span><br><span class="line">       6: ldc           <span class="comment">#4                  // String ab</span></span><br><span class="line">       8: astore_3</span><br><span class="line">       9: new           <span class="comment">#5                  // class java/lang/StringBuilder</span></span><br><span class="line">      12: dup</span><br><span class="line">      13: invokespecial <span class="comment">#6                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">      16: aload_1</span><br><span class="line">      17: invokevirtual <span class="comment">#7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">      20: aload_2</span><br><span class="line">      21: invokevirtual <span class="comment">#7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">      24: invokevirtual <span class="comment">#8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">      27: astore        4</span><br><span class="line">      29: <span class="built_in">return</span></span><br></pre></td></tr></table></figure><p>通过拼接的方式来创建字符串的<strong>过程</strong>是：new StringBuilder().append(“a”).append(“b”).toString()，地址应该在<strong>堆</strong>中</p><p>最后的toString方法的返回值是一个<strong>新的字符串</strong>，但字符串的<strong>值</strong>和拼接的字符串一致，但是两个不同的字符串，<strong>一个存在于串池之中，一个存在于堆内存之中</strong></p><h5 id="5-5-3-串池：拼接常量字符串对象的方法创建字符串"><a href="#5-5-3-串池：拼接常量字符串对象的方法创建字符串" class="headerlink" title="5.5.3 串池：拼接常量字符串对象的方法创建字符串"></a>5.5.3 串池：<strong>拼接常量字符串对象</strong>的方法创建字符串</h5><p>使用<strong>拼接字符串常量对象</strong>的方法创建字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableStudy</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">ab</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ab2</span> <span class="operator">=</span> a+b;</span><br><span class="line"><span class="type">String</span> <span class="variable">ab3</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>; <span class="comment">// 使用拼接字符串的方法创建字符串，由于编译期间的优化</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(ab == ab3); <span class="comment">// 结果为true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">  stack=2, locals=6, args_size=1</span><br><span class="line">     0: ldc           <span class="comment">#2                  // String a</span></span><br><span class="line">     2: astore_1</span><br><span class="line">     3: ldc           <span class="comment">#3                  // String b</span></span><br><span class="line">     5: astore_2</span><br><span class="line">     6: ldc           <span class="comment">#4                  // String ab</span></span><br><span class="line">     8: astore_3</span><br><span class="line">     9: new           <span class="comment">#5                  // class java/lang/StringBuilder</span></span><br><span class="line">    12: dup</span><br><span class="line">    13: invokespecial <span class="comment">#6                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">    16: aload_1</span><br><span class="line">    17: invokevirtual <span class="comment">#7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">    20: aload_2</span><br><span class="line">    21: invokevirtual <span class="comment">#7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">    24: invokevirtual <span class="comment">#8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">    27: astore        4//ab3初始化时直接从串池中获取字符串</span><br><span class="line">    29: ldc           <span class="comment">#4                  // String ab</span></span><br><span class="line">    31: astore        5</span><br><span class="line">    33: <span class="built_in">return</span></span><br></pre></td></tr></table></figure><ul><li><p>当虚拟机执行到<strong>第0、3、5行</strong>时，会将“a” “b“ ”ab“放入串池。当执行到<strong>29行</strong>时我们可以看到，虚拟机不会先找“a” 再找“b”然后再将它们拼接起来，而是之间找到拼接后的“ab”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringTable[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;ab&quot;</span>]</span><br></pre></td></tr></table></figure></li><li><p>使用<strong>拼接字符串常量</strong>的方法来创建新的字符串时，因为<strong>内容是常量，javac在编译期会进行优化，结果已在编译期确定为ab</strong>，而创建ab的时候已经在串池中放入了“ab”，所以ab3直接从串池中获取值，所以进行的操作和 ab = “ab” 一致。</p></li><li><p>使用<strong>拼接字符串变量</strong>的方法来创建新的字符串时，因为内容是变量，只能<strong>在运行期确定它的值，所以需要使用StringBuilder来创建</strong></p></li></ul><h5 id="5-5-4-串池：intern方法-JDK1-8"><a href="#5-5-4-串池：intern方法-JDK1-8" class="headerlink" title="5.5.4 串池：intern方法(JDK1.8)"></a>5.5.4 串池：intern方法(JDK1.8)</h5><p>调用字符串对象的intern()方法，会将该字符串对象尝试放入到串池中</p><ul><li>如果串池中没有该字符串对象，则放入成功</li><li>如果有该字符串对象，则放入失败</li><li>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</li></ul><p>Example1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableInternMethod1</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">/* &quot;a&quot; &quot;b&quot; 被放入串池中，str则存在于堆内存之中 */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 调用str的intern方法，这时串池中没有&quot;ab&quot;，则会将该字符串对象放入到串池中，此时堆内存与串池中的&quot;ab&quot;是同一个对象*/</span></span><br><span class="line"><span class="type">String</span> <span class="variable">st2</span> <span class="operator">=</span> str.intern();</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 给str3赋值，因为此时串池中已有&quot;ab&quot;，则直接将串池中的内容返回 */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 因为堆内存与串池中的&quot;ab&quot;是同一个对象，所以以下两条语句打印的都为true */</span></span><br><span class="line">System.out.println(str == st2);</span><br><span class="line">System.out.println(str == str3);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Example2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SringTableInternMethod2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">/* 此处创建字符串对象&quot;ab&quot;，因为串池中还没有&quot;ab&quot;，所以将其放入串池中 */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="comment">/* &quot;a&quot; &quot;b&quot; 被放入串池中，str则存在于堆内存之中 */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="comment">/* 此时因为在创建str3时，&quot;ab&quot;已存在与串池中，所以放入失败，但是会返回串池中的&quot;ab&quot; */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> str.intern();</span><br><span class="line">    </span><br><span class="line">System.out.println(str == str2); <span class="comment">//false</span></span><br><span class="line">System.out.println(str == str3); <span class="comment">//false</span></span><br><span class="line">System.out.println(str2 == str3); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-5-5-串池的位置"><a href="#5-5-5-串池的位置" class="headerlink" title="5.5.5 串池的位置"></a>5.5.5 串池的位置</h5><p>在JDK1.8中：</p><p><img src="/2022/03/22/JVM-1/IMG_42907AA7BAF6-1.jpeg" alt="StringTable1.8"></p><p>在JDK1.6中：</p><p><img src="/2022/03/22/JVM-1/IMG_9A689689FB20-1.jpeg" alt="1.6" style="zoom: 60%;"></p><h5 id="5-5-6-串池的垃圾回收"><a href="#5-5-6-串池的垃圾回收" class="headerlink" title="5.5.6 串池的垃圾回收"></a>5.5.6 串池的垃圾回收</h5><p>StringTable在内存紧张时，会发生垃圾回收。</p><h5 id="5-5-7-串池的性能调优"><a href="#5-5-7-串池的性能调优" class="headerlink" title="5.5.7 串池的性能调优"></a>5.5.7 串池的性能调优</h5><ul><li><p>因为StringTable是用HashTable实现的，所以我们可以<strong>适当增加HashTable的桶的个数</strong>，来减少字符串放入串池所需要的时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:StringTableSize=xxxx</span><br></pre></td></tr></table></figure></li><li><p>考虑是否需要将字符串对象入池，可以通过<strong>intern()方法减少重复入池</strong></p></li></ul><h3 id="6-直接内存"><a href="#6-直接内存" class="headerlink" title="6 直接内存"></a>6 直接内存</h3><h4 id="6-1-定义"><a href="#6-1-定义" class="headerlink" title="6.1 定义"></a>6.1 定义</h4><p>直接内存不属于JVM内存结构，而是<strong>操作系统的内存</strong>。</p><ul><li>属于操作系统，常见于NIO操作时，<strong>用于数据缓冲区</strong></li><li>分配回收成本较高，但读写性能高</li><li>不受JVM内存回收管理</li></ul><h4 id="6-2-基本使用"><a href="#6-2-基本使用" class="headerlink" title="6.2 基本使用"></a>6.2 基本使用</h4><p><img src="/2022/03/22/JVM-1/20200608150715.png" alt="123" style="zoom:60%;"></p><p>使用了DirectBuffer后</p><p><img src="/2022/03/22/JVM-1/20200608150736.png" alt="234" style="zoom:60%;"></p><p>直接内存是操作系统和Java代码<strong>都可以访问的一块区域</strong>，无需将代码从系统内存复制到Java堆内存，从而提高了效率</p><h4 id="6-3-分配和回收原理"><a href="#6-3-分配和回收原理" class="headerlink" title="6.3 分配和回收原理"></a>6.3 分配和回收原理</h4><ul><li>使用了Unsafe类来完成直接内存的分配回收，而且回收需要主动调用<strong>unsafe.freeMemory()</strong>方法</li><li>ByteBuffer的实现内部使用了Cleaner（虚引用）来检测ByteBuffer。一旦ByteBuffer被垃圾回收，那么会由ReferenceHandler来调用Cleaner的clean方法调用freeMemory来释放内存</li></ul><p>直接内存的回收不是通过JVM的垃圾回收来释放的，而是通过<strong>unsafe.freeMemory()</strong>来手动释放</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过ByteBuffer申请1M的直接内存</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(_1M);</span><br></pre></td></tr></table></figure><p>申请直接内存，但JVM并不能回收直接内存中的内容，它是如何实现回收的呢？</p><h5 id="allocateDirect-的实现底层源码分析"><a href="#allocateDirect-的实现底层源码分析" class="headerlink" title="allocateDirect() 的实现底层源码分析"></a>allocateDirect() 的实现底层源码分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title function_">allocateDirect</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectByteBuffer</span>(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DirectByteBuffer类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">DirectByteBuffer(<span class="type">int</span> cap) &#123;   <span class="comment">// package-private</span></span><br><span class="line">   </span><br><span class="line">    <span class="built_in">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">pa</span> <span class="operator">=</span> VM.isDirectMemoryPageAligned();</span><br><span class="line">    <span class="type">int</span> <span class="variable">ps</span> <span class="operator">=</span> Bits.pageSize();</span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> Math.max(<span class="number">1L</span>, (<span class="type">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        base = unsafe.allocateMemory(size); <span class="comment">//申请内存</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.setMemory(base, size, (<span class="type">byte</span>) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// Round up to page boundary</span></span><br><span class="line">        address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    cleaner = Cleaner.create(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">Deallocator</span>(base, size, cap)); <span class="comment">//通过虚引用，来实现直接内存的释放，this为虚引用的实际对象</span></span><br><span class="line">    att = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了一个Cleaner的create()方法，且后台线程还会对虚引用的对象监测，如果虚引用的实际对象（这里是DirectByteBuffer）被回收以后，就会调用Cleaner的clean()方法，来清除直接内存中占用的内存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clean</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (remove(<span class="built_in">this</span>)) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="built_in">this</span>.thunk.run(); <span class="comment">//调用run方法</span></span><br><span class="line">           &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable var2) &#123;</span><br><span class="line">               AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">                   <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                       <span class="keyword">if</span> (System.err != <span class="literal">null</span>) &#123;</span><br><span class="line">                           (<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Cleaner terminated abnormally&quot;</span>, var2)).printStackTrace();</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       System.exit(<span class="number">1</span>);</span><br><span class="line">                       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><p>对应对象的run()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (address == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Paranoia</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.freeMemory(address); <span class="comment">//释放直接内存中占用的内存</span></span><br><span class="line">    address = <span class="number">0</span>;</span><br><span class="line">    Bits.unreserveMemory(size, capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;JVM-基础学习&quot;&gt;&lt;a href=&quot;#JVM-基础学习&quot; class=&quot;headerlink&quot; title=&quot;JVM 基础学习&quot;&gt;&lt;/a&gt;JVM 基础学习&lt;/h1&gt;&lt;p&gt;视频课程: &lt;a href=&quot;https://www.bilibili.com/video/BV1yE411Z7AP&quot;&gt;BiliBili - 黑马程序员JVM完整教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Java Virtual Machine - java 程序的运行环境(Java 二进制字节码的运行环境)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;好处:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以提供一个跨平台的一致的运行环境, 达到平台无关性;&lt;/li&gt;
&lt;li&gt;提供内存管理, 垃圾回收功能;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JRE = JVM + 基础类库&lt;br&gt;JDK = JVM + 基础类库 + 编译工具&lt;/p&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://dave0126.github.io/categories/JVM/"/>
    
    
    <category term="Java" scheme="https://dave0126.github.io/tags/Java/"/>
    
    <category term="JVM" scheme="https://dave0126.github.io/tags/JVM/"/>
    
  </entry>
  
</feed>
