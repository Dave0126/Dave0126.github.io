<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lost N Found</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-03-22T21:41:27.922Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Guohao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java 虚拟机 - JVM 第二讲</title>
    <link href="http://example.com/2022/03/22/JVM-2/"/>
    <id>http://example.com/2022/03/22/JVM-2/</id>
    <published>2022-03-22T21:36:23.000Z</published>
    <updated>2022-03-22T21:41:27.922Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM-基础学习"><a href="#JVM-基础学习" class="headerlink" title="JVM 基础学习"></a>JVM 基础学习</h1><p>视频课程: <a href="https://www.bilibili.com/video/BV1yE411Z7AP?p=48">BiliBili - 黑马程序员JVM完整教程: JVM垃圾回收</a></p><h2 id="三、JVM-垃圾回收"><a href="#三、JVM-垃圾回收" class="headerlink" title="三、JVM 垃圾回收"></a>三、JVM 垃圾回收</h2><h3 id="0-主要内容大纲"><a href="#0-主要内容大纲" class="headerlink" title="0 主要内容大纲"></a>0 主要内容大纲</h3><ol><li>如何判断对象可以回收</li><li>垃圾回收算法</li><li>分代垃圾回收</li><li>垃圾回收器</li><li>垃圾回收调优</li></ol><span id="more"></span><h3 id="1-如何判断对象可以被回收"><a href="#1-如何判断对象可以被回收" class="headerlink" title="1 如何判断对象可以被回收"></a>1 如何判断对象可以被回收</h3><h4 id="1-1-引用计数法"><a href="#1-1-引用计数法" class="headerlink" title="1.1 引用计数法"></a>1.1 引用计数法</h4><p>只要一个对象被其他变量所引用，那我们就让这个对象的计数加1，如果被引用两次，该计数就为2。如果某个变量不再引用这个对象，该对象的引用计数减1。当计数为0时，表示没有变量引用这个对象了，则可作为垃圾回收掉。</p><img src="/2022/03/22/JVM-2/20200608150750 (1).png" alt="20200608150750 (1)" style="zoom:75%;"><ul><li>弊端：在例如上图的循环引用时，两个对象的计数都为1，导致两个对象都无法被释放</li></ul><h4 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2 可达性分析算法"></a>1.2 可达性分析算法</h4><p>首先先要确定根对象。那么什么是根对象呢？就是那些肯定不能被当成垃圾回收的对象。</p><p>在垃圾回收之前，我们先扫描堆内存中的所有对象，检查对象是否被根对象直接或者间接的引用。若是，则不能被回收；反之则可以被回收。</p><ul><li>JVM中的垃圾回收器通过<strong>可达性分析</strong>来探索所有存活的对象</li><li>扫描堆中的对象，看能否沿着GC Root对象（根对象）为起点的引用链找到该对象，如果<strong>找不到，则表示可以回收</strong></li><li>可以作为GC Root的对象：<ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。　</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li></ul></li></ul><h4 id="1-3-五种引用"><a href="#1-3-五种引用" class="headerlink" title="1.3 五种引用"></a>1.3 五种引用</h4><p><img src="/2022/03/22/JVM-2/20200608150800.png" alt="20200608150800"></p><h5 id="1-3-1-强引用"><a href="#1-3-1-强引用" class="headerlink" title="1.3.1 强引用"></a>1.3.1 强引用</h5><p>如上图，实线箭头表示强引用。日常使用中的引用都属于强引用。例如，new一个对象，使用“&#x3D;”将该对象赋值给一个变量，那么这个变量就强引用该对象。</p><p>只有GC Root<strong>都不引用</strong>该对象时，才会回收<strong>强引用</strong>对象</p><ul><li>如上图B、C对象都不引用A1对象时，A1对象才会被回收</li></ul><h5 id="1-3-2-软引用-SoftReference"><a href="#1-3-2-软引用-SoftReference" class="headerlink" title="1.3.2 软引用 (SoftReference)"></a>1.3.2 软引用 (SoftReference)</h5><p>当内存空间有限时，一些不重要的资源可以用软引用。</p><p>只要A2、A3两个对象没有被直接的强引用所引用，当垃圾回收发生时，都有可以被回收。</p><p>当GC Root指向软引用对象（垃圾回收）时，在<strong>内存不足时</strong>，会<strong>回收软引用所引用的对象</strong>。（先回收一次，如果内存还不够，回收软引用所引用的对象）</p><ul><li>如上图如果B对象不再引用A2对象且内存不足时，软引用所引用的A2对象就会被回收</li></ul><p>案列1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoSortReference1</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">_4M</span> <span class="operator">=</span> <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="comment">//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span></span><br><span class="line">List&lt;SoftReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 强引用</span></span><br><span class="line">SoftReference&lt;<span class="type">byte</span>[]&gt; ref= <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[_4M]); <span class="comment">// 软引用</span></span><br><span class="line">    <span class="comment">// List list --强--&gt; SoftReference ref --软--&gt; byte[_4M]</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在垃圾回收时发现内存不足，在回收软引用所指向的对象时，<strong>软引用本身不会被清理</strong></p><p>如果想要<strong>清理软引用</strong>，需要使<strong>用引用队列</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoSortReference2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">_4M</span> <span class="operator">=</span> <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//使用引用队列，用于移除引用为空的软引用对象</span></span><br><span class="line">ReferenceQueue&lt;<span class="type">byte</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;(); <span class="comment">// 引用队列</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span></span><br><span class="line">List&lt;SoftReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 强引用</span></span><br><span class="line">SoftReference&lt;<span class="type">byte</span>[]&gt; ref= <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[_4M]); <span class="comment">// 软引用</span></span><br><span class="line">    <span class="comment">// List list --强--&gt; SoftReference ref --软--&gt; byte[_4M]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历引用队列，如果有元素，则取出</span></span><br><span class="line">Reference&lt;? <span class="keyword">extends</span> <span class="title class_">byte</span>[]&gt; poll = queue.poll(); <span class="comment">// poll(), 取出最先放入队列的元素，返回类型Reference</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span>(poll != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//引用队列不为空，则从集合中移除该元素</span></span><br><span class="line">list.remove(poll);</span><br><span class="line"><span class="comment">//移动到引用队列中的下一个元素</span></span><br><span class="line">poll = queue.poll();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>大概思路为：</strong>查看引用队列中有无软引用，如果有，则将该软引用从存放它的集合中移除（这里为一个list集合）</p><h5 id="1-3-3-弱引用-WeakReferrnce"><a href="#1-3-3-弱引用-WeakReferrnce" class="headerlink" title="1.3.3 弱引用 (WeakReferrnce)"></a>1.3.3 弱引用 (WeakReferrnce)</h5><p>只有弱引用引用该对象时，在垃圾回收时，<strong>无论内存是否充足</strong>，都会回收弱引用所引用的对象</p><ul><li>如上图如果B对象不再引用A3对象，则A3对象会被回收</li></ul><p><strong>弱引用的使用和软引用类似</strong>，只是将 <strong>SoftReference 换为了 WeakReference</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoWeakReference1</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">_4M</span> <span class="operator">=</span> <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="comment">//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是弱引用</span></span><br><span class="line">List&lt;WeakReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 强引用</span></span><br><span class="line">WeakReference&lt;<span class="type">byte</span>[]&gt; ref= <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[_4M]); <span class="comment">// 弱引用</span></span><br><span class="line">    <span class="comment">// List list --强--&gt; WeakReference ref --弱--&gt; byte[_4M]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用引用队列，用于移除引用为空的软引用对象</span></span><br><span class="line">ReferenceQueue&lt;<span class="type">byte</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;(); <span class="comment">// 引用队列</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历引用队列，如果有元素，则取出</span></span><br><span class="line">Reference&lt;? <span class="keyword">extends</span> <span class="title class_">byte</span>[]&gt; poll = queue.poll(); <span class="comment">// poll(), 取出最先放入队列的元素，返回类型Reference</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span>(poll != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//引用队列不为空，则从集合中移除该元素</span></span><br><span class="line">list.remove(poll);</span><br><span class="line"><span class="comment">//移动到引用队列中的下一个元素</span></span><br><span class="line">poll = queue.poll();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-3-4-虚引用-PhantomReference"><a href="#1-3-4-虚引用-PhantomReference" class="headerlink" title="1.3.4 虚引用 (PhantomReference)"></a>1.3.4 虚引用 (PhantomReference)</h5><p>必须配合引用队列一同使用。当虚（终结器）引用被创建时，会关联一个引用队列。</p><p>当虚引用对象所引用的对象被回收以后，虚引用对象就会被放入引用队列中，调用虚引用的方法</p><ul><li>虚引用的一个体现是<strong>释放直接内存所分配的内存</strong>，当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean()方法来释放直接内存</li><li>如上图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象Cleaner放入引用队列中，然后调用它的clean方法来释放直接内存</li></ul><h5 id="1-3-5-终结器引用-FinalReference"><a href="#1-3-5-终结器引用-FinalReference" class="headerlink" title="1.3.5 终结器引用 (FinalReference)"></a>1.3.5 终结器引用 (FinalReference)</h5><p>所有的对象都继承自Object类，Object类有一个finalize()方法。当某个对象不再被其他的对象所引用时，会先将终结器引用对象放入引用队列中(处理这个引用队列的<em>FinalizeHandler线程</em>优先级很低)，然后根据终结器引用对象找到它所引用的对象，然后调用该对象的finalize()方法。调用以后，该对象就可以被垃圾回收了。</p><ul><li>如上图，B对象不再引用A4对象。这是终结器对象就会被放入引用队列中，引用队列会根据它，找到它所引用的对象。然后调用被引用对象的finalize()方法。调用以后，该对象就可以被垃圾回收了</li></ul><h3 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2 垃圾回收算法"></a>2 垃圾回收算法</h3><h4 id="2-1-标记-清除-算法-Mark-Sweep"><a href="#2-1-标记-清除-算法-Mark-Sweep" class="headerlink" title="2.1 标记 - 清除 算法 (Mark - Sweep)"></a>2.1 标记 - 清除 算法 (Mark - Sweep)</h4><img src="/2022/03/22/JVM-2/20200608150813.png" alt="20200608150813" style="zoom:67%;"><p><strong>定义</strong>：标记清除算法顾名思义，是指在虚拟机执行垃圾回收的过程中，先采用标记算法确定可回收对象（图中为没有GC Root引用的块），然后垃圾收集器根据标识清除相应的内容，给堆内存腾出相应的空间。</p><ul><li>这里的腾出内存空间并不是将内存空间的字节清0，而是记录下这段内存的起始结束地址，下次分配内存的时候，会直接<strong>覆盖</strong>这段内存。同理于操作系统中的内存管理</li></ul><p>优点：垃圾回收速度快</p><p><strong>缺点</strong>：<strong>容易产生大量的内存碎片</strong>，可能无法满足大对象的内存分配，一旦导致无法分配对象，那就会导致jvm启动gc，一旦启动gc，我们的应用程序就会暂停，这就导致应用的响应速度变慢。同理于操作系统中的内存碎片。</p><h4 id="2-2-标记-整理-算法-Mark-Compact"><a href="#2-2-标记-整理-算法-Mark-Compact" class="headerlink" title="2.2 标记 - 整理 算法 (Mark - Compact)"></a>2.2 标记 - 整理 算法 (Mark - Compact)</h4><p><img src="/2022/03/22/JVM-2/20200608150827.png" alt="20200608150827"></p><p><strong>标记-整理</strong> 会将不被GC Root引用的对象回收，清理其占用的内存空间。然后整理剩余的对象（将其地址向前移动，使内存更为紧凑，连续空间更多），可以<strong>有效避免因内存碎片而导致的问题</strong>，但是因为整体需要消耗一定的时间，所以<strong>效率较低</strong></p><h4 id="2-3-复制-算法-Copy"><a href="#2-3-复制-算法-Copy" class="headerlink" title="2.3 复制 算法 (Copy)"></a>2.3 复制 算法 (Copy)</h4><p>将内存分为等大小的两个区域，FROM和TO（TO中为空）。</p><p>先将被GC Root引用的对象从FROM放入TO中，再回收不被GC Root引用的对象。然后交换FROM和TO。这样也可以避免内存碎片的问题，但是会<strong>占用双倍的内存空间</strong>。</p><ol><li>如下图，先采用标记算法确定可回收对象（图中为没有GC Root引用的块）</li></ol><img src="/2022/03/22/JVM-2/20200608150842.png" alt="20200608150842" style="zoom:75%;"><ol start="2"><li>将FROM区域中存活的对象复制到TO区域</li></ol><img src="/2022/03/22/JVM-2/20200608150856.png" alt="20200608150856" style="zoom:75%;"><ol start="3"><li>此时由于FROM区域中全是垃圾，全部清空</li></ol><img src="/2022/03/22/JVM-2/20200608150907.png" alt="20200608150907" style="zoom:75%;"><ol start="4"><li>交换 FROM 区域 和 TO 区域 的位置</li></ol><img src="/2022/03/22/JVM-2/20200608150919.png" alt="20200608150919" style="zoom:75%;"><h3 id="3-分代垃圾回收机制"><a href="#3-分代垃圾回收机制" class="headerlink" title="3 分代垃圾回收机制"></a>3 分代垃圾回收机制</h3><p><img src="/2022/03/22/JVM-2/20200608150931.png" alt="20200608150931"></p><p>如上图，我们将堆内存划分成两个部分，一个是左边的YoungGeneration新生代 (新生代又分为伊甸园Edin、幸存区FROM 和 幸存区TO 三个部分)，另一个是老年代OldGeneration。</p><p>Java中，长时间使用的对象放在老年代中，用完就可以丢弃的对象放在新生代中。这样就可以根据对象的存活时间的不同特点进行不用的回收策略。老年代中的垃圾回收很久发生一次，而新生代中回收更频繁。</p><h4 id="3-1-分代回收流程"><a href="#3-1-分代回收流程" class="headerlink" title="3.1 分代回收流程"></a>3.1 分代回收流程</h4><ol><li>新创建的对象都被放在了<strong>新生代的伊甸园</strong>中，伊甸园逐渐就会被占满。</li></ol><p><img src="/2022/03/22/JVM-2/20200608150939.png" alt="20200608150939"></p><p><img src="/2022/03/22/JVM-2/20200608150946.png" alt="20200608150946"></p><ol start="2"><li><p>当伊甸园中的内存不足时，就会进行一次垃圾回收，这时新生代的垃圾回收叫做 <strong>Minor GC</strong></p><p>(1) Minor GC触发后，采用“可达性分析算法”，沿着以GC Root对象（根对象）为起点的引用链，采用“标记算法”确定可回收对象；</p><p>(2) 标记完成后，采用“复制算法”将<strong>伊甸园和幸存区FROM</strong>存活的对象<strong>先</strong>复制到 <strong>幸存区 TO</strong>中， 并让其<strong>寿命加1</strong>；</p><p>(3) 根据复制算法，我们将交换 幸存区FROM 和 幸存区TO 的位置</p><p><img src="/2022/03/22/JVM-2/20200608150955.png" alt="20200608150955"></p></li></ol><p><img src="/2022/03/22/JVM-2/20200608151002.png" alt="20200608151002"></p><ol start="3"><li><p>再次创建对象，若新生代的伊甸园又满了，则会<strong>再次触发 Minor GC</strong>（会触发 <strong>“Stop the world”</strong>， 暂停其他用户线程，只让垃圾回收线程工作）；</p><p>这时不仅会回收伊甸园中的垃圾，<strong>还会回收幸存区中的垃圾</strong>，再将活跃对象复制到幸存区TO中；</p><p>回收以后会交换两个幸存区，并让幸存区中的对象<strong>寿命加1</strong></p></li></ol><p><img src="/2022/03/22/JVM-2/20200608151010.png" alt="20200608151010"></p><ol start="4"><li>如果幸存区中的对象的<strong>寿命超过某个阈值</strong>（最大为15，4bit），就会<strong>晋升到老年代</strong>中</li></ol><p><img src="/2022/03/22/JVM-2/20200608151018.png" alt="20200608151018"></p><ol start="5"><li>如果新生代老年代中的内存都满了，就会先触发Minor GC，再触发<strong>Full GC</strong> (整体清理)，也会触发“Stop the world”，时间更长，以扫描<strong>新生代和老年代中</strong>所有不再使用的对象并回收</li><li>如果老年代的内存也不够，内存分配失败，触发 <code>java.lang.OutOfMemoryError</code>。</li></ol><p><img src="/2022/03/22/JVM-2/IMG_FB5339E468EB-1.jpeg" alt="IMG_FB5339E468EB-1"></p><h4 id="3-2-相关虚拟机参数"><a href="#3-2-相关虚拟机参数" class="headerlink" title="3.2 相关虚拟机参数"></a>3.2 相关虚拟机参数</h4><table><thead><tr><th align="left">含义</th><th align="left">参数</th></tr></thead><tbody><tr><td align="left">堆初始大小</td><td align="left"><code>-Xms</code></td></tr><tr><td align="left">堆最大大小</td><td align="left"><code>-Xmx</code> 或 <code>-XX:MaxHeapSize=size</code></td></tr><tr><td align="left">新生代大小</td><td align="left"><code>-Xmn</code> 或 <code>-XX:NewSize=size + XX:MaxNewSize=size</code></td></tr><tr><td align="left">幸存区比例（动态）</td><td align="left"><code>-XX:InitialSurvivorRatio=ratio</code> 和 <code>-XX:+UseAdaptiveSizePolicy</code></td></tr><tr><td align="left">幸存区比例</td><td align="left"><code>-XX:SurvivorRatio=ratio</code></td></tr><tr><td align="left">晋升阈值</td><td align="left"><code>-XX:MaxTenuringThreshold=threshold</code></td></tr><tr><td align="left">晋升详情</td><td align="left"><code>-XX:+PrintTenuringDistribution</code></td></tr><tr><td align="left">GC详情</td><td align="left"><code>-XX:+PrintGCDetails -verbose:gc</code></td></tr><tr><td align="left">FullGC 前 MinorGC</td><td align="left"><code>-XX:+ScavengeBeforeFullGC</code></td></tr><tr><td align="left"></td><td align="left"></td></tr></tbody></table><h4 id="3-3-GC分析"><a href="#3-3-GC分析" class="headerlink" title="3.3  GC分析"></a>3.3  GC分析</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line">def new generationtotal 9216K, used 2309K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">edenspace 8192K,28% used [0x00000000fec00000, 0x00000000fee41460, 0x00000000ff400000)</span><br><span class="line">fromspace 1024K, 0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)</span><br><span class="line">tospace 1024K, 0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)</span><br><span class="line">tenured generationtotal 10240K, used 0K [0x00000000ff600000, 0x00000000ff600200, 0x0000000100000000)</span><br><span class="line"> the space 10240K, 0% used [0x00000000ff600000, 0x00000000ff600000, 0x00000000ff600200, 0x0000000100000000)</span><br><span class="line">Metaspaceused 3279K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">class spaceused 359K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure><h5 id="3-3-1-大对象处理策略"><a href="#3-3-1-大对象处理策略" class="headerlink" title="3.3.1 大对象处理策略"></a>3.3.1 大对象处理策略</h5><p>当遇到一个<strong>较大的对象</strong>时，就算新生代的<strong>伊甸园</strong>为空，也<strong>无法容纳该对象</strong>时，会将该对象<strong>直接晋升为老年代</strong></p><h5 id="3-3-2-线程内存溢出"><a href="#3-3-2-线程内存溢出" class="headerlink" title="3.3.2 线程内存溢出"></a>3.3.2 线程内存溢出</h5><p>某个线程的内存溢出了而抛异常 (<code>java.lang.OutOfMemoryError</code>)，不会让其他的线程结束运行，原因如下：</p><ul><li>当一个线程<strong>抛出OOM异常后</strong>，<strong>它所占据的内存资源会全部被释放掉</strong>，从而不会影响其他线程的运行，<strong>其他进程依然正常</strong></li></ul><h3 id="4-垃圾回收器"><a href="#4-垃圾回收器" class="headerlink" title="4 垃圾回收器"></a>4 垃圾回收器</h3><p>更新中…</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;JVM-基础学习&quot;&gt;&lt;a href=&quot;#JVM-基础学习&quot; class=&quot;headerlink&quot; title=&quot;JVM 基础学习&quot;&gt;&lt;/a&gt;JVM 基础学习&lt;/h1&gt;&lt;p&gt;视频课程: &lt;a href=&quot;https://www.bilibili.com/video/BV1yE411Z7AP?p=48&quot;&gt;BiliBili - 黑马程序员JVM完整教程: JVM垃圾回收&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;三、JVM-垃圾回收&quot;&gt;&lt;a href=&quot;#三、JVM-垃圾回收&quot; class=&quot;headerlink&quot; title=&quot;三、JVM 垃圾回收&quot;&gt;&lt;/a&gt;三、JVM 垃圾回收&lt;/h2&gt;&lt;h3 id=&quot;0-主要内容大纲&quot;&gt;&lt;a href=&quot;#0-主要内容大纲&quot; class=&quot;headerlink&quot; title=&quot;0 主要内容大纲&quot;&gt;&lt;/a&gt;0 主要内容大纲&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;如何判断对象可以回收&lt;/li&gt;
&lt;li&gt;垃圾回收算法&lt;/li&gt;
&lt;li&gt;分代垃圾回收&lt;/li&gt;
&lt;li&gt;垃圾回收器&lt;/li&gt;
&lt;li&gt;垃圾回收调优&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java 虚拟机 - JVM 第一讲</title>
    <link href="http://example.com/2022/03/22/JVM-1/"/>
    <id>http://example.com/2022/03/22/JVM-1/</id>
    <published>2022-03-22T20:52:44.000Z</published>
    <updated>2022-03-22T21:33:48.361Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM-基础学习"><a href="#JVM-基础学习" class="headerlink" title="JVM 基础学习"></a>JVM 基础学习</h1><p>视频课程: <a href="https://www.bilibili.com/video/BV1yE411Z7AP">BiliBili - 黑马程序员JVM完整教程</a></p><p>Java Virtual Machine - java 程序的运行环境(Java 二进制字节码的运行环境)</p><p><strong>好处:</strong></p><ul><li>可以提供一个跨平台的一致的运行环境, 达到平台无关性;</li><li>提供内存管理, 垃圾回收功能;</li></ul><p>JRE &#x3D; JVM + 基础类库<br>JDK &#x3D; JVM + 基础类库 + 编译工具</p><span id="more"></span><h2 id="一、JVM-结构"><a href="#一、JVM-结构" class="headerlink" title="一、JVM 结构"></a>一、JVM 结构</h2><p><img src="/2022/03/22/JVM-1/1.png" alt="arch"></p><h2 id="二、JVM-内存结构"><a href="#二、JVM-内存结构" class="headerlink" title="二、JVM 内存结构"></a>二、JVM 内存结构</h2><ol><li>程序计数器 (Program Counter Register)</li><li>虚拟机栈 (JVM Stacks)</li><li>本地方法栈 (Native Method Stacks)</li><li>堆 (Heap)</li><li>方法区 (Method Area)</li></ol><h3 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1 程序计数器"></a>1 程序计数器</h3><p>作用: 在指令的执行中, 记住<strong>下一条JVM指令的执行地址</strong>. 在物理上可使用<strong>寄存器</strong>实现.</p><p>特点:</p><ul><li>线程私有. 在多线程下, 线程间切换时需要保存当前环境, 需要用到程序计数器记住下一条JVM指令的执行地址</li><li>不会存在内存溢出.</li></ul><h3 id="2-虚拟机栈"><a href="#2-虚拟机栈" class="headerlink" title="2 虚拟机栈"></a>2 虚拟机栈</h3><h4 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h4><p>回忆数据结构中“栈”的结构: 先进后出</p><p>虚拟机栈是<strong>线程运行需要的内存空间</strong>, <strong>一个栈由多个栈帧组成</strong>. 一个栈帧对应一次方法的调用, <strong>栈帧(Frame)<strong>即</strong>每个方法运行时需要的内存(参数、局部变量、返回地址等)</strong>.</p><ul><li>每个线程只能有一个活动栈帧,对应着当前正在执行的那个方法.</li></ul><p>可以在idea用debug模式下的“Debugger”视图中看到栈和栈帧.</p><p><strong>思考:</strong></p><ul><li>在函数的调用中, <ol><li>先把主调函数入栈, 调用被调函数, 紧接着被调函数入栈, 活动栈帧为被调函数;</li><li>等被调函数返回返回值时, 被调函数出栈, 活动栈帧为主调函数.</li></ol></li><li>垃圾回收不涉及栈内存, 因为每次执行后栈内存都会被清空(出栈)</li><li>栈内存越大, 线程数越小 (默认 1024KB)</li></ul><h4 id="2-2-栈内存溢出"><a href="#2-2-栈内存溢出" class="headerlink" title="2.2 栈内存溢出"></a>2.2 栈内存溢出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.StackOverflowError</span><br></pre></td></tr></table></figure><ol><li>栈帧过多导致内存溢出<ul><li>想象一下, 在不断的调用方法时, 一直入栈没有出栈, 直到某一次调用时无法分配新的栈帧内存. e.g.无递归终止条件的<strong>递归调用</strong></li></ul></li><li>栈帧过大导致内存溢出, 栈帧 &gt; 栈内存</li></ol><h4 id="2-3-线程运行诊断"><a href="#2-3-线程运行诊断" class="headerlink" title="2.3 线程运行诊断"></a>2.3 线程运行诊断</h4><p>JDK 自带一个工具“JStack“命令, 用于定位CPU占用过多的Java线程(TID). 根据线程id(TID)找到有问题的线程,即可能有问题的代码行数. 也可以发现<strong>有死锁的进程</strong>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack 进程id(PID)</span><br></pre></td></tr></table></figure><h3 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3 本地方法栈"></a>3 本地方法栈</h3><p>不是由Java代码编写的方法, 由于java语言限制, 不能直接和os底层“打交道”, 所以需要c&#x2F;c++语言编写的方法直接与底层os“打交道”, 而java代码可以使用本地方法调用来调用这些方法.<br>本地方法使用的内存就是本地方法栈.</p><ul><li>e.g. <code>hashCode()</code>, <code>wait()</code>, <code>notify()</code>, <code>notifyAll()</code> 等</li><li>由 <code>native</code> 修饰</li></ul><h3 id="4-堆"><a href="#4-堆" class="headerlink" title="4 堆"></a>4 堆</h3><p>线程共享的区域</p><h4 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h4><ul><li>通过 <code>new</code> 关键字 -&gt; 创建一个堆, 都会使用堆的内存</li></ul><p>特点:</p><ul><li><strong>线程共享</strong>, 堆中对象都要考虑线程安全问题</li><li>有垃圾回收机制, 当对象不再被时, 其占用的内存会被回收</li></ul><h4 id="4-2-堆内存溢出"><a href="#4-2-堆内存溢出" class="headerlink" title="4.2 堆内存溢出"></a>4.2 堆内存溢出</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 创建堆</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            list.add(a);</span><br><span class="line">            a = a + a; <span class="comment">// Hello, HelloHello, HelloHelloHelloHello, ....</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-堆内存诊断"><a href="#4-3-堆内存诊断" class="headerlink" title="4.3 堆内存诊断"></a>4.3 堆内存诊断</h4><p>java常用工具:</p><ol><li>jps 工具<ul><li>查看当前系统中有哪些java进程</li></ul></li><li>jmap 工具 <ul><li>查看某一时刻下,堆内存的占用情况</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ jps</span><br><span class="line">$ jmap -heap 进程id(PID)</span><br></pre></td></tr></table></figure><ol start="3"><li>jconsole 工具<ul><li>图形界面的, 多功能的检查工具, 可以连续监测</li></ul></li><li>jvisualvm 工具 (需要自行下载)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;1....&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">    <span class="type">byte</span>[] array = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>];  <span class="comment">// 堆中内存占用新增10MB</span></span><br><span class="line">    System.out.println(<span class="string">&quot;2....&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">    array = <span class="literal">null</span>;</span><br><span class="line">    System.gc();                                <span class="comment">// 垃圾回收</span></span><br><span class="line">    System.out.println(<span class="string">&quot;3....&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5 方法区"></a>5 方法区</h3><h4 id="5-1-定义"><a href="#5-1-定义" class="headerlink" title="5.1 定义"></a>5.1 定义</h4><p>方法区是JVM中<strong>所有线程共享</strong>的区域.</p><p>存储了<strong>与类结构相关的信息</strong>: </p><ul><li>成员变量(field)</li><li>方法的数据(method data)</li><li>方法的代码(code of method)</li><li>构造器的代码(code of constructor)</li><li>运行时常量池(run-time constant pool)</li></ul><p>方法区在JVM启动时创建, 逻辑上是堆的一部分.</p><h4 id="5-2-组成"><a href="#5-2-组成" class="headerlink" title="5.2 组成"></a>5.2 组成</h4><p>JDK1.6 与 JDK1.8<br><img src="/2022/03/22/JVM-1/IMG_6B2CE85A4DCA-1.jpeg" alt="methodArea"></p><h4 id="5-3-方法区的内存溢出"><a href="#5-3-方法区的内存溢出" class="headerlink" title="5.3 方法区的内存溢出"></a>5.3 方法区的内存溢出</h4><ul><li>永久代内存溢出（JDK 1.8以前）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: PermGen space</span><br><span class="line">-XX:MaxPermSize=8m</span><br></pre></td></tr></table></figure><ul><li>元空间内存溢出（JDK 1.8以后）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Metaspace</span><br><span class="line">-XX:MaxMetaspaceSize=8m</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123; <span class="comment">// 类加载器: 可以用来加载类的二进制字节码, 动态加载</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Demo</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++, j++) &#123;</span><br><span class="line">                <span class="type">ClassWriter</span> <span class="variable">cw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(<span class="number">0</span>); <span class="comment">// ClassWriter作用是生成类的二进制字节码</span></span><br><span class="line">                <span class="comment">// 版本号, public, 类名:1~10000, 包名:null, 父类: 继承自&quot;java/lang/Object&quot;, 接口名:null</span></span><br><span class="line">                cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, <span class="string">&quot;Class&quot;</span> + i, <span class="literal">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">                <span class="comment">//返回 byte[]</span></span><br><span class="line">                <span class="type">byte</span>[] code = cw.toByteArray();</span><br><span class="line">                <span class="comment">// 只执行类的加载, 而不链接</span></span><br><span class="line">                test.defineClass(<span class="string">&quot;Class&quot;</span> + i, code, <span class="number">0</span>, code.length); <span class="comment">// class 对象</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有可能的溢出场景：实际生产中，动态产生并加载类时容易产生这种内存溢出</p><ol><li>Spring框架 中的cglib字节码技术，AOP的核心 - 生成动态代理类</li><li>Mybatis框架 中的cglib字节码技术</li></ol><h4 id="5-4-运行时常量池"><a href="#5-4-运行时常量池" class="headerlink" title="5.4 运行时常量池"></a>5.4 运行时常量池</h4><p>编译后的二进制字节码包含: 类基本信息、常量池、类方法定义、虚拟机指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -v &lt;xxx.class&gt; // -v 显示反编译后的详细信息</span><br></pre></td></tr></table></figure><p>例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后的详细信息: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">Classfile /学习笔记/JVM学习笔记/test.class</span><br><span class="line">  Last modified 2022年3月6日; size 413 bytes</span><br><span class="line">  SHA-256 checksum 7ab757ee2d78f0e76a52ba8b03b43fee2fe9d7994d74bc7d133b2e309ceed8f3</span><br><span class="line">  Compiled from <span class="string">&quot;test.java&quot;</span></span><br><span class="line">public class <span class="built_in">test</span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 59</span><br><span class="line">  flags: (0x0021) ACC_PUBLIC, ACC_SUPER// 访问修饰符</span><br><span class="line">  this_class: <span class="comment">#21                         // test</span></span><br><span class="line">  super_class: <span class="comment">#2                         // 父类:java/lang/Object</span></span><br><span class="line">  interfaces: 0, fields: 0, methods: 2, attributes: 1</span><br><span class="line">Constant pool:// 常量池</span><br><span class="line">   <span class="comment">#1 = Methodref          #2.#3          // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   <span class="comment">#2 = Class              #4             // java/lang/Object</span></span><br><span class="line">   <span class="comment">#3 = NameAndType        #5:#6          // &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   <span class="comment">#4 = Utf8               java/lang/Object</span></span><br><span class="line">   <span class="comment">#5 = Utf8               &lt;init&gt;</span></span><br><span class="line">   <span class="comment">#6 = Utf8               ()V</span></span><br><span class="line">   <span class="comment">#7 = Fieldref           #8.#9          // java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   <span class="comment">#8 = Class              #10            // java/lang/System</span></span><br><span class="line">   <span class="comment">#9 = NameAndType        #11:#12        // out:Ljava/io/PrintStream;</span></span><br><span class="line">  <span class="comment">#10 = Utf8               java/lang/System</span></span><br><span class="line">  <span class="comment">#11 = Utf8               out</span></span><br><span class="line">  <span class="comment">#12 = Utf8               Ljava/io/PrintStream;</span></span><br><span class="line">  <span class="comment">#13 = String             #14            // Hello World</span></span><br><span class="line">  <span class="comment">#14 = Utf8               Hello World</span></span><br><span class="line">  <span class="comment">#15 = Methodref          #16.#17        // java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">  <span class="comment">#16 = Class              #18            // java/io/PrintStream</span></span><br><span class="line">  <span class="comment">#17 = NameAndType        #19:#20        // println:(Ljava/lang/String;)V</span></span><br><span class="line">  <span class="comment">#18 = Utf8               java/io/PrintStream</span></span><br><span class="line">  <span class="comment">#19 = Utf8               println</span></span><br><span class="line">  <span class="comment">#20 = Utf8               (Ljava/lang/String;)V</span></span><br><span class="line">  <span class="comment">#21 = Class              #22            // test</span></span><br><span class="line">  <span class="comment">#22 = Utf8               test</span></span><br><span class="line">  <span class="comment">#23 = Utf8               Code</span></span><br><span class="line">  <span class="comment">#24 = Utf8               LineNumberTable</span></span><br><span class="line">  <span class="comment">#25 = Utf8               main</span></span><br><span class="line">  <span class="comment">#26 = Utf8               ([Ljava/lang/String;)V</span></span><br><span class="line">  <span class="comment">#27 = Utf8               SourceFile</span></span><br><span class="line">  <span class="comment">#28 = Utf8               test.java</span></span><br><span class="line">&#123;</span><br><span class="line">  public <span class="built_in">test</span>();// 当程序没有构造方法时, 编译器会自动生成一个无参的构造方法</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (0x0001) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial <span class="comment">#1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         4: <span class="built_in">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 1: 0</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);// main方法</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: (0x0009) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">      // 虚拟机指令<span class="comment">#n: 对应着常量池中的变量</span></span><br><span class="line">         0: getstatic     <span class="comment">#7                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         3: ldc           <span class="comment">#13                 // String Hello World 加载引用地址</span></span><br><span class="line">         5: invokevirtual <span class="comment">#15                 // Method java/io/PrintStream.println:(Ljava/lang/String;方法的参数类型)V 虚拟方法调用</span></span><br><span class="line">         8: <span class="built_in">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">        line 4: 8</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;test.java&quot;</span></span><br></pre></td></tr></table></figure><ul><li>以上的例子表明, <strong>常量池</strong>就是一张常量表, 虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量(如字符串、整型、bool类型等)等信息</li><li>运行时常量池, 就是当该类被加载时, 它的常量池信息会放入运行常量池, 地址会替换为真正的内存地址</li></ul><h4 id="5-5-StringTable串池"><a href="#5-5-StringTable串池" class="headerlink" title="5.5 StringTable串池"></a>5.5 StringTable串池</h4><p>特征：</p><ul><li><p>常量池中的信息，都会被加载到运行时常量池中。这时a b ab都是常量池中的符号，<strong>还不是 java字符串对象</strong></p></li><li><p>常量池中的字符串仅是符号，只有<strong>在被第一次引用到时才会转化为对象</strong>，ldc</p></li><li><p>StringTable在内存结构上是哈希表，不能扩容</p></li><li><p>利用串池的机制，来避免重复创建字符串对象</p></li><li><p>字符串<strong>变量</strong>拼接的原理是<strong>StringBuilder</strong></p></li><li><p>字符串<strong>常量</strong>拼接的原理是<strong>编译器优化</strong></p></li><li><p>可以使用<strong>intern方法</strong>，主动将串池中还没有的字符串对象放入串池中</p><p><strong>注意</strong>：无论是串池还是堆里面的字符串，都是对象</p></li></ul><h5 id="5-5-1-串池"><a href="#5-5-1-串池" class="headerlink" title="5.5.1 串池"></a>5.5.1 串池</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableStudy</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>; </span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">ab</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常量池中的信息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0: ldc           <span class="comment">#2                  // String a</span></span><br><span class="line">2: astore_1// 把 a符号 变成 “a”字符串对象</span><br><span class="line">3: ldc           <span class="comment">#3                 // String b</span></span><br><span class="line">5: astore_2// 把 b符号 变成 “b”字符串对象</span><br><span class="line">6: ldc           <span class="comment">#4                  // String ab</span></span><br><span class="line">8: astore_3// 把 ab符号 变成 “ab”字符串对象</span><br><span class="line">9: <span class="built_in">return</span></span><br></pre></td></tr></table></figure><ol><li><p>当执行到 ldc #2 时，会把符号 a 变为 “a” 字符串对象，<strong>并放入串池中</strong>（hashtable结构 不可扩容）</p></li><li><p>当执行到 ldc #3 时，会把符号 b 变为 “b” 字符串对象，并放入串池中</p></li><li><p>当执行到 ldc #4 时，会把符号 ab 变为 “ab” 字符串对象，并放入串池中</p></li><li><p>最终<strong>StringTable [“a”, “b”, “ab”]</strong></p><p><strong>注意</strong>：字符串对象的创建都是<strong>懒惰的</strong>，只有当运行到那一行字符串且在串池中不存在的时候（如 ldc #2）时，该字符串才会被创建并放入串池中。</p></li></ol><h5 id="5-5-2-串池：拼接变量字符串对象创建字符串"><a href="#5-5-2-串池：拼接变量字符串对象创建字符串" class="headerlink" title="5.5.2 串池：拼接变量字符串对象创建字符串"></a>5.5.2 串池：拼接变量字符串对象创建字符串</h5><p>使用拼接<strong>字符串变量对象</strong>创建字符串的过程: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableStudy</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">ab</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">ab2</span> <span class="operator">=</span> a+b;  <span class="comment">// 拼接字符串对象来创建新的字符串 new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toSrting()</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(ab == ab2); <span class="comment">// 结果为false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">    stack=2, locals=5, args_size=1</span><br><span class="line">       0: ldc           <span class="comment">#2                  // String a</span></span><br><span class="line">       2: astore_1</span><br><span class="line">       3: ldc           <span class="comment">#3                  // String b</span></span><br><span class="line">       5: astore_2</span><br><span class="line">       6: ldc           <span class="comment">#4                  // String ab</span></span><br><span class="line">       8: astore_3</span><br><span class="line">       9: new           <span class="comment">#5                  // class java/lang/StringBuilder</span></span><br><span class="line">      12: dup</span><br><span class="line">      13: invokespecial <span class="comment">#6                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">      16: aload_1</span><br><span class="line">      17: invokevirtual <span class="comment">#7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">      20: aload_2</span><br><span class="line">      21: invokevirtual <span class="comment">#7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">      24: invokevirtual <span class="comment">#8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">      27: astore        4</span><br><span class="line">      29: <span class="built_in">return</span></span><br></pre></td></tr></table></figure><p>通过拼接的方式来创建字符串的<strong>过程</strong>是：new StringBuilder().append(“a”).append(“b”).toString()，地址应该在<strong>堆</strong>中</p><p>最后的toString方法的返回值是一个<strong>新的字符串</strong>，但字符串的<strong>值</strong>和拼接的字符串一致，但是两个不同的字符串，<strong>一个存在于串池之中，一个存在于堆内存之中</strong></p><h5 id="5-5-3-串池：拼接常量字符串对象的方法创建字符串"><a href="#5-5-3-串池：拼接常量字符串对象的方法创建字符串" class="headerlink" title="5.5.3 串池：拼接常量字符串对象的方法创建字符串"></a>5.5.3 串池：<strong>拼接常量字符串对象</strong>的方法创建字符串</h5><p>使用<strong>拼接字符串常量对象</strong>的方法创建字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableStudy</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">ab</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ab2</span> <span class="operator">=</span> a+b;</span><br><span class="line"><span class="type">String</span> <span class="variable">ab3</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>; <span class="comment">// 使用拼接字符串的方法创建字符串，由于编译期间的优化</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(ab == ab3); <span class="comment">// 结果为true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">  stack=2, locals=6, args_size=1</span><br><span class="line">     0: ldc           <span class="comment">#2                  // String a</span></span><br><span class="line">     2: astore_1</span><br><span class="line">     3: ldc           <span class="comment">#3                  // String b</span></span><br><span class="line">     5: astore_2</span><br><span class="line">     6: ldc           <span class="comment">#4                  // String ab</span></span><br><span class="line">     8: astore_3</span><br><span class="line">     9: new           <span class="comment">#5                  // class java/lang/StringBuilder</span></span><br><span class="line">    12: dup</span><br><span class="line">    13: invokespecial <span class="comment">#6                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">    16: aload_1</span><br><span class="line">    17: invokevirtual <span class="comment">#7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">    20: aload_2</span><br><span class="line">    21: invokevirtual <span class="comment">#7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">    24: invokevirtual <span class="comment">#8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">    27: astore        4//ab3初始化时直接从串池中获取字符串</span><br><span class="line">    29: ldc           <span class="comment">#4                  // String ab</span></span><br><span class="line">    31: astore        5</span><br><span class="line">    33: <span class="built_in">return</span></span><br></pre></td></tr></table></figure><ul><li><p>当虚拟机执行到<strong>第0、3、5行</strong>时，会将“a” “b“ ”ab“放入串池。当执行到<strong>29行</strong>时我们可以看到，虚拟机不会先找“a” 再找“b”然后再将它们拼接起来，而是之间找到拼接后的“ab”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringTable[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;ab&quot;</span>]</span><br></pre></td></tr></table></figure></li><li><p>使用<strong>拼接字符串常量</strong>的方法来创建新的字符串时，因为<strong>内容是常量，javac在编译期会进行优化，结果已在编译期确定为ab</strong>，而创建ab的时候已经在串池中放入了“ab”，所以ab3直接从串池中获取值，所以进行的操作和 ab &#x3D; “ab” 一致。</p></li><li><p>使用<strong>拼接字符串变量</strong>的方法来创建新的字符串时，因为内容是变量，只能<strong>在运行期确定它的值，所以需要使用StringBuilder来创建</strong></p></li></ul><h5 id="5-5-4-串池：intern方法-JDK1-8"><a href="#5-5-4-串池：intern方法-JDK1-8" class="headerlink" title="5.5.4 串池：intern方法(JDK1.8)"></a>5.5.4 串池：intern方法(JDK1.8)</h5><p>调用字符串对象的intern()方法，会将该字符串对象尝试放入到串池中</p><ul><li>如果串池中没有该字符串对象，则放入成功</li><li>如果有该字符串对象，则放入失败</li><li>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</li></ul><p>Example1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableInternMethod1</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">/* &quot;a&quot; &quot;b&quot; 被放入串池中，str则存在于堆内存之中 */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 调用str的intern方法，这时串池中没有&quot;ab&quot;，则会将该字符串对象放入到串池中，此时堆内存与串池中的&quot;ab&quot;是同一个对象*/</span></span><br><span class="line"><span class="type">String</span> <span class="variable">st2</span> <span class="operator">=</span> str.intern();</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 给str3赋值，因为此时串池中已有&quot;ab&quot;，则直接将串池中的内容返回 */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 因为堆内存与串池中的&quot;ab&quot;是同一个对象，所以以下两条语句打印的都为true */</span></span><br><span class="line">System.out.println(str == st2);</span><br><span class="line">System.out.println(str == str3);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Example2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SringTableInternMethod2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">/* 此处创建字符串对象&quot;ab&quot;，因为串池中还没有&quot;ab&quot;，所以将其放入串池中 */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="comment">/* &quot;a&quot; &quot;b&quot; 被放入串池中，str则存在于堆内存之中 */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="comment">/* 此时因为在创建str3时，&quot;ab&quot;已存在与串池中，所以放入失败，但是会返回串池中的&quot;ab&quot; */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> str.intern();</span><br><span class="line">    </span><br><span class="line">System.out.println(str == str2); <span class="comment">//false</span></span><br><span class="line">System.out.println(str == str3); <span class="comment">//false</span></span><br><span class="line">System.out.println(str2 == str3); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-5-5-串池的位置"><a href="#5-5-5-串池的位置" class="headerlink" title="5.5.5 串池的位置"></a>5.5.5 串池的位置</h5><p>在JDK1.8中：</p><p><img src="/2022/03/22/JVM-1/IMG_42907AA7BAF6-1.jpeg" alt="StringTable1.8"></p><p>在JDK1.6中：</p><img src="/2022/03/22/JVM-1/IMG_9A689689FB20-1.jpeg" alt="1.6" style="zoom: 60%;"><h5 id="5-5-6-串池的垃圾回收"><a href="#5-5-6-串池的垃圾回收" class="headerlink" title="5.5.6 串池的垃圾回收"></a>5.5.6 串池的垃圾回收</h5><p>StringTable在内存紧张时，会发生垃圾回收。</p><h5 id="5-5-7-串池的性能调优"><a href="#5-5-7-串池的性能调优" class="headerlink" title="5.5.7 串池的性能调优"></a>5.5.7 串池的性能调优</h5><ul><li><p>因为StringTable是用HashTable实现的，所以我们可以<strong>适当增加HashTable的桶的个数</strong>，来减少字符串放入串池所需要的时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:StringTableSize=xxxx</span><br></pre></td></tr></table></figure></li><li><p>考虑是否需要将字符串对象入池，可以通过<strong>intern()方法减少重复入池</strong></p></li></ul><h3 id="6-直接内存"><a href="#6-直接内存" class="headerlink" title="6 直接内存"></a>6 直接内存</h3><h4 id="6-1-定义"><a href="#6-1-定义" class="headerlink" title="6.1 定义"></a>6.1 定义</h4><p>直接内存不属于JVM内存结构，而是<strong>操作系统的内存</strong>。</p><ul><li>属于操作系统，常见于NIO操作时，<strong>用于数据缓冲区</strong></li><li>分配回收成本较高，但读写性能高</li><li>不受JVM内存回收管理</li></ul><h4 id="6-2-基本使用"><a href="#6-2-基本使用" class="headerlink" title="6.2 基本使用"></a>6.2 基本使用</h4><img src="/2022/03/22/JVM-1/20200608150715.png" alt="123" style="zoom:60%;"><p>使用了DirectBuffer后</p><img src="/2022/03/22/JVM-1/20200608150736.png" alt="234" style="zoom:60%;"><p>直接内存是操作系统和Java代码<strong>都可以访问的一块区域</strong>，无需将代码从系统内存复制到Java堆内存，从而提高了效率</p><h4 id="6-3-分配和回收原理"><a href="#6-3-分配和回收原理" class="headerlink" title="6.3 分配和回收原理"></a>6.3 分配和回收原理</h4><ul><li>使用了Unsafe类来完成直接内存的分配回收，而且回收需要主动调用**unsafe.freeMemory()**方法</li><li>ByteBuffer的实现内部使用了Cleaner（虚引用）来检测ByteBuffer。一旦ByteBuffer被垃圾回收，那么会由ReferenceHandler来调用Cleaner的clean方法调用freeMemory来释放内存</li></ul><p>直接内存的回收不是通过JVM的垃圾回收来释放的，而是通过**unsafe.freeMemory()**来手动释放</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过ByteBuffer申请1M的直接内存</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(_1M);</span><br></pre></td></tr></table></figure><p>申请直接内存，但JVM并不能回收直接内存中的内容，它是如何实现回收的呢？</p><h5 id="allocateDirect-的实现底层源码分析"><a href="#allocateDirect-的实现底层源码分析" class="headerlink" title="allocateDirect() 的实现底层源码分析"></a>allocateDirect() 的实现底层源码分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title function_">allocateDirect</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectByteBuffer</span>(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DirectByteBuffer类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">DirectByteBuffer(<span class="type">int</span> cap) &#123;   <span class="comment">// package-private</span></span><br><span class="line">   </span><br><span class="line">    <span class="built_in">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">pa</span> <span class="operator">=</span> VM.isDirectMemoryPageAligned();</span><br><span class="line">    <span class="type">int</span> <span class="variable">ps</span> <span class="operator">=</span> Bits.pageSize();</span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> Math.max(<span class="number">1L</span>, (<span class="type">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        base = unsafe.allocateMemory(size); <span class="comment">//申请内存</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.setMemory(base, size, (<span class="type">byte</span>) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// Round up to page boundary</span></span><br><span class="line">        address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    cleaner = Cleaner.create(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">Deallocator</span>(base, size, cap)); <span class="comment">//通过虚引用，来实现直接内存的释放，this为虚引用的实际对象</span></span><br><span class="line">    att = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了一个Cleaner的create()方法，且后台线程还会对虚引用的对象监测，如果虚引用的实际对象（这里是DirectByteBuffer）被回收以后，就会调用Cleaner的clean()方法，来清除直接内存中占用的内存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clean</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (remove(<span class="built_in">this</span>)) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="built_in">this</span>.thunk.run(); <span class="comment">//调用run方法</span></span><br><span class="line">           &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable var2) &#123;</span><br><span class="line">               AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">                   <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                       <span class="keyword">if</span> (System.err != <span class="literal">null</span>) &#123;</span><br><span class="line">                           (<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Cleaner terminated abnormally&quot;</span>, var2)).printStackTrace();</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       System.exit(<span class="number">1</span>);</span><br><span class="line">                       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><p>对应对象的run()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (address == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Paranoia</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.freeMemory(address); <span class="comment">//释放直接内存中占用的内存</span></span><br><span class="line">    address = <span class="number">0</span>;</span><br><span class="line">    Bits.unreserveMemory(size, capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;JVM-基础学习&quot;&gt;&lt;a href=&quot;#JVM-基础学习&quot; class=&quot;headerlink&quot; title=&quot;JVM 基础学习&quot;&gt;&lt;/a&gt;JVM 基础学习&lt;/h1&gt;&lt;p&gt;视频课程: &lt;a href=&quot;https://www.bilibili.com/video/BV1yE411Z7AP&quot;&gt;BiliBili - 黑马程序员JVM完整教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Java Virtual Machine - java 程序的运行环境(Java 二进制字节码的运行环境)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;好处:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以提供一个跨平台的一致的运行环境, 达到平台无关性;&lt;/li&gt;
&lt;li&gt;提供内存管理, 垃圾回收功能;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JRE &amp;#x3D; JVM + 基础类库&lt;br&gt;JDK &amp;#x3D; JVM + 基础类库 + 编译工具&lt;/p&gt;</summary>
    
    
    
    
    <category term="Java" scheme="http://example.com/tags/Java/"/>
    
    <category term="JVM" scheme="http://example.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>赤壁赋</title>
    <link href="http://example.com/2022/03/22/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%B5%8B%E8%AF%95%E5%8D%9A%E5%AE%A2/"/>
    <id>http://example.com/2022/03/22/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E6%B5%8B%E8%AF%95%E5%8D%9A%E5%AE%A2/</id>
    <published>2022-03-22T11:57:00.000Z</published>
    <updated>2022-03-22T20:41:16.070Z</updated>
    
    <content type="html"><![CDATA[<p><strong>（宋）苏轼</strong></p><p>​        壬戌之秋，七月既望，苏子与客泛舟游于赤壁之下。清风徐来，水波不兴。举酒属客，诵明月之诗，歌窈窕之章。少焉，月出于东山之上，徘徊于斗牛之间。白露横江，水光接天。纵一苇之所如，凌万顷之茫然。浩浩乎如冯虚御风，而不知其所止；飘飘乎如遗世独立，羽化而登仙。</p><span id="more"></span><p>　　于是饮酒乐甚，扣舷而歌之。歌曰：“桂棹兮兰桨，击空明兮溯流光。渺渺兮予怀，望美人兮天一方。”客有吹洞箫者，倚歌而和之。其声呜呜然，如怨如慕，如泣如诉；余音袅袅，不绝如缕。舞幽壑之潜蛟，泣孤舟之嫠妇。</p><p>　　苏子愀然，正襟危坐，而问客曰：“何为其然也？”客曰：“‘月明星稀，乌鹊南飞。’此非曹孟德之诗乎？西望夏口，东望武昌，山川相缪，郁乎苍苍，此非孟德之困于周郎者乎？方其破荆州，下江陵，顺流而东也，舳舻千里，旌旗蔽空，酾酒临江，横槊赋诗，固一世之雄也，而今安在哉？况吾与子渔樵于江渚之上，侣鱼虾而友麋鹿，驾一叶之扁舟，举匏樽以相属。寄蜉蝣于天地，渺沧海之一粟。哀吾生之须臾，羡长江之无穷。挟飞仙以遨游，抱明月而长终。知不可乎骤得，托遗响于悲风。”</p><p>　　苏子曰：“客亦知夫水与月乎？逝者如斯，而未尝往也；盈虚者如彼，而卒莫消长也。盖将自其变者而观之，则天地曾不能以一瞬；自其不变者而观之，则物与我皆无尽也，而又何羡乎！且夫天地之间，物各有主，苟非吾之所有，虽一毫而莫取。惟江上之清风，与山间之明月，耳得之而为声，目遇之而成色，取之无禁，用之不竭。是造物者之无尽藏也，而吾与子之所共适。”</p><p>　　客喜而笑，洗盏更酌。肴核既尽，杯盘狼籍。相与枕藉乎舟中，不知东方之既白。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;（宋）苏轼&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;​        壬戌之秋，七月既望，苏子与客泛舟游于赤壁之下。清风徐来，水波不兴。举酒属客，诵明月之诗，歌窈窕之章。少焉，月出于东山之上，徘徊于斗牛之间。白露横江，水光接天。纵一苇之所如，凌万顷之茫然。浩浩乎如冯虚御风，而不知其所止；飘飘乎如遗世独立，羽化而登仙。&lt;/p&gt;</summary>
    
    
    
    
    <category term="测试" scheme="http://example.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://example.com/2022/03/22/hello-world/"/>
    <id>http://example.com/2022/03/22/hello-world/</id>
    <published>2022-03-22T11:12:45.551Z</published>
    <updated>2022-03-22T20:39:22.458Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><span id="more"></span><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;</summary>
    
    
    
    
    <category term="测试" scheme="http://example.com/tags/%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
</feed>
