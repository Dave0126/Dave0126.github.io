<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Lost N Found</title>
  
  
  <link href="https://dave0126.github.io/atom.xml" rel="self"/>
  
  <link href="https://dave0126.github.io/"/>
  <updated>2022-04-26T14:13:18.458Z</updated>
  <id>https://dave0126.github.io/</id>
  
  <author>
    <name>Guohao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>最优化</title>
    <link href="https://dave0126.github.io/2022/04/22/%E6%9C%80%E4%BC%98%E5%8C%96/"/>
    <id>https://dave0126.github.io/2022/04/22/%E6%9C%80%E4%BC%98%E5%8C%96/</id>
    <published>2022-04-22T19:25:39.000Z</published>
    <updated>2022-04-26T14:13:18.458Z</updated>
    
    <content type="html"><![CDATA[<h4 id="最优化问题解题步骤"><a href="#最优化问题解题步骤" class="headerlink" title="最优化问题解题步骤"></a>最优化问题解题步骤</h4><h5 id="1-建模最优化问题"><a href="#1-建模最优化问题" class="headerlink" title="1. 建模最优化问题"></a>1. 建模最优化问题</h5><p>我们首先需要根据题目的描述对于问题 $(\mathcal{P})$ 进行数学建模。包括问题中提供的任何信息。确定</p><p>(1) 我们想要最大化或最小化目标函数，并将其统一转换成最小化问题；</p><p>(2) 为目标方程中的变量依照题意添加约束，统一标准化为小于等于约束；</p><p>(3) 如果可以，结合图形更加直观。</p><h5 id="2-确定目标函数的定义域-Omega"><a href="#2-确定目标函数的定义域-Omega" class="headerlink" title="2. 确定目标函数的定义域 $\Omega$"></a>2. 确定目标函数的定义域 $\Omega$</h5><p>目标函数的定义域 $\Omega$ 的封闭性、有无界性、是否非空 和 凹凸性：必须是一个<u>封闭(closed) 的</u>、<u>有界的(bounded)</u> <u>非空 (non-empty) 凸区间 (convex interval)</u> （即两端都有端点并包含这些端点的区间，且区间中任意两点的连线上的所有点都属于这个区间）</p><h5 id="3-判断目标函数在定义域-Omega-上的极值情况"><a href="#3-判断目标函数在定义域-Omega-上的极值情况" class="headerlink" title="3. 判断目标函数在定义域 $\Omega$ 上的极值情况"></a>3. 判断目标函数在定义域 $\Omega$ 上的极值情况</h5><ul><li><p><u>存在性 (existence)</u>：一阶偏导 (梯度) $\nabla$ 检验，评估目标函数在定义域 $\Omega$ 中的一阶偏导，简单判断目标函数的极值情况。例如：</p><p>$f(x_1,x_2,x_3)\;\Rightarrow \; f(z,z,z) \; \xrightarrow{z\to \infin}\; f\to \infin \text{ 无全局最大值}$，$f(x_1,x_2,x_3)\;\Rightarrow \; f(z,z,z) \; \xrightarrow{z\to -\infin}\; f\to -\infin \text{ 无全局最小值}$</p></li><li><p><u>唯一性 (unicité)</u>：二阶偏导 (梯度) $\nabla^2$ 检验，要求：定义域 $\Omega$ 中必须只有一个极值。测试：求目标函数的二阶偏导 ，并在临界数处对其进行评估。如果该值为 $<0$，则临界数表示严格极大值 (strict maximum)。如果该值为$>0$，则临界数表示严格极小值 (strict minimum)。</0$，则临界数表示严格极大值></p></li></ul><h5 id="4-构造拉格朗日乘数法或-mathcal-KKT"><a href="#4-构造拉格朗日乘数法或-mathcal-KKT" class="headerlink" title="4. 构造拉格朗日乘数法或$\mathcal{KKT}$"></a>4. 构造拉格朗日乘数法或$\mathcal{KKT}$</h5><p>下略。</p><h4 id="范数"><a href="#范数" class="headerlink" title="范数"></a>范数</h4><p>是数学中的一种基本概念。 在泛函分析中，它定义在赋范线性空间中，并满足一定的条件，即 <strong>①非负性</strong>；<strong>②齐次性</strong>；<strong>③三角不等式</strong>。 它常常被用来度量<u>某个向量空间（或矩阵）中的每个向量的长度或大小</u>。</p><ul><li><p>$l_1范数$ ：</p><script type="math/tex; mode=display">\lVert x\rVert_1 = \sum_{i=1}^n |x_i|</script></li><li><p>$l_2范数$ ：</p><script type="math/tex; mode=display">\lVert x\rVert_2 = \sqrt{x^Tx} = \sqrt{\sum_{i=1}^n x_i^2}</script></li><li><p>$l_\infin范数$ ：</p><script type="math/tex; mode=display">\lVert x\rVert_{\infin} = max\{ |x_i|:i\in 1,2,...,n\}</script></li><li><p>$l_p范数$ ：</p><script type="math/tex; mode=display">\lVert x\rVert_p =(\sum_{i=1}^n |x_i|^p)^{\frac {1}{p}},p \in [1,\infin)</script></li></ul><h4 id="凸集"><a href="#凸集" class="headerlink" title="凸集"></a>凸集</h4><h5 id="凸集-Convex-set"><a href="#凸集-Convex-set" class="headerlink" title="凸集 (Convex set)"></a>凸集 (Convex set)</h5><p>给定非空集合 $F \subseteq \R^n$，如果 $\forall x,y \in F, \alpha \in [0,1]$ 都有 $\alpha x+(1-\alpha) y \in F$，那么我们就称这个 $F$ 为 $\R^n$ 中的一个凸集，即集合中的任意两点的连线仍然属于该集合。</p><h5 id="凸组合-Convex-combination"><a href="#凸组合-Convex-combination" class="headerlink" title="凸组合 (Convex combination)"></a>凸组合 (Convex combination)</h5><p>$x^1, x^2,…,x^k$ 的凸组合：</p><script type="math/tex; mode=display">\lambda_1x^1 + \lambda_2x^2 + ... +\lambda_kx^k</script><p>其中，$\lambda_1, \lambda_2,…,\lambda_k \ge 0, \sum_{i=1}^k \lambda_i = 1$</p><h4 id="黑塞矩阵-Hessain"><a href="#黑塞矩阵-Hessain" class="headerlink" title="黑塞矩阵 (Hessain)"></a>黑塞矩阵 (Hessain)</h4><p>在之前的学习中我们已经知道，一阶导数，也就是目标函数的梯度，反映了函数值随着自变量 $x$ 变化的速率情况。所谓二阶导数，就是在一阶导数的基础上再求导数，反映了一阶导数的变化情况。</p><p>例如对于二次型函数 $f(x) = x^2$，它的一阶导数就是 $\frac {df(x)}{dx} = 2x$，二阶导数为 $\frac{d^2f(x)}{dx^2} = 2$</p><p>将其推广，对于一般的多元函数 $f(x) : \R^n \to \R$， 对其求一阶偏导数 (partial)，一阶偏导为向量称作梯度 (gradient):</p><script type="math/tex; mode=display">\nabla f(x) = \begin{bmatrix}\frac{\partial f}{\partial x_1} \\\frac{\partial f}{\partial x_2} \\\vdots\\\frac{\partial f}{\partial x_n}\end{bmatrix}</script><p>我们再对一阶导数 $\frac{\part f(x)}{\part x}$ 对于 $x_i$ 求偏导，我们可以得到</p><script type="math/tex; mode=display">\nabla (\frac{\partial f}{\partial x_i}) = \nabla^2 f(x) =\begin{bmatrix}\frac{\partial}{\partial x_1}\frac{\partial f}{\partial x_1} & \frac{\partial}{\partial x_2}\frac{\partial f}{\partial x_1} & \cdots & \frac{\partial}{\partial x_n}\frac{\partial f}{\partial x_1}      \\\frac{\partial}{\partial x_1}\frac{\partial f}{\partial x_2} & \frac{\partial}{\partial x_2}\frac{\partial f}{\partial x_2} & \cdots & \frac{\partial}{\partial x_n}\frac{\partial f}{\partial x_2}      \\\vdots & \vdots & \ddots & \vdots \\\frac{\partial}{\partial x_1}\frac{\partial f}{\partial x_n} & \frac{\partial}{\partial x_2}\frac{\partial f}{\partial x_n} & \cdots & \frac{\partial}{\partial x_n}\frac{\partial f}{\partial x_n}      \\\end{bmatrix}\leftarrow Hessian \; Matrix</script><p>黑塞矩阵是对梯度再求一次偏导，所以它是 $n \times n$ 的方阵，满足对称性 $\mathcal{H}_{ij} = \mathcal{H}_{ji}$</p><blockquote><p>例：对于 $f(x,y) = 5x + 8y +xy -x^2 -2y^2$</p></blockquote><script type="math/tex; mode=display">\nabla f(x,y) = \begin{bmatrix}\frac{\partial f}{\partial x} \\\frac{\partial f}{\partial y} \end{bmatrix}= \begin{bmatrix}5-2x+y \\8+x-4y \end{bmatrix}\\\mathcal{H} (x) =\begin{bmatrix}2 & 1 \\1 & -4\\\end{bmatrix}</script><p>对于二次函数，黑塞矩阵为常数矩阵。</p><h5 id="黑塞矩阵的意义"><a href="#黑塞矩阵的意义" class="headerlink" title="黑塞矩阵的意义"></a>黑塞矩阵的意义</h5><p>如果一个函数的黑塞矩阵是<strong>正定</strong> (positive definite) 的，即特征值大于 0，也即目标函数在所有可行方向 $d$ 上的二阶导数都大于 $0$。我们就可以得出 $f(x)$ 是<u>一个严格的凸函数</u>，其<u>极值就是极小值</u>，而且也是<strong><u>全局的最小值</u></strong>。</p><h4 id="矩阵的正定"><a href="#矩阵的正定" class="headerlink" title="矩阵的正定"></a>矩阵的正定</h4><p>正定矩阵首先是一个对称阵。以下我们介绍一种判断矩阵是否正定的方法，Sylvester’s Criterion：</p><h5 id="Sylvester’s-Criterion"><a href="#Sylvester’s-Criterion" class="headerlink" title="Sylvester’s Criterion"></a>Sylvester’s Criterion</h5><p>各阶行列式（顺序主子式）都大于0 $\Rightarrow$ 矩阵正定 $\succ 0$</p><script type="math/tex; mode=display">\begin{bmatrix}2 & -1 & 0 \\-1 & 2 & -1 \\0 & -1 & 2\end{bmatrix}\quad \Rightarrow \quad \begin{vmatrix}2 \end{vmatrix} > 0\quad\begin{vmatrix}2 & -1 \\-1 & 2 \end{vmatrix} > 0\quad\begin{vmatrix}2 & -1 & 0 \\-1 & 2 & -1 \\0 & -1 & 2\end{vmatrix} > 0</script><h4 id="无约束优化问题的最优性条件"><a href="#无约束优化问题的最优性条件" class="headerlink" title="无约束优化问题的最优性条件"></a>无约束优化问题的最优性条件</h4><p>无约束优化问题： $\min f(x)$</p><p>最优解的定义：</p><ul><li><p>局部最优解：对于一个解 $\bar x$，在 $\bar x$ 的临域空间 $N_s(\bar x)$ 内 $f(\bar x)$ 的值是最大或最小的。</p><script type="math/tex; mode=display">\forall x \in N_s(\bar x), f(x) \ge f(\bar x) \;或\; f(x) \le f(\bar x)</script></li><li><p>全局最优解：对于一个解 $\bar x$，在任意n维空间 $\R^n$ 内 $f(\bar x)$ 的值是最大或最小的。</p><script type="math/tex; mode=display">\forall x \in \R^n, f(x) \ge f(\bar x) \;或\; f(x) \le f(\bar x)</script></li><li><p>严格局部最优解：对于一个解 $\bar x$，在 $\bar x$ 的临域空间 $N_s(\bar x)$ 内 $f(\bar x)$ 的值是严格最大或最小的（不包含等于情况）。</p><script type="math/tex; mode=display">\forall x \in N_s(\bar x), f(x) > f(\bar x) \;或\; f(x) < f(\bar x)</script></li><li><p>严格全局最优解：对于一个解 $\bar x$，在任意n维空间 $\R^n$ 内 $f(\bar x)$ 的值是严格最大或最小的（不包含等于情况）。</p><script type="math/tex; mode=display">\forall x \in \R^n, f(x) > f(\bar x) \;或\; f(x) < f(\bar x)</script></li></ul><h5 id="最优性条件"><a href="#最优性条件" class="headerlink" title="最优性条件"></a>最优性条件</h5><p>考虑无约束优化问题： $\min f(x)$</p><ul><li><p>必要条件：若 $x^<em>$ 是最优解，则 $x^</em>$ 有如下性质：</p><script type="math/tex; mode=display">(1)\quad \nabla f(x^*) = 0 \qquad \qquad \qquad \text{目标函数在 } x^* \text{的位置时梯度为零} \\(2)\quad \nabla^2 f(x^*) \succeq 0 \qquad \text{目标函数在 } x^* \text{的位置时黑塞矩阵是半正定的}</script></li><li><p>充分条件：</p><script type="math/tex; mode=display">若 \nabla f(x^*) = 0, \nabla^2 f(x^*) \succ 0 \quad \Rightarrow \quad 则 x^* 是严格最优的</script></li></ul><h4 id="无约束优化：线搜索-和-信赖域"><a href="#无约束优化：线搜索-和-信赖域" class="headerlink" title="无约束优化：线搜索 和 信赖域"></a>无约束优化：线搜索 和 信赖域</h4><p>考虑无约束优化问题： $\min f(x)$</p><p>迭代下降算法的描述：</p><p>给定一个初始点 $x_0$ ，我们可以判断 $x_0$ 是否是我们需要找的点，如果不是，我们要产生点列 $\{x_k\}^\infin_{k=1}$ ，并且满足 $f(x_{k+1}) &lt; f(x)$ “下一个点的函数值比当前点的函数值小”。我们有两种策略：线搜索 (Line search) 和 信赖域 (Trust region)</p><h5 id="线搜索方法"><a href="#线搜索方法" class="headerlink" title="线搜索方法"></a>线搜索方法</h5><h6 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h6><ol><li>给定初始点 $x_0$</li><li>判断 $x_0$ 是否满足【终止条件】；是，则终止</li><li>当前点为 $x_k$，首先找到【下降方向 $d_k$】（从这个点出发，有一段步长的距离，目标函数值会减小的方向）</li><li>确定【步长 $\alpha _k &gt; 0$ 】，使得 $f(x_k + \alpha_k d_k) &lt; f(x)$</li><li>我们就得到了下一个点 $x_{k+1} :=x_k + \alpha_k d_k$；转第 2 步</li></ol><ul><li>终止条件：$\lVert \nabla f(x_k) \rVert_2 \le \mathcal{E}$，其中 $\mathcal{E}$ 是一个很小的正整数，意味着当梯度趋近于 0</li><li>下降方向 $d_k$ 的选择：最速下降、共轭梯度等</li><li>步长 $\alpha _k$ 的选择：我们令 $\phi(\alpha) := f(x_k + \alpha d_k)$，步长 $\alpha_k = \min \phi (\alpha),\alpha \ge 0$</li><li>算法结束后会给我们一个点列 $\{x_k\}$，我们需要关心点列的收敛性和收敛速度</li></ul><h5 id="信赖域方法"><a href="#信赖域方法" class="headerlink" title="信赖域方法"></a>信赖域方法</h5><ol><li>当前点为 $x_k$，首先决定“活动范围 $\Delta$” $\lVert d\rVert_2 \le \Delta$</li><li>再决定“活动方向”</li></ol><h4 id="无约束优化：最速下降"><a href="#无约束优化：最速下降" class="headerlink" title="无约束优化：最速下降"></a>无约束优化：最速下降</h4><h5 id="收敛速度"><a href="#收敛速度" class="headerlink" title="收敛速度"></a>收敛速度</h5><p>设当前点列 $\{x_k\}$ 收敛到 $x^*$，若存在极限</p><script type="math/tex; mode=display">\lim_{k\to \infin} \frac{\lVert x_{k+1} - x^* \rVert_2}{\lVert x_{k} - x^* \rVert_2} = \beta</script><ul><li>当 $0 &lt; \beta &lt; 1$ 时，则称点列 $\{x_k\}$ 为<strong>线性收敛</strong></li><li>当 $\beta = 0$ 时，则称点列 $\{x_k\}$ 为<strong>超线性收敛</strong></li></ul><p>若存在某个 $p \ge 1$，有</p><script type="math/tex; mode=display">\lim_{k\to \infin} \frac{\lVert x_{k+1} - x^* \rVert_2}{\lVert x_{k} - x^* \rVert_2^p} = \beta <+\infin</script><p>则称点列 $\{x_k\}$ 为<strong>p阶收敛</strong></p><ul><li>当 $p &gt; 1$ 时，p阶收敛必为超线性收敛</li></ul><h5 id="最速下降法"><a href="#最速下降法" class="headerlink" title="最速下降法"></a>最速下降法</h5><p>也叫做梯度下降法。【基本思想】是选择 $x_k$ 处的负梯度方向作为搜素方向，即 $d_k = -\nabla f(x_k) $</p><ul><li>优点：简单直观；收敛；搜素方向只需计算 $-\nabla f(x_k) $</li><li>缺点：收敛速度慢（线性搜索）；Zigzag现象（路径是“之”字形）；不具备“在有限步内求得凸二次函数最优解”的特性</li></ul><h4 id="约束优化：-mathcal-KKT-条件"><a href="#约束优化：-mathcal-KKT-条件" class="headerlink" title="约束优化：$\mathcal{KKT}$ 条件"></a>约束优化：$\mathcal{KKT}$ 条件</h4><h5 id="一阶必要条件-最优解-to-mathcal-KKT-点"><a href="#一阶必要条件-最优解-to-mathcal-KKT-点" class="headerlink" title="一阶必要条件 : $最优解 \to \mathcal{KKT} 点$"></a>一阶必要条件 : $最优解 \to \mathcal{KKT} 点$</h5><p>假设 $x^<em>$ 是问题 $\mathcal{P}$ 的局部最优解，且 $x^</em>$ 某处的约束规范 (constraint qualification) 成立，则存在 $\lambda$，$\mu$ 使得</p><script type="math/tex; mode=display">\min_{x\in \R^2} f(x) \\s.t. \quad \forall i \in \{1,2,...,l\}:h_i(x)=0\quad 且 \quad \forall j \in \{1,2,...,m\}:g_j(x) \le 0 \\可行集 S(\mathcal{E}) = \{x| 满足 \; s.t.\} \\</script><ol><li><script type="math/tex; mode=display">\nabla f(x^*) + \sum_{i=1}^m \lambda_i \nabla g_i(x^*) + \sum_{i=1}^l \mu_i \nabla h_i(x^*)= 0</script></li><li><p>$\forall i \in \{1,2,…,m\}:\lambda_i \ge 0$</p></li><li><p>$\forall i \in \{1,2,…,m\}:g_i(x^*) \le 0$</p></li><li><p>$\forall i \in \{1,2,…,m\}:h_i(x^*) = 0$</p></li><li><p>$\forall i \in \{1,2,…,m\}:\lambda_i g_i(x^*) = 0$</p></li></ol><h5 id="二阶充分条件-mathcal-KKT-点-to-最优解"><a href="#二阶充分条件-mathcal-KKT-点-to-最优解" class="headerlink" title="二阶充分条件 : $\mathcal{KKT}点 \to 最优解$"></a>二阶充分条件 : $\mathcal{KKT}点 \to 最优解$</h5><p>假设 $x^*$ 满足上述的 $\mathcal{KKT}$ 条件，我们定义一个函数 $\mathcal{L}(x) = f(x) + \sum \mu_i h_i(x) + \sum \lambda_i g_i(x))$，可知：</p><ol><li>$\nabla_{x} \mathcal{L}(x^*) = 0 \qquad \mathcal{KKT}\text{条件中的第 1 条}$</li><li>$\mathcal{L}(x^<em>) = f(x^</em>) + \sum \mu_i h_i(x^<em>) + \sum \lambda_i g_i(x^</em>)) = f(x^<em>) + 0 + 0 \quad \Rightarrow \quad \mathcal{L}(x^</em>) = f(x^*)$</li><li>$\forall x \in S(\mathcal{E}),\;\mathcal{L}(x) \le f(x)$</li></ol><p>有以下结论：</p><ul><li>由 2, 3 可知，若 $x^<em>$ 是 $\mathcal{L} (x)$ 的最优解，则$x^</em>$ 也是 $\mathcal{P}$ 的最优解：$f(x^<em>) = \mathcal{L}(x^</em>) \le \mathcal{L}(x) \le f(x)$</li><li>若 $\nabla_{xx} \mathcal{L}(x^<em>) \succeq 0, \; \forall x \in S(\mathcal{E})$，则 $x^</em>$ 是 $\mathcal{P}$ 的<u>全局最优解</u></li><li>若 $\nabla_{xx} \mathcal{L}(x^<em>) \succeq 0, \; \forall x \in \{S(\mathcal{E})\cap _{临域}N_S(x</em>)\}$，则 $x^*$ 是 $\mathcal{P}$ 的<u>局部最优解</u></li><li>若 $\nabla_{xx} \mathcal{L}(x^<em>) \succ 0$，则 $x^</em>$ 是 $\mathcal{P}$ 的<u>严格局部最优解</u></li></ul><h4 id="约束优化：对偶理论"><a href="#约束优化：对偶理论" class="headerlink" title="约束优化：对偶理论"></a>约束优化：对偶理论</h4><p>考虑如下一般形式的约束优化问题：</p><script type="math/tex; mode=display">(\mathcal{P}):\; \min_{x\in \R^2} f(x) \\s.t. \quad \left\{\begin{aligned}& h_i(x)=0, \;\forall i \in \{1,2,...,l\} \\ & g_j(x) \le 0 , \; \forall j \in \{1,2,...,m\} \\& x \in X\end{aligned}\right.\\ \\可行集 S(\mathcal{E}) = \{ x \in X | 满足 \; s.t.\} \\</script><p>其中 $X$ 是“<strong>集合约束</strong>”，如果：</p><ol><li>$X = \R^n$ 所研究的问题 $\mathcal{P}$ 就是在 <strong>n 维实数域</strong>上的<strong>连续优化问题</strong>，就可以运用以上知识</li><li>$X = \Z^n_+$ 所研究的问题 $\mathcal{P}$ 就是在 <strong>n 维整数（或非负整数）域</strong>上的<strong>连续优化问题</strong>，就可以运用以上知识</li><li>$X = \{0,1\}^n$ 所研究的问题 $\mathcal{P}$ 就是在 <strong>n 维 0-1 集合</strong>上的<strong>离散整数优化问题</strong></li></ol><h5 id="对偶问题的意义"><a href="#对偶问题的意义" class="headerlink" title="对偶问题的意义"></a>对偶问题的意义</h5><script type="math/tex; mode=display">原问题 \; (\mathcal{P}) \quad \xrightarrow{构建} \quad 对偶问题 \; (\mathcal{D})</script><ol><li>如果原问题 $(\mathcal{P})$ 是非凸问题，我们很难求解这一类 <code>NP-hard</code> 问题，我们就可以构造一个和原问题 $(\mathcal{P})$ 的关系紧密又简单的对偶问题 $(\mathcal{D})$ 来求解；</li><li>在线性规划问题中的对偶问题；</li><li>鲁棒优化，锥优化</li></ol><h5 id="拉格朗日对偶问题"><a href="#拉格朗日对偶问题" class="headerlink" title="拉格朗日对偶问题"></a>拉格朗日对偶问题</h5><script type="math/tex; mode=display">(\mathcal{P}):\; \min_{x\in \R^2} f(x) \\s.t. \quad \left\{\begin{aligned}& h_i(x)=0, \;\forall i \in \{1,2,...,l\} \\ & g_j(x) \le 0 , \; \forall j \in \{1,2,...,m\} \\& x \in X\end{aligned}\right.\\ \\可行集 S(\mathcal{E}) = \{ x \in X | 满足 \; s.t.\} \\</script><p>我们引入拉格朗日函数：</p><script type="math/tex; mode=display">\mathcal{L}(x, \lambda, \mu) = f(x) + \sum_{i=1}^l \mu_i h_i(x) + \sum_{i=1}^m \lambda_i g_i(x))</script><p>此时我们对拉格朗日函数 $\mathcal{L}$ 求最小值，得到拉格朗日对偶函数 (dual function)：</p><script type="math/tex; mode=display">\begin{aligned}d(\lambda,\mu)& = \min _{x \in X} (\mathcal{L}(x, \lambda, \mu)) = \min _{x \in X} \{ f(x) + \sum_{i=1}^l \mu_i h_i(x) + \sum_{i=1}^m \lambda_i g_i(x)\} \\& \le \min _{x \in S(\mathcal{E})} \{ f(x) + \sum_{i=1}^l \mu_i h_i(x) + \sum_{i=1}^m \lambda_i g_i(x)\} \\& \le \min _{x \in S(\mathcal{E})} \{ f(x) \}\end{aligned}</script><ul><li>对于 $\forall (\lambda, \mu), \lambda \ge 0$ 必有 $d(\lambda,\mu) \le v (\mathcal{P})$，即 $d(\lambda, \mu)$ 是 $v (\mathcal{P})$ 的下界，所以我们要找出 $d(\lambda, \mu)$ 的【最大值】</li></ul><p>此时我们就可以给出拉格朗日问题的对偶问题 $(\mathcal{D})$ ：</p><script type="math/tex; mode=display">(\mathcal{D}):\; \max d(\lambda, \mu) \\s.t. \quad \lambda_i \ge 0,\; \forall i \in \{1,2,...,m\}</script><p>写成以下形式：</p><script type="math/tex; mode=display">(\mathcal{D}):\; \max _{\lambda \ge 0} \quad \min _{x \in X} (\mathcal{L}(x, \lambda, \mu)) \quad \xrightarrow{交换} \quad \min _{x \in X} \quad \max _{\lambda \ge 0}  (\mathcal{L}(x, \lambda, \mu))</script><p>经过推导，问题 $(\mathcal{D})$ 可转化成原问题 $(\mathcal{P})$：</p><script type="math/tex; mode=display">(\mathcal{P}):\; \min_{x\in \R^2} f(x) \\s.t. \quad \left\{\begin{aligned}& h_i(x)=0, \;\forall i \in \{1,2,...,l\} \\ & g_j(x) \le 0 , \; \forall j \in \{1,2,...,m\} \\& x \in X\end{aligned}\right.</script><h5 id="弱对偶定理"><a href="#弱对偶定理" class="headerlink" title="弱对偶定理"></a>弱对偶定理</h5><p>在之前拉格朗日对偶问题中，“对于 $\forall (\lambda, \mu), \lambda \ge 0$ 必有 $d(\lambda,\mu) \le v (\mathcal{P})$，即 $d(\lambda, \mu)$ 是 $v (\mathcal{P})$ 的下界，所以我们要找出 $d(\lambda, \mu)$ 的最大值”。我们可以推导到一般：</p><ul><li>设 $ v (\mathcal{P})$ 是原问题 $(\mathcal{P})$ 的最优值，$ v (\mathcal{D})$ 是对偶问题 $(\mathcal{D})$ 的最优值，则 $ v (\mathcal{D}) \le v (\mathcal{P})$ </li></ul><p>推论：假设 $\bar x \in S(\mathcal{E})，(\bar \lambda,\bar \mu),\bar \lambda \ge 0 \; 且 \; d(\bar \lambda,\bar \mu) = f(\bar x)$，则 $ v (\mathcal{P}) =  v (\mathcal{D}) \; 且 \; \bar x,(\bar \lambda,\bar \mu) \; 是\; v (\mathcal{P}) \; 和 \; v (\mathcal{D}) \; 的最优解$</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h4 id=&quot;最优化问题解题步骤&quot;&gt;&lt;a href=&quot;#最优化问题解题步骤&quot; class=&quot;headerlink&quot; title=&quot;最优化问题解题步骤&quot;&gt;&lt;/a&gt;最优化问题解题步骤&lt;/h4&gt;&lt;h5 id=&quot;1-建模最优化问题&quot;&gt;&lt;a href=&quot;#1-建模最优化问题&quot; class</summary>
      
    
    
    
    <category term="课程笔记" scheme="https://dave0126.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="课程笔记" scheme="https://dave0126.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="最优化" scheme="https://dave0126.github.io/tags/%E6%9C%80%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>拉格朗日乘数与KKT几何关联推导</title>
    <link href="https://dave0126.github.io/2022/04/21/KKT/"/>
    <id>https://dave0126.github.io/2022/04/21/KKT/</id>
    <published>2022-04-21T20:57:45.000Z</published>
    <updated>2022-04-24T07:18:01.085Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Lagrange-Multipliers-amp-mathcal-KKT-几何关联推导"><a href="#Lagrange-Multipliers-amp-mathcal-KKT-几何关联推导" class="headerlink" title="Lagrange Multipliers &amp; $\mathcal{KKT}$ 几何关联推导"></a>Lagrange Multipliers &amp; $\mathcal{KKT}$ 几何关联推导</h3><h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>我们想要找到一个满足一些约束的函数的最大值或最小值</p><h4 id="公式描述"><a href="#公式描述" class="headerlink" title="公式描述"></a>公式描述</h4><p>给定一个函数 $f$，不等式约束 $g_1, . . . , g_m$ 和等式约束 $h_1,…, h_l$ 都在在定义域 $Ω ⊂ \mathbb{R}^n$ 上的优化问题：</p><script type="math/tex; mode=display">\min_{x∈Ω} \;f(x) \\s.t.\left\{\begin{aligned}∀i \quad g_i(x) ≤ 0 \\∀j \quad h_j (x) = 0 \end{aligned}\right.</script><h4 id="No-constraints"><a href="#No-constraints" class="headerlink" title="No constraints"></a>No constraints</h4><p><strong>Assume</strong>: Let $f$ : $Ω → \mathbb{R}$  be a continuously differentiable function. 在定义域上连续可微</p><p>【局部最小值】的【充要条件】(Necessary and sufficient conditions): </p><p>$x^*$ is a local minimum of $f(x)$ 当且仅当</p><ol><li><p>$f$ 在 $x^*$ 处是零梯度 (zero gradient)：</p><script type="math/tex; mode=display">∇_x f(x^∗) = 0</script></li><li><p>$f$ 的 Hessian 矩阵在 $x^<em>$ 处是半正定的 (positive semi-definite)：保证$f$ 在 $x^</em>$ 处是“波谷”</p><script type="math/tex; mode=display">v^t (∇^2f(x^*)) v ≥ 0, ∀v ∈ \mathbb{R}^n\\\\ \nabla_{xx}^2 f(x) =\begin{bmatrix}\frac{\partial^2 f(x)}{\partial x_1 ^2} & \frac{\partial^2 f(x)}{\partial x_1 \partial x_2} & \cdots & \frac{\partial^2 f(x)}{\partial x_1 \partial x_n}      \\\frac{\partial^2 f(x)}{\partial x_2 \partial x_1} & \frac{\partial^2 f(x)}{\partial x_2 ^2} & \cdots & \frac{\partial^2 f(x)}{\partial x_2 \partial x_n}      \\\vdots & \vdots & \ddots & \vdots \\\frac{\partial^2 f(x)}{\partial x_n \partial x_1} & \frac{\partial^2 f(x)}{\partial x_n  \partial x_2} & \cdots & \frac{\partial^2 f(x)}{\partial x_n ^2}      \\\end{bmatrix}\leftarrow Hessian \; Matrix</script></li></ol><p>【局部最大值】的【充要条件】(Necessary and sufficient conditions): $x^*$ is a local minimum of $f(x)$ 当且仅当</p><ol><li><p>$f$ 在 $x^*$ 处是零梯度 (zero gradient)：</p><script type="math/tex; mode=display">∇_x f(x^∗) = 0</script></li><li><p>$f$ 的 Hessian 矩阵在 $x^<em>$ 处是半正定的 (positive semi-definite)：保证$f$ 在 $x^</em>$ 处是“波谷”</p><script type="math/tex; mode=display">v^t (∇^2f(x^*)) v \le 0, ∀v ∈ \mathbb{R}^n \\\\\\\nabla^2 f(x) =\begin{bmatrix}\frac{\partial^2 f(x)}{\partial x_1 ^2} & \frac{\partial^2 f(x)}{\partial x_1 \partial x_2} & \cdots & \frac{\partial^2 f(x)}{\partial x_1 \partial x_n}      \\\frac{\partial^2 f(x)}{\partial x_2 \partial x_1} & \frac{\partial^2 f(x)}{\partial x_2 ^2} & \cdots & \frac{\partial^2 f(x)}{\partial x_2 \partial x_n}      \\\vdots & \vdots & \ddots & \vdots \\\frac{\partial^2 f(x)}{\partial x_n \partial x_1} & \frac{\partial^2 f(x)}{\partial x_n  \partial x_2} & \cdots & \frac{\partial^2 f(x)}{\partial x_n ^2}      \\\end{bmatrix}\leftarrow Hessian \; Matrix</script></li></ol><h4 id="Equality-Constrainsts"><a href="#Equality-Constrainsts" class="headerlink" title="Equality Constrainsts"></a>Equality Constrainsts</h4><p>问题提出：</p><script type="math/tex; mode=display">\min_{x∈\mathbb{R}^2} \;f(x) \\s.t. \quad h_i (x) = 0, \; ∀i\in \{1,2,...,l\}</script><p>举例：</p><script type="math/tex; mode=display">f(x) = x_1 + x_2 \\s.t.\; h(x) = x^2_1 + x^2_2 − 2</script><ol><li><p>可行点 (feasible point) $x_F \in$ 可行域 (feasible region) 满足约束 $h(x) = x^2_1 + x^2_2 − 2 = 0$，图形上的表示就是在 $x^2_1 + x^2_2 − 2$ 的圆上</p></li><li><p>目标函数 $f(x) = x_1 + x_2$ 的梯度方向 $\nabla_x f(x) = [1,1]^T$，所以它的负梯度方向为 $- \nabla_x f(x) = [-1,-1]^T$</p></li><li><p>我们找到一个点 $x_i$ 满足约束：其中 $\alpha$ 为步长，$\delta x_i$ 为 $x_i$ 点的运动方向</p><ul><li>$h(x_F + \alpha \delta x_i) = 0$（确保在圆上）</li><li>$f(x_F + \alpha \delta x) &lt; f(x_F)$（确保移动后的函数值 &lt; 移动前）</li></ul><p><img src="/2022/04/21/KKT/2022-04-23 20.51.01.png" alt="2022-04-23 20.51.01" style="zoom:35%;"></p></li><li><p>一个点 $x_i$ 要沿着 $f(x)$ 的最速下降 (the steepest descent) 方向，即负梯度方向为 $- \nabla_x f(x) = [-1,-1]^T$ ；但是 $x_i$ 还要满足等式约束，所以我们要确保 $\delta x_i$ 与 负梯度方向 $- \nabla_x f(x)$ 的夹角为锐角，即内积 $\delta x_i \cdot (- \nabla_x f(x_F)) &gt; 0$</p><p><img src="/2022/04/21/KKT/2022-04-23 21.12.41.png" alt="2022-04-23 21.12.41" style="zoom:35%;"></p><ul><li>至此，我们就找到了满足约的点 $x_i$ 移动的方向，即与目标函数 $f(x)$ 负梯度方向的夹角为锐角的约束函数 $h(x)$ 的切线方向。那么，什么时候停止移动呢？</li></ul></li><li><p>从图像中我们可以看到，当目标函数 $f(x)$ 与约束函数 $h(x)$ 相切的时候，我们可以取到局部极值点 (临界点 critical point)，即 目标函数 $f(x)$ 的梯度方向与约束函数 $h(x)$ 的梯度方向共线：</p><script type="math/tex; mode=display">\nabla_x f(x_F) = \mu \nabla_x h(x_F)\quad \Rightarrow \quad\nabla_x f(x_F) + \mu \nabla_x h(x_F) = 0 \quad ①</script><p>这个条件【确保局部极值】</p><p><img src="/2022/04/21/KKT/2022-04-23 21.30.49.png" alt="2022-04-23 21.30.49" style="zoom:35%;"></p><p>而此时， $x_i$ 移动的方向 $\delta x_i$ 始终与约束函数 $g(x)$ 梯度方向 $\nabla_x h(x)$ 正交，即</p><script type="math/tex; mode=display">\delta x_i \cdot \mu \nabla_x h(x_F) = \delta x_i \cdot (- \nabla_x h(x_F))</script></li></ol><ol><li><p>我们重新构造这个优化问题 $(\mathcal{P})$，并推广到多等式约束：</p><script type="math/tex; mode=display">\min_{x∈\mathbb{R}^2} \;f(x) \\s.t. \quad h_i (x) = 0, \; ∀i\in \{1,2,...,l\}</script><p>我们定义拉格朗日函数 $\mathcal{L}$：</p><script type="math/tex; mode=display">\mathcal{L} (x, \mu) = f(x) + \sum_{i=1}^l \mu_i h_i(x)</script><p>当 $x^<em>$ 是局部最小值时，存在唯一的 $\mu ^</em>$ 满足约束：</p><ul><li>$\nabla_{x} \mathcal{L} (x^<em>,\mu ^</em>)= 0 \qquad \Leftarrow \qquad \nabla_x f(x_F) + \mu \nabla_x h(x_F) = 0 \quad ①$ </li><li>$\begin{aligned} \nabla_{\mu} \mathcal{L} (x^<em>,\mu ^</em>)= 0 \qquad \Leftarrow \qquad \frac {\partial \mathcal{L} (x,\mu_i)}{\partial \mu_i} = h_i(x) = 0\end{aligned} \quad \text{满足约束条件}$ </li><li>$\nabla_{xx}^2 \mathcal{L}(x^<em>, \mu^</em>) \succeq 0\qquad \Leftarrow \qquad \text{Hessain matrix 半正定：满足局部极小}$</li></ul></li></ol><h4 id="Inequality-Constraints"><a href="#Inequality-Constraints" class="headerlink" title="Inequality Constraints"></a>Inequality Constraints</h4><p>问题提出：</p><script type="math/tex; mode=display">\min_{x∈\mathbb{R}^2} \;f(x) \\s.t. \quad g_j (x) \le 0, \; ∀j\in \{1,2,...,m\}</script><h5 id="Case-1-可退化到无约束"><a href="#Case-1-可退化到无约束" class="headerlink" title="Case 1 : 可退化到无约束"></a>Case 1 : 可退化到无约束</h5><p>举例：</p><script type="math/tex; mode=display">f(x) = x_1^2 + x_2^2 \\s.t.\; h(x) = x^2_1 + x^2_2 − 1</script><p><img src="/2022/04/21/KKT/2022-04-23 22.33.13.png" alt="2022-04-23 22.33.13" style="zoom:40%;"></p><ol><li>可以从图像中看出，当 $f(x)$ 不加约束条件时的最优点为 $(0,0)$</li><li>可行点 (feasible point) $x_F \in$ 可行域 (feasible region) 满足约束 $h(x) = x^2_1 + x^2_2 − 1 = 0$，图形上的表示就是在 $x^2_1 + x^2_2 − 1$ 的圆上</li><li>当 $f(x)$ 加入约束条件时的最优点还是 $(0,0)$</li><li>说明有无约束条件对这个问题的求解并没有影响</li><li>此时我们就可以将这个约束优化问题退化成无约束问题：<ul><li>$f(x)$ 在 $x^*$ 处是零梯度 (zero gradient)：$∇_x f(x^∗) = 0$</li><li>$f$ 的 Hessian 矩阵在 $x^<em>$ 处是半正定的 (positive definite) ：$\nabla_{xx}^2 f(x^</em>) \succeq 0$</li></ul></li></ol><h5 id="Case-2-不等式约束"><a href="#Case-2-不等式约束" class="headerlink" title="Case 2 : 不等式约束"></a>Case 2 : 不等式约束</h5><p>我们更改上一例题的条件：</p><script type="math/tex; mode=display">f(x) = (x_1 - 1.1)^2 + (x_2 - 1.1)^2 \\s.t.\; h(x) = x^2_1 + x^2_2 − 1</script><p><img src="/2022/04/21/KKT/2022-04-23 22.49.34.png" alt="2022-04-23 22.49.34" style="zoom:40%;"></p><ol><li><p>可以从图像中看出，当 $f(x)$ 不加约束条件时的最优点为 $(1.1,-1.1)$</p></li><li><p>可行点 (feasible point) $x_F \in$ 可行域 (feasible region) 满足约束 $h(x) = x^2_1 + x^2_2 − 1 = 0$，图形上的表示就是在 $x^2_1 + x^2_2 − 1$ 的圆上</p></li><li><p>当 $f(x)$ 加入约束条件时的最优点并不在原来的 $(1.1,-1.1)$ 点</p></li><li><p>在这种情况下，极值在约束面上，即 $g(x^<em>) = 0$，此时就与<em>*等式约束条件</em></em>一致了</p></li><li><p>所以参考等式约束问题，最优值出现在目标函数 $f(x)$ 的梯度方向与约束函数 $h(x)$ 的梯度方向共线：</p><script type="math/tex; mode=display">-\nabla_x f(x) = \lambda \nabla_x g(x), \lambda > 0\quad \Rightarrow \quad\nabla_x f(x) + \lambda \nabla_x g(x) = 0 \quad ②</script><p><img src="/2022/04/21/KKT/2022-04-23 22.57.55.png" alt="2022-04-23 22.57.55" style="zoom:40%;"></p></li></ol><h5 id="总结两种情况"><a href="#总结两种情况" class="headerlink" title="总结两种情况"></a>总结两种情况</h5><script type="math/tex; mode=display">\min_{x∈\mathbb{R}^2} \;f(x) \\s.t. \quad g_j (x) \le 0, \; ∀j\in \{1,2,...,m\}</script><h6 id="Case-1-无约束时的局部极小值在可行域【中】"><a href="#Case-1-无约束时的局部极小值在可行域【中】" class="headerlink" title="Case 1 : 无约束时的局部极小值在可行域【中】"></a>Case 1 : 无约束时的局部极小值在可行域【中】</h6><ol><li>$g(x^*) &lt; 0 \qquad \Leftarrow \qquad 在可行域里$</li><li>$\nabla_x f(x^<em>) = \nabla_x f(x^</em>) + \lambda_{(=0)} \nabla_x g(x^*) = 0 \qquad \Leftarrow \qquad \mathcal{KKT} 条件1$</li><li>$\nabla_{xx}^2 f(x^*) \succeq 0 \qquad \Leftarrow \qquad Hessian 矩阵是半正定的$</li></ol><h6 id="Case-2-无约束时的局部极小值在可行域【外】"><a href="#Case-2-无约束时的局部极小值在可行域【外】" class="headerlink" title="Case 2 : 无约束时的局部极小值在可行域【外】"></a>Case 2 : 无约束时的局部极小值在可行域【外】</h6><ol><li>$g(x^*) = 0 \qquad \Leftarrow \qquad \mathcal{KKT} 条件3$</li><li>$- \nabla_x f(x^<em>) + \lambda \nabla_x g(x^</em>) = 0, \; \lambda &gt; 0 \qquad \Leftarrow \qquad \mathcal{KKT} 条件1$</li><li>$\nabla_{xx}^2 f(x^*) \succeq 0 \qquad \Leftarrow \qquad Hessian 矩阵是半正定的$</li></ol><p>$\mathcal{KKT}$ 条件4 ：$x^*$ 是可行点</p><h5 id="多等式和多不等式的-mathcal-KKT-条件"><a href="#多等式和多不等式的-mathcal-KKT-条件" class="headerlink" title="多等式和多不等式的 $\mathcal{KKT}$ 条件"></a>多等式和多不等式的 $\mathcal{KKT}$ 条件</h5><p>给定一个函数 $f$，不等式约束 $g_1, . . . , g_m$ 和等式约束 $h_1,…, h_l$ 都在在定义域 $Ω ⊂ \mathbb{R}^n$ 上的优化问题：</p><script type="math/tex; mode=display">(\mathcal{P}):\; \min_{x\in Ω} f(x) \\s.t. \quad \left\{\begin{aligned}& h_i(x)=0, \;\forall i \in \{1,2,...,l\} \\ & g_j(x) \le 0 , \; \forall j \in \{1,2,...,m\} \end{aligned}\right.</script><p>我们定义拉格朗日函数 $\mathcal{L}$：</p><script type="math/tex; mode=display">\mathcal{L}(x, \lambda, \mu) = f(x) + \sum_{i=1}^l \mu_i h_i(x) + \sum_{j=1}^m \lambda_j g_j(x))</script><p>当 $x^<em>$ 是局部最小值时，存在唯一的 $\mu ^</em>$ 满足约束：</p><ul><li><p>$\nabla_{x} \mathcal{L} (x^<em>,\mu ^</em>, \lambda^<em>)= 0 \qquad \Leftarrow \qquad \nabla_x f(x^</em>) + \sum_{i=1}^l \mu_i \nabla_x h_i(x^<em>) + \sum_{j=1}^m \lambda_j \nabla_x g_j(x^</em>) = 0$ </p></li><li><p>$\lambda^*_j \ge 0 \text{ for } j=1,…,m$</p></li><li>$\lambda^<em>_j g_j(x^</em>) = 0 \text{ for } j=1,…,m$</li><li>$g_j(x^*) \le 0 \text{ for } j=1,…,m$</li><li>$g_i(x^*) = 0 \text{ for } i=1,…,l$</li><li>$\nabla_{xx}^2 \mathcal{L}(x^<em>, \lambda^</em>) \succ 0\qquad \Leftarrow \qquad \text{Hessain matrix 正定：满足局部极小}$</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Lagrange-Multipliers-amp-mathcal-KKT-几何关联推导&quot;&gt;&lt;a href=&quot;#Lagrange-Multipliers-amp-mathcal-KKT-几何关联推导&quot; class=&quot;headerlink&quot; title=&quot;Lagran</summary>
      
    
    
    
    <category term="课程笔记" scheme="https://dave0126.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="课程笔记" scheme="https://dave0126.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="最优化" scheme="https://dave0126.github.io/tags/%E6%9C%80%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>运筹学</title>
    <link href="https://dave0126.github.io/2022/04/19/%E8%BF%90%E7%AD%B9%E5%AD%A6/"/>
    <id>https://dave0126.github.io/2022/04/19/%E8%BF%90%E7%AD%B9%E5%AD%A6/</id>
    <published>2022-04-19T20:02:52.000Z</published>
    <updated>2022-04-27T19:41:31.396Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基础运筹学"><a href="#基础运筹学" class="headerlink" title="基础运筹学"></a>基础运筹学</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><a href>本文章</a>是根据法国国立高等电力技术、电子学、计算机、水力学与电信学校 (E.N.S.E.E.I.H.T.) 第七学期课程<em>“Recherche Operation”</em> 总结而来的【部分课程笔记】。碍于本人学识有限，部分叙述难免存在纰漏，请读者注意甄别。</p><p>总而言之，运筹学就是从真实系统中<strong>建立模型</strong>，用数学的形式表示出来。</p><span id="more"></span><h3 id="附录一：KKT-和-拉格朗日乘子"><a href="#附录一：KKT-和-拉格朗日乘子" class="headerlink" title="附录一：KKT 和 拉格朗日乘子"></a>附录一：KKT 和 拉格朗日乘子</h3><h5 id="关系：-KKT-，拉格朗日乘子-和-线性规划"><a href="#关系：-KKT-，拉格朗日乘子-和-线性规划" class="headerlink" title="关系：$KKT$ ，拉格朗日乘子 和 线性规划"></a>关系：$KKT$ ，拉格朗日乘子 和 线性规划</h5><p>本科阶段，我们在高等数学中认识了拉格朗日乘子。其研究范围可以认为是</p><script type="math/tex; mode=display">拉格朗日乘子 \sim 在约束条件为强约束（即约束条件都为等式）的情况下，非线性规划的问题中求解最优值。</script><p>而 $KKT$ 研究范围可以认为是</p><script type="math/tex; mode=display">KKT \sim 在约束条件为弱约束（即约束条件有不等式）的情况下，非线性规划的问题中求解最优值。</script><p>线性规划问题的研究范围可以认为是</p><script type="math/tex; mode=display">LP(线性规划) \sim 在约束条件下，线性规划的问题中求解最优值。</script><p>所以我们可以认为 $KKT &gt; 拉格朗日乘子$，$KKT &gt; LP &gt; 整数线性规划$</p><h4 id="拉格朗日乘子"><a href="#拉格朗日乘子" class="headerlink" title="拉格朗日乘子"></a>拉格朗日乘子</h4><p>引例：我们有如下问题</p><script type="math/tex; mode=display">W = f(x,y,z) = 3x^2 + 2y^2 - 4z^2\\s.t.\left\{\begin{aligned}3x + 4y -z = 0\\6x^2 + y - z^2 = 0\end{aligned}\right.</script><p>由于对于拉格朗日乘子法的证明过程并不感兴趣，所以在此不加证明地直接给出其计算方法：</p><ol><li><p>已知我们想要求解目标函数 $W = f(x,y,z) = 3x^2 + 2y^2 - 4z^2$ 的最大值$maxW$ 或最小值$minW$​，我们有两个约束条件$g_1,g_2$： $s.t.\left\{\begin{aligned} g_1:3x + 4y -z = 0\\ g_2:6x^2 + y - z^2 = 0 \end{aligned}\right.$</p></li><li><p>我们引入拉格朗日乘子 $\lambda _i$ 辅助求解该问题。拉格朗日乘子 $\lambda _i$ 引入的数量由<strong>约束条件的数量决定</strong>。所以本引例中需要引入两个拉格朗日乘子 $\lambda_1, \lambda_2$ 。</p></li><li><p>构造一个包含拉格朗日乘子 $\lambda_1,\lambda_2$ 的新函数 $F(x,y,z,\lambda_i) = f(x,y,z) + \lambda_1g_1 + \lambda_2g_2 + …+ \lambda_ng_n$ 。所以原函数可转化为以下的拉格朗日函数：</p><script type="math/tex; mode=display">\begin{aligned}F(x,y,z,\lambda_1,\lambda_2) & =  f(x,y,z) + \lambda_1g_1 + \lambda_2g_2\\&= 3x^2 + 2y^2 - 4z^2 + \lambda_1 (3x + 4y -z) + \lambda_2(6x^2 + y - z^2)\end{aligned}</script></li><li><p>则我们就可以通过导数的方法求解此问题 $F(x,y,z,\lambda_1,\lambda_2)$ 。对 $F$ 求偏导，有几个自变量，就求几次偏导，令其都等于 0。方程 ①②③④⑤ 一定能得到不止一组的解 $(x_i,\; y_i,\; z_i,\; {\lambda_1}_i,\; {\lambda_2}_i)$ ，将解得的解 $(x_i,\; y_i,\; z_i,\; {\lambda_1}_i,\; {\lambda_2}_i)$ 代入原来的目标函数 $W=f(x,y,z)$ 中，算出的 $W_{max}$ 和 $W_{min}$。</p><script type="math/tex; mode=display">\left\{\begin{aligned}\frac {\partial F}{\partial x} =0 \qquad ①\\\frac {\partial F}{\partial y} =0 \qquad ②\\\frac {\partial F}{\partial z} =0 \qquad ③\\\frac {\partial F}{\partial {\lambda_1}} =0 \qquad ④\\\frac {\partial F}{\partial {\lambda_2}} =0 \qquad ⑤\\\end{aligned}\right.\quad \stackrel{解}{\Longrightarrow} \quad\begin{pmatrix}x_i\\y_i\\z_i\\{\lambda_1}_i\\{\lambda_2}_i\\\end{pmatrix}\quad \stackrel{代入原来的目标函数}{\Longrightarrow} \quadf(x_i,y_i,z_i)\quad \stackrel{找Min和Max}{\Longrightarrow} \quad(W_{max}, W_{min})</script></li></ol><h4 id="KKT"><a href="#KKT" class="headerlink" title="KKT"></a>KKT</h4><p>KKT 本质上是拉格朗日乘数法的推广，即推广到弱约束（即约束条件有不等式）条件。</p><p>【拉格朗日乘数法】：</p><script type="math/tex; mode=display">Z_{max}或Z_{min} = f(x,y,z,...)\\g_1 =0, \; g_2 =0,\; g_3 = 0\\①观察约束条件，有几个约束，方程就引入几个拉格朗日乘子 \lambda ,对于\lambda 无限制\\②构建F(x,y,z,\lambda_1, \lambda_2, \lambda_3) = f(x,y,z) + \lambda_1g_1 + \lambda_2g_2 + \lambda_3g_3\\③\left\{\begin{aligned}\frac {\partial F}{\partial x} =0 \quad \stackrel{本质是}{\Longrightarrow} \quad F对目标函数的自变量求偏导\\ \frac {\partial F}{\partial y} =0 \quad \stackrel{本质是}{\Longrightarrow} \quad F对目标函数的自变量求偏导\\ \frac {\partial F}{\partial z} =0 \quad \stackrel{本质是}{\Longrightarrow} \quad F对目标函数的自变量求偏导\\ \frac {\partial F}{\partial {\lambda_1}} =0 \quad {\Longrightarrow} \quad g_1= 0 \\\frac {\partial F}{\partial {\lambda_2}} =0 \quad {\Longrightarrow} \quad g_2= 0 \\\frac {\partial F}{\partial {\lambda_3}} =0 \quad {\Longrightarrow} \quad g_3= 0 \\\end{aligned}\right.\quad {\Longrightarrow} \quad 约束 g_i=0\\ \\④ 解方程组 \\⑤ 将所有解代入目标函数 f(x,y,z)，判断最大值和最小值\\⑥ 结束\\</script><p>【KKT】：</p><script type="math/tex; mode=display">Z_{max}或Z_{min} = f(x,y,z,...)\\g_1 \le 0, \; g_2 \ge 0, \; g_n = 0\\⓪化为标准型^*\\①观察约束条件，有几个约束，方程就引入几个拉格朗日乘子 \lambda^* ,\lambda^* \ge 0\\\begin{aligned}②构建\mathcal{L}(x,y,z,\lambda_1^*, \lambda_2^*, \lambda_3^*, \lambda_4^*) & = f(x,y,z) + \lambda_1^*g'_1 + \lambda_2^*g'_2 + \lambda_3^*g'_3 + \lambda_4^*g'_4\\& = f(x,y,z) + \lambda_1^*g_1 - \lambda_2^*g_2 + \lambda_3^*g_3 - \lambda_4^*g_3\end{aligned}\\③\left\{\begin{aligned}\frac {\partial \mathcal{L}}{\partial x} =0 \quad \stackrel{本质是}{\Longrightarrow} \quad F对目标函数的自变量求偏导\\ \frac {\partial \mathcal{L}}{\partial y} =0 \quad \stackrel{本质是}{\Longrightarrow} \quad F对目标函数的自变量求偏导\\ \frac {\partial \mathcal{L}}{\partial z} =0 \quad \stackrel{本质是}{\Longrightarrow} \quad F对目标函数的自变量求偏导\\ \lambda_1^*g_1 = 0 \\\lambda_2^*(-g_2) = 0 \\\lambda_3^*(g_3) = 0 \\\lambda_4^*(-g_3) = 0\end{aligned}\right.\quad {\Longrightarrow} \quad 广义乘子 \lambda_i^*\times 约束g_i = 0 \\ \\④ 解方程组 \\⑤ 将所有解代入目标函数 f(x,y,z)，判断最大值和最小值\\⑥ 结束\\</script><ol><li><p>化为【标准型】：</p><p>对于上述例子，我们可以看到【约束条件】很“混乱”，即符号不同，有$\le, \ge ,=$ ，我们需要将它们化为统一标准形式（“$代数式     \ge 0$”）。</p><ul><li>对于 $=$ ：$g_3 = 0 \Leftrightarrow g_3\le 0 且 g_3 \ge 0$ </li><li>对于 $\le$ ：$g_1 \le 0 \Leftrightarrow -g_1 \ge 0$ </li></ul><p>所以我们可以按上述规则将约束条件改写为</p><script type="math/tex; mode=display">s.t.\left\{\begin{aligned}- g_1 \ge 0\\g_2 \ge 0\\g_3 \ge 0\\-g_3 \ge 0\\\end{aligned}\right.\quad \stackrel{看作整体}{\Longrightarrow} \quads.t.\left\{\begin{aligned}g_1' = - g_1 \ge 0\\g_2' = g_2 \ge 0\\g_3' = g_3 \ge 0\\g_4' = -g_3 \ge 0\\\end{aligned}\right.</script><p>不过更建议化成 “$代数式 \le 0$” 的形式，因为可以更好的和拉格朗日乘数法结合观察：</p><script type="math/tex; mode=display">s.t.\left\{\begin{aligned}- g_1 \ge 0\\g_2 \ge 0\\g_3 \ge 0\\-g_3 \ge 0\\\end{aligned}\right.\quad \stackrel{看作整体}{\Longrightarrow} \quads.t.\left\{\begin{aligned}g_1' = g_1 \le 0\\g_2' = -g_2 \le 0\\g_3' = g_3 \le 0\\g_4' = -g_3 \le 0\\\end{aligned}\right.</script></li><li><p>观察约束条件，有几个约束，方程就引入几个广义拉格朗日乘子 $\lambda^<em>$：$\lambda_1^</em>, \lambda_2^<em>, \lambda_3^</em>, \lambda_4^*$ 。注意，在拉格朗日乘数法中，引入拉格朗日乘子 $\lambda$ 后并无任何限制，但是在 $KKT$ 中，我们要求所有的广义拉格朗日乘子</p><script type="math/tex; mode=display">\lambda^* \ge 0</script></li></ol><ol><li><p>构造一个包含广义拉格朗日乘子 $\lambda_1^<em>, \lambda_2^</em>, \lambda_3^<em>, \lambda_4^</em>$ 的新函数 $\mathcal{L} (x,y,z,\lambda_i^<em>) = f(x,y,z) + \lambda_1^</em>g_1 + \lambda_2^<em>g_2 + …+ \lambda_n^</em>g_n$ 。所以原函数可转化为以下的广义拉格朗日函数：</p><script type="math/tex; mode=display">\begin{aligned}\mathcal{L} (x,y,z,\lambda_1^*, \lambda_2^*, \lambda_3^*, \lambda_4^*) & = f(x,y,z) + \lambda_1^*g'_1 + \lambda_2^*g'_2 + \lambda_3^*g'_3 + \lambda_4^*g'_4\\& = f(x,y,z) + \lambda_1^*g_1 - \lambda_2^*g_2 + \lambda_3^*g_3 - \lambda_4^*g_3\end{aligned}\\</script></li><li><p>则我们就可以通过导数的方法求解此问题 $\mathcal{L} (x,y,z,\lambda_1^<em>, \lambda_2^</em>, \lambda_3^<em>, \lambda_4^</em>)$ 。写出如下形式的方程。方程定能得到不止一组的解 $(x_i,\; y_i,\; z_i,\; {\lambda_1^<em>}_i, {\lambda_2^</em>}_i, {\lambda_3^<em>}_i, {\lambda_4^</em>}_i$ ，将解得的解 $(x_i,\; y_i,\; z_i,\; {\lambda_1^<em>}_i, {\lambda_2^</em>}_i, {\lambda_3^<em>}_i, {\lambda_4^</em>}_i$ 代入原来的目标函数 $Z=f(x,y,z)$ 中，算出的 $Z_{max}$ 和 $Z_{min}$。</p><script type="math/tex; mode=display">\left\{\begin{aligned}\frac {\partial \mathcal{L}}{\partial x} =0 \\\frac {\partial \mathcal{L}}{\partial y} =0 \\\frac {\partial \mathcal{L}}{\partial z} =0 \\\lambda_1^*g_1 = 0 \\\lambda_2^*(-g_2) = 0 \\\lambda_3^*(g_3) = 0 \\\lambda_4^*(-g_3) = 0\end{aligned}\right.\quad \stackrel{解}{\Longrightarrow} \quad\begin{pmatrix}x_i\\y_i\\z_i\\{\lambda_1^*}_i\\{\lambda_2^*}_i\\{\lambda_3^*}_i\\{\lambda_4^*}_i\\\end{pmatrix}\quad \stackrel{代入原来的目标函数}{\Longrightarrow} \quadf(x_i,y_i,z_i)\quad \stackrel{找Min和Max}{\Longrightarrow} \quad(Z_{max}, Z_{min})</script></li></ol><h5 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h5><p>$f(x) = (x-3)^2，0 \le x \le 5，求_{min}f(x)$</p><ol><li><p>规范化（化标准型“$代数式 \le 0$”）：</p><script type="math/tex; mode=display">0 \le x \le 5 \quad \Rightarrow \quad\begin{aligned}x \ge 0\\x \le 5\end{aligned}\quad \Rightarrow \quad\begin{aligned}-x \le 0\\x-5 \le 0\end{aligned}\quad \Rightarrow \quad\begin{aligned}g_1 = -x \le 0\\g_2 = x-5 \le 0\end{aligned}</script></li><li><p>观察约束，有 2 个约束，所以引入 2 个广义拉格朗日乘子 $\lambda_1^<em>, \lambda_2^</em>$，</p><script type="math/tex; mode=display">\lambda_1^* \ge 0 \\\lambda_2^* \ge 0 \\</script></li><li><p>构建广义拉格朗日函数 $\mathcal{L} (x,\lambda_1^<em>, \lambda_2^</em>)$ :</p><script type="math/tex; mode=display">\begin{aligned}\mathcal{L} (x,\lambda_1^*, \lambda_2^*) &= f(x) +  \lambda_1^*g_1 + \lambda_2^*g_2 \\&= (x-3)^2 +  \lambda_1^*(-x) + \lambda_2^*(x-5)\end{aligned}</script></li><li><p>联立方程组：</p><script type="math/tex; mode=display">\left\{\begin{aligned}\frac {\partial F}{\partial x} = 2(x-3) - \lambda_1^* + \lambda_2^* = 0 \qquad ①\\\lambda_1^*g_1 = \lambda_1^* (-x) = 0 \qquad ② \\\lambda_2^*g_2 = \lambda_2^* (x-5) = 0 \qquad ③ \\\end{aligned}\right.</script></li><li><p>解方程组。(【注意⚠️】：一般需要详细讨论解的情况。)</p><p>【1】我们先从 ② 式开始 ：$② \Rightarrow \lambda_1^<em> x = 0 \quad \stackrel{两种情况}{\Longrightarrow} \quad \lambda_1^</em>=0 \; 或\; x=0$ </p><ol><li><p>当 $\lambda_1^<em> \ne 0$ 时，我们可以得到 $x = 0$ 。我们再结合 $③\;\lambda_2^</em> (x-5) = 0$，我们得到 $\lambda_2^<em> = 0$ 。我们再结合 $ ① \; 2(x-3) - \lambda_1^</em> + \lambda_2^<em> = 0$ ，我们可以解得 $\lambda_1^</em> = -6 &lt; 0$ 。因为我们有约束条件 $\lambda_1^* \ge 0$，所以我们要舍弃这组解。</p></li><li><p>当 $\lambda_1^* = 0$ 时，在 ② 式中 $x$ 可以是任意值，所以我们要结合 ① ③ 式：</p><script type="math/tex; mode=display">\left\{\begin{aligned}2(x-3) + \lambda_2^* = 0 \qquad ①\\\lambda_2^* (x-5) = 0 \qquad ③ \\\end{aligned}\right.\quad \stackrel{解得}{\Longrightarrow} \quad\left\{\begin{aligned}x = 3 \\\lambda_2^* = 0\\\end{aligned}\right.\quad 或 \quad\left\{\begin{aligned}x = 5 \\\lambda_2^* = -4 < 0\\\end{aligned}\right.</script><p>我们可以看出，其中存在一组解</p><script type="math/tex; mode=display">\left\{\begin{aligned}x = 3 \\\lambda_1^* = 0\\\lambda_2^* = 0\\\end{aligned}\right.</script></li></ol><p>【2】我们再回到 ③ 式重新讨论：$ ③ \;  \lambda_2^<em> (x-5) = 0 \quad \stackrel{两种情况}{\Longrightarrow} \quad \lambda_2^</em>=0 \; 或\; x=5$</p><ol><li><p>$x=5, \lambda_2^* \ne 0$ 的情况已经在 ② 式的第 2 种情况中讨论过了，所以跳过。</p></li><li><p>当 $\lambda_2^* = 0$ 时，在 ③ 式中 $x$ 可以是任意值，所以我们要结合 ① ② 式：</p><script type="math/tex; mode=display">\left\{\begin{aligned}2(x-3) - \lambda_1^* = 0 \qquad ①\\\lambda_1^* (-x) = 0 \qquad ② \\\end{aligned}\right.\quad \stackrel{解得}{\Longrightarrow} \quad\left\{\begin{aligned}x = 0 \\\lambda_1^* = -6 < 0\\\end{aligned}\right.\quad 或 \quad\left\{\begin{aligned}x = 3 \\\lambda_1^* = 0\\\end{aligned}\right.</script><p>我们可以看出，其中存在一组解</p><script type="math/tex; mode=display">\left\{\begin{aligned}x = 3 \\\lambda_1^* = 0\\\lambda_2^* = 0\\\end{aligned}\right.</script></li></ol></li><li><p>所以 $_{min}f(x) = f(3) = (3-3)^2 = 0$ 。</p></li></ol><p>【一点想法】</p><p>当我们使用 KKT 得到一个解时，若该解中某个广义拉格朗日乘子 $\lambda_i^* &gt;0$，则说明 $\lambda_i$ 所对应的约束 $g_i = 0$，即这个解所对应的点恰好落在了曲线 $g_i = 0$ 上。</p><h3 id="附录二：线性代数回顾"><a href="#附录二：线性代数回顾" class="headerlink" title="附录二：线性代数回顾"></a>附录二：线性代数回顾</h3><p>简言之，线性代数的目的就是求解线性方程组。经典的理论是与几何联系起来。</p><h5 id="方法论"><a href="#方法论" class="headerlink" title="方法论"></a>方法论</h5><pre class="mermaid">graph LR提取系统信息 --经过运算--> 判断解的情况提取系统信息 --经过运算--> 解方程</pre><script type="math/tex; mode=display">\left\{\begin{aligned}a_{1,1}x_1 + a_{1,2}x_2 + ... a_{1,n}x_n = \; b_1 \\a_{2,1}x_1 + a_{2,2}x_2 + ... a_{2,n}x_n = \; b_2 \\...    \quad ... \quad ... \quad ... \quad \\a_{i,1}x_1 + a_{i,2}x_2 + ... a_{i,n}x_n = \; b_i \\...    \quad ... \quad ... \quad ... \quad \\a_{n,1}x_1 + a_{n,2}x_2 + ... a_{n,n}x_n = \; b_n \\\end{aligned}\right.\quad \stackrel{提取系统信息}{\Longrightarrow} \quad\begin{pmatrix}a_{1,1} & a_{1,2} & \cdots & a_{1,n}\\a_{2,1} & a_{2,2} & \cdots & a_{2,n}\\\vdots & \vdots & \vdots & \vdots\\a_{n,1} & a_{n,2} & \cdots & a_{n,n}\\\end{pmatrix} \begin{pmatrix}x_1\\x_2\\\vdots\\x_n\\\end{pmatrix}=\begin{pmatrix}b_1\\b_2\\\vdots\\b_n\\\end{pmatrix}</script><p>【秩】Rank：矩阵的本质属性。如果把矩阵看成一个个行向量或者列向量，如果其中<strong>有一个向量</strong>能被另一个向量<strong>线性表示</strong>的话，那么该矩阵表示的方程组有<strong>无穷多解</strong>；如果<strong>没有任何一个</strong>向量能被另一个向量线性表示的话，那么该矩阵表示的方程组<strong>有唯一解</strong>。【秩】的本质就是矩阵中<strong>独立向量的个数</strong>。</p><p>【行列式】：行列式的本质是代表一种算法的运算符，和 $+,-,\times,\div$ 类似。用 $A_{2 \times 2}$ 举例：</p><script type="math/tex; mode=display">A_{2 \times 2} =\begin{vmatrix}x & y \\z & v\end{vmatrix}=xv-yz</script><p>【行列式的几何意义】</p><ul><li>二阶：是这 2 个向量围成的平行四边形的面积</li><li>三阶：是这 3 个向量围成的平行六面体的体积</li><li>n阶：n维超立方体的体积</li></ul><p>所以，<u>行列式一旦 $=0$</u> ，说明行列式对应的矩阵里有<u>线性相关的向量</u>。当<u>行列式 $\ne 0$</u> 时，说明行列式对应的<u>矩阵是<strong>满秩</strong></u>的。</p><h3 id="第一部分：线性规划"><a href="#第一部分：线性规划" class="headerlink" title="第一部分：线性规划"></a>第一部分：线性规划</h3><h4 id="1-1-线性规划问题及数学模型"><a href="#1-1-线性规划问题及数学模型" class="headerlink" title="1.1 线性规划问题及数学模型"></a>1.1 线性规划问题及数学模型</h4><h5 id="1-1-1-问题的提出"><a href="#1-1-1-问题的提出" class="headerlink" title="1.1.1 问题的提出"></a>1.1.1 问题的提出</h5><p>我们可以考虑以下一个简单的例子：</p><p>例1，某工厂在计划期内要安排生产甲、乙两种产品，已知生产单位产品所需的设备合时及 A、B 两种原材料的消耗如表所示。该厂每生产一件产品甲可获利2元，一件产品乙可获利3元，问该工厂如何安排生产计划使利润最大？</p><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">产品甲</th><th style="text-align:center">产品乙</th><th style="text-align:center">资源限量</th></tr></thead><tbody><tr><td style="text-align:center">设备</td><td style="text-align:center">1 台时/件</td><td style="text-align:center">2 台时/件</td><td style="text-align:center">8 台时</td></tr><tr><td style="text-align:center">原材料 A</td><td style="text-align:center">4 kg/件</td><td style="text-align:center">0</td><td style="text-align:center">16 kg</td></tr><tr><td style="text-align:center">原材料 B</td><td style="text-align:center">0</td><td style="text-align:center">4 kg/间</td><td style="text-align:center">12 kg</td></tr><tr><td style="text-align:center">利润</td><td style="text-align:center">2 元</td><td style="text-align:center">3 元</td></tr></tbody></table></div><p>我们可以根据以上描述建立一个数学模型：</p><script type="math/tex; mode=display">Profit_{max} = 2x+3y\\s.t.\left\{\begin{aligned}x_1 + 2x_2 \le 8 \\4x_1 \le 16 \\4x_2 \le 12 \\x_1, x_2 \ge 0\end{aligned}\right.</script><p>其中，</p><ul><li>$x_1$ 和 $x_2$ 为【决策变量】；</li><li>$Profit_{max} = 2x+3y$ 是【决策函数】，是决策者希望达到的计划目标；</li><li>$s.t.$ 为“subject to”，为【约束条件】，为决策变量取值时受到的限制。</li></ul><p>这类优化问题的共同特征：</p><ol><li>每一个问题都用一组决策变量表示某一方案，这组决策变量的值就代表一个具体方案。<strong>一般取值非负且连续</strong>。</li><li>要有建模的相关数据，如资源拥有量、消耗资源定额、创造的新价值量等并构造不矛盾的约束条件，<strong>由线性等式或不等式来表示</strong>。</li><li>都有一个要达到的目标，可用决策变量及其有关的价值系数构成的线性函数来表示，一般要求<strong>最大或最小</strong></li></ol><p>线性规划问题模型的【一般表达式形式】为：</p><script type="math/tex; mode=display">max(min)Z = c_1x_1 + c_2x_2 + c_3x_3 + ...+ c_nx_n\\s.t.\left\{\begin{aligned}a_{1,1}x_1 + a_{1,2}x_2 + ... a_{1,n}x_n \le (\ge ,=) \; b_1 \\a_{2,1}x_1 + a_{2,2}x_2 + ... a_{2,n}x_n \le (\ge ,=) \; b_2 \\...    \quad ... \quad ... \quad ... \quad \\a_{i,1}x_1 + a_{i,2}x_2 + ... a_{i,n}x_n \le (\ge ,=) \; b_i \\...    \quad ... \quad ... \quad ... \quad \\a_{n,1}x_1 + a_{n,2}x_2 + ... a_{n,n}x_n \le (\ge ,=) \; b_n \\x_1, x_2, ... x_n \ge 0\end{aligned}\right.</script><p>其中，</p><ul><li>$c_n$ 为价值系数</li><li>$a_{ij}$ 为技术系数</li><li>$b_i$ 为资源限制</li><li>$x_1, x_2, … x_n \ge 0$ 为决策变量约束</li></ul><h5 id="1-1-2-图解法"><a href="#1-1-2-图解法" class="headerlink" title="1.1.2 图解法"></a>1.1.2 图解法</h5><p>图解法求解步骤（只适用于两个决策变量的问题 - 二维）：</p><ol><li>由全部约束条件作图求出【可行域】；</li><li>作目标函数【等值线】，确定使目标函数最优的移动方向；</li><li>平移目标函数的等值线，找出【最优点】，算出最优值。</li></ol><p><img src="/2022/04/19/%E8%BF%90%E7%AD%B9%E5%AD%A6/2022-04-20 09.38.37.png" alt="2022-04-20 09.38.37" style="zoom:40%;"></p><h5 id="1-1-3-化标准型"><a href="#1-1-3-化标准型" class="headerlink" title="1.1.3 化标准型"></a>1.1.3 化标准型</h5><p>参考以上线性规划问题模型的一般表达式形式，我们发现线性规划的共同特证：</p><ol><li><p>决策变量：每个问题都用一组决策变量表示某个方案</p><p>决策变量：决策变量的取值一般都是非负且连续的</p></li><li><p>约束条件：与决策变量不矛盾的条件，用线性等式或不等式表示</p></li><li><p>目标函数：决策变量与价值系数组成，一般要求实现最大或最小</p></li></ol><p>所以我们建模的一般思路为：<strong>确定决策变量，写出目标函数，找出约束条件</strong>。</p><p>如果我们想用<strong>单纯形法</strong>求解线性规划问题，第一步是将一般表达式为以下的<strong>标准型</strong>：</p><script type="math/tex; mode=display">maxZ = c_1x_1 + c_2x_2 + c_3x_3 + ...+ c_nx_n\\s.t.\left\{\begin{aligned}a_{1,1}x_1 + a_{1,2}x_2 + ... a_{1,n}x_n = \; b_1 \\a_{2,1}x_1 + a_{2,2}x_2 + ... a_{2,n}x_n = \; b_2 \\...    \quad ... \quad ... \quad ... \quad \\a_{i,1}x_1 + a_{i,2}x_2 + ... a_{i,n}x_n = \; b_i \\...    \quad ... \quad ... \quad ... \quad \\a_{m,1}x_1 + a_{m,2}x_2 + ... a_{m,n}x_n = \; b_m \\x_1, x_2, ... x_n \ge 0\\b_1, b_2, ... b_n \ge 0\end{aligned}\right.</script><p>简言之：</p><ol><li>目标函数 $Z$ 最大；</li><li>约束条件 $a_{i,1}x_1 + a_{i,2}x_2 + … a_{i,n}x_n = \; b_i$ 为等式；</li><li>决策条件 $x_1, x_2, … x_n$ 非负</li><li>资源限量 $b_1, b_2, … b_n$ 非负</li></ol><p>上方的单纯形法的标准型可以简写成以下形式</p><script type="math/tex; mode=display">maxZ = \sum_{j=1}^n c_jx_j\\s.t.\left\{\begin{aligned}\sum_{j=1}^n a_{i,j}x_j = b_j \quad i=1,2,3,...,m\\x_j \ge 0 \quad j=1,2,3,...,n\end{aligned}\right.</script><p>或写成向量的形式</p><script type="math/tex; mode=display">maxZ = CX\\s.t.\left\{\begin{aligned}\sum_{j=1}^n P_jx_j = b \\x_j \ge 0 \quad j=1,2,3,...,n \\\end{aligned}\right.\\价值向量C = (c_1, c_2, ..., c_n)；\quad 决策变量的向量X = (x_1, x_2, ..., x_n)^T\\资源向量b = (b_1, b_2, ..., b_m)^T；\quad 约束条件的系数列向量P_j = (a_{1,j}, a_{2,j}, ..., a_{m,j})</script><p>或写成矩阵的形式</p><script type="math/tex; mode=display">maxZ = CX\\s.t.\left\{\begin{aligned}AX = b \\X \ge O\end{aligned}\right.\\其中，A =\begin{pmatrix}a_{1,1} & a_{1,2} & \cdots & a_{1,n}\\a_{2,1} & a_{2,2} & \cdots & a_{2,n}\\\vdots & \vdots & \vdots & \vdots\\a_{m,1} & a_{m,2} & \cdots & a_{m,n}\\\end{pmatrix}, \quadO =\begin{pmatrix}0\\0\\\vdots\\0\\\end{pmatrix}, \quad X =\begin{pmatrix}x_1\\x_2\\\vdots\\x_n\\\end{pmatrix}</script><h6 id="一般形式化成标准型"><a href="#一般形式化成标准型" class="headerlink" title="一般形式化成标准型"></a>一般形式化成标准型</h6><p>例2：我们需要将以下一般形式化成标准型</p><script type="math/tex; mode=display">minZ = x_1 + 2x_2 + 3x_3 \quad ① \\s.t.\left\{\begin{aligned}-2x_1 + x_2 + x_3 \le 9 \quad ②\\-3x_1 + x_2 + 2x_3 \ge 4 \quad ③\\4x_1 - 2x_2 - 3x_3 = -6 \quad ④ \\x_1 \le 0,\; x_2 \ge 0,\; x_3无约束\end{aligned}\right.</script><ol><li><p>【目标函数最大】</p><p>如果目标函数的求解是最小值问题，我们需要将其转换成<strong>最大值问题</strong>，方法为<strong>取负数</strong>：</p><script type="math/tex; mode=display">min \; Z = CX \quad \stackrel{Z'=-Z}{\Longrightarrow} \quad max\; Z' = -CX</script><p>所以在例题中：</p><script type="math/tex; mode=display">minZ = x_1 + 2x_2 + 3x_3 \quad \stackrel{Z'=-Z}{\Longrightarrow} \quad maxZ' = -x_1 - 2x_2 - 3x_3</script></li><li><p>【资源限量非负】</p><script type="math/tex; mode=display">b_i < 0 \quad \stackrel{两端同乘(-1)}{\Longrightarrow} \quad 右端项非负\\b_i = 0\;的情况日后再议</script></li></ol><p>   我们可以发现，例中的 ④ 式的资源限量为 -6，所以</p><script type="math/tex; mode=display">   ④ \quad 4x_1 - 2x_2 - 3x_3 = -6 \quad \stackrel{两端同乘(-1)}{\Longrightarrow} \quad -4x_1 + 2x_2 + 3x_3 = 6</script><ol><li><p>【约束条件化为等式】</p><script type="math/tex; mode=display">将约束条件中的 \le \quad \stackrel{【加上】松弛变量}{\Longrightarrow} \quad 变成 =    \\将约束条件中的 \ge \quad \stackrel{【减掉】剩余变量}{\Longrightarrow} \quad 变成 =</script><p>例如例中的 ② 式，我们需要将其化为等式，则</p><script type="math/tex; mode=display">② \quad -2x_1 + x_2 + x_3 \le 9 \quad \stackrel{【加上】松弛变量}{\Longrightarrow} \quad -2x_1 + x_2 + x_3 +x_4 = 9</script><p>注意⚠️：此时的 $x_4$ 实际上是无意义的，只是我们加入的使等式成立的松弛变量。</p><p>同理，对于 ③ 式，我们有</p><script type="math/tex; mode=display">③ \quad -3x_1 + x_2 + 2x_3 \ge 4 \quad \stackrel{【减掉】剩余变量}{\Longrightarrow} \quad -3x_1 + x_2 + 2x_3 - x_5 = 4</script><p><strong>松弛变量</strong>与<strong>剩余变量</strong>在实际问题中分别表示未被充分利用的资源和超出的资源，均未转化为价值和利润，所以引进模型后它们<strong>在目标函数中的系数均为 0 </strong>。</p></li><li><p>【决策变量非负】</p><script type="math/tex; mode=display">x \le 0 \quad \stackrel{x' = -x}{\Longrightarrow} \quad x' \ge 0</script><p>例如例题中的 $x_1 \le 0$，我们需要将其化为大于 0 的形式，则</p><script type="math/tex; mode=display">x_1 \le 0 \quad \stackrel{x_1' = -x_1}{\Longrightarrow} \quad {x_1}' \ge 0</script><ul><li><p>【处理无约束变量】</p><script type="math/tex; mode=display">x无约束 \quad \stackrel{x = x' -x''}{\Longrightarrow} \quad x'\ge 0,\; x'' \ge 0</script><p>意为，一个无约束的数 $x$ 可以等于两个非负数 $x’,x’’$ 的差，其结果依然无约束。但是 $x’,x’’$ 是存在约束的。</p><p>例如例题中的 $x_3 无约束$，我们将其变化为</p><script type="math/tex; mode=display">x_3无约束 \quad \stackrel{x_3 = x_3' -x_3''}{\Longrightarrow} \quad x_3'\ge 0,\; x_3'' \ge 0</script></li></ul></li><li><p>最后请注意替换后的变量代入原式时的<strong>替换问题</strong></p></li></ol><p>所以，通过以上步骤，例题中的原式可化为如下形式：</p><script type="math/tex; mode=display">maxZ = x_1' - 2x_2 - 3x_3' + 3x_3'' + 0x_4 + 0x_5 \quad ① \\s.t.\left\{\begin{aligned}2x_1' + x_2 + x_3' - x_3'' + x_4 = 9 \quad ②\\3x_1' + x_2 + 2x_3' - 2x_3'' - x_5 = 4 \quad ③\\-4x_1' + 2x_2 + 3x_3' - 3x_3'' = 6 \quad ④ \\x_1',\; x_2,\; x_3',\; x_3'',\; x_4,\; x_5 \ge 0\end{aligned}\right.</script><h5 id="1-1-4-解的概念"><a href="#1-1-4-解的概念" class="headerlink" title="1.1.4 解的概念"></a>1.1.4 解的概念</h5><h6 id="可行解-和-最优解"><a href="#可行解-和-最优解" class="headerlink" title="可行解 和 最优解"></a>可行解 和 最优解</h6><p>在以下线性规划问题的一般形式中，</p><script type="math/tex; mode=display">maxZ = \sum_{j=1}^n c_jx_j \qquad ①\\s.t.\left\{\begin{aligned}\sum_{j=1}^n a_{i,j}x_j = b_j \quad i=1,2,3,...,m \qquad ② \\x_j \ge 0 \quad j=1,2,3,...,n \qquad ③\end{aligned}\right.</script><ul><li>【可行解】：满足约束条件 ② 和 ③ 的解。<strong>全部可行解的集合称为可行域</strong></li><li>【最优解】：是目标函数 ① 最大的<strong>可行解</strong></li></ul><p><img src="/2022/04/19/%E8%BF%90%E7%AD%B9%E5%AD%A6/2022-04-20 11.46.29.png" alt="2022-04-20 11.46.29" style="zoom:50%;"></p><h6 id="基解-和-基可行解"><a href="#基解-和-基可行解" class="headerlink" title="基解 和 基可行解"></a>基解 和 基可行解</h6><script type="math/tex; mode=display">maxZ = CX\\s.t.\left\{\begin{aligned}AX = b \\X \ge O\end{aligned}\right.\\其中，C =\begin{pmatrix}c_1\\c_2\\\vdots\\c_n\\\end{pmatrix}, \quadX =\begin{pmatrix}x_1\\x_2\\\vdots\\x_n\\\end{pmatrix}, \quadA_{m<n} =\begin{pmatrix}a_{1,1} & a_{1,2} & \cdots & a_{1,n}\\a_{2,1} & a_{2,2} & \cdots & a_{2,n}\\\vdots & \vdots & \vdots & \vdots\\a_{m,1} & a_{m,2} & \cdots & a_{m,n}\\\end{pmatrix}, \quadb =\begin{pmatrix}b_1\\b_2\\\vdots\\b_n\\\end{pmatrix}, \quadO =\begin{pmatrix}0\\0\\\vdots\\0\\\end{pmatrix}</script><ul><li>【基】：设 $A$ 是约束方程组 ② 的 $m\times n$ 阶系数矩阵（<strong>设 $n&gt;m$，变量的个数大于方程的个数</strong>，即方程组一定有无穷多个解），<strong>其秩(rank) 为 $m$</strong>，$B$ 是 $A$ 中的一个 $m\times m$ 阶的满秩子矩阵（<strong>行列式 $|B| \ne 0$ 的非奇异子矩阵</strong>），称 $B$ 是线性规划问题的一个基。</li></ul><script type="math/tex; mode=display">R(A) = m \Rightarrow\begin{pmatrix}a_{1,1} & a_{1,2} & \cdots & a_{1,m}\\a_{2,1} & a_{2,2} & \cdots & a_{2,m}\\\vdots & \vdots & \vdots & \vdots\\a_{m,1} & a_{m,2} & \cdots & a_{m,m}\\\end{pmatrix}\Rightarrow\begin{pmatrix}P_{1} & P_{2} & \cdots & P_{m}\end{pmatrix},\; 其中P_i =\begin{pmatrix}a_{1,i}\\a_{2,i}\\\vdots\\a_{m,i}\\\end{pmatrix}</script><ul><li>【基向量组 $B$】（极大线性无关组）：向量组 $A$ 中有 $m$ 个线性无关的向量，且其余向量均可由这 $m$ 个向量来线性表示</li></ul><script type="math/tex; mode=display">\begin{pmatrix}a_{1,1} & a_{1,2} & \cdots & a_{1,n}\\a_{2,1} & a_{2,2} & \cdots & a_{2,n}\\\vdots & \vdots & \vdots & \vdots\\a_{m,1} & a_{m,2} & \cdots & a_{m,n}\\\end{pmatrix}\times X\Rightarrow\begin{pmatrix}a_{1,1}\\a_{2,1}\\\vdots\\a_{m,1}\\\end{pmatrix}x_1 +\begin{pmatrix}a_{1,2}\\a_{2,2}\\\vdots\\a_{m,2}\\\end{pmatrix}x_2 + ...+\begin{pmatrix}a_{1,n}\\a_{2,n}\\\vdots\\a_{m,n}\\\end{pmatrix} x_n =\begin{pmatrix}b_{1}\\b_{2}\\\vdots\\b_{m}\\\end{pmatrix}</script><p>设方程组前 $m$ 个变量的系数列向量就是它的基向量（极大线性无关组），则</p><script type="math/tex; mode=display">\begin{pmatrix}a_{1,1}\\a_{2,1}\\\vdots\\a_{m,1}\\\end{pmatrix}x_1 +\begin{pmatrix}a_{1,2}\\a_{2,2}\\\vdots\\a_{m,2}\\\end{pmatrix}x_2 + ...+\begin{pmatrix}a_{1,n}\\a_{2,n}\\\vdots\\a_{m,n}\\\end{pmatrix} x_n =\begin{pmatrix}b_{1}\\b_{2}\\\vdots\\b_{m}\\\end{pmatrix}\Rightarrow</script><script type="math/tex; mode=display">\begin{pmatrix}a_{1,1}\\a_{2,1}\\\vdots\\a_{m,1}\\\end{pmatrix}x_1 +\begin{pmatrix}a_{1,2}\\a_{2,2}\\\vdots\\a_{m,2}\\\end{pmatrix}x_2 + ...+\begin{pmatrix}a_{1,m}\\a_{2,m}\\\vdots\\a_{m,m}\\\end{pmatrix} x_m =\begin{pmatrix}b_{1}\\b_{2}\\\vdots\\b_{m}\\\end{pmatrix} - \begin{pmatrix}a_{1,m+1}\\a_{2,m+1}\\\vdots\\a_{m,m+1}\\\end{pmatrix} x_{m+1} - ... -\begin{pmatrix}a_{1,n}\\a_{2,n}\\\vdots\\a_{m,n}\\\end{pmatrix} x_n</script><p>其中，$P_1,\;P_2,\;…,\; P_m$ 被称为【基向量】，它们对应的变量 $x_1,\; x_2,\; …,\; x_m$​ 被称作【基变量】；$P_{m+1},\; …,\; P_n$ 被称为【非基向量】，它们对应的变量 $x_{m+1},\; …,\; x_n$ 被称作【非基变量】。</p><p>令所有的非基变量 $x_{m+1}=x_{m+2}= …=x_n = 0$，又因为 $|B| \ne 0$，根据克莱姆法则，可以求出一个唯一解：</p><script type="math/tex; mode=display">\begin{pmatrix}a_{1,1}\\a_{2,1}\\\vdots\\a_{m,1}\\\end{pmatrix}x_1 +\begin{pmatrix}a_{1,2}\\a_{2,2}\\\vdots\\a_{m,2}\\\end{pmatrix}x_2 + ...+\begin{pmatrix}a_{1,m}\\a_{2,m}\\\vdots\\a_{m,m}\\\end{pmatrix} x_m =\begin{pmatrix}b_{1}\\b_{2}\\\vdots\\b_{m}\\\end{pmatrix} \quad \stackrel{解得X_B}{\Longrightarrow} \quad\begin{pmatrix}x_1 \\x_2 \\\vdots \\x_m\\\end{pmatrix}</script><p>【基解】：根据基 $B$ 求得的解 $X$ 被称作基解。</p><script type="math/tex; mode=display">X = (X_B + X_N) = (x_1,\; x_2,\; ...,\; x_m,\; 0, \; 0, \; ...,\; 0)^T</script><p>其中，</p><ul><li>基解中非零分量的数目不大于 $m$（方程个数）；</li><li>有一个基，就能求得一组基解。</li></ul><p>【基可行解】：基解中所有分量<strong>都满足非负条件</strong>的解，即</p><script type="math/tex; mode=display">X = (X_B + X_N) = (x_1,\; x_2,\; ...,\; x_m,\; 0, \; 0, \; ...,\; 0)^T,\quad x_i \ge 0,i\in1,2,...,n</script><p>【可行即】：对应于<u>基可行解</u>的<u>基</u>，称为可行基。</p><h6 id="四个解的关系"><a href="#四个解的关系" class="headerlink" title="四个解的关系"></a>四个解的关系</h6><p><img src="/2022/04/19/%E8%BF%90%E7%AD%B9%E5%AD%A6/2022-04-21 12.10.57.png" alt="2022-04-21 12.10.57" style="zoom:50%;"></p><ul><li>当最优解唯一时，最优解也是基可行解；</li><li>当最优解不唯一时，最优解不一定是基可行解。</li></ul><h4 id="1-2-单纯形法"><a href="#1-2-单纯形法" class="headerlink" title="1.2 单纯形法"></a>1.2 单纯形法</h4><h5 id="单纯形法的思想"><a href="#单纯形法的思想" class="headerlink" title="单纯形法的思想"></a>单纯形法的思想</h5><p>我们继续探究例2，用基的方法求解最优解。在 1.1.3 节的末尾，我们得到了化为标准型的线性规划问题模型：</p><script type="math/tex; mode=display">maxZ = x_1' - 2x_2 - 3x_3' + 3x_3'' + 0x_4 + 0x_4 \quad ① \\s.t.\left\{\begin{aligned}2x_1' + x_2 + x_3' - x_3'' + x_4 = 9 \quad ②\\3x_1' + x_2 + 2x_3' - 2x_3'' - x_5 = 4 \quad ③\\-4x_1' + 2x_2 + 3x_3' - 3x_3'' = 6 \quad ④ \\x_1',\; x_2,\; x_3',\; x_3'',\; x_4,\; x_5 \ge 0\end{aligned}\right.</script><ol><li><p>首先，我们可以将约束条件中的系数矩阵 $A$ 写出来：</p><script type="math/tex; mode=display">A =\begin{pmatrix}2 & 1 & 1 & -1 & 1 & 0\\3 & 1 & 2 & -2 & 0 & 1\\-4 & 2 & 3 & -3 & 0 & 0\\\end{pmatrix} \Rightarrow\begin{pmatrix}P_{1} & P_{2} & P_3 & P_4 & P_5 & P_{6}\end{pmatrix}</script></li><li><p>我们可以看出，这是 $A$ 是一个 $3\times 6$ ，秩为 3 的矩阵，<u>则我们需要找到一个行列式不为 $0$ 的 $3 \times 3$ 的基矩阵 $B$</u> </p><script type="math/tex; mode=display">|B_1| = \begin{vmatrix}P_{1} & P_{2} & P_3\end{vmatrix} =\begin{vmatrix}2 & 1 & 1 \\3 & 1 & 2 \\-4 & 2 & 3 \\\end{vmatrix} = -9</script></li><li><p>因为 $P_1, P_2, P_3$ 线性无关，令 $\begin{pmatrix}P_{1} &amp; P_{2} &amp; P_3\end{pmatrix}$ 为基，则</p><script type="math/tex; mode=display">\begin{pmatrix}2 & 1 & 1 & -1 & 1 & 0\\3 & 1 & 2 & -2 & 0 & 1\\-4 & 2 & 3 & -3 & 0 & 0\\\end{pmatrix} \times\begin{pmatrix}x_1'\\x_2\\x_3'\\0\\0\\0\end{pmatrix} = \begin{pmatrix}9 \\4 \\6\end{pmatrix}\qquad \Rightarrow \qquadX^{(1)}=\begin{pmatrix}x_1'\\x_2\\x_3'\\0\\0\\0\end{pmatrix} =\begin{pmatrix}0.7778\\13.2222\\-5.77778\\0\\0\\0\end{pmatrix}</script></li><li><p>求解出的基解有元素小于 0，所以这个基解 $X^{(1)}$不是可行解。</p></li><li><p>重复第 2 步，<u>找到一个行列式不为 $0$ 的 $3 \times 3$ 的基矩阵 $B_i$，解得它的基解 $X^{(i)}$ 。若 $X^{(i)}$ 的所有元素都满足非负约束（$\ge 0$），则 $X^{(i)}$ 就是可行解。</u></p><ul><li><p>【出基】：将列向量 $P_i$ 从基里移除，即</p><script type="math/tex; mode=display">B_i = \begin{pmatrix}P_{a} & P_{i} & P_{b}\end{pmatrix} =\begin{pmatrix}a_{1,a} & a_{1,i} & a_{1,b} \\a_{2,a} & a_{2,i} & a_{2,b} \\a_{3,a} & a_{3,i} & a_{3,b} \\\end{pmatrix} \quad \stackrel{P_i出基}{\Longrightarrow} \quad\begin{pmatrix}P_{a} & P_{b}\end{pmatrix} =\begin{pmatrix}a_{1,a} & a_{1,b} \\a_{2,a} & a_{2,b} \\a_{3,a} & a_{3,b} \\\end{pmatrix}</script><p>【进基】：将列向量 $P_j$ 移进基中，即</p><script type="math/tex; mode=display">B_j = \begin{pmatrix}P_{a} & P_{b}\end{pmatrix} =\begin{pmatrix}a_{1,a} & a_{1,b} \\a_{2,a} & a_{2,b} \\a_{3,a} & a_{3,b} \\\end{pmatrix}\quad \stackrel{P_j进基}{\Longrightarrow} \quad\begin{pmatrix}P_{a} & P_{j} & P_{b}\end{pmatrix} =\begin{pmatrix}a_{1,a} & a_{1,j} & a_{1,b} \\a_{2,a} & a_{2,j} & a_{2,b} \\a_{3,a} & a_{3,j} & a_{3,b} \\\end{pmatrix}</script><p>尽量选择<strong>目标函数里对结果影响大的向量</strong>【进基】，因为我们不希望它是<strong>非基向量</strong>而<strong>使其基变量为 0</strong>；尽量选择“容量”最小的列向量【出基】</p></li></ul></li><li><p><u>解出所有的基解  $X^{(n)}$</u>，其中基解的数目 $n \le C_6^4=15$ 个。<u>找出所有基解中的可行解</u></p></li><li><p>再将<u>所有可行解代入目标函数 ① 中，结果最大的就是【最优解】</u></p></li></ol><h5 id="单纯形法的计算步骤"><a href="#单纯形法的计算步骤" class="headerlink" title="单纯形法的计算步骤"></a>单纯形法的计算步骤</h5><ul><li>为了书写规范和便于计算，对单纯形法的计算设计了【单纯形表】</li><li>每一次迭代对应一张单纯形表</li><li>含<u>初始基可行解</u>的单纯形表称为【初始单纯形表】</li><li>含<u>最优解</u>的单纯形表称为【最终单纯形表】</li></ul><h5 id="单纯形表"><a href="#单纯形表" class="headerlink" title="单纯形表"></a>单纯形表</h5><p>单纯形表解题方法：</p><ol><li>将题目给出的线性规划问题化为标准型</li><li>根据标准型填写初始单纯形表<ul><li>列数： $未知数\;x_i\;的个数+ c_B + X_B + b + \theta_i$</li><li>行数：$约束方程的个数 + c_j + \sigma_j$</li><li>$c_j$：目标函数中各个变量的系数，对应地填入表内</li><li><strong>每个变量所在列的数字</strong>根据大括号中<strong>约束方程组中该变量的系数</strong></li><li>【基】找出变量下放已填写数字构成的矩阵中的<strong>单位矩阵</strong>，依次将该单位矩阵对应的变量写在 $X_B$ 的下面</li><li>将上一步骤中找到的变量上方的数字 $c_j$ 依次对应地填入 $c_B$ 中</li><li>将大括号中约束方程组等号右边的 $b_i$ 依次填到 $b$ 下面</li></ul></li><li>找出可行解<ul><li>令 <strong>$X_B$ 所在列的变量</strong>与<strong>$b$ 所在列的数字</strong>对应相等，再令其他变量等于 0</li></ul></li><li>求出检验数 $\sigma_j = c_j -(c_{B_1}x_{j1} + c_{B_2}x_{j2} + …)$ <ul><li>$X_B$ 下面的变量对应的 $\sigma$ 的值为 0</li><li>【<strong>初始单纯形表</strong>】中 $c_j$ 的数字与 $\sigma_j$ 行的数字完全相同</li></ul></li><li>观察一下 $\sigma_j$ 这一行的数字看一下是否都 $≤0$<ul><li>若这些数字都 $≤0$，则该可行解就是最优解</li><li>若这些数字有＞0的，则该可行解不是最优解，继续进行步骤 6</li></ul></li><li>找到 $\sigma_j$ 行最大的数字 $max(\sigma_j)$ 那一列对应的变量 $x_a$【进基变量】，求出 $\theta _{i} = {b_i}/{x_{ai}}$：<ul><li>若 $\theta \ge 0$，则把 $\theta$ 的值填到表中</li><li>若 $\theta &lt; 0$，则<strong>不用</strong>把 $\theta$ 的值填到表中</li><li>若 $\theta \; 无意义$，则<strong>不用</strong>把 $\theta$ 的值填到表中</li></ul></li><li>找到表中 $\theta _i$ 最小值对应 $X_B$ 列的变量 $x_b$（出基变量），找到【 $x_a$ 的列】和 【$x_b$ 的行】交叉的数字 $m$</li><li>用 【$x_a$ 上面的数字 $c_a】$ 替代 【$x_b$ 前面的数字 $c_b$】，用 $x_a$ 替代 $x_b$，清空 $\sigma_j$ 行与 $\theta_i$ 列</li><li>对 $x_1,x_2…x_n$ 与 $b$ 列组成的矩阵进行运算，【将 $m$ 变成 $1$】（矩阵的初等行变换），同列其他元素变成 $0$，形成一个新的矩阵，将该矩阵中的数字填入表格中对应的位置形成新的单纯形表并进行步骤 3</li><li>如何检验所求的最优解是不是唯一最优解：<ul><li>找出 $X_B$ 列变量以外的变量</li><li>找出 $X_B$ 列变量以外的变量对应的 $\sigma_i$</li><li>若 $X_B$ 列变量以外的变量对应的 $\sigma_i$ 都 $＜0$，则 $X^*$ 为唯一最优解</li><li>若 $X_B$ 列变量以外的变量对应的 $\sigma_i$ 中有 $=0$ 的，则 $X^*$ 是无穷多最优解中的一个</li></ul></li></ol><p>【例】给出下列问题：</p><script type="math/tex; mode=display">max Z = 2x_1 + 3x_2 + 0x_3 + 0x_4 + 0x_5 \quad ① \\s.t.\left\{\begin{aligned}x_1 + 2x_2 + x_3 + 0x_4+ 0x_5 = 8 \quad ②\\4x_1 + 0x_2 + 0x_3 + x_4 + 0x_5 = 16 \quad ③\\0x_1 + 4x_2 + 0x_3+ 0x_4+ x_5 = 12 \quad ④ \\x_1, x_2, x_3, x_4, x_5 \ge 0\end{aligned}\right.</script><ol><li><p>该线性规划问题已化成标准形式；</p></li><li><p>根据标准型填写如下的初始单纯形表。</p><p>|   \   |   $c_j:$    |   2   |   3   |   0   |   0   |   0   |  \   | \          |<br>| :—-: | :————-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—: | ————— |<br>| $c_B$ |    $X_B$    | $x_1$ | $x_2$ | $x_3$ | $x_4$ | $x_5$ | $b$  | $\theta_i$ |<br>|   0   |    $x_3$    |   1   |   2   |   1   |   0   |   0   |  8   | 4          |<br>|   0   |    $x_4$    |   4   |   0   |   0   |   1   |   0   |  16  | ❌          |<br>|   0   |    $x_5$    |   0   |   4   |   0   |   0   |   1   |  12  | 3          |<br>|   \   | $\sigma_i:$ |   2   |   3   |   0   |   0   |   0   |  \   | \          |</p></li><li><p>找出可行解：令 <strong>$X_B$ 所在列的变量</strong>与<strong>$b$ 所在列的数字</strong>对应相等，再令其他变量等于 0。故</p><script type="math/tex; mode=display">X^{(0)} = (x_3 = 8, x_4 = 16, x_5 = 12, x_1 =0 , x_2 =0) \quad \stackrel{整理}{\Longrightarrow} \quad X^{(0)}=(0,0,8,16,12)^T</script></li><li><p>求出检验数 $\sigma_j = c_j -(c_{B_1}x_{j1} + c_{B_2}x_{j2} + …)$ :</p><ul><li>$\sigma_1 = c_1 -(c_{B_1}x_{11} + c_{B_2}x_{12} + c_{B_3}x_{13}) = 2-(0\times 1+0\times 4+0\times0) = 2$</li><li>$\sigma_2 = c_2 -(c_{B_1}x_{21} + c_{B_2}x_{22} + c_{B_3}x_{23}) = 3-(0\times 2+0\times 0+0\times4) = 3$</li><li>$\sigma_3 = c_3 -(c_{B_1}x_{31} + c_{B_2}x_{32} + c_{B_3}x_{33}) = 0-(0\times 1+0\times 0+0\times0) = 0$</li><li>$\sigma_4 = c_4 -(c_{B_1}x_{41} + c_{B_2}x_{42} + c_{B_3}x_{43}) = 0-(0\times 0+0\times 1 + 0\times0) = 0$</li><li>$\sigma_5 = c_5 -(c_{B_1}x_{51} + c_{B_2}x_{52} + c_{B_3}x_{53}) = 0-(0\times 0+0\times 0+0\times1) = 0$</li></ul></li><li><p>观察一下 $\sigma_j$ 这一行的数字看一下是否都 $≤0$ ？否，继续进行下一步。</p></li><li><p>找到 $\sigma_j$ 行最大的数字 $max(\sigma_j)$ 那一列对应的变量 $x_a$【进基变量】，求出 $\theta _{i} = {b_i}/{x_{ai}}$：</p><p> $max(\sigma_j) = 3 =\theta_2 \quad \stackrel{对应的}{\Longrightarrow} \quad 进基变量x_a = x_2$</p><ul><li>$\theta _{1} = {b_1}/{x_{21}} = 8 / 2 = 4 &gt;0$，填入表中</li><li>$\theta _{2} = {b_2}/{x_{22}} = 16 / 0 :无意义$</li><li>$\theta _{3} = {b_3}/{x_{31}} = 12 / 4 = 3 &gt;0$，填入表中</li></ul></li><li><p>找到表中 $\theta _i$ 最小值对应 $X_B$ 列的变量 $x_b$【出基变量】，找到 $x_a$ 的列和 $x_b$ 的行交叉的数字 $m$：</p><p>$min(\theta_i) = 3 = \theta_3 \quad \stackrel{对应的}{\Longrightarrow} \quad 出基变量 x_b = x_5$。$x_a = x_2$的列 与 $x_b = x_5$ 的行交叉的数字 $m = 4$</p></li><li><p>用 $x_a$ 上面的数字替代 $x_b$ 前面的数字，用 $x_a$ 替代 $x_b$，清空 $\sigma_j$ 行与 $\theta_i$ 列：</p><p>|   \   |   $c_j:$    |   2   |   3   |   0   |   0   |   0   |  \   | \          |<br>| :—-: | :————-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—: | ————— |<br>| $c_B$ |    $X_B$    | $x_1$ | $x_2$ | $x_3$ | $x_4$ | $x_5$ | $b$  | $\theta_i$ |<br>|   0   |    $x_3$    |   1   |   2   |   1   |   0   |   0   |  8   |            |<br>|   0   |    $x_4$    |   4   |   0   |   0   |   1   |   0   |  16  |            |<br>|   3   |    $x_2$    |   0   |   4   |   0   |   0   |   1   |  12  |            |<br>|   \   | $\sigma_i:$ |       |       |       |       |       |  \   | \          |</p></li><li><p>对 $x_1,x_2…x_n$ 与 $b$ 列组成的矩阵进行运算，<u>将 $m$ 变成 $1$，同列其他元素变成 $0$，形成一个新的矩阵</u>，将该矩阵中的数字填入表格中对应的位置形成新的单纯形表并进行步骤 3：</p><script type="math/tex; mode=display">M = (x_1,x_2…x_n|b) =(A|b) =\begin{pmatrix}1 & 2 & 1 & 0 & 0 & 8\\4 & 0 & 0 & 1 & 0 & 16\\0 & 4 & 0 & 0 & 1 & 12\\\end{pmatrix}\\\quad \xrightarrow[1/4 \times 第3行]{m=1的初等行变换} \quad\begin{pmatrix}1 & 2 & 1 & 0 & 0 & 8\\4 & 0 & 0 & 1 & 0 & 16\\0 & 1 & 0 & 0 & 1/4 & 3\\\end{pmatrix}\\\quad \xrightarrow[第1行+(-2)\times第3行]{m所在列其他元素为0} \quad\begin{pmatrix}1 & 0 & 1 & 0 & -1/2 & 2\\4 & 0 & 0 & 1 & 0 & 16\\0 & 1 & 0 & 0 & 1/4 & 3\\\end{pmatrix}\\</script><p>|   \   |   $c_j:$    |   2   |   3   |   0   |   0   |   0   |  \   | \          |<br>| :—-: | :————-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—: | ————— |<br>| $c_B$ |    $X_B$    | $x_1$ | $x_2$ | $x_3$ | $x_4$ | $x_5$ | $b$  | $\theta_i$ |<br>|   0   |    $x_3$    |   1   |   0   |   1   |   0   | -1/2  |  2   |            |<br>|   0   |    $x_4$    |   4   |   0   |   0   |   1   |   0   |  16  |            |<br>|   3   |    $x_2$    |   0   |   1   |   0   |   0   |  1/4  |  3   |            |<br>|   \   | $\sigma_i:$ |       |       |       |       |       |  \   | \          |</p><p>重复步骤 3 ……</p></li><li><p>经过多次迭代，列出每次迭代过后的单纯形表：</p><ul><li><p>第一次迭代：</p><p>|   \   |   $c_j:$    |   2   |   3   |   0   |   0   |   0   |  \   | \          |<br>| :—-: | :————-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—: | ————— |<br>| $c_B$ |    $X_B$    | $x_1$ | $x_2$ | $x_3$ | $x_4$ | $x_5$ | $b$  | $\theta_i$ |<br>|   0   |    $x_3$    |   1   |   2   |   1   |   0   |   0   |  8   | 4          |<br>|   0   |    $x_4$    |   4   |   0   |   0   |   1   |   0   |  16  | ❌          |<br>|   0   |    $x_5$    |   0   |   4   |   0   |   0   |   1   |  12  | 3          |<br>|   \   | $\sigma_i:$ |   2   |   3   |   0   |   0   |   0   |  \   | \          |</p><p>$X^{(0)}=(0,0,8,16,12)^T$</p></li><li><p>第二次迭代：</p><p>|   \   |   $c_j:$    |   2   |   3   |   0   |   0   |   0   |  \   | \          |<br>| :—-: | :————-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—: | ————— |<br>| $c_B$ |    $X_B$    | $x_1$ | $x_2$ | $x_3$ | $x_4$ | $x_5$ | $b$  | $\theta_i$ |<br>|   0   |    $x_3$    |   1   |   0   |   1   |   0   | -1/2  |  2   | 2          |<br>|   0   |    $x_4$    |   4   |   0   |   0   |   1   |   0   |  16  | 4          |<br>|   3   |    $x_2$    |   0   |   1   |   0   |   0   |  1/4  |  3   | ❌          |<br>|   \   | $\sigma_i:$ |   2   |   0   |   0   |   0   | -3/4  |  \   | \          |</p><p>$X^{(1)}=(0,3,2,16,0)^T$</p></li><li><p>第三次迭代：</p><p>|   \   |   $c_j:$    |   2   |   3   |   0   |   0   |   0   |  \   | \          |<br>| :—-: | :————-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—: | ————— |<br>| $c_B$ |    $X_B$    | $x_1$ | $x_2$ | $x_3$ | $x_4$ | $x_5$ | $b$  | $\theta_i$ |<br>|   2   |    $x_1$    |   1   |   0   |   1   |   0   | -1/2  |  2   | ❌          |<br>|   0   |    $x_4$    |   0   |   0   |  -4   |   1   |   2   |  8   | 4          |<br>|   3   |    $x_2$    |   0   |   1   |   0   |   0   |  1/4  |  3   | 12         |<br>|   \   | $\sigma_i:$ |   0   |   0   |  -2   |   0   |  1/4  |  \   | \          |</p><p>$X^{(2)}=(2,3,0,8,0)^T$</p></li><li><p>第四次迭代：</p><p>|   \   |   $c_j:$    |   2   |   3   |   0   |   0   |   0   |  \   | \          |<br>| :—-: | :————-: | :—-: | :—-: | :—-: | :—-: | :—-: | :—: | ————— |<br>| $c_B$ |    $X_B$    | $x_1$ | $x_2$ | $x_3$ | $x_4$ | $x_5$ | $b$  | $\theta_i$ |<br>|   2   |    $x_1$    |   1   |   0   |   0   |   0   |  1/4  |  4   |            |<br>|   0   |    $x_5$    |   0   |   0   |  -2   |  1/2  |   1   |  4   |            |<br>|   3   |    $x_2$    |   0   |   1   |  1/2  | -1/8  |   0   |  2   |            |<br>|   \   | $\sigma_i:$ |   0   |   0   | -3/2  | -1/8  |   0   |  \   | \          |</p><p>$X^{(3)}=(4,2,0,0,4)^T$</p><p>我们观察观察一下 $\sigma_j$ 这一行的数字看一下是否都 $≤0$？是，则该可行解就是最优解，即$X^* = X^{(3)}=(4,2,0,0,4)^T$</p><p>所以，$max Z = 2x_1 + 3x_2 + 0x_3 + 0x_4 + 0x_5 = 14$</p></li></ul></li></ol><h3 id="第二部分：整数线性规划"><a href="#第二部分：整数线性规划" class="headerlink" title="第二部分：整数线性规划"></a>第二部分：整数线性规划</h3><p>整数线性规划模型是在一般线性规划模型的基础上加上<u>决策变量取整数值的约束</u>，由此，我们可以得到整数线性规划问题的一般形式如下：</p><script type="math/tex; mode=display">maxZ = \sum_{j=1}^n c_jx_j \qquad ①\\s.t.\left\{\begin{aligned}\sum_{j=1}^n a_{i,j}x_j = b_j \quad i=1,2,3,...,m \qquad ② \\x_j \ge 0 \quad j=1,2,3,...,n \qquad ③\\x_1,x_2,x_3,...,x_n \in \Z \qquad ④\end{aligned}\right.</script><ol><li>先不考虑 $x \in \Z$，求解问题；</li><li>再不考虑 $x \in \Z$，结合 1 中的解，找到最优解。</li></ol><p>实际上，整数线性规划根据<u>决策变量取整数的情况</u>可以进行如下区分：</p><ul><li><p>混合整数规划 ＆ 全整数规划</p></li><li><p>0-1型整数规划 ＆ 非0-1型整数规</p></li></ul><h4 id="含-0-1-变量的建模"><a href="#含-0-1-变量的建模" class="headerlink" title="含 0-1 变量的建模"></a>含 0-1 变量的建模</h4><p>对不含0-1变量的整数规划问题，我们只需要按照一般线性规划问题的形式进行建模，然后综合问题的性质给相应变量增加取整的约束即可；但对于包含0-1变量的问题，由于0-1变量作为二进制变量（或逻辑量），其应用性很强，在实际问题的建模中常常需要灵活运用。</p><ul><li><p>表示系统是否处于某个特定状态，或决策时是否取某个特定方案，如</p><script type="math/tex; mode=display">x =\left\{\begin{aligned}1 \qquad \qquad决策取方案P时 \\0 \qquad 决策不取方案P时(\bar P) \\\end{aligned}\right.</script></li><li><p>当问题含多项要素，每项要素面临两种选择时，可用0-1变量来描述。<br>设问题有有限项要素 $E_1, E_2,…,E_n$，其中每项E，有两种选择 $A_j$ 和 $\bar A_j (j=1,2,…,n)$，可令：</p><script type="math/tex; mode=display">x_j =\left\{\begin{aligned}1 \qquad 若E_j选择A_j \\0 \qquad 若E_j选择\bar A_j \\\end{aligned}\right.</script></li></ul><h5 id="含有相互排斥的约束条件的问题"><a href="#含有相互排斥的约束条件的问题" class="headerlink" title="含有相互排斥的约束条件的问题"></a>含有相互排斥的约束条件的问题</h5><p>我们可以设两个 0-1 变量 $y_1,y_2$:</p><script type="math/tex; mode=display">y_1 =\left\{\begin{aligned}1 \qquad 若E_j选择A_j \\0 \qquad 若E_j选择\bar A_j \\\end{aligned}\right.</script><h4 id="分支定界法"><a href="#分支定界法" class="headerlink" title="分支定界法"></a>分支定界法</h4><p>可以理解为“二分比较”，对可行域进行二分，如果在当前可行域内有最优解</p><script type="math/tex; mode=display">maxZ = 40x_1 + 90x_2 \qquad ①\\s.t.\left\{\begin{aligned}9x_1 +7x_2 \le 56\qquad ② \\7x_1 + 20x_2 \le 70 \qquad ③\\x_1,x_2 \ge 0 \quad x_1,x_2\in \Z \qquad ④\end{aligned}\right.</script><ol><li><p>我们先设不考虑 $x_1,x_2\in \Z$ 的情况为B问题：</p><script type="math/tex; mode=display">maxZ = 40x_1 + 90x_2 \qquad ①\\s.t.\left\{\begin{aligned}9x_1 +7x_2 \le 56\qquad ② \\7x_1 + 20x_2 \le 70 \qquad ③\\x_1,x_2 \ge 0  \qquad ④\end{aligned}\right.</script></li><li><p>运用单纯形法，我们可以得出B问题的最优解 $X_B^* = (4.81,\;1.82)^T$，$maxZ_B = 356$</p></li><li><p>我们可以根据整数对可行域进行二分，然后再讨论：</p><ul><li><p>不考虑 $x_1,x_2\in \Z$ 的情况下 $x_1^* = 4.81$，所以我们可以在左右两边对区域进行划分，即 $x_1 \le 4$ 和 $x_1 \ge 5$ ，将新得到的约束分别加入到 B 问题中</p><p>(1) 问题 $B_1$</p><script type="math/tex; mode=display">maxZ = 40x_1 + 90x_2 \qquad ①\\s.t.\left\{\begin{aligned}9x_1 +7x_2 \le 56\qquad ② \\7x_1 + 20x_2 \le 70 \qquad ③\\x_1,x_2 \ge 0  \qquad ④\\x_1 \le 4 \qquad ⑤\end{aligned}\right.</script></li></ul></li></ol><pre><code> 运用单纯形法，我们可以得出 $B_1$ 问题的最优解 $&#123;X_B&#125;_1^* = (4,\;2.1)^T$，$max&#123;Z_B&#125;_1 = 349$ 我们可以在 $x_2$ 左右两边对区域进行划分，即 $x_2 \le 2$ 和 $x_2 \ge 3$ ，将新得到的约束分别加入到 $B_1$ 问题中： ​    (i) 问题 $B_&#123;11&#125;$ $$ maxZ = 40x_1 + 90x_2 \qquad ①\\ s.t.\left\&#123;\begin&#123;aligned&#125; 9x_1 +7x_2 \le 56\qquad ② \\ 7x_1 + 20x_2 \le 70 \qquad ③\\ x_1,x_2 \ge 0  \qquad ④\\ x_1 \le 4 \qquad ⑤\\ x_2 \le 2 \qquad ⑥ \end&#123;aligned&#125;\right. $$ ​    运用单纯形法，我们可以得出 $B_1$ 问题的最优解 $&#123;X_B&#125;_&#123;11&#125;^* = (4,\;2)^T$，$max&#123;Z_B&#125;_&#123;11&#125; = 340$ ​    (ii) 问题 $B_&#123;12&#125;$ $$ maxZ = 40x_1 + 90x_2 \qquad ①\\ s.t.\left\&#123;\begin&#123;aligned&#125; 9x_1 +7x_2 \le 56\qquad ② \\ 7x_1 + 20x_2 \le 70 \qquad ③\\ x_1,x_2 \ge 0  \qquad ④\\ x_1 \le 4 \qquad ⑤\\ x_2 \ge 3 \qquad ⑥ \end&#123;aligned&#125;\right. $$ ​    运用单纯形法，我们可以得出 $B_1$ 问题的最优解 $&#123;X_B&#125;_&#123;12&#125;^* = (1.42,\;3)^T$，$max&#123;Z_B&#125;_&#123;12&#125; = 327$ (2) 问题 $B_2$ $$ maxZ = 40x_1 + 90x_2 \qquad ①\\ s.t.\left\&#123;\begin&#123;aligned&#125; 9x_1 +7x_2 \le 56\qquad ② \\ 7x_1 + 20x_2 \le 70 \qquad ③\\ x_1,x_2 \ge 0  \qquad ④\\ x_1 \ge 5 \qquad ⑤ \end&#123;aligned&#125;\right. $$ 运用单纯形法，我们可以得出 $B_2$ 问题的最优解 $&#123;X_B&#125;_2^* = (5,\;1.57)^T$，$max&#123;Z_B&#125;_2 = 341$ 我们可以在 $x_2$ 左右两边对区域进行划分，即 $x_2 \le 1$ 和 $x_2 \ge 2$ ，将新得到的约束分别加入到 $B_2$ 问题中： ​    (i) 问题 $B_&#123;21&#125;$ $$ maxZ = 40x_1 + 90x_2 \qquad ①\\ s.t.\left\&#123;\begin&#123;aligned&#125; 9x_1 +7x_2 \le 56\qquad ② \\ 7x_1 + 20x_2 \le 70 \qquad ③\\ x_1,x_2 \ge 0  \qquad ④\\ x_1 \ge 5 \qquad ⑤\\ x_2 \le 1 \qquad ⑥ \end&#123;aligned&#125;\right. $$ ​    运用单纯形法，我们可以得出 $B_1$ 问题的最优解 $&#123;X_B&#125;_&#123;21&#125;^* = (5.44,\;1)^T$，$max&#123;Z_B&#125;_&#123;21&#125; = 308$ ​    (ii) 问题 $B_&#123;22&#125;$ $$ maxZ = 40x_1 + 90x_2 \qquad ①\\ s.t.\left\&#123;\begin&#123;aligned&#125; 9x_1 +7x_2 \le 56\qquad ② \\ 7x_1 + 20x_2 \le 70 \qquad ③\\ x_1,x_2 \ge 0  \qquad ④\\ x_1 \ge 5 \qquad ⑤\\ x_2 \ge 2 \qquad ⑥ \end&#123;aligned&#125;\right. $$ ​    运用单纯形法，我们可以得出 $B_1$ 问题的最优解 $&#123;X_B&#125;_&#123;22&#125;^*无可行解$</code></pre><h3 id="第三部分：动态规划"><a href="#第三部分：动态规划" class="headerlink" title="第三部分：动态规划"></a>第三部分：动态规划</h3><p>我们有如下问题，给定一个线路网络，两点之间连线上的数字表示两点间的距离（或费用），试求一段由 A 到 E 的管线铺路，使总距离为最短（或总费用最小）。</p><p><img src="/2022/04/19/%E8%BF%90%E7%AD%B9%E5%AD%A6/IMG_42512D145660-1.jpeg" alt="IMG_42512D145660-1" style="zoom:50%;"></p><p>其实从A到E并不是一次性的决策，$A \to B, \quad B \to C, \quad C\to D, \quad D \to E$。</p><p>由此我们可见，将问题分成若干相互联系的阶段，在每个阶段都需要做出决策，使全过程达到整体最优，这类问题我们称为多阶段决策问题（资源分配、生产存储）。最大特点就是可以把问题拆分成很多阶段。</p><h4 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h4><ul><li><p>阶段：将问题划分成若干个相互联系的阶段。$k$ 表示为阶段变量。</p><blockquote><p>上图有四个阶段，分别是：$A \to B, \quad B \to C, \quad C\to D, \quad D \to E$</p></blockquote></li><li><p>状态：每个阶段开始时所处的自然状态。$s_k$ 表示为状态变量。</p><blockquote><p>上图有10个状态，分别是：$A,\qquad B_1,B_2,B_3 \qquad C_1,C_2 \qquad D_1,D_2,D_3 \qquad E$</p></blockquote></li><li><p>决策：当过程处于某一阶段的某一状态时作出的<u>决定</u>，从而确定下一阶段的状态。$x_k$ 表示为决策变量。</p><ul><li>允许决策集合：决策变量的取值范围。$D_k(s_k)$ 表示第k阶段从状态$s_k$ 出发的允许决策集合。$x_k \in D_k(s_k)$</li></ul></li><li><p>策略：按顺序排列的决策集合。</p></li><li><p>状态转移方程：确定过程由一个状态到另一个状态的演变过程。$S_{k+1} = T_k(S_k,x_k)$。</p></li><li><p>指标函数：衡量所实现过程优劣的数值指标</p><ul><li>阶段指标函数 $v_k(S_k,x_k)$ ：从k阶段状态 $s_k$ 出发，选择决策 $x_k$ 所产生的第k阶段指标</li><li>过程指标函数 $V_k(S_k,x_k,x_{k+1},…,x_n)$：从k阶段状态 $S_k$ 出发，选择决策 $x_k,x_{k+1},…,x_n$ 所产生的过程指标<ul><li>$V_k(s_k,x_k,x_{k+1},…,x_n) = V[v_k(s_k,x_k),V_{k+1}(S_{k+1},x_{x+1},…,x_n)]$</li></ul></li></ul></li><li><p>最优值函数 $f_x(S_k)= \text{min/max}_{x_k\in D_k(S_k)} \quad V_k(s_k,x_k,x_{k+1},…,x_n)$</p></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">连和形式</th><th style="text-align:center">连乘形式</th></tr></thead><tbody><tr><td style="text-align:center">指标函数</td><td style="text-align:center">$V_k(S_k,x_k,x_{k+1},…,x_n) = \sum _{j=k}^{n-1}v_j(s_j,x_j)+V_n$</td><td style="text-align:center">$V_k(S_k,x_k,x_{k+1},…,x_n) = \prod _{j=k}^{n-1}v_j(s_j,x_j)+V_n$</td></tr><tr><td style="text-align:center">最优值函数</td><td style="text-align:center">$f_x(S_k)= \text{min/max}_{x_k\in D_k(S_k)} \quad V_k(s_k,x_k,x_{k+1},…,x_n)$</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">动态规划模型</td><td style="text-align:center"></td></tr></tbody></table></div><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><ol><li>最优性原理：一个最优策略的子策略也是最优的。</li></ol><blockquote><p>例如：已知最优策略为 $A \to B_1 \to C_1 \to D_1 \to E$，则 $C \to E$ 的最优策略为  $C_1 \to D_1 \to E$ 。</p></blockquote><ol><li>无后效性原理：如果某阶段的状态给定之后，在此<u>阶段以后过程</u>的发展<u>不受这个阶段以前各个状态</u>的影响</li></ol><blockquote><p>我们以上图为例：</p><p>阶段 $k$：$k=1,2,3,4$</p><p>状态变量 $S_k$：$S_1=\{A\} \quad S_1=\{A\} \quad S_2=\{B_1,B_2,B_3\} \quad S_3=\{C_1,C_2\} \quad S_4=\{D_1,D_2,D_3\} \quad S_5=\{E\}$</p><p>决策变量 $x_k$ ：$S_k$ 状态时选择到达下一阶段的点</p><p>允许决策集合：$x_k \in D_k(S_k)$</p><p>状态指标函数 $v_k(S_k,x_k)$：状态点 $S_k$ 到决策点 $x_k$ 间的<u>最短距离</u></p><p>最优指标函数 $f_k(S_k)$：k阶段状态为 $S_k$ 时到终点 $E$ 间的<u>最短距离</u></p><p>递推方程：$\left\{\begin{aligned}<br>f_x(S_k)= \text{min}_{x_k\in D_k(S_k)} \quad \{v_k(s_k,x_k)+f_{k+1}(S_{k+1})\}, k=1,2,3,4 \\<br>f_{5}(S_{5})=0 \\<br>\end{aligned}\right.$</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;基础运筹学&quot;&gt;&lt;a href=&quot;#基础运筹学&quot; class=&quot;headerlink&quot; title=&quot;基础运筹学&quot;&gt;&lt;/a&gt;基础运筹学&lt;/h2&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&lt;a href&gt;本文章&lt;/a&gt;是根据法国国立高等电力技术、电子学、计算机、水力学与电信学校 (E.N.S.E.E.I.H.T.) 第七学期课程&lt;em&gt;“Recherche Operation”&lt;/em&gt; 总结而来的【部分课程笔记】。碍于本人学识有限，部分叙述难免存在纰漏，请读者注意甄别。&lt;/p&gt;
&lt;p&gt;总而言之，运筹学就是从真实系统中&lt;strong&gt;建立模型&lt;/strong&gt;，用数学的形式表示出来。&lt;/p&gt;</summary>
    
    
    
    <category term="课程笔记" scheme="https://dave0126.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="课程笔记" scheme="https://dave0126.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="最优化" scheme="https://dave0126.github.io/tags/%E6%9C%80%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>事务 Transaction 简介</title>
    <link href="https://dave0126.github.io/2022/04/11/%E4%BA%8B%E5%8A%A1transaction%E7%AE%80%E4%BB%8B/"/>
    <id>https://dave0126.github.io/2022/04/11/%E4%BA%8B%E5%8A%A1transaction%E7%AE%80%E4%BB%8B/</id>
    <published>2022-04-11T17:22:49.000Z</published>
    <updated>2022-04-19T11:51:50.616Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是「事务」？"><a href="#什么是「事务」？" class="headerlink" title="什么是「事务」？"></a>什么是「事务」？</h2><p><img src="/2022/04/11/%E4%BA%8B%E5%8A%A1transaction%E7%AE%80%E4%BB%8B/transaction.png" alt="「技术笔记」数据库系统概念-事务transaction 总结" style="zoom:50%;"></p><p>数据库事务通常包含了<u>一序列的对数据库的<strong>读/写</strong>操作</u>，是一系列操作的集合。包含有以下两个目的：</p><ol><li>为数据库操作序列提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。</li><li>当多个<a href="https://zh.wikipedia.org/wiki/应用程序">应用程序</a>在<a href="https://zh.wikipedia.org/wiki/并发">并发</a>访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。</li></ol><p>当事务被提交给了<a href="https://zh.wikipedia.org/wiki/数据库管理系统">数据库管理系统</a>（DBMS），则DBMS需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要<a href="https://zh.wikipedia.org/wiki/回滚_(数据管理">回滚</a>)，回到事务执行前的状态；同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行。</p><span id="more"></span><h2 id="为什么要有「事务」？"><a href="#为什么要有「事务」？" class="headerlink" title="为什么要有「事务」？"></a>为什么要有「事务」？</h2><p>事务是关系型数据库引入的概念，一个现实的业务操作往往关联多处数据，需要在数据库层面提供一种底层的逻辑保障，确保对数据的操作符合一定的特性，简化业务逻辑。<br>事务transaction解决以下问题：</p><ul><li><p>逻辑操作的原子性(<strong>Atomicity</strong>)：</p><p>一系列的逻辑操作要么成功的反应在数据库中，要么完全不反映在数据库中（意味着如果有任何一处失败，整个操作需要回滚）。</p></li><li><p>数据约束的一致性(<strong>Consistency</strong>)：</p><p>数据库的表之间存在各种约束条件，比如主键约束、外键约束等，在没有其他事务并发执行的情况下，对数据库的修改需要符合数据库的一致性约束。</p></li><li><p>并发执行的隔离性(<strong>Isolation</strong>)：</p><p>数据库需要能够并发执行多个事务，对于每个事务来说，其他事务是不可见的；整理看起来，事务并发执行的结果跟按顺序一个一个串行地执行结果一样。</p></li><li><p>执行结果的持久性(<strong>Durability</strong>)：</p><p>一旦对数据库操作结果返回成功，就代表这个改变是永久的，不管数据库系统出现什么故障，比如断电、系统故障、磁盘故障等等（意味着数据库需要在保证性能的情况下具备恢复能力，即，每个成功的操作均需要存储在非易失性存储器上）</p></li></ul><h2 id="「事务」跟「SQL」什么关系？"><a href="#「事务」跟「SQL」什么关系？" class="headerlink" title="「事务」跟「SQL」什么关系？"></a>「事务」跟「SQL」什么关系？</h2><p>事务是数据库逻辑逻辑的基本单元，由高级数据操纵语言编写；SQL全称为「结构化查询语言(Structured Query Language, SQL)就是数据库高级数据操纵语言的一种。在SQL语言的语法中，除了大家经常用到的<code>select</code>、<code>insert</code>、<code>delete</code>、<code>update</code>以外，也有赋值和其他逻辑操作。一个Transaction包含一条或者多条SQL语句，也可以不包含SQL语句。</p><h2 id="什么时候一个事务算成功执行？"><a href="#什么时候一个事务算成功执行？" class="headerlink" title="什么时候一个事务算成功执行？"></a>什么时候一个事务算成功执行？</h2><p>由于有「原子性」的要求，每个事务都有一个状态机，包含：</p><ul><li>活动状态(active)</li><li>部分提交(partially committed)</li><li>失败(failed)</li><li>中止(aborted)</li><li>提交(commit)</li></ul><p>只有当事务的commit日志记录到硬盘之后，日志才会进入提交状态，此时事务算是成功执行。<br>对于一些存在「可见外部写(observable exernal writes)」的事务，一般都是在提交状态之后操作。一个复杂的例子是ATM机：系统状态正常，但是吐钱的时候发生故障。</p><h2 id="「原子性」如何实现？"><a href="#「原子性」如何实现？" class="headerlink" title="「原子性」如何实现？"></a>「原子性」如何实现？</h2><ul><li>原理：影子拷贝(shadow copy)，在数据库副本上执行事务操作，如果成功，则更新数据库指针指向新的copy。</li><li>前提：数据库指针存储在磁盘上，更新磁盘上数据库指针的操作要确保原子性，要么写入新的指针，要么原指针不被擦除。这个由磁盘提供原子性支持，磁盘系统确保了对块或者磁盘扇区更新的原子性。</li><li>其他案例：文本编辑器在编辑的时候，也通过shadow copy的方案来确保编辑会话的事务性。</li></ul><h2 id="「持久性」如何实现？"><a href="#「持久性」如何实现？" class="headerlink" title="「持久性」如何实现？"></a>「持久性」如何实现？</h2><p>持久性的需求：事务成功返回，则记录必须有效保存在非易失存储器（比如硬盘）上。</p><h3 id="困难"><a href="#困难" class="headerlink" title="困难"></a>困难</h3><ul><li>每次事务都直接更新保存在硬盘上的数据库数据文件，不仅性能不行，也无法做到错误恢复；</li><li>如果在内存中加buffer，将一批事务批处理更新到数据库数据文件，则无法做到持久（系统随时有断电风险）</li></ul><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>每次事务的修改保存在硬盘上的「更新日志记录(update log record)」，而不是直接修改数据库「数据文件」。</p><p>日志文件和数据文件相比，虽然都是保存在硬盘上，但是有两个优点：</p><ol><li>效率更高：日志是「顺序」的，又叫顺序日志，记录都是append在上面，不需要磁头寻址；而数据文件是「随机」的，每次都需要寻址。几乎所有的磁盘针对数据库日志文件更新效率都很高。</li><li>确保事务的原子性：一个事务对应的日志包括start、commit作为开头和提交，只有日志完整的事务，才会被批量更新到数据文件。</li></ol><p>此外，日志文件的更新可以通过在内存中加buffer（日志记录缓冲）实现批处理，进一步提高效率，毕竟将数据输出到硬盘上开销还是比较高。在这种方案下，只要日志没有真正写入硬盘，事务就不进入提交状态。在高并发的情况下，让事务阻塞几纳秒，但是极大提高了日志写的效率，系统整体效率还是提升的。</p><p>日志文件中还可以加入「检查点(checkpoint)」,让数据库系统在恢复的时候可以少做一些工作，不需要从头开始redo日志记录，而是从最近的检查点开始。</p><h2 id="「隔离性」如何实现？"><a href="#「隔离性」如何实现？" class="headerlink" title="「隔离性」如何实现？"></a>「隔离性」如何实现？</h2><p>隔离性是针对事务并发的场景，需要达到的目标：</p><ul><li>事务尽可能并行执行，但是执行效果跟事务串行执行一样。</li><li>提高系统的吞吐量(throughput)和处理器、磁盘的利用率(utilization)</li><li>同时减少事务的平均响应时间(average response time)</li></ul><p><strong>调度(schedule)</strong>：一个事务组的操作的<strong>绝对执行顺序</strong>就是一个调度。</p><p><strong>冲突(conflict)</strong>：当两个事务 $T_i$、$T_j$ 对同一数据项 $x$ 进行操作，其中至少有一个是 <code>write</code> 操作时，事务 $T_i$ 和 $T_j$ 是冲突的。有冲突存在，决定了产生冲突的两个事务的冲突操作先后顺序不能改变。</p><p><strong>冲突可串行化</strong>：在不改变一个调度中同一数据项产生操作冲突的操作的先后顺序的情况下，可以将调度变成一个串行调度，则表示这个调度是冲突可串行化的。</p><h4 id="困难-1"><a href="#困难-1" class="headerlink" title="困难"></a>困难</h4><ol><li>调度可串行化：对于多个事务组成的事务组，每个事务包含多个操作（<code>read</code>、<code>write</code> 以及 <code>数据修改操作</code>），如何产生一个冲突可串行化的调度，同时尽可能的提高执行效率（并行执行）</li><li>调度可恢复&amp;无级联：对于一个调度，如果某一个事务 $T_1$ 失败了，确保整个调度是可以恢复的(recoverable)，也就是：既可以 <code>redo</code> 执行失败的事务，而不影响其他事务；也可以 <code>rollback</code> 回滚失败的事务，而不会导致其他事务级联回滚(cascading rollable)</li></ol><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><ol><li>为了保证调度的可串行性，首先要明确什么情况下会出现冲突，其次要确定处理冲突的方式。</li></ol><ul><li>定义冲突的过程中，我们可以对事务操作进行规范，降低复杂度。比如两阶段加锁、有效性检查等方法，都约定了事务操作的规范。</li><li>解决冲突的方式，要么延迟冲突的操作（比如加锁），要么终止发出冲突操作的事务（比如时间戳协议、有效性检查）。</li></ul><ol><li>为了保证调度的可恢复性和无级联性，需要确保「当T2事务读取了T1事务所写的数据项，那么T1事务必须T2读取该数据项之前提交」。</li></ol><h3 id="可串行化判定"><a href="#可串行化判定" class="headerlink" title="可串行化判定"></a>可串行化判定</h3><p>冲突可串行化判定原理：事务 $T_i$ 对数据项 $x$ 的 <code>read</code>、<code>write</code>操作和事务 $T_j$ 对数据项 $x$ 的 <code>read</code>、<code>write</code> 操作决定了他们的串行顺序。以下两种情况均表示 $T_i$ 依赖 $T_j$（$T_i \to T_j$）</p><ul><li>$T_i$ 事务 <code>read</code> 操作前，如果 $T_j$ 有 <code>write</code> 操作</li><li>$T_i$ 事务 <code>write</code> 操作前，如果 $T_j$ 有 <code>write</code> 或 <code>read</code> 操作<br>（两个事务的 <code>read</code> 操作无法确定依赖关系，任何对同一数据项 的<code>read</code>、<code>write</code> 操作可以确定一组依赖关系）</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">Read</th><th style="text-align:center">Write</th><th style="text-align:center">Increase</th><th style="text-align:center">Decrease</th></tr></thead><tbody><tr><td style="text-align:center"><strong>Read</strong></td><td style="text-align:center">OK</td><td style="text-align:center">依赖</td><td style="text-align:center">依赖</td><td style="text-align:center">依赖</td></tr><tr><td style="text-align:center"><strong>Write</strong></td><td style="text-align:center">依赖</td><td style="text-align:center">依赖</td><td style="text-align:center">依赖</td><td style="text-align:center">依赖</td></tr><tr><td style="text-align:center"><strong>Increase</strong></td><td style="text-align:center">依赖</td><td style="text-align:center">依赖</td><td style="text-align:center">OK</td><td style="text-align:center">OK</td></tr><tr><td style="text-align:center"><strong>Decrease</strong></td><td style="text-align:center">依赖</td><td style="text-align:center">依赖</td><td style="text-align:center">OK</td><td style="text-align:center">OK</td></tr></tbody></table></div><blockquote><p>例如：两个事务 $T_1$、$T_2$ 对同一数据项 $x$ 进行操作。在 $T_1$ 的操作 <code>write(x,1)</code> 之后 $T_2$ 中有操作 <code>read(x,1)</code>。我们可以得到一组依赖关系：$T_1 \to T_2$</p></blockquote><p>根据依赖关系可以画出调度的<strong>优先图(precedence graph)</strong>，如果该图是<strong>无环图</strong>，可以通过拓扑排序获得等价的串行 (serialisabilite)调度；否则表示这个<strong>调度是非串行的</strong>。</p><blockquote><p>例：</p></blockquote><pre class="mermaid">sequenceDiagram    participant T1    participant T2    participant T3    participant T4    Note over T1 :1. start();    Note over T2 :2. start();    Note over T3 :3. start();    Note over T4 :4. start();    Note over T1 :5. read(z);    Note over T2 :6. read(y);    Note over T3 :7. write(z,1);    Note over T1 :8. write(x,2);    Note over T4 :9. write(y,3);    Note over T3 :10. read(y);    Note over T2 :11. write(z,4);    Note over T4 :12. read(x);    Note over T3 :13. end();    Note over T2 :14. end();    Note over T4 :15. end();    Note over T1 :16. end();</pre><blockquote><p>调度优先图为：</p></blockquote><pre class="mermaid">graph LRT1 --"(7)"--> T3T2 --"(9)"--> T4T4 --"(10)"--> T3T1 --"(12)"--> T4T3 --"(11)"--> T2</pre><blockquote><p>由图可见，该图内存在环，所以不符合可串行性。</p></blockquote><h3 id="可串行性解决方案"><a href="#可串行性解决方案" class="headerlink" title="可串行性解决方案"></a>可串行性解决方案</h3><h4 id="方案1：加锁（悲观）"><a href="#方案1：加锁（悲观）" class="headerlink" title="方案1：加锁（悲观）"></a>方案1：加锁（悲观）</h4><p><strong>两阶段封锁协议(two-phase locking protocol, 2PL)</strong>：将事务加锁、解锁请求分成两个阶段，所有<strong>加锁请求必须在第一阶段</strong>（增长阶段growing phase）申请，<strong>所有解锁请求必须在第二阶段</strong>（缩减阶段shrinking phase）申请，<strong>加锁和解锁操作不能交叉执行（同一个事务内）</strong>。</p><p>两段锁协议规定所有的事务应遵守的规则：</p><blockquote><p>① 在对任何数据进行<strong>读、写操作之前</strong>，首先要<strong>申请</strong>并获得对该数据的<strong>锁</strong>。</p><p>② 在<strong>释放</strong>一个<strong>锁之后</strong>，事务<strong>不再申请</strong>和获得其它<strong>任何锁</strong>。</p></blockquote><ol><li><p>第一阶段（增长阶段Growing Phase）：</p><p>其实也就是该阶段可以进入加锁操作，在对任何数据进行读操作之前要申请获得S<strong>锁</strong>；在进行<strong>写操作之前要申请并获得X锁</strong>，加锁不成功，则事务进入等待状态，直到加锁成功才继续执行。<br>就是加锁后就不能解锁了。</p></li><li><p>第二阶段（缩减阶段Shrinking Phase）：</p><p>第二阶段是释放封锁，事务可以释放任何数据项上的任何类型的锁，但不能申请。</p><p>当事务释放一个封锁后，事务进入封锁阶段，在该阶段只能进行解锁而不能再进行加锁操作。</p></li></ol><pre class="mermaid">sequenceDiagram    participant T1    participant T2    Note over T1 :1. S_Lock(x);    Note over T1 :2. read(x);    Note over T1 :3. X_Lock(y);    Note over T2 :4. S_Lock(y);    Note over T1 :4. write(y,1);    Note over T2 :5. 等待;    Note over T2 :6. 等待;    Note over T1 :7. unlock(y);    Note over T2 :8. S_Lock(y);    Note over T1 :8. unlock(x);    Note over T2 :9. read(y);    Note over T2 :10. unlock(y);</pre><p>2PL协议解决「串行化」问题的思路是通过把可能冲突的数据操作集中在申请锁的阶段，由锁的不相容性延迟有冲突的事务，从而确定冲突事务的执行次序。这种加锁方式也避免了事务解锁了一部分锁之后又去申请新的锁，导致脏读的问题。但是，2PL协议<strong>无法解决「死锁(dead lock)」问题和级联回滚(cascading rollback) 问题</strong>。</p><p><strong>严格(strict)两阶段封锁协议</strong>：规定持有<strong>排他锁</strong>的事务必须在事务 <code>commit</code> <strong>之后</strong>才能<strong>释放锁</strong>。避免了<strong>级联回滚</strong>。<br><strong>强(rigorous)两阶段封锁协议</strong>：规定持有任何锁的事务必须在事务 <code>commit</code> <strong>之后</strong>才能<strong>释放锁</strong>。比strict模式更严格，避免了<strong>死锁</strong>。</p><p>大部分数据库要么采用strict 2PL，要么rigorous 2PL。为了提高并行性能，允许在增长阶段将共享锁S升级(upgrade)为排他锁X，同时在缩减阶段将排他锁X降级(downgrade)为共享锁S，这样确保在write的时间点才排他，操作完之后就不排他，减少事务等待时间。</p><p><strong>重点注意</strong>：使用2PL，虽然可以确保冲突可串行化，但是不代表它的执行效果跟串行一样。因为加锁状态下的可串行化是理论上的可串行化，是根据每个事物的封锁点(lock point，也就是最后加锁的位置)排序得到的串行化顺序，而<u>调度实际执行的时候主要依靠「锁」来保证对冲突操作的执行顺序，这个是并行执行的，因此会出现不同的事务都优先拿到对方需要的数据集的锁的情况（死锁）</u>。</p><p><strong>数据多粒度(granularity)封锁</strong>：理论情况下，加锁针对的数据项Q是没有粒度的。实际中，数据项在保存的时候，经常多个数据项聚成一个数据单元。这种情况下，如果要加锁一个范围比较大的数据时，需要挨个数据项加锁，比较费时；如果需要加锁一个范围比较小的数据时，又会锁定无关的数据项，导致整体并发性减弱。为数据建立<em>多粒度</em>机制就是解决方案。该方案根据数据在数据库中的存储特点，从「数据库」到「区域的文件节点」再到「记录」，形成一颗提现粒度层次的树。并引入「共享型意向锁IS」、「排他型意向锁IX」、「共享排他型意向锁SIX」，实现多粒度封锁。</p><p><strong>多版本两阶段封锁(Multiversion two-phase locking protocol)</strong>：2PL的并行性能有待提升，尤其是在大部分事务「只读」，小部分事务是「更新」操作的情况下，只读的事务会被延迟到更新事务完成，这种情况可以通过结合多版本的特性进行提升。<br>多版本的2PL协议，将事务分为「只读事务」和「更新事务」，针对每一个数据项 $x$ 维护一个全局的版本号ts-counter（计数器型时间戳），事务 $T_i$ 执行 <code>read(x)</code> 操作将返回时间戳小于 $TS(T_i)$ 的最大时间戳版本的内容；<code>write(x)</code> 操作会增加全局版本号以及写入 $x$ 的新版本。这种情况下，只读事务永远不需要等待锁，更新事务则执行强两阶段封锁协议，确保他们可以按照提交次序串行化。</p><h4 id="方案2：时间戳规则（乐观）"><a href="#方案2：时间戳规则（乐观）" class="headerlink" title="方案2：时间戳规则（乐观）"></a>方案2：时间戳规则（乐观）</h4><p><strong>时间戳排序协议(timestamp-ordering protocol)</strong>：不同于加锁的方式，通过锁的相容性决定冲突事务执行顺序，时间戳排序机制<strong>通过事务的时间戳</strong>来决定事务串行化的次序。</p><ol><li>为每一个数据项 $x$ 关联 <code>read</code>、<code>write</code> 操作最近一次成功执行的时间戳 $R_{ead}T_{imestamp}(x)\quad W_{rite}T_{imestamp}(x)$。</li><li>当事务 $T_i$ 对数据项 $x$ 进行 <code>write</code> 操作的时候，如果在事务 $T_i$ 开始之后，$x$ 被其他事务 <code>read</code> 或者 <code>write</code> 过，则当前事务 $T_i$ 进行回滚。</li></ol><blockquote><p>基本时间戳排序协议的工作原理如下：</p><ul><li><code>TS(Ti)</code>表示事务 $T_i$ 的时间戳。</li><li><code>RT(x)</code>表示数据项 $x$ 的读时间戳。</li><li><code>WT(x)</code>表示数据项 $x$ 的写时间戳。</li></ul><ol><li>每当事务 $T_i$ 发出 <code>read(x)</code> 操作时，请检查以下条件：</li></ol><ul><li>如果 $WT(x) &gt; TS(T_i)$ 则<strong>拒绝</strong>该操作；</li><li>如果 $WT(x) \le TS(T_i)$ 则<strong>执行</strong>操作；</li><li>更新所有数据项的时间戳。</li></ul><ol><li>每当事务 $T_i$ 发出 <code>write(x)</code> 操作时，请检查以下条件（<strong>Thomas 写规则</strong>）：</li></ol><ul><li>如果 $TS(T_i)&lt;RT(x)$，则表明 $T_i$ 准备写的值还没来得及写入，$x$ 就提前被读取了，所以 $T_i$ 的 <code>write(x)</code>操作被拒绝，并且事务 $T_i$ 被回滚</li><li>如果 $TS(T_i) &lt; WT(x)$，表明 $T_i$ 写的值已过期，比它更新的值已经写到 $x$ 上，所以 $T_i$ 的 <code>write(x)</code>操作被拒绝；</li><li>剩下的情况，<code>write(x)</code> 操作被允许；</li><li>更新所有数据项的时间戳。</li></ul></blockquote><p>时间戳排序协议<strong>不会有死锁</strong>，因为没有事务处于「等待」状态，事务发现数据项被后来者动过之后就回滚了。但是，这种规则有很强的「抢断」性质，容易导致<strong>长事务持续被短事务抢断，长事务反复重启，可能导致饿死</strong>。</p><p><em>Thomas写规则</em>：对时间戳排序协议的性能优化，当事务 $T_i$ 对数据项 $x$ 进行<code>write</code>操作的时候，如果在事务 $T_i$ 开始之后，$x$ 被其他事务<code>write</code> 过，则当前事务 $T_i$ 的 <code>write</code> 操作<strong>忽略</strong>，而不是进行<strong>回滚</strong>。通过这种方式减少不必要的回滚。</p><p><em>多版本时间戳排序机制(multiversion timestamp-ordering scheme)</em>：类似多版本两阶段封锁协议，让每个 <code>write(x)</code> 操作创建 $x$ 的新版本，而 <code>read(x)</code> 操作则会被分配一个合适的 $x$ 版本进行读取，提高「读」的效率。</p><h4 id="方案3：Validation-有效性规则（乐观）"><a href="#方案3：Validation-有效性规则（乐观）" class="headerlink" title="方案3：Validation 有效性规则（乐观）"></a>方案3：Validation 有效性规则（乐观）</h4><p>有效性检查协议：假设每个事物Ti的生命周期分为2个阶段（只读事务）或者3个阶段（更新事务）。读阶段只进行读、计算操作，之后进行$validation$ 检查，通过的话就进行写操作。每个阶段都关联一个时间戳：$Start(T_i)$，$Validation(T_i)$，$Finish(T_i)$。有效性测试的原理跟时间戳规则一样，</p><blockquote><p><em>如果事务 $T_i$ 在写数据项 $x$（有效性验证）的时候发现数据项已经被写过了，则事务 $T_i$ 回滚</em>。</p></blockquote><p>相比时间戳排序，有效性检查协议把 $validation$ 的时间作为事务的时间戳，而不是使用事务开始的时间，这样可以在冲突度低的情况下有更快响应。</p><p>有效性规则是一种<strong>乐观并发控制(optimistic concurrency control)</strong></p><h3 id="非可串行性解决方案：增强并发性能的「弱一致性级别」"><a href="#非可串行性解决方案：增强并发性能的「弱一致性级别」" class="headerlink" title="非可串行性解决方案：增强并发性能的「弱一致性级别」"></a>非可串行性解决方案：增强并发性能的「弱一致性级别」</h3><h4 id="为什么要有非可串行化解决方案"><a href="#为什么要有非可串行化解决方案" class="headerlink" title="为什么要有非可串行化解决方案"></a>为什么要有非可串行化解决方案</h4><p>在某些应用中，串行化方案可能会影响并发性能，但是应用并不需要精确的信息，因此可以牺牲串行性而提高并发性。</p><h4 id="二级一致性"><a href="#二级一致性" class="headerlink" title="二级一致性"></a>二级一致性</h4><h4 id="弱一致性要解决的问题"><a href="#弱一致性要解决的问题" class="headerlink" title="弱一致性要解决的问题"></a>弱一致性要解决的问题</h4><ol><li>脏读(Dirty read)：当前事务读取的数据项已经过时，原因是其他事务已经修改了该数据，但是并未最后提交（也可能最终回滚）。总之，当前事务读到的数据是不可靠的，是「脏数据」。</li><li>不重复读(Unrepeatable read)：同一个事务连续两次读取同一数据项 $x$，间隙之间其他事务修改了数据项 $x$，因此本事务先后两次读到的数据结果会不一致。</li><li>幻读(Phantom Read)：当前事务进行某个范围数据的读或者写的操作的同时，另一个事物插入了符合当前事务读写约束的新数据，当前事务再更新时，惊奇地发现了这些新数据，貌似之前读到的数据是幻觉一样。</li></ol><h4 id="弱一致性的级别：由弱到强一次解决上述3个问题"><a href="#弱一致性的级别：由弱到强一次解决上述3个问题" class="headerlink" title="弱一致性的级别：由弱到强一次解决上述3个问题"></a>弱一致性的级别：由弱到强一次解决上述3个问题</h4><ul><li>未提交读(Read uncommited)：读操作不加锁，可能读到已经过时的数据，存在「脏读」的问题。</li><li>已提交读(Read commited)：只允许读取已提交记录，但是不要求可重复读。事务连续两次读取同一数据之间会释放锁，因此两次读取结果不保证一样。解决了「脏读」，但是不解决「不重复读」。</li><li>可重复读(Repeatable read)：只允许读取已提交记录，且同一个事务两次读取同一数据项 $x$ 得到的结果是一致的。事务在提交之前不会释放锁。解决了「脏读」、「不重复读」问题，但是解决不了「幻读(Phantom Read)」。</li><li>串行化(Serializable)：执行结果跟串行执行一样。解决了「幻读」问题。</li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td style="text-align:center">未提交读(Read uncommited)</td><td style="text-align:center">N</td><td style="text-align:center">N</td><td style="text-align:center">N</td></tr><tr><td style="text-align:center">已提交读(Read commited)</td><td style="text-align:center">Y</td><td style="text-align:center">N</td><td style="text-align:center">N</td></tr><tr><td style="text-align:center">可重复读(Repeatable read)</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">N</td></tr><tr><td style="text-align:center">串行化(Serializable)</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td></tr></tbody></table></div><h2 id="高效的数据库系统为什么对操作系统是有要求？"><a href="#高效的数据库系统为什么对操作系统是有要求？" class="headerlink" title="高效的数据库系统为什么对操作系统是有要求？"></a>高效的数据库系统为什么对操作系统是有要求？</h2><p>数据库系统进行数据操作的逻辑单元—事务，包含两个访问数据的核心操作：</p><ul><li><code>read(x)</code>：从数据库中把数据项 $x$ 传送到执行 <code>read</code> 操作的事务的局部缓冲区</li><li><code>write(x)</code>：从执行<code>write(x)</code> 操作的事务的局部缓冲区把数据项 $x$ 传回数据库</li></ul><h3 id="困难-2"><a href="#困难-2" class="headerlink" title="困难"></a>困难</h3><p>数据库系统为了实现「持久性」，必须遵守先写日志（write-ahead logging，WAL）规则，这样从数据库文件中读出的存放在内存中的数据块就不能由操作系统自由写回，而应该由数据库系统根据日志的完成情况，强制输出缓冲块。</p><h3 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h3><ol><li>数据库系统保留部分内存作为缓冲区并进行管理，而不是让操作系统来管理。</li></ol><ul><li>优点：由数据库管理，可以完全按照符合数据库规则的方式使用，效率高。</li><li>缺点：这部分保留内存无法被数据库以外的应用使用，限制了内存使用的灵活性。</li></ul><ol><li>数据库在操作系统提供的虚拟内存中实现缓冲区。</li></ol><ul><li>缺点：大部分操作系统都会完全控制虚拟内存，导致当数据库系需要输出某个数据块时（保存在虚拟内存中），需要更多次的操作。</li></ul><h2 id="死锁-Dead-lock-如何处理？"><a href="#死锁-Dead-lock-如何处理？" class="headerlink" title="死锁(Dead lock)如何处理？"></a>死锁(Dead lock)如何处理？</h2><p>死锁就是循环「等待(wait)」，只要事务需要等待，就有可能存在死锁。处理死锁问题的思路：</p><ol><li>死锁预防(deadlock prevention)：对加锁请求进行排序或者要求同时获得所有锁来确保不会发生循环等待。</li><li>死锁恢复(deadlock recovery)：在检测出死锁之后，根据一定的规则选择某些事务进行回滚，打破循环等待的状态。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>Database System Concepts（数据库系统概念）</li><li><a href="https://draveness.me/mysql-transaction">『浅入深出』MySQL 中事务的实现</a></li><li><a href="http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html">MySQL的InnoDB的幻读问题</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;什么是「事务」？&quot;&gt;&lt;a href=&quot;#什么是「事务」？&quot; class=&quot;headerlink&quot; title=&quot;什么是「事务」？&quot;&gt;&lt;/a&gt;什么是「事务」？&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/2022/04/11/%E4%BA%8B%E5%8A%A1transaction%E7%AE%80%E4%BB%8B/transaction.png&quot; alt=&quot;「技术笔记」数据库系统概念-事务transaction 总结&quot; style=&quot;zoom:50%;&quot;&gt;&lt;/p&gt;
&lt;p&gt;数据库事务通常包含了&lt;u&gt;一序列的对数据库的&lt;strong&gt;读/写&lt;/strong&gt;操作&lt;/u&gt;，是一系列操作的集合。包含有以下两个目的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;为数据库操作序列提供了一个从失败中恢复到正常状态的方法，同时提供了数据库即使在异常状态下仍能保持一致性的方法。&lt;/li&gt;
&lt;li&gt;当多个&lt;a href=&quot;https://zh.wikipedia.org/wiki/应用程序&quot;&gt;应用程序&lt;/a&gt;在&lt;a href=&quot;https://zh.wikipedia.org/wiki/并发&quot;&gt;并发&lt;/a&gt;访问数据库时，可以在这些应用程序之间提供一个隔离方法，以防止彼此的操作互相干扰。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;当事务被提交给了&lt;a href=&quot;https://zh.wikipedia.org/wiki/数据库管理系统&quot;&gt;数据库管理系统&lt;/a&gt;（DBMS），则DBMS需要确保该事务中的所有操作都成功完成且其结果被永久保存在数据库中，如果事务中有的操作没有成功完成，则事务中的所有操作都需要&lt;a href=&quot;https://zh.wikipedia.org/wiki/回滚_(数据管理&quot;&gt;回滚&lt;/a&gt;)，回到事务执行前的状态；同时，该事务对数据库或者其他事务的执行无影响，所有的事务都好像在独立的运行。&lt;/p&gt;</summary>
    
    
    
    <category term="课程笔记" scheme="https://dave0126.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="并发系统" scheme="https://dave0126.github.io/tags/%E5%B9%B6%E5%8F%91%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="SQL" scheme="https://dave0126.github.io/tags/SQL/"/>
    
  </entry>
  
  <entry>
    <title>Transition System(变迁系统) 与 TLA+</title>
    <link href="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/"/>
    <id>https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/</id>
    <published>2022-03-29T08:59:58.000Z</published>
    <updated>2022-04-17T10:47:56.512Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Transition-System-变迁系统-与-TLA"><a href="#Transition-System-变迁系统-与-TLA" class="headerlink" title="Transition System(变迁系统) 与 TLA+"></a>Transition System(变迁系统) 与 TLA+</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><a href="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/">本文章</a>是根据法国国立高等电力技术、电子学、计算机、水力学与电信学校 (E.N.S.E.E.I.H.T.) 第八学期课程“Système de Transition”总结而来的课程笔记。碍于本人学识有限，部分叙述难免存在纰漏，请读者注意甄别。</p><p>参考：</p><ul><li><a href="https://blog.csdn.net/campsisgrandiflora/category_10509594.html">系统分析与验证 - Campsisgrandiflora的博客</a> </li><li>《 Introduction to TLA 》- Lesie Lamport</li></ul><span id="more"></span><h4 id="变迁系统"><a href="#变迁系统" class="headerlink" title="变迁系统"></a>变迁系统</h4><p>在计算机科学和控制理论中，“变迁系统”用数学的方法描述离散系统的行为。变迁系统主要由“状态”和状态之间的“状态迁移”组成。 有标号的变迁系统可以从已定义的标签集合中选择相应标签来标记状态迁移，而且相同的标签可能被应用在多个状态迁移上。 变迁系统也可以是无标记的，此时也可以认为标签集合中只有单一标签元素，从而省略了状态迁移上的标签记号。</p><p>变迁系统在数学定义上和<strong>有向图</strong>一致，但与<strong>有限状态自动机</strong>有一定不同。</p><p>变迁系统的特点有：</p><ul><li>系统状态的集合不一定是有限的或可数的；</li><li>状态迁移的集合不一定是有限的或可数的；</li><li>变迁系统并不需要给出“开始”状态或“最终”状态；</li><li>变迁系统可以表示为<strong>有向图</strong>，有限状态自动机则不能。</li></ul><p>资料来源于<a href="https://zh.wikipedia.org/wiki/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F">维基百科：变迁系统</a></p><h4 id="TLA"><a href="#TLA" class="headerlink" title="TLA+"></a>TLA+</h4><h5 id="形式化验证"><a href="#形式化验证" class="headerlink" title="形式化验证"></a>形式化验证</h5><p>形式化验证技术想要解决的核心问题是：软件总是可能存在 Bug 的，而测试始终无法涵盖所有可能性，特别是对于并发系统及分布式系统来说，就算单元测试达到了 100% 分支覆盖率，也不能肯定的说这个系统在线程安全，一致性等方面不会出问题。那如何更好的来验证我们的程序是否符合预期呢？</p><p>形式化验证就旨在使用严谨的数学证明方法来证明某一算法是正确的。</p><h5 id="TLA-1"><a href="#TLA-1" class="headerlink" title="TLA+"></a>TLA+</h5><p><strong>T</strong>emporal <strong>L</strong>ogic of <strong>A</strong>ctions <strong>+</strong>是由<em>Leslie Lamport</em>开发的一种【形式化验证语言】。它用于设计、建模、记录和验证程序，尤其是并发系统和分布式系统。TLA +被描述为可完全测试的伪代码，其用途类似于为软件系统绘制蓝图。</p><p>由于 TLA+ 写的代码并不是用来实际运行的，故一般将其代码称为模型（Model）而非程序（Program）。</p><h4 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h4><ol><li><a href="https://learntla.com/">Learn TLA+</a></li><li><a href="https://lamport.azurewebsites.net/video/videos.html">L. Lamport 关于TLA+的视频</a></li><li><a href="https://lamport.azurewebsites.net/tla/tla.html">其他资源</a></li></ol><h3 id="第一部分：Transition-System"><a href="#第一部分：Transition-System" class="headerlink" title="第一部分：Transition System"></a>第一部分：Transition System</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><h5 id="变迁系统-1"><a href="#变迁系统-1" class="headerlink" title="变迁系统"></a>变迁系统</h5><p>Transition System在计算机科学中通常用作描述系统行为的模型，它是一种有向图，节点代表状态，边代表着状态的转化。</p><p>状态（state）描述了系统在其行为的特定时刻的一些信息。<br>例如，交通灯的状态指示灯的当前颜色。类似地，顺序计算机程序的状态指示所有程序变量的当前值，以及指示要执行的下一个程序语句的程序计数器的当前值。</p><p>转变（transition）指定系统如何从一种状态演变为另一种状态。<br>对交通信号灯来说，转换表示从一种颜色切换到另一种颜色。而对于顺序程序，转换通常对应于语句的执行，并且可能涉及某些变量和程序计数器的更改。</p><p>下面给出一种Transition System（TS）的定义</p><p>变迁系统是一个三元组$⟨S,I,R⟩$:</p><ul><li>$S$ 是状态集。包含 <strong>终结状态</strong> 和 <strong>非终结状态</strong></li><li>$I \subseteq S$ 是一个 <strong>初始状态</strong></li><li>$R \subseteq S \times S$ 是状态对之间的（转换）关系。$(s,s’) \in R$ 表示系统从状态 $s$ 到状态$s’$ 的转换。我们假定 $s$ 表示现在时刻的状态集合， $s$ 中的变量称为现态， $s’$ 表示发生转变之后的状态集合， $s’$ 中的变量称为次态。</li></ul><p>例：</p><script type="math/tex; mode=display">S = {S_0, S_1, S_2, S_3,S_4}</script><script type="math/tex; mode=display">I = {S_0}</script><script type="math/tex; mode=display">R = \{(S_0,S_0), (S_0,S_1), (S_0,S_2), (S_2,S_3), (S_3,S_4), (S_4,S_3)\}</script><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29 13.16.51-8552669.png" alt="2022-03-29 13.16.51" style="zoom:67%;"></p><h6 id="直接后继（Direct-Successors）"><a href="#直接后继（Direct-Successors）" class="headerlink" title="直接后继（Direct Successors）"></a>直接后继（Direct Successors）</h6><p>定义为：</p><script type="math/tex; mode=display">Post(s,α)=\{s'∈S | s\xrightarrow{α}s' \}</script><p>就是指状态$s$执行动作$α$之后能达到的状态的集合</p><p>如果α为任意动作，可以记为：</p><script type="math/tex; mode=display">Post(s)=\bigcup_{α∈Act}Post(s,α)</script><h6 id="直接前任（Direct-Predecessors）"><a href="#直接前任（Direct-Predecessors）" class="headerlink" title="直接前任（Direct Predecessors）"></a>直接前任（Direct Predecessors）</h6><script type="math/tex; mode=display">Pre(s, α) =\{s'∈S|s'\xrightarrow{α}s\}</script><p>指通过执行动作α之后能达到状态s的状态集合</p><p>同理，α如果为任意动作，则记为：</p><script type="math/tex; mode=display">Pre(s)=\bigcup_{α∈Act}Pre(s,α)</script><p>用图来表示前任和后继的话就是这样子的：</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/20201127224956365.png" alt="20201127224956365" style="zoom:50%;"></p><h6 id="终止状态"><a href="#终止状态" class="headerlink" title="终止状态"></a>终止状态</h6><p>对于TS模型来说，终止状态就是指没有后继状态的状态，即$Post(s)=\varnothing$</p><p>串行程序的终止状态代表着程序的终止。</p><p>对于并行程序来说，我们一般不考虑它的终止状态，因为并行程序大都要求持续运行下去。</p><h6 id="确定性TS（Deterministic-Transition-System）"><a href="#确定性TS（Deterministic-Transition-System）" class="headerlink" title="确定性TS（Deterministic Transition System）"></a>确定性TS（Deterministic Transition System）</h6><p>如果</p><script type="math/tex; mode=display">|S_{0}|≤1\;and\;|Post(s,α)|≤1</script><p>那么这个TS就可以称为动作确定的TS</p><p>如果</p><script type="math/tex; mode=display">|S_{0}|≤1\;and\;|Post(s,α)\cap \{s'∈S|L(s')=A\}|≤1(A∈2^{AP})</script><p>那么这个TS就可以称为AP确定的TS</p><h5 id="序列（Sequence）"><a href="#序列（Sequence）" class="headerlink" title="序列（Séquence）"></a>序列（Séquence）</h5><p>$S$ 是状态集：</p><ul><li>$S^<em>$ 是 $S$ 上的<em>*有限序列集</em></em>；</li><li>$S^w$ 是 $S$ 上的<strong>无限数据集</strong>；</li><li>$\sigma _i$ 是序列 $\sigma$ 从 0 开始的第 $i$个元素。</li><li>序列 $S$ 用以下形式表示：$⟨s1 → s2 → …⟩$</li><li>$⟨⟩$ 表示空序列；</li></ul><p>对于一个有限序列$\sigma$ ：</p><ul><li>$\sigma^<em>$ 是由任意的 $\sigma $ 重复产生的<em>*有限序列集</em></em>。</li><li>$\sigma^+ \triangleq \sigma^* \backslash \{ ⟨⟩ \}$</li><li>$\sigma^w$  是由任意的 $\sigma $ 重复产生的无限序列集。</li></ul><h5 id="迹（trace）"><a href="#迹（trace）" class="headerlink" title="迹（trace）"></a>迹（trace）</h5><h6 id="有限轨迹（Traces-finies）"><a href="#有限轨迹（Traces-finies）" class="headerlink" title="有限轨迹（Traces finies）"></a>有限轨迹（Traces finies）</h6><p>令 $⟨S, I, R⟩$ 是一个变迁系统。我们称有限迹为有限序列$\sigma \in S^*$ 使得</p><ul><li><p>$\sigma = ⟨s_0 → s_1 → … → s_{n-1} → s_n ⟩$</p></li><li><p>$\forall i \in [0 … n[:(s_i, s_{i-1}) \in R$</p></li></ul><h6 id="最大有限轨迹（Traces-finies-maximales）"><a href="#最大有限轨迹（Traces-finies-maximales）" class="headerlink" title="最大有限轨迹（Traces finies maximales）"></a>最大有限轨迹（Traces finies maximales）</h6><p>当有限轨迹$⟨s_0 → s_1 → … → s_{n-1} → s_n ⟩ \in S^*$ 时，我们称它是最大的。$s_n$没有后继状态，即$\forall s \in S:(s_n, s) \notin R$</p><h6 id="无限轨迹（Trace-infinies）"><a href="#无限轨迹（Trace-infinies）" class="headerlink" title="无限轨迹（Trace infinies）"></a>无限轨迹（Trace infinies）</h6><p>令 $⟨S, I, R⟩$ 是一个变迁系统，并且$s_0 \in S$。我们称从 $s_0$开始到元素 $tr \in S^w$ 的无限序列为</p><ul><li><p>$tr = ⟨s_0 → s_1 → s_2 → … ⟩$</p></li><li><p>$\forall i \in \mathbb{N}:(s_i, s_{i+1}) \in R$</p></li></ul><h6 id="来自状态的轨迹（Traces-issues-d’un-etat）"><a href="#来自状态的轨迹（Traces-issues-d’un-etat）" class="headerlink" title="来自状态的轨迹（Traces issues d’un état）"></a>来自状态的轨迹（Traces issues d’un état）</h6><p>令 $⟨S, I, R⟩$ 是一个变迁系统，并且$s \in S$。</p><ul><li>$Traces(s) $ 是从状态$s$ 开始的最大无限或有限轨迹的集合。</li></ul><h5 id="执行（Executions）"><a href="#执行（Executions）" class="headerlink" title="执行（Exécutions）"></a>执行（Exécutions）</h5><p>令 $⟨S, I, R⟩$ 是一个变迁系统，</p><p>一次执行片段 $σ = ⟨s_0 →…⟩ $ 是满足 $s_0 ∈ I $ 的最大无限或有限轨迹（如果是有限执行片段，那么它结束于终止状态，或者该片段是一个无限执行片段）。</p><ul><li>$Exec(S)$ 是 $S = \bigcup_{s_0 \in I} Traces(s_0)$ 的执行集。</li><li>如果 $I = ∅$，则我们有一个（也是唯一一个）空执行$ ⟨⟩$。</li><li>如果一个初始、有限执行片段的终止状态为s，那么s称为<strong>可达的</strong>(reachable)，直观来说，可达表示从初始状态开始能够到达某个状态。我们把所有的可达状态记为<strong>Reach(TS)</strong></li></ul><h5 id="练习一"><a href="#练习一" class="headerlink" title="练习一"></a>练习一</h5><h6 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h6><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29 13.16.51-8552669.png" alt="2022-03-29 13.16.51" style="zoom:67%;"></p><p>$s_0 → s_0 → s_2 → s_3$ 是一段非最大的有限轨迹。</p><ol><li>$Traces(s_1) = ⟨s_1⟩$</li><li>$Traces(s_3) = ⟨(s_3 → s_4)^w⟩$</li><li>$Traces(s_2) = ⟨s_2 → (s_3 → s_4)^w⟩$</li><li>$Traces(s_0) = ⟨{s_0}^w⟩, ⟨{s_0}^+ → s_1⟩, ⟨s_0 → s_2 → (s_3 → s_4)^w⟩$</li><li>$Exec(S) = Traces(s_0)$</li></ol><h6 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h6><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29 13.28.06-8553323.png" alt="2022-03-29 13.28.06" style="zoom:67%;"></p><ol><li>$Traces(s_2) = ⟨s_2 → s_4⟩, ⟨(s_2 → s_3 → s_0 → s_1)^w⟩, ⟨(s_2 → s_3 → s_0 → s_1)^* → s_2 → s_4⟩$</li><li>$Traces(s_0) = ⟨(s_0 → s_1 → s_2 → s_3⟩^w, ⟨s_0 → s_1 → (s_2 → s_3 → s_0 → s_1)^* → s_2 → s_4⟩$</li><li>$Exec(S) = Traces(s_0)$</li></ol><h6 id="例三"><a href="#例三" class="headerlink" title="例三"></a>例三</h6><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29 13.48.33-8554538.png" alt="2022-03-29 13.48.33" style="zoom:67%;"></p><ol><li>$Traces(s_2) = ⟨(s_2 → s_3)^w⟩, ⟨(s_2 → s_3)^* → s_2 → s_4⟩$</li><li>$Traces(s_0) = ⟨(s_0 → (s_2 → s_3)^w⟩, ⟨(s_0 → (s_2 → s_3)^* → s_2 → s_4⟩$</li><li>$Traces(s_1) = ⟨(s_1 → (s_3 → s_2)^w⟩, ⟨(s_1 → (s_3 → s_2)^+ → s_4⟩$</li><li>$Exec(S) = Traces(s_0) \cup Traces(s_1)$</li></ol><h5 id="可访问状态（Etats-accessibles）"><a href="#可访问状态（Etats-accessibles）" class="headerlink" title="可访问状态（Etats accessibles）"></a>可访问状态（Etats accessibles）</h5><p>令 $⟨S, I, R⟩$ 是一个变迁系统。</p><ul><li>$s ∈ S$ 是一个可访问状态 $\triangleq $ 有一个通过 $s$ 的执行（或等价的，有一个以 $s$ 结尾的执行前缀）;</li><li>$Acc(S)$ 是 $S$ 的可访问状态集。</li></ul><h5 id="执行图（Graphe-des-Executions）"><a href="#执行图（Graphe-des-Executions）" class="headerlink" title="执行图（Graphe des Exécutions）"></a>执行图（Graphe des Exécutions）</h5><p>令 $⟨S, I, R⟩$ 是一个变迁系统。</p><p>执行图是有向图，其中：</p><ul><li>顶点集是 $Acc(S)$；</li><li>有向边的集合是 $R$，仅限于可访问状态。</li></ul><p>因此它是$ ⟨S ∩ Acc(S), R ∩ (Acc(S) × Acc(S))⟩ $ 的图。</p><h5 id="被标记的变迁系统（Systeme-de-Transitions-etiquete-）"><a href="#被标记的变迁系统（Systeme-de-Transitions-etiquete-）" class="headerlink" title="被标记的变迁系统（Systeme de Transitions étiqueté ）"></a>被标记的变迁系统（Systeme de Transitions étiqueté ）</h5><p>被标记的变迁系统 是一个五元组$⟨S、I、R、L、Etiq⟩$：</p><ul><li>$S$：状态集。</li><li>$I ⊆ S$：初始状态集。</li><li>$R ⊆ S × S$：状态对之间的转换关系。</li><li>$L$：标签集。</li><li>$Etiq$：将标签与每个转换(transition) 相关联的函数：$Etiq ∈ R → L$。带</li></ul><p>被标记的变迁系统 非常接近自动机。但是没有 terminal state + infinity execution。</p><p>被标记的变迁系统 $⟨S, I, R, L, Etiq⟩$ <strong>等价于</strong>由如下定义的 未标记系统$⟨S’, I’, R’⟩$ ：</p><ul><li>$S’ = (L \cup \{ \epsilon \}) \times S$</li><li>$I’ = \{ \epsilon \} \times I$</li><li>$R’ = \{ ( ⟨I,s⟩, ⟨I’,s’⟩ )| (s, s’) \in R \land I’ = Etiq(s,s’)\}$</li></ul><p>转换(transition) $s_1 \xrightarrow{a} s_2 $ 可变成 $ ⟨$_$,s_1⟩ \to ⟨a,s_2⟩$，其中 _ 是任何标签。</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29 15.18.04.png" alt="2022-03-29 15.18.04" style="zoom:50%;"></p><p>可变为</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29 15.19.07-8559976.png" alt="2022-03-29 15.19.07" style="zoom:50%;"></p><h5 id="变迁系统-不等于-自动机"><a href="#变迁系统-不等于-自动机" class="headerlink" title="变迁系统 不等于 自动机"></a>变迁系统 不等于 自动机</h5><ul><li>转换没有标签：Pas d’étiquette sur les transitions (ou comme si)</li><li>转换不是由环境引起的：Une transition n’est pas causée par l’environnement</li><li>没有终结状态：Pas d’états terminaux</li><li>可能有许多的有限状态：Nombre d’états infini possible</li><li>可能有无限的执行：Exécution infinie possible</li></ul><h4 id="表示形式"><a href="#表示形式" class="headerlink" title="表示形式"></a>表示形式</h4><h5 id="显式的表示"><a href="#显式的表示" class="headerlink" title="显式的表示"></a>显式的表示</h5><p>在执行图(Graphe d’exécution) 中显式地给出，例如以图像形式或通过顶点和边的集合。仅适用于<strong>状态和转换数量有限</strong>的变迁系统。</p><h5 id="隐式的表示"><a href="#隐式的表示" class="headerlink" title="隐式的表示"></a>隐式的表示</h5><p>基于变量的变迁系统的三元组$ ⟨V, Init,Trans⟩ $ 中，</p><ul><li>$V = \{ v_1, …, v_n\}$：有限的的变量集；</li><li>$Init(v_1, …, v_n)$ ：定义初始状态并与变量 $v_i$ 相关的谓词（系数）</li><li>$Trans(v_1, …, v_n, {v_1}’, …, {v_n}’)$：谓词定义转换，涉及表示当前状态的变量 $v_i$ 和表示后续状态的变量 ${v_i}’$。</li></ul><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><h6 id="有界计数器"><a href="#有界计数器" class="headerlink" title="有界计数器"></a>有界计数器</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; N) &#123;</span><br><span class="line">i = i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在显式的表示中，$N = 5$:</li></ol><script type="math/tex; mode=display">⟨(0, 1, 2, 3, 4, 5), \{ 0\}, \{ (0,1), (1,2), (2,3), (3,4), (4,5)\}⟩</script><p>​    执行图(Graphe d’exécution)为</p><script type="math/tex; mode=display">0 \to 1 \to 2 \to 3 \to 4 \to5</script><ol><li>隐式的表示为：</li></ol><ul><li>$V \triangleq i \in \mathbb{N}$</li><li>$Init \triangleq i = 0$</li><li>$Trans \triangleq i &lt; N \land i’ = i+1$ 或 $Trans \triangleq i’ \leq N \land i’-i=1$ </li></ul><h6 id="循环计数器"><a href="#循环计数器" class="headerlink" title="循环计数器"></a>循环计数器</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">i = (i+<span class="number">1</span>) % N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在显式的表示中，$N = 4$:</li></ol><script type="math/tex; mode=display">⟨(0, 1, 2, 3, 4), \{ 0\}, \{ (0,1), (1,2), (2,3), (3,4), (4,0)\}⟩</script><p>​    执行图(Graphe d’exécution)为</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29 16.53.51-8565663.png" alt="2022-03-29 16.53.51" style="zoom:40%;"></p><ol><li>隐式的表示为：</li></ol><ul><li>$V \triangleq i \in \mathbb{N}$</li><li>$Init \triangleq i = 0$</li><li>$Trans \triangleq i’ = (i+1) \mod N $ </li></ul><h6 id="振荡整数"><a href="#振荡整数" class="headerlink" title="振荡整数"></a>振荡整数</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">i &gt; <span class="number">0</span> -&gt; i = i - <span class="number">1</span>;</span><br><span class="line">or</span><br><span class="line">  i &lt; N -&gt; i = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li>在显式的表示中，$N = 5$:</li></ol><script type="math/tex; mode=display">⟨(0, 1, 2, 3, 4, 5), \{ 0\}, \{ (0,1), (1,2), (2,3), (3,4), (4,5), (5,4), (4,3), (3,2), (2,1)\}⟩</script><p>​    执行图(Graphe d’exécution)为</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29 17.02.57.png" alt="2022-03-29 17.02.57" style="zoom:40%;"></p><ol><li>隐式的表示为：</li></ol><ul><li>$V \triangleq i \in \mathbb{N}$</li><li>$Init \triangleq i = 0$</li><li>$Trans \triangleq (i &gt; 0 \land i’=i-1) \lor (i &lt; N \land i’=i+1) $ 或 $Trans \triangleq \left| i’ -i \right| = 1 \land 0 \leq i’ \leq N$</li></ul><h5 id="表示形式所对应的变迁系统"><a href="#表示形式所对应的变迁系统" class="headerlink" title="表示形式所对应的变迁系统"></a>表示形式所对应的变迁系统</h5><p>对于符号描述$⟨V, Init,Trans⟩$，对应的变迁系统是$⟨S, I, R⟩$，其中：</p><ul><li>$S = \prod_{i \in 1..n} D_i$ ，其中$D_1,…,D_n$ 是变量 $v_1, …, v_n$ 的域（类型）</li><li>$I = \{ (v_1,…,v_n) | Init(v_1, …, v_n)\}$</li><li>$R = \{ ((v_1, …, v_n),({v_1}’, …, {v_n}’)) | Trans(v_1, …, v_n,{v_1}’, …, {v_n}’)\}$</li></ul><h5 id="状态谓词（Predicat-d’etat）"><a href="#状态谓词（Predicat-d’etat）" class="headerlink" title="状态谓词（Prédicat d’état）"></a>状态谓词（Prédicat d’état）</h5><p>状态谓词是与隐式表示的系统的（状态）变量有关的谓词。</p><p>状态谓词可以看作是 S 的一部分的特征函数。</p><h5 id="转换谓词（Predicat-de-transition）"><a href="#转换谓词（Predicat-de-transition）" class="headerlink" title="转换谓词（Prédicat de transition）"></a>转换谓词（Prédicat de transition）</h5><p>转换谓词是与已启动和未启动（状态）变量相关的谓词。</p><p>转换谓词可以看作是 $S × S$ 子集的特征函数。</p><h5 id="实例：谓词"><a href="#实例：谓词" class="headerlink" title="实例：谓词"></a>实例：谓词</h5><p>$V \triangleq n \in \mathbb{N} $ </p><p>$Init \triangleq -5 \leq n \leq 5$</p><p>$Trans \triangleq n \neq 1 \land ((n’ = n/2 \land n \equiv 0[2]) \lor (n’ = (3n+1)/2 \land n \equiv 1[2]))$</p><ul><li><p>Prédicat d’état : $ Init, n &lt; 20 $</p></li><li><p>Prédicat de transition : $Trans, n’ − n &gt; 3$</p></li></ul><h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><h5 id="阻塞（Blocage）"><a href="#阻塞（Blocage）" class="headerlink" title="阻塞（Blocage）"></a>阻塞（Blocage）</h5><h6 id="死锁（Interblocage）"><a href="#死锁（Interblocage）" class="headerlink" title="死锁（Interblocage）"></a>死锁（Interblocage）</h6><p>一个系统有一个死锁  $\triangleq$  存在一个可访问的状态，没有关系 R 的后继。等效地，如果执行（execution）有限，系统就会出现死锁。</p><p>对于建模经典顺序程序的系统，死锁相当于终止。</p><h5 id="可复位（Reinitialisable）"><a href="#可复位（Reinitialisable）" class="headerlink" title="可复位（Réinitialisable）"></a>可复位（Réinitialisable）</h5><p>一个系统可以从任何可访问的状态重置  $\triangleq$  有一个有限轨迹导致一个初始状态。</p><p>这个属性意味着在任何时候，都有一系列的转换（transitions）返回到系统的初始状态，从而重新启动。 这样的系统只有无限的执行。</p><h5 id="重复（Begaiement）"><a href="#重复（Begaiement）" class="headerlink" title="重复（Bégaiement）"></a>重复（Bégaiement）</h5><p>重复状态  $\triangleq$  状态有一个循环：$(s,s) ∈ R$。</p><p>一个重复变迁系统  $\triangleq$  任何状态都有一个到自身的循环：$Id ⊆ R$。</p><p><strong>用处</strong></p><ol><li>我们可以在 $s_0$ 中停留任意时间后进入 $s_1$。</li></ol><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29 17.55.30.png" alt="2022-03-29 17.55.30" style="zoom:50%;"></p><ol><li>无限的执行：在无重复系统中，任何没有后继者的状态都有一个独特的后继者：它自己。</li><li>终止状态时（或死锁）$… \to s_i$  就相当于  $… \to {s_i}^w$</li><li>可以组成几个变迁系统。</li></ol><h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><h5 id="自由组合"><a href="#自由组合" class="headerlink" title="自由组合"></a>自由组合</h5><p>变迁系统 $⟨V,I,T⟩$  由带有重复的 $⟨V_1, I_1,T_1⟩$ 和 $⟨V_2, I_2, T_2⟩ $ 组成， 其中：</p><ul><li>$V \triangleq V_1 \cup V_2$ ：变量$V_1$和$V_2$的并集</li><li>$I \triangleq I_1 \land I_2$ ：每个子系统都从它的一个初始状态开始</li><li>$ T \triangleq T_1 ∧ T_2 $ ：每个子系统都根据其转换（transition）演变</li></ul><p>由于 $T_1$ 和 $T_2$ 中有循环的状态，因此 $T_1 ∧ T_2$ 意味着我们可以单独执行 $T_1$ 的转换和 $T_2$ 的循环，反之亦然，甚至可以与 $T_2$ 同时执行 $T_1$。</p><p>例：</p><script type="math/tex; mode=display">\left(    \begin{matrix}        V_1 \triangleq i \in \mathbb{N}\\        I_1 \triangleq i = 0 \\        T_1 \triangleq            \begin{cases}                i'=i+1\\        \lor \ i'=i\\            \end{cases}\\    \end{matrix}\right)\otimes\left(    \begin{matrix}        V_2 \triangleq j \in \mathbb{N}\\        I_2 \triangleq j = 0 \\        T_2 \triangleq            \begin{cases}                j'=j+1\\        \lor \ j'=j\\            \end{cases}\\    \end{matrix} \right)\to\left(    \begin{matrix}        V \triangleq i,j \in \mathbb{N}\\        I \triangleq i=0 \land j=0\\        T \triangleq            \begin{cases}                i'=i+1 \land j' = j\\        \lor \ (i'=i \land j'=j+1)\\        \lor \ (i'=i+1 \land j'=j+1)\\        \lor \ (i'=i \land j'=j)            \end{cases}\\    \end{matrix}\right)</script><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30 20.56.29.png" alt="2022-03-30 20.56.29" style="zoom:40%;"></p><h5 id="严格同步的组合"><a href="#严格同步的组合" class="headerlink" title="严格同步的组合"></a>严格同步的组合</h5><p>变迁系统 $⟨S,I,R,L⟩$  由标记为 $⟨S_1,I_1,R_1,L_1⟩$ 和  $⟨S_2,I_2,R_2,L_2⟩$ 严格同步地组成， 其中：</p><ul><li>$S \triangleq S_1 \times S_2$ ：状态对</li><li>$I \triangleq I_1 \times I_2$ ：每个子系统都从它的一个初始状态开始</li><li>$R \triangleq \{ ((s_1, s_2), ({s_1}’, {s_2}’)) | (s_1, {s_1}’) \in R_1 \land (s_2, {s_2}’) \in R_2 \land Etiq((s_1, {s_1}’)) = Etiq((s_2, {s_2}’)) \}$ ：这两个子系统严格根据带有相同标签转换</li><li>$ L \triangleq L_1 \cap L_2 $ </li></ul><p>例：</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30 21.14.36.png" alt="2022-03-30 21.14.36" style="zoom:45%;"></p><ol><li>Synchronizé strict avec LIFO 2 éléments (pile)</li></ol><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30 21.16.51.png" alt="2022-03-30 21.16.51" style="zoom:45%;"></p><p>​    Donne：</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30 21.18.02.png" alt="2022-03-30 21.18.02" style="zoom:40%;"></p><ol><li>Synchronizé strict avec FIFO 2 éléments (file)</li></ol><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30 21.22.31.png" alt="2022-03-30 21.22.31" style="zoom:45%;"></p><p>​    Donne:</p><p>​    <img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30 21.23.35.png" alt="2022-03-30 21.23.35" style="zoom:40%;"></p><h5 id="Synchronise-ouvert-的组合"><a href="#Synchronise-ouvert-的组合" class="headerlink" title="Synchronisé ouvert 的组合"></a>Synchronisé ouvert 的组合</h5><p>变迁系统 $⟨S,I,R,L⟩$  由标记为 $⟨S_1,I_1,R_1,L_1⟩$ 和  $⟨S_2,I_2,R_2,L_2⟩$ 同步地组成， 其中：</p><ul><li><p>$S \triangleq S_1 \times S_2$ ：状态对</p></li><li><p>$I \triangleq I_1 \times I_2$ ：每个子系统都从它的一个初始状态开始</p></li><li><script type="math/tex; mode=display">R \triangleq \begin{cases}    ((s_1, s_2), ({s_1}', {s_2}')) | (s_1, {s_1}') \in R_1 \land (s_2, {s_2}') \in R_2 \land Etiq((s_1, {s_1}')) = Etiq((s_2, {s_2}'))\\    ((s_1, s_2), ({s_1}', {s_2})) | (s_1, {s_1}') \in R_1 \land Etiq((s_1, {s_1}')) \notin L_2\\    ((s_1, s_2), ({s_1}, {s_2}')) | (s_2, {s_2}') \in R_2 \land Etiq((s_2, {s_2}')) \notin L_1\end{cases}</script></li><li><p>$ L \triangleq L_1 \cap L_2 $ </p></li></ul><p>例：</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30 21.42.35.png" alt="2022-03-30 21.42.35" style="zoom:50%;"></p><p>Synchronizé strict avec LIFO 2 éléments (pile)</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30 21.16.51-8669562.png" alt="2022-03-30 21.16.51" style="zoom:45%;"></p><p>Donne：</p><ul><li>strict：</li></ul><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30 21.42.56.png" alt="2022-03-30 21.42.56" style="zoom:50%;"></p><ul><li><p>ouvert</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30 21.43.21.png" alt="2022-03-30 21.43.21" style="zoom:45%;"></p></li></ul><h3 id="第二部分：Action"><a href="#第二部分：Action" class="headerlink" title="第二部分：Action"></a>第二部分：Action</h3><p>在《概述》中，我们提到<strong>T</strong>emporal <strong>L</strong>ogic of <strong>A</strong>ctions <strong>+</strong>是由<em>Leslie Lamport</em>开发的一种<strong>【形式化验证语言】</strong>。</p><p>本章我们会简单介绍这种语言。</p><h4 id="规约-Specification"><a href="#规约-Specification" class="headerlink" title="规约 Specification"></a>规约 Specification</h4><h5 id="规约的结构"><a href="#规约的结构" class="headerlink" title="规约的结构"></a>规约的结构</h5><p>一个TLA+的Model里应该包含的元素有：</p><ul><li>常数 Constant</li><li>变量 Variable（状态 = 变量的值）</li><li>Init. State 由状态谓词定义的一组初始状态 </li><li>动作 Action = 连接两个状态的转换谓词：<ol><li>当前状态，未启动的变量</li><li>到达状态，主要变量</li></ol></li><li>由动作的析取构造的过渡谓词（≈无限重复动作）</li></ul><p>例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">---------------- MODULE example ----------------</span><br><span class="line">EXTENDS Naturals</span><br><span class="line">VARIABLE x</span><br><span class="line"></span><br><span class="line">\* 初始状态 Init是初始化谓词（initial predicate）</span><br><span class="line">Init == x \in 0..2\* 等价于x属于自然数 并且 0 &lt;= x &lt; 3</span><br><span class="line"></span><br><span class="line">\* 动作</span><br><span class="line">Plus == x&#x27;=x+1</span><br><span class="line">Sub == x&gt;0 /\ x&#x27;=x-1</span><br><span class="line">Next == Plus \/ Sub\* Next是Next-state动作（action）</span><br><span class="line">Spec == Init /\ [] [ Next ]_&lt;&lt;x&gt;&gt;</span><br></pre></td></tr></table></figure><p>上述规约语言等价于下述变迁系统</p><ul><li>$V \triangleq x \in \mathbb{N}$</li><li>$I \triangleq 0 \le x \le 2$</li><li>$R \triangleq \begin{cases} x’ = x+1\\ \lor x&gt;0 \land x’=x-1\\ \lor x’=x \end{cases}$</li></ul><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30 23.53.48.png" alt="2022-03-30 23.53.48" style="zoom:40%;"></p><h5 id="常量-Constantes"><a href="#常量-Constantes" class="headerlink" title="常量 Constantes"></a>常量 Constantes</h5><ul><li>显式常量：0、1、true、false、“string”</li><li>命名常量：$_{CONSTANT} \ N$，通常伴随着属性：$_{ASSUME}\ N \in Nat \land N \ge 2$</li></ul><h5 id="表达式-Expression"><a href="#表达式-Expression" class="headerlink" title="表达式 Expression"></a>表达式 Expression</h5><p>一切可以公理化的东西：</p><ul><li>逻辑表达式：$¬， ∧， ∨， ∀x ∈ S:p(x)， ∃x ∈ S:p(x)$</li><li>算术表达式：$+，-，&gt;，…$</li><li>集合表达式： $∈$，$∪$，$∩$，$⊂$，$\{e1, e2, . . . , en\}$，$n..m$，$\{x ∈ S : p(x)\}$，$\{f (x) : x ∈ S\}$，$_{UNION}\  S$，$_{SUBSET} \ S$</li><li>$_{IF}$ … $_{THEN}$ … $_{ELSE}$ …</li><li>从 X 到 Y 的函数</li><li>元组、序列等</li></ul><h5 id="集合运算符-Operateurs-ensemblistes"><a href="#集合运算符-Operateurs-ensemblistes" class="headerlink" title="集合运算符 Operateurs ensemblistes"></a>集合运算符 Operateurs ensemblistes</h5><ul><li>$\{e_1, …,e_n\}$ ： 扩展成集合</li><li>$n ..m$ ： $i \in Nat : n \le i \le m$</li><li>$\{ x \in S : p(x)\}$ ：S 中满足性质 p 的元素集合<ul><li>例1，$\{ n \in 1..10 : n\%2=0\} = \{2,4,6,8,10\} $ </li><li>例2，$\{ n \in Nat : n\%2=1\} = \{所有的奇数\} $ </li></ul></li><li>$\{ f(x) :x \in S\} $ ：所有$f(x)$ 的值的集合<ul><li>例1，$\{ 2*n: n \in 1..5\} = \{2,4,6,8,10\} $ </li><li>例2，$\{2*n+1 : n \in Nat\} = \{所有的奇数\} $ </li></ul></li><li>$_{UNION}\ S$ ：S 的元素的并集<ul><li>$_{UNION} \{ \{ 1,2\},  \{ 3,4\}\} =  \{ 1,2,3,4\}$</li></ul></li><li>$_{SUBSET}\ S$：S的所有子集的集合<ul><li>$_{SUBSET} \{ 1,2\} = \{ \{\}, \{1\}, \{ 2\}, \{ 1,2\}\}$</li></ul></li></ul><h4 id="动作-Action"><a href="#动作-Action" class="headerlink" title="动作 Action"></a>动作 Action</h4><h5 id="操作符-Action-Operators"><a href="#操作符-Action-Operators" class="headerlink" title="操作符 Action Operators"></a>操作符 Action Operators</h5><ul><li>$e’$ :  The value of e in the final state of a step (迭代器中e的更新值)</li><li>$[A]_e$ : $[A ∨ (e’ = e)]$ </li><li>$⟨A⟩_e$ : $[A ∧ (e’ \ne e)]$</li><li>$_{ENABLE} \ A$ : [An A step is possible]</li><li>$_{UNCHANGED}\ E$ : $[e’ = e]$</li><li>$A · B$ : [Composition of actions]</li></ul><p>动作 = 转换谓词 = 包含常量、变量和引发变量的布尔表达式。</p><p>动作 不等于 任务</p><ul><li><p>$\begin{aligned} &amp; x’=x+1\\   &amp; \equiv x’-x=1\\   &amp; \equiv x=x’-1\\  &amp; \equiv (x&gt;1 \land x’/x=1 \land x’\%x=1) \lor (1=x \land 2=x’) \lor (x=0 \land x’ \in \{y \in Nat:y+1=2*y\})\\ \end{aligned}$</p></li><li><p>Other types of actions:</p><ul><li>$x’ &gt; x$ 或 $x’ ∈ \{x + 1, x + 2, x + 3\}$（不确定性）</li><li>$x’ ∈ \{y ∈ \mathbb{N}: ∃z ∈ N: z ∗ y = x ∧ z \% 2 = 0\}$（不可评估）</li><li>$x’ = y ∧ y’ = x$（多个变量）</li></ul></li></ul><h5 id="由连词组成的动作"><a href="#由连词组成的动作" class="headerlink" title="由连词组成的动作"></a>由连词组成的动作</h5><ol><li>仅与起始状态有关的状态谓词</li><li>确定性转移谓词 $var’ = . . .$ 或 非确定性转移谓词 $var’ ∈ …$</li></ol><p>例：$x &lt; 10 ∧ x’ = x + 1$，而不是 $x′ = x + 1 ∧ x’ &lt; 11$ 或 $x′ - x = 1 ∧ x’ &lt; 11$</p><h5 id="重复（Begaiement）-1"><a href="#重复（Begaiement）-1" class="headerlink" title="重复（Bégaiement）"></a>重复（Bégaiement）</h5><h6 id="Begaiement"><a href="#Begaiement" class="headerlink" title="Bégaiement"></a>Bégaiement</h6><p>$[\mathcal{A}]_f \triangleq \mathcal{A} ∨ f’ = f$ ，其中 $f$ 是变量元组。</p><p>示例：</p><p>$\begin{aligned} {[x’=x+1]_{⟨x,y⟩}} &amp; = {(x’=x+1 ∨ (⟨x, y⟩’=⟨x,y⟩))} \\     &amp; = {(x’= x+1 ∨ (x’=x ∧ y’=y))} \\ \end{aligned}$</p><h6 id="Non-Begaiement"><a href="#Non-Begaiement" class="headerlink" title="Non Bégaiement"></a>Non Bégaiement</h6><p>$[\mathcal{A}]_f \triangleq \mathcal{A} ∨ f’ \ne f$ ，其中 $f$ 是变量元组。</p><h6 id="无约束变量-Variables-non-contraintes"><a href="#无约束变量-Variables-non-contraintes" class="headerlink" title="无约束变量 Variables non contraintes"></a>无约束变量 Variables non contraintes</h6><p>$\begin{aligned} {(x′=x+1)} &amp; = {(x’=x+1 \land y’= 任何值 )} \\     &amp; \ne {(x’=x+1 \land y’=y)} \\ \end{aligned}$</p><h6 id="UNCHANGED"><a href="#UNCHANGED" class="headerlink" title="UNCHANGED"></a>UNCHANGED</h6><p>$_{UNCHANGED}\ e \triangleq e’ = e$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">---------------- MODULE AlternatingBit ----------------</span><br><span class="line">EXTENDS Naturals</span><br><span class="line">CONSTANT Data</span><br><span class="line">VARIABLE val, ready, ack</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">\* 初始状态 Init是初始化谓词（initial predicate）</span><br><span class="line">Init == /\ val \in Data</span><br><span class="line">/\ ready \in &#123;0,1&#125;</span><br><span class="line">/\ ack = ready</span><br><span class="line"></span><br><span class="line">Send == /\ ready = ack</span><br><span class="line">/\ val&#x27; \in Data</span><br><span class="line">/\ ready&#x27; = 1 - ready</span><br><span class="line">/\ UNCHANGED ack</span><br><span class="line"></span><br><span class="line">Receive == /\ ready # ac k</span><br><span class="line">/\ ack&#x27; = 1 - ack</span><br><span class="line">/\ UNCHANGED &lt;&lt;val, ready&gt;&gt;</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">Next == Send \/ Receive\* Next是Next-state动作（action）</span><br><span class="line">Spec == Init /\ [] [ Next ]_&lt;&lt;val, ready, ack&gt;&gt;</span><br><span class="line">=========================================================</span><br></pre></td></tr></table></figure><h4 id="函数-Function"><a href="#函数-Function" class="headerlink" title="函数 Function"></a>函数 Function</h4><p>“映射(mapping) ”意义上的函数，对应：</p><ul><li>$X \to Y$ : 从 X 到 Y 的一组函数。</li><li>$f \in [X \to Y]$ : X 在 Y 中的 f 函数</li><li>$f[x]$ : x 处的 f 值。</li></ul><p>一个函数就是一个值。<br>一个包含函数的变量可以改变它的值⇒“函数改变”。</p><h5 id="符号的定义-Definition-of-symbol"><a href="#符号的定义-Definition-of-symbol" class="headerlink" title="符号的定义 Definition of symbol"></a>符号的定义 Definition of symbol</h5><p>$f[x \in Nat]$ : 关于x的表达式。例 : $Inc[x \in Nat] \triangleq x+1$</p><h5 id="值的定义-Definition-of-value"><a href="#值的定义-Definition-of-value" class="headerlink" title="值的定义 Definition of value"></a>值的定义 Definition of value</h5><p>$[x \in S \mapsto expr]$. 例 : $x \in 1..4 \mapsto 2*x$</p><h5 id="表-Table"><a href="#表-Table" class="headerlink" title="表 Table"></a>表 Table</h5><p>函数 $t ∈ [X → Y ]$ 其中 X 是整数区间。</p><h5 id="定义域-Domain"><a href="#定义域-Domain" class="headerlink" title="定义域 Domain"></a>定义域 Domain</h5><p>$_{DOMAIN}\ f$ : f 的定义域</p><h5 id="值域-Codomaine"><a href="#值域-Codomaine" class="headerlink" title="值域 Codomaine"></a>值域 Codomaine</h5><p>$Codomain(f) \triangleq \{ f[x]:x \in _{DOMAIN}f\}$</p><h5 id="EXCEPT"><a href="#EXCEPT" class="headerlink" title="EXCEPT"></a>EXCEPT</h5><p>$[a \ _{EXCEPT}\ ![i] =v] \triangleq [j\in _{DOMAIN} \ a \mapsto _{IF}\ j=i\ _{THEN}\ v\ _{ELSE}\ a[j]]$</p><p>例：$[a’ = a \ _{EXCEPT}\ ![2] =8] \not\equiv (a[2]’ =8)$</p><h5 id="IncF"><a href="#IncF" class="headerlink" title="IncF"></a>IncF</h5><p>IncF 是数学意义上的函数定义，等价于 $IncF \triangleq [x ∈ Nat \mapsto x + 1]$</p><ul><li>它的定义域：$_{DOMAIN}\ IncF$</li><li>它的值域：$ \{IncF[x] : x ∈ _{DOMAIN}IncF\}$</li><li>$IncF \in [X \mapsto Y]$</li></ul><h5 id="IncO"><a href="#IncO" class="headerlink" title="IncO"></a>IncO</h5><p>IncO 是运算符(Operator) 的定义</p><ul><li>写因式分解：类似于一个宏，其文本可以替换</li><li>没有定义域 和 值域</li><li>$IncO ∈ [X → Y ]$ 没有意义</li></ul><h5 id="记录-Record"><a href="#记录-Record" class="headerlink" title="记录 Record"></a>记录 Record</h5><p>记录是 $[X → Y]$ 的函数，其中 X 是一组字符串。</p><p>简写作：<br>$[“qwerty” \mapsto 1, “asdfgh” \mapsto 2] = [qwerty \mapsto 1,asdfgh \mapsto 2]$$</p><p>$rec[“qwerty”] = rec.qwerty$</p><h5 id="递归定义-Definition-recursive"><a href="#递归定义-Definition-recursive" class="headerlink" title="递归定义 Définition récursive"></a>递归定义 Définition récursive</h5><p>定义（函数或运算符）时，可以给出递归定义：</p><ul><li>函数：$fact[n \in Nat] \triangleq _{IF}\ n=0\ _{THEN}\ 1\ _{ELSE}\ n*fact(n-1)$</li><li>运算符：$fact(n) \triangleq _{IF}\ n=0\ _{THEN}\ 1\ _{ELSE}\ n*fact(n-1)$</li></ul><p>从理论上讲，必须证明这些定义的有效性。</p><h5 id="n元组-n-Tuple"><a href="#n元组-n-Tuple" class="headerlink" title="n元组 n-Tuple"></a>n元组 n-Tuple</h5><p>符号：⟨a, b, c⟩。</p><ul><li>n元组是定义域函数= $\{1,. . .,n\} :⟨a, b, c⟩[3] = c$</li><li>用于表示关系：$\{⟨x, y⟩ ∈ X × Y: R(x, y)\}$。示例：$\{⟨a, b⟩ ∈ Nat × Nat:a=2*b\}$。</li></ul><h5 id="序列-Sequence"><a href="#序列-Sequence" class="headerlink" title="序列 Sequence"></a>序列 Sequence</h5><p>$\begin{aligned} Seq(T) &amp; \triangleq _{UNION} \{[1..n → T]: n ∈ Nat\}\\ &amp; \triangleq 包含 T 的有限序列集 \end{aligned}$</p><p>运算符：$Len(s)$，$s ◦ t$（连接），$Append(s,e)$，$Head(s)$，$Tail(s)$。</p><h5 id="局部定义-Local-Definition"><a href="#局部定义-Local-Definition" class="headerlink" title="局部定义 Local Definition"></a>局部定义 Local Definition</h5><p>$LET$</p><ul><li><p>表达式： $_{LET}\ v \triangleq e\ _{IN}\ f$</p><p>等效于表达式 $f$，其中所有的符号 $v$ 的都被 $e$ 替换。例子：$_{LET}\ i \triangleq g(x)\ _{IN}\ f (i)≡ f (g(x))$</p></li></ul><p>例：</p><p>$Pythagore(x, y, z) \triangleq _{LET}\ square(n) \triangleq n∗n\ _{IN}\ square(x) + square(y) = square(z)$</p><h5 id="选择-CHOOSE"><a href="#选择-CHOOSE" class="headerlink" title="选择 CHOOSE"></a>选择 CHOOSE</h5><ul><li><p>$_{CHOOSE}\ x \in S:p$ ：确定性任意选择集合 S 中满足谓词 p 的元素。</p></li><li><p>$max[S \in _{SUBSET}\ Nat] \triangleq\ _{CHOOSE}\ m \in S:(\forall p \in S : m \ge p)$</p></li></ul><p>对于集合 S 和属性 p，选择的元素在所有执行过程中始终相同。 它不是一个随机选择器，它在每次调用时都给出一个不同的元素。所以$_{CHOOSE}\ x \in S:p = _{CHOOSE}\ x \in S:p$。</p><p><strong>规约</strong></p><ul><li><p>$(x =\ _{CHOOSE}\ n : n ∈ Nat) ∧ \Box [x’=_{CHOOSE}\ n : n ∈ Nat]_{⟨x⟩}$</p><p>有一个独特的执行：$ x = c → x = c → …$其中 c 是一个不确定的整数（由选择指定）。</p></li><li><p>$(x ∈ Nat) ∧ \Box [x’ ∈ Nat]_{⟨x⟩}$</p><p>有无限次执行，其中一些在每个状态中 x 是不同的，另一些在 x 是恒定的，另一些在 x 中循环</p></li></ul><h3 id="第三部分：线性时间属性-LT-Properties"><a href="#第三部分：线性时间属性-LT-Properties" class="headerlink" title="第三部分：线性时间属性(LT Properties)"></a>第三部分：线性时间属性(LT Properties)</h3><h4 id="刻画线性时间属性-LT-Properties"><a href="#刻画线性时间属性-LT-Properties" class="headerlink" title="刻画线性时间属性(LT Properties)"></a>刻画线性时间属性(LT Properties)</h4><p>因为线性时间属性（LT Properties）是TS中迹的要求，所以在原子命题（AP）上的线性时间属性是$S^{w}$<br>的子集。$S^{w}$表示的是AP中命题的无限级联的集合</p><p>如果AP={a,b}，那么$(2^{AP})^{w}$ 可以表示为</p><script type="math/tex; mode=display">\{\{a\}\{a,b\}\varnothing ...，\{b\}\{a\}\varnothing\varnothing...，...\}</script><p>类似该集合中的元素，由无限个字符级联在一起组成的序列称为无限字(infinite word)，无限字可以表示为:</p><script type="math/tex; mode=display">W=A_{0}A_{1}A_{2}...</script><p>当这个序列是有限时，便称为有限字(finite word)，有限字可以表示为:</p><script type="math/tex; mode=display">W=A_{0}A_{1}A_{2}...A_{n}</script><p>因为TS不考虑终止状态，所以也就无需使用有限字。</p><p>如果一个TS满足线性时间属性P，那么就表明：</p><script type="math/tex; mode=display">TS \vDash P\text{ 当且仅当}Traces(TS) ⊆ P</script><blockquote><p>我个人的理解是线性时间属性P刻画了AP上能够出现的原子命题序列，而迹表示的是系统在AP上出现的原子命题序列，如果系统的迹是P的子集，那么肯定这个系统就满足了线性时间属性P。</p></blockquote><h6 id="刻画基于信号量互斥系统的属性"><a href="#刻画基于信号量互斥系统的属性" class="headerlink" title="刻画基于信号量互斥系统的属性"></a>刻画基于信号量互斥系统的属性</h6><p>一说到信号量和互斥，再次搬出这个例子：</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/20201118212040185.png" alt="20201118212040185" style="zoom:50%;"></p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/20201118212152854.png" alt="20201118212152854" style="zoom:60%;"></p><p>在这里，$AP=\{crit_1, crit_2\}$，这个系统中的约束有一条：</p><blockquote><p>“Always at most one process is in its critical section”</p><p>就是最多有一个进程能够进入临界区</p></blockquote><p>用形式化的语言描述就是：</p><script type="math/tex; mode=display">P_{mutex} = 一个无限字的集合\{A0A1A2...\} 且满足对于所有0\le i,\{crit_1, crit_2\} \nsubseteq A_{i}</script><p>这就完成对系统属性的刻画，描述一下就是对于这个TS的运行轨迹来说不存在$\{crit_1, crit2\}$满足条件的情况。</p><p>所以无限字可以是类似$\{crit_1\}\{crit_2\}\{crit_1\}\{crit_2\}…$或者$\varnothing\varnothing\varnothing\varnothing\varnothing…$反正就是不能出现$\{crit_1, crit2\}$这个元素。</p><p>那么再问一个问题，上面的那个TS系统满足这个$P_{mutex}$ 性质嘛？</p><ul><li>Yes，因为从图上看不存在$\{crit_1, crit2\}$以满足了我们定义的互斥性性质。</li></ul><h6 id="刻画无饥饿-starvation-freedom-系统的属性"><a href="#刻画无饥饿-starvation-freedom-系统的属性" class="headerlink" title="刻画无饥饿(starvation freedom)系统的属性"></a>刻画无饥饿(starvation freedom)系统的属性</h6><p>不存在饥饿的系统要求满足条件:</p><blockquote><p>“A process that wants to enter the critical section is eventually able to do so”</p><p>如果一个进程想要进入临界区，那么它最终总是能够进入临界区。</p></blockquote><p>这一次让$AP=\{crit_1,wait_1,crit_2,wait_2\}$</p><p>用形式化的语言描述为LT性质就是：</p><script type="math/tex; mode=display">P_{nostarve} = 一个无限字的集合\{A_0A_1A_2...\} \\ 满足(\overset{\infty}∃ j.\;wait_{i}∈A_{j})\Rightarrow (\overset{\infty}∃ j.\;crit_{i}∈A_{j})\; for\;each\;i∈\{1,2\}</script><p>其中 $\overset{\infty}∃$ 代表无限多</p><p>描述一下就是当一个进程进入等待状态后，之后肯定会进入临界区</p><p>那么基于信号量的互斥系统满足无饥饿性质嘛？no，如果是这样一条迹:$\varnothing\{wait_2\}\{wait_1,wait_2\}\{crit_1,wait_2\}\{wait_2\}\{wait_1,wait_2\}\{crit_1,wait_2\}…$，那么进程2将永远的不能进入临界区。</p><h5 id="不变性-Invariants"><a href="#不变性-Invariants" class="headerlink" title="不变性(Invariants)"></a>不变性(Invariants)</h5><p>事实上，上述（互斥与无死锁）安全性是一种特殊的性质：不变性。不变性是LT属性，由状态的条件$Φ$给出，并且要求$Φ$对所有可达到的状态保持不变。不变性是安全性的一种，也就是安全性的子集。</p><p>如果在AP上的线性属性$P_{inv}$是不变性，那么它具有如下形式：</p><script type="math/tex; mode=display">P_{inv}=\{A_{0}A_{1}A_{2}... ∈ (2^{AP})^{w} | ∀j \ge 0. A_{j} \vDash Φ \}</script><p>其中$Φ$AP上的逻辑命题公式，$Φ$ 被称为$P_{inv}$ 的不变条件。</p><p>让我们回想一下先前的基于信号量的互斥系统，在那个系统中$Φ=\lnot crit1\vee \lnot crit2$, 保证crit1和crit2不能同时为真。</p><p>设TS是一个没有终止状态的转换系统，那么有：</p><ul><li>$TS\vDash P_{inv}$<ul><li>$iff\; trace(\pi)∈ P_{inv}\; for\; all\; paths\;\pi \; in\; TS$</li><li>$iff\; L(s)\vDash Φ\; for\; all\; states\;s\;that\;belong\; to\; a\;path\; of\;TS$</li><li>$iff\; L(s)\vDash Φ\; for\; all\; states\;s∈Reach(TS)$</li></ul></li></ul><p>注意上面的最后一个式子，我们将TS能否满足不变性，转换成为了所有可达状态是否满足不变性这一问题。基于此我们可以设计检验不变性的算法。</p><h6 id="我们该如何检验一个系统是否满足了不变性呢？"><a href="#我们该如何检验一个系统是否满足了不变性呢？" class="headerlink" title="我们该如何检验一个系统是否满足了不变性呢？"></a>我们该如何检验一个系统是否满足了不变性呢？</h6><p>我们只要遍历系统的每个状态，从初始状态开始，利用深度优先(Dfs)或者广度优先(Bfs)算法，检查每一个可达状态是否满足$Φ$，只要找到一个可达状态不满足$Φ$，那么系统就不满足不变性，如果我们遍历所有状态发现均满足$Φ$，那么系统就满足不变性。</p><h5 id="安全性-safety"><a href="#安全性-safety" class="headerlink" title="安全性(safety)"></a>安全性(safety)</h5><p>上面我们可以看到，不变性可以被视为状态属性，并且可以通过考虑可达状态来检查。但是安全性不能仅考虑可达状态来验证，而是需要对有限路径片段提出要求。</p><blockquote><p>个人理解，不变性的要求是满足所有可达状态满足要求，而安全性是要求所有的系统上出现的有限路径片段满足要求，从这个角度来看，不变性就是安全性的一种特例，如果安全性要求的有限路径片段的长度为1的话，那就变成了不变性要求。</p></blockquote><p>我们考虑一个自动取款机（ATM）的例子，ATM机的要求是，只有在提供了正确的个人识别码（PIN）后，才能从自动取款机中取款。这个属性不是不变量，因为它不是一个单纯的状态属性。但是，它是一种安全性，例如</p><script type="math/tex; mode=display">"提供正确的PIN","取款",...</script><p>这样的路径片段是满足安全性的，但如果出现</p><script type="math/tex; mode=display">"提供错误的PIN","取款"...</script><p>这样的路径片段是是不满足安全性的，我们可以看到，一旦出现了这样”坏(bad)”的片段，不管后面如何都是不满足安全性的，我们引入前缀、坏前缀等概念来帮助我们定义安全性。</p><p>安全性通常被描述为“<strong>不会发生不好的事情</strong>”(nothing bad should happen)</p><h6 id="安全性的例子"><a href="#安全性的例子" class="headerlink" title="安全性的例子"></a>安全性的例子</h6><ul><li><strong>互斥性</strong>是一种典型的安全性，它要求在临界区最终只有一个进程存在，bad thing指的是在临界区存在两个或两个以上的进程，这种坏事要求永远不会发生</li><li><strong>无死锁性</strong>(deadlock freedom)是另一个典型的安全属性。在哲学家问题中，发生死锁的特征是所有哲学家都拿起了一把筷子，并且正在等待拿起第二把筷子，这种坏的（或unwanted，即不必要的）情况要求永远都不会发生。</li></ul><h6 id="安全性定义为"><a href="#安全性定义为" class="headerlink" title="安全性定义为"></a>安全性定义为</h6><script type="math/tex; mode=display">对于所有的\sigma∈(2^{AP})^w\setminus P_{safe}存在一个\sigma的有限前缀\hat{\sigma}满足 \\ P_{safe}\cap\{\sigma'∈(2^{AP})^w|\hat{\sigma}是\sigma'的有限前缀\}=\varnothing</script><p>解释一下，对于所有的无限字$\sigma=A_{0}A_{1}A_{2}…\in(2^{AP})^w\setminus P_{safe}$ ，存在$\sigma$的有限前缀 $\hat{\sigma}=A_{0}A_{1}…A_{n} $<br>，使得以 $\hat{\sigma}$ 有限前缀起始的字$A_{0}A_{1}…A_{n}B_{n+1}B_{n+2}…$ 不属于$P_{safe}$。</p><p>有限字 $\hat{\sigma}=A_{0}A_{1}…A_{n}$ 被称为$P_{safe}$ 的坏前缀(bad prefix)，符号表示为 $BadPref(P_{safe})$ 。</p><p>如果 $\hat{\sigma} $被称为 $P_{safe}$ 的最小坏前缀(minimal bad prefix)，那么就是说 $\hat{\sigma}$ 中没有比 $\hat{\sigma} $ 长度更小的坏前缀，符号表示为$MinBadPref(P_{safe})$。</p><p>对于一个TS系统满足安全性，那么当且仅当： </p><ul><li>$TS\models P_{safe}$</li><li>$iff\; trace(TS)\subseteq P_{safe}$</li><li>$iff\; trace_{fin}(TS) \cap BadPref=\varnothing$</li><li>$iff\; trace_{fin}(TS) \cap MinBadPref=\varnothing$</li></ul><p>以红绿灯系统为例，它拥有一个属性</p><blockquote><p>each red phase should be immediately preceded by a yellow phase<br>只有在黄灯亮了之后红灯才能亮</p></blockquote><p>AP定义为$\{red,yellow\}$，用形式化的符号表述为：</p><script type="math/tex; mode=display">一个无限字的集合\{A_{0}A_{1}A_{2}...\}\; 对于所有i>0满足red∈A_{i},yellow∈A_{i-1}</script><p>类似于$\varnothing\varnothing\{red\}$，$\varnothing\{red\}$ 都是最小坏前缀，因为 $\{red\}$之前没有出现 $\{yellow\}$</p><p>而类似于$\{yellow\}\{yellow\}\{red\}\{red\}\varnothing\{red\}$是坏前缀而不是最小坏前缀，因为存在比它更小的坏前缀 $\{yellow\}\{yellow\}\{red\}\{red\}$</p><h5 id="活性-liveness"><a href="#活性-liveness" class="headerlink" title="活性(liveness)"></a>活性(liveness)</h5><p>安全性规定“<strong>不好的事情永远不会发生</strong>”，一个算法可以很容易地实现一个安全性，只要检验一下看看会不会出现不好的情况。但是这很多时候是不需要的，有时候没有必要保证永远不会发生不好的事情，为此需要一些其他属性来补充。这样的属性称为”活性(liveness)”属性。可以说，活性表示“好事”将来会发生(something good will happen)</p><h6 id="活性的例子"><a href="#活性的例子" class="headerlink" title="活性的例子"></a>活性的例子</h6><ul><li>“每个进程最终都会进入临界区”</li><li>“每个哲学家将会无限经常次吃到饭”</li></ul><p>从上面的定义中我们就可以知道，对于活性的判断和安全性完全不同，因为<u>安全性只要有一个坏前缀就可以驳倒安全性，不论后面的序列如何</u>。而<u>活性需要考虑未来无限路径中需要满足的特性</u>。</p><p>如果 $P_{live}$ 是AP上上的活性，那么无论何时：p$ref(P_{live})=(2^{AP})^{*}$ 被称为活性，那么每个在AP上的有限字都能够扩展成为 $P_{live}$ 中的无限字</p><h5 id="活性-vs-安全性"><a href="#活性-vs-安全性" class="headerlink" title="活性 vs 安全性"></a>活性 vs 安全性</h5><ul><li><p>活性和安全性是不相交的嘛？</p><p>是的</p></li><li><p>所有线性时间属性都是活性或者安全性嘛？</p><p>不是</p></li><li><p>有哪些既不是安全性也不是活性的例子？</p><p>例如：“机器在提供三次雪碧之后，会无限次提供啤酒”</p><p>这个例子由两个部分组成，一个是“提供三次雪碧之后”，这是一个安全属性，我们给出一个坏前缀，提供一次雪碧后提供啤酒，另一部分是“无限次提供啤酒”，这是一个活性属性。所以这种包含了安全性和活性的特性，既不属于安全性也不属于活性。</p></li><li><p>是否所有的线性时间属性都可以表示为安全性和活性的交集？</p><p>是的</p><p>根据分解定理(Decomposition theorem)</p><p>对于任何AP上的线性时间属性P，存在安全性$P_{safe}$ 和活性 $P_{live}$ 使得</p><script type="math/tex; mode=display">P=P_{safe}\cap P_{live}</script></li></ul><ul><li><p>线性时间属性的分类（注：不变性是包含在安全性里面，中间那块黄色的区域既是安全性又是活性，代表的含义是True）</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/20201120223125939.png" alt="20201120223125939" style="zoom:60%;"></p></li></ul><h3 id="第四部分：Fairness"><a href="#第四部分：Fairness" class="headerlink" title="第四部分：Fairness"></a>第四部分：Fairness</h3><p>系统的一个重要方面是公平性，公平性排除了被认为是不现实(unrealistic)的无限行为，并且这一步通常是建立活性属性所必需的。</p><p>我们通过在并发系统中经常遇到的一个问题来说明公平的概念：</p><blockquote><p>现有一个并发系统N，有进程 $P_{1},P_{2}…P_{N}$，它们在有需要时就会请求服务，但是现在只有一个服务进程名叫Server会为这些进程提供服务，现在Server采用如下策略：</p><ol><li>从P1开始检查，如果P1请求了服务，那么就为P1提供服务;</li><li>如果P1没有请求，那么就检查下一个进程P2，直到检查完毕，然后从头开始检查……</li></ol><p>我们可以想见，如果P1一直请求服务，那么Server会为P1无限次提供服务，而剩下的进程都会陷入无限等待的过程，这对除P1外的进程来说是是不公平(unfair)的，这种行为就属于不现实的无限行为。</p></blockquote><p>为了获得由TS建模的并行系统的行为的真实描述，我们需要一种另一种形式的LT属性，来解决TS中不确定性决策的问题。</p><p>于是，为了排除上述不现实的行为，我们需要添加公平性约束(Fairness Constraints)，而公平的执行或者轨迹(execute or trace)就是满足了某些公平性约束。</p><h4 id="公平性约束-Contraintes-d’equite"><a href="#公平性约束-Contraintes-d’equite" class="headerlink" title="公平性约束 Contraintes d’équité"></a>公平性约束 Contraintes d’équité</h4><p>公平性约束指定在程序的任何执行中必须<strong>经常无限</strong>地访问（或执行）某些状态（某些转换）。</p><p>通常，公平性约束用于将程序或其环境约束为<strong><u>活性（liveness）</u></strong>，而不涉及有关这些约束的实际实现的细节。</p><p>公平约束通过消除不尊重公平约束的执行来减少合法执行的集合。</p><h5 id="循环状态集-（Ensemble-recurrent-d’etats）"><a href="#循环状态集-（Ensemble-recurrent-d’etats）" class="headerlink" title="循环状态集 （Ensemble recurrent d’etats）"></a>循环状态集 （Ensemble recurrent d’etats）</h5><p>令 $⟨S, I, R⟩$ 是一个变迁系统，且$\sigma = \langle s_0 \to … \rangle$是一段执行。状态集$P$在$\sigma$ 中是循环的，当</p><ul><li>情况1：$\sigma$是无限的：$\forall i \in \mathbb{N} : ∃ j \ge i : s_j \in P$ （$P在\sigma中出现无限次$）</li><li>情况2：$\sigma$是有限的：$\sigma$的最终状态在$P$里</li></ul><blockquote><p>$Inf_S(P,\sigma)$ ：$P$是在$\sigma$中的循环状态集</p></blockquote><h5 id="循环转换集（Ensemble-recurrent-de-transitions）"><a href="#循环转换集（Ensemble-recurrent-de-transitions）" class="headerlink" title="循环转换集（Ensemble recurrent de transitions）"></a>循环转换集（Ensemble recurrent de transitions）</h5><p>令 $⟨S, I, R⟩$ 是一个变迁系统，且$\sigma = \langle s_0 \to … \rangle$是一段执行。转换集$Q$在$\sigma$ 中是循环的，当</p><ul><li>情况1：$\sigma$是无限的：$\forall i \in \mathbb{N} : ∃ j \ge i : s_j \to s_{j+1} \in Q$ （$Q在\sigma中出现无限次$）</li><li>情况2：$\sigma$是有限的：$\sigma$的最终转换在$Q$里</li></ul><blockquote><p>$Inf_T(Q,\sigma)$ ：$Q$是在$\sigma$中的循环状态集</p></blockquote><p>例（循环状态）：</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03 12.10.42.png" alt="2022-04-03 12.10.42" style="zoom:30%;"></p><ul><li><p>$s_1 \; is\;recurrent\;in\;⟨(s_0 → s_1 → s_3)^ω⟩$</p></li><li><p>$s_1 \; is\;recurrent\;in\;⟨(s_0 → s_1 → s_3 \to s_0 \to s_2 \to s_3)^ω⟩$</p></li><li><p>$s_1 \; is\;NOT\;recurrent\;in\;⟨(s_0 → s_1 → s_3)^* \to (s_0 \to s_2 \to s_3)^ω⟩$</p><blockquote><p>个人理解，这里在说循环状态时有两个判断标准：</p><ol><li>当这段执行是<strong>无限</strong>的时，该状态应该在这段<strong>无限执行内</strong>；</li><li>当这段执行是<strong>有限</strong>的时，该状态应该是这段<strong>有限执行的最终状态</strong>。</li></ol><p>下列循环转换可类比于循环状态</p></blockquote></li><li><p>$s_1 \to s_3 \; is\;recurrent\;in\;⟨(s_0 → s_1 → s_3 \to s_0 \to s_2 \to s_3)^ω⟩$</p></li><li><p>$s_1 \to s_3 \; is\;NOT\;recurrent\;in\;⟨(s_0 → s_1 → s_3)^* \to (s_0 \to s_2 \to s_3)^ω⟩$</p></li></ul><h4 id="关于状态的公平性"><a href="#关于状态的公平性" class="headerlink" title="关于状态的公平性"></a>关于状态的公平性</h4><h5 id="简单公平性"><a href="#简单公平性" class="headerlink" title="简单公平性"></a>简单公平性</h5><p>令 $⟨S, I, R⟩$ 是一个变迁系统，如果$ F ⊆ S $ 是一组公平的状态，那么任何执行 $σ$ 必须满足循环状态集 $Inf_S (F, σ)$。</p><p>例：</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03 12.23.47.png" alt="2022-04-03 12.23.47" style="zoom:40%;"></p><p>$Exec(S) = ⟨{s_0}^ω⟩,⟨{s_0}^+ \to s_1⟩,⟨{s_0}^+ \to s_2 \to (s_3 \to s_4) ^w⟩,⟨{s_0}^+ \to s_2 \to (s_3 \to s_4) ^+ \to s_5⟩$</p><ul><li>满足 $\{s_0\}$ 简单公平性的执行是：$⟨{s_0}^ω⟩$</li><li>满足 $\{s_1, s_4\}$ 简单公平性的执行是：$⟨{s_0}^+ \to s_1⟩,⟨{s_0}^+ \to s_2 \to (s_3 \to s_4) ^w⟩$</li><li>满足 $\{s_1, s_5\}$ 简单公平性的执行是：$⟨{s_0}^+ \to s_1⟩,⟨{s_0}^+ \to s_2 \to (s_3 \to s_4) ^+ \to s_5⟩$</li></ul><blockquote><p>满足 $\{s_0, s_1\}$ 简单公平性意味着<strong>分别满足</strong>$\{s_0\}$ 和 $\{s_1\}$ 的简单公平性</p></blockquote><h5 id="多重公平性"><a href="#多重公平性" class="headerlink" title="多重公平性"></a>多重公平性</h5><p>令 $⟨S, I, R⟩$ 是一个变迁系统，给定一个可枚举的集合，可由一组整数$ J = \{0, 1, 2,…\}$，公平集 $\{F_i\}i ∈ J$。</p><p>任何执行 $σ$ 必须满足 $∀i ∈ J : Inf_S (F_i, σ)$。</p><p>例：</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03 14.11.29.png" alt="2022-04-03 14.11.29" style="zoom:40%;"></p><p>$Exec(S) = ⟨{s_0}^ω⟩,⟨{s_0}^+ \to {s_1}^w⟩,⟨({s_0}^+ \to {s_1}^+)^w⟩,⟨({s_0}^+ \to {s_1}^+)^* \to {s_0}^+ \to {s_1}^w⟩$</p><ul><li>满足 $\{s_0\}$ 简单公平性的执行是：$⟨{s_0}^ω⟩, ⟨({s_0}^+ \to {s_1}^+)^w⟩$</li><li>满足 $\{s_0, s_1\}$ 简单公平性的执行是：$Exec(S)$</li><li>满足 $\{s_0\}\{s_1\}$ <strong>多重公平性</strong>的执行是：$⟨({s_0}^+ \to {s_1}^+)^w⟩$</li></ul><blockquote><p>满足 $\{s_0\}\{s_1\}$ <strong>多重公平性</strong>意味着<strong>同时满足</strong>$\{s_0\}$ 和 $\{s_1\}$ 的简单公平性</p></blockquote><h6 id="有限多重公平性-↔-简单公平性"><a href="#有限多重公平性-↔-简单公平性" class="headerlink" title="有限多重公平性 ↔ 简单公平性"></a>有限多重公平性 ↔ 简单公平性</h6><ol><li><p>简单情况：$J$ 是有限的。 $|J|$ 是 $J$ 的基数(cardinalite)。</p><p>下面的简单公平性系统$⟨S’, I’, R’⟩$ 是等价的（执行的平等投影到 S）：</p><ul><li>$S’ = S \times J$</li><li>$I’ = I \times \{0\}$</li><li>$\begin{aligned} R’ = &amp;\{ (⟨s,j⟩,⟨s’,j+1 \mod |J|⟩) | (s,s’) \in R \land s \in F_j\}\\ &amp;∪ \{(⟨s, j⟩,⟨s’, j⟩) |(s,s’) ∈ R ∧ s \notin F_j \} \end{aligned}$</li><li>简单公平状态$F’ = F_0 \times \{0\}$</li></ul><p>例：</p><p>带有多重公平性$F_0 = \{s_0\}$，$ F_1 =\{s_1\}$ 的ST系统<img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03 14.11.29.png" alt="2022-04-03 14.11.29" style="zoom:30%;">与下述带有简单公平性$\{(s_0,0)\}$的ST系统等价：</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03 14.45.46.png" alt="2022-04-03 14.45.46" style="zoom:40%;"></p></li></ol><ol><li><p>一般情况（J 可能无限）。</p><p>下面的简单公平性系统$⟨S’, I’, R’⟩$ 是等价的（执行的平等投影到 S）：</p><ul><li><p>$S’ = S \times J \times J$</p></li><li><p>$I’ = I \times \{0\} \times \{0\}$</p></li><li><p>$\begin{aligned} R’ = &amp;\{ (⟨s,i,i⟩,⟨s’,i⊕1,0⟩) | (s,s’) \in R \land s \in F_j\}\\ &amp;∪ \{(⟨s,i,j⟩,⟨s’,i,j+1⟩) | j &lt; i \land (s,s’) \in R \land s \in F_j\} \\&amp;∪ \{(⟨s,i,j⟩,⟨s’,i,j⟩) |(s,s’) ∈ R ∧ s \notin F_j \} \end{aligned}$</p></li><li><p>简单公平状态$F’ = F_0 \times J \times \{0\}$</p><p>注：$ i⊕1 \triangleq \begin{cases} i+1\;(if\;J是无限的) \\ i+1 \mod |J| \;(else)\end{cases}$</p></li></ul></li></ol><blockquote><p>在公平执行中，计数器 i、j 形成一个三角形：$⟨(0, 0) → (1, 0) → (1, 1) → (2, 0) → (2, 1) → (2, 2) → (3, 0) → …⟩$</p></blockquote><p>例：带有多重公平性$F_0 = \{s_0\}$，$ F_1 =\{s_1\}$ 的ST系统<img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03 14.11.29.png" alt="2022-04-03 14.11.29" style="zoom:30%;">与下述带有简单公平性$\{(s_0,0,0)\}$，$\{(s_0,1,0)\}$的ST系统等价：</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03 15.06.04.png" alt="2022-04-03 15.06.04" style="zoom:30%;"></p><h5 id="条件公平性"><a href="#条件公平性" class="headerlink" title="条件公平性"></a>条件公平性</h5><p>令 $⟨S, I, R⟩$ 是一个变迁系统，我们有两个集合 F 和 G。</p><p>任何执行 σ 必须满足 $Inf_S (F, σ) ⇒ Inf_S (G, σ)$。如果 $F$ 在 $σ$ 中循环，则 $G$ 必须在 $σ$ 中循环。</p><p>例：</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03 12.23.47.png" alt="2022-04-03 12.23.47" style="zoom:40%;"></p><p>$Exec(S) = ⟨{s_0}^ω⟩,⟨{s_0}^+ \to s_1⟩,⟨{s_0}^+ \to s_2 \to (s_3 \to s_4) ^w⟩,⟨{s_0}^+ \to s_2 \to (s_3 \to s_4) ^+ \to s_5⟩$</p><ul><li>满足 $\{s_0\} ⇒ \{s_5\} $ 简单公平性的执行是：$⟨{s_0}^+ \to s_1⟩,⟨{s_0}^+ \to s_2 \to (s_3 \to s_4) ^w⟩,⟨{s_0}^+ \to s_2 \to (s_3 \to s_4) ^+ \to s_5⟩$</li><li>满足 $\{s_3\} ⇒ \{s_4\} $ 简单公平性的执行是：$Exec(S)$</li></ul><blockquote><p>满足 $\{s_3\} ⇒ \{s_4\}$ 条件公平性意味着什么？</p></blockquote><h4 id="关于转换的公平性"><a href="#关于转换的公平性" class="headerlink" title="关于转换的公平性"></a>关于转换的公平性</h4><h5 id="基于动作的公平性约束"><a href="#基于动作的公平性约束" class="headerlink" title="基于动作的公平性约束"></a>基于动作的公平性约束</h5><p>如何表述这类公平性约束？这里采用基于动作 $\mathcal{A}$ (action)的观点.</p><hr><p>弱可能性 ( $WF$ )：</p><p>我们说，一个 TLA 的 Action 动作 $\mathcal{A}$ 在状态 $s$ 下是“使能的” 或者“可触发的”(Enabled)，当且仅当系统的行为序列中可能存 在着一个状态 $t$ 是 $s$ 的一个下一个后续状态，即 $⟨上一个状态\;s, 下一个状态\;t⟩$，并且这个二元组可以满足 $\mathcal{A}$ 这个动作规范。 $WF_f(\mathcal{A})$ 表示一个这样的系统行为，如果存在这样的一个 TLA 动 作 $\mathcal{A} ∧ (f’ \neq f)$，一旦变成是“使能的”，“可触发的”，就保持着， 并且永远是“使能的”，“可触发的”，我们认为，那么这个系统就 会出现无限多次（Infinitely Many) 的 $\mathcal{A} ∧ (f’ \neq f)$ 步骤。<u>换言之， 如果一旦<strong>出现一个 Action 动作的可能性</strong>并且一直保持着这种系统<strong>会执行这个动作的可能性</strong>，那么就<strong>一定会出现和发生</strong>，或者说，<strong>被执行无限多次</strong>。</u></p><p>强可能性 ( $SF$ )：</p><p>TLA 规约另外也定义了强公平性 (Strong Fairness) $SF_f (\mathcal{A})$，其中 $f$ 是一个状态函数，$\mathcal{A}$ 是一个 TLA 动作范式。 强公平性范式表示，如果 $\mathcal{A} ∧ (f’ \neq f)$ 在一个无限的系统行为里<strong>存在着</strong>无限频繁多次的可能性，那么 $\mathcal{A} ∧ (f’ \neq f)$ 就一定会出现无限多次。<u>如果一个动作范式在某个时间点变得永远可能，那么 也满足“无限经常”的条件。</u>因此，强公平性 $SF_f(\mathcal{A})$ 中蕴含了 $WF_f(\mathcal{A})$</p><blockquote><p>个人理解：</p><ul><li>在弱可能性 $WF_f(\mathcal{A})$ 中，$\mathcal{A}$ 满足 $⟨上一个状态\;s, 下一个状态\;t⟩$ 的二元组，即 $s \to t$。当 TLA 处于当前状态 $s$ 时，动作 $\mathcal{A}$ 是 “Enable”，<strong>则该动作 $\mathcal{A}$ 一定会发生（被执行无限多次）</strong>。</li><li>在强可能性 $SF_f(\mathcal{A})$ 中，$\mathcal{A}$ 满足 $⟨上一个状态\;s, 下一个状态\;t⟩$ 的二元组，即 $s \to t$。当 TLA 处于当前状态 $s$ 时，动作 $\mathcal{A}$ 是 “Enable”，<strong>则该动作 $\mathcal{A}$ 可能会发生（存在被执行无限多次的可能性）</strong>。</li></ul></blockquote><hr><p>公平属性是 <a href="https://wikichi.icu/wiki/Precondition">前提条件</a> 施加在系统上以排除不切实际的痕迹。</p><ul><li>无条件公平的形式是<strong>“每个过程都会无休止地轮流使用”</strong>。</li><li>强公平性 (SF) 的形式是<strong>“如果无限频繁地启用它，则每个过程都将无限次地轮流运行”</strong>。</li><li>弱公平性 (WF) 的形式是<strong>“如果从某个特定点连续进行，则每个过程都会无限制地轮流转动”</strong>。</li></ul><p>之前我们看到了，LTL公式可以用来描述两进程互斥问题的公平性属性，现在我们将它推广到一般的公平性问题</p><p>设 $\phi$ 和 $\psi$ 是命题公式：</p><ul><li>无条件的公平性：$\Box\Diamond\psi$</li><li>强公平性：$\Box\Diamond\phi\rightarrow\Box\Diamond\psi$</li><li>弱公平性：$\Diamond\Box\phi\rightarrow\Box\Diamond\psi$</li></ul><p>对于公平性假设fair和LTL公式 $\phi$，我们有如下结论</p><script type="math/tex; mode=display">s\vDash_{fair}\phi \\ \text{当且仅当 对于所有的π∈Paths(s),如果}π\vDash fair，那么π\vDash\phi \\ \text{当且仅当 }s\vDash (fair\rightarrow\phi)</script><p>其实这里想要表达的意思是，如果我们有了一套算法或者说流程可以验证TS系统是否满足LTL公式，那么我们可以用相同的流程步骤来检测在加入公平性约束的情况下，TS系统是否满足LTL公式。</p><p>对于一个没有终止状态的$TS=⟨S,I,R⟩$，$ \alpha ⊆ Act$，TS上的无限执行片段$ρ =s{0}\xrightarrow{α{0}} s{1}\xrightarrow{α{1}}…$，公平约束具有三种：</p><ol><li><p>如果$\rho$是<strong>无条件公平性（unconditionally A-fair）</strong>，那么无论何时</p><script type="math/tex; mode=display">\text{if }\overset{∞}∃ j\ge 0,a_{j}∈A.</script><p>无条件A-fair的含义是，<u>无论在什么情况下，A中的动作总能无限经常次执行。</u></p></li><li><p>如果$\rho$是<strong>强公平性（strongly A-fair）</strong>，那么无论何时</p><script type="math/tex; mode=display">(\overset{∞}∃ j.Act(s_{j}\cap A\ne ∅)\Rightarrow(\text{if }\overset{∞}∃ j\ge 0,a_{j}∈A)</script><blockquote><p>strongly A-fair的含义是，<u><strong>存在无限经常次A为enabled时，A中动作将会无限经常次执行</strong>。</u></p></blockquote></li><li><p>如果$\rho$是<strong>弱公平性（weakly A-fair）</strong>，那么无论何时</p><script type="math/tex; mode=display">(\overset{∞}\forall j.Act(s_{j}\cap A\ne ∅)\Rightarrow(\text{if }\overset{∞}∃ j\ge 0,a_{j}∈A)</script><blockquote><p>weakly A-fair的含义是，<u><strong>从某个时刻起，A将会为enabled，从而A中动作将会无限经常次执行</strong>。</u></p></blockquote></li></ol><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/20201126194333746.png" alt="20201126194333746" style="zoom:70%;"></p><blockquote><p>strong和weak引入了enabled这个概念，</p><p>strongly A-fair要求在enable的片段中动作能够无限经常次执行，而在not enabled的片段中没有规定</p><p>weakly A-fair则是，不管之前如何，如果在某一个时间点之后，动作持续一直enabled，那么在这片段中动作要求能够无限经常次执行。</p><p>从上面的定义中我们可以容易得到</p><script type="math/tex; mode=display">\text{unconditionally A-fair}\Rightarrow \text{strongly A-fair}\Rightarrow \text{weakly A-fair}</script><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/20201126192818563.png" alt="20201126192818563" style="zoom:60%;"></p></blockquote><h3 id="第五部分：-LTL"><a href="#第五部分：-LTL" class="headerlink" title="第五部分：$LTL$"></a>第五部分：$LTL$</h3><h4 id="时间逻辑TL（Temporal-Logic）"><a href="#时间逻辑TL（Temporal-Logic）" class="headerlink" title="时间逻辑TL（Temporal Logic）"></a>时间逻辑TL（Temporal Logic）</h4><p>时间逻辑TL：用以表达与系统执行相关的属性。不能表达没有明确的转换关系，没有初始状态的概念。</p><p>TL逻辑定义为：</p><ul><li>一种语法：经典逻辑运算符加上时间运算符来谈论未来和过去。</li><li>语义：对象域（称为模型），我们将在其上测试公式的有效性，以及运算符的解释。</li></ul><h4 id="线性时间逻辑LTL（Linear-Temporal-Logic）"><a href="#线性时间逻辑LTL（Linear-Temporal-Logic）" class="headerlink" title="线性时间逻辑LTL（Linear Temporal Logic）"></a>线性时间逻辑LTL（Linear Temporal Logic）</h4><h5 id="LTL模型"><a href="#LTL模型" class="headerlink" title="LTL模型"></a>LTL模型</h5><p>LTL 公式总是与系统的<strong>给定迹</strong> $σ$ 相关：<strong>迹构成该逻辑的模型。</strong></p><blockquote><p>注意：我们经常说即时而不是状态，以指定迹 $σ$ 的元素。</p></blockquote><h5 id="LTL语法"><a href="#LTL语法" class="headerlink" title="LTL语法"></a>LTL语法</h5><ul><li>$s$：表示s在<strong>当前时刻成立</strong>，在轨迹表现为在第一个位置成立</li><li>$\neg P$</li><li>$P \lor Q$</li><li>$P \land Q$</li><li>$\bigcirc P$：表示P在<strong>下一个时刻成立</strong>，在轨迹表现为第二个位置成立</li><li>$\Box P$：表示<strong>P总是(always)成立</strong>，即在<strong>全部的时刻都成立</strong>，在轨迹上表现为每个位置都成立，$\Box P=\lnot \Diamond \lnot P$ </li><li>$\Diamond P$：表示的是<strong>P最终(eventually)能够成立</strong>，在轨迹上表现为，在<strong>某一个时刻的时候P成立</strong>，$\Diamond P = \lnot \Box \lnot P$ : $P$ 不永远为假 $\to$ 存在 $P$ 为真（在这个序列的某个点上 $F$ 为真，哪个点我不关心） </li><li>$\Diamond \Box P$：表示在某一个点之后 $F$ 永远为真。 </li><li>$\Box \Diamond P$：表示存在无穷多个点 $F$ 为真。有一个执行序列 $Exec$，任给一个迹 $\sigma$，总要包含一个 $F$ 为真。</li><li>$P \mathcal{U} Q$：表示<strong>直到Q成立前，P一直成立</strong></li><li>$P \rightsquigarrow Q$：表示<strong>当P成立时，Q一会后也成立</strong>。如果 $P$ 在某个点上为真了，那么 $Q$一定在后面的某个点上为真</li></ul><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03 16.06.08.png" alt="2022-04-03 16.06.08" style="zoom:40%;"></p><h6 id="最小的运算符"><a href="#最小的运算符" class="headerlink" title="最小的运算符"></a>最小的运算符</h6><p>最小的运算符是$\bigcirc P$ 和 $P \mathcal{U}Q$：</p><ul><li>$\Diamond P \triangleq True \; \mathcal{U} P$</li><li>$\Box P \triangleq \neg \Diamond \neg P$ </li><li>$P \rightsquigarrow Q \triangleq \Box (P ⇒ \Diamond Q)$</li></ul><h6 id="替代语法"><a href="#替代语法" class="headerlink" title="替代语法"></a>替代语法</h6><p>我们可以使用另一种语法：</p><ul><li>$\Box ↔ G$（Globally）</li><li>$\Diamond ↔ F$（Finally）</li><li>$\bigcirc↔ X$（Next）</li></ul><h6 id="互补运算符"><a href="#互补运算符" class="headerlink" title="互补运算符"></a>互补运算符</h6><p>运算符 <code>wating-for</code>（或 <code>unless</code> 或 <code>weak-less</code>）: Q 可能最终为真，同时 P 仍然为真</p><p>$P\; \mathcal{W}\;Q \triangleq \Box P ∨ P \mathcal{U}Q$</p><h6 id="释放运算符"><a href="#释放运算符" class="headerlink" title="释放运算符"></a>释放运算符</h6><p>$P \; \mathcal{R} \; Q \triangleq Q \mathcal{U}(P ∧ Q)$Q :  保持为真，直到 P 变为真。</p><h6 id="过去式运算符"><a href="#过去式运算符" class="headerlink" title="过去式运算符"></a>过去式运算符</h6><ul><li>$\ominus P$：<code>previous</code> : P 在前一个瞬间为真</li><li>$\boxminus P$：<code>has-always-been</code> : P 一直是真实的直到当前时刻</li><li>$ \diamond P$：<code>once</code> : P 在过去是真的</li><li>$P\; \mathcal{S}\;Q$：<code>since</code> : 自 Q 过去一直为真，而 P 自上次出现 Q 以来一直为真</li><li>$P\; \mathcal{B}\;Q$：<code>back-to</code> : P 自上次出现 Q 以来为真，或者如果 Q 从未为真，则自初始时刻起为真</li></ul><h5 id="LTL语义"><a href="#LTL语义" class="headerlink" title="LTL语义"></a>LTL语义</h5><p>我们用 $(σ, i)$ 表示后缀为 $⟨s_i → s_i+1 → …⟩$ 的迹 $σ = ⟨s0 → s1 → …⟩$</p><h6 id="系统验证"><a href="#系统验证" class="headerlink" title="系统验证"></a>系统验证</h6><p>系统 $S$ 验证（valid）公式 $F$ 当且仅当 $S$ 的所有执行从初始时刻验证它：</p><script type="math/tex; mode=display">\frac{\forall σ \in Exec(S):(σ,0) \models F}{S \models F}</script><h6 id="P-land-Q"><a href="#P-land-Q" class="headerlink" title="$P\land Q$"></a>$P\land Q$</h6><p>$(\sigma,i) \models P \land Q$ 当且仅当$(\sigma ,i) \models P$ <strong>并且</strong> $(\sigma ,i) \models Q$ </p><script type="math/tex; mode=display">\frac{(\sigma,i) \models P\qquad(\sigma,i) \models Q}{(\sigma,i) \models P \land Q}</script><h6 id="P-lor-Q"><a href="#P-lor-Q" class="headerlink" title="$P\lor Q$"></a>$P\lor Q$</h6><p>$(\sigma,i) \models P \land Q$ 当且仅当$(\sigma ,i) \models P$ <strong>或者</strong> $(\sigma ,i) \models Q$ </p><script type="math/tex; mode=display">\frac{(\sigma,i) \models P}{(\sigma,i) \models P \lor Q} \qquad\frac{(\sigma,i) \models Q}{(\sigma,i) \models P \lor Q}</script><h6 id="neg-P"><a href="#neg-P" class="headerlink" title="$\neg P$"></a>$\neg P$</h6><script type="math/tex; mode=display">\frac{\neg (\sigma,i) \models P}{(\sigma,i) \models \neg P}</script><h6 id="s"><a href="#s" class="headerlink" title="$s$"></a>$s$</h6><script type="math/tex; mode=display">\frac{\sigma_i=s}{(\sigma,i) \models s}</script><h6 id="bigcirc-P"><a href="#bigcirc-P" class="headerlink" title="$\bigcirc P$"></a>$\bigcirc P$</h6><p>$(\sigma,i) \models \bigcirc P$ 当且仅当对使$suffix(\sigma,1) = \sigma_{1},\sigma_{2},\sigma_{3}…\models P$</p><script type="math/tex; mode=display">\frac{(\sigma,i+1) \models P}{(\sigma,i) \models \bigcirc P}</script><h6 id="P-mathcal-U-Q"><a href="#P-mathcal-U-Q" class="headerlink" title="$P\;\mathcal{U}\;Q$"></a>$P\;\mathcal{U}\;Q$</h6><p>$(\sigma,i) \models P\;\mathcal{U}\;Q$ 存在 $j \ge 0$ 使得 $suffix(\sigma,j)=\sigma_{j},\sigma_{j+1},\sigma_{j+2}…\models Q$ 且 $suffix(\sigma,i)=\sigma_{i}, \sigma_{i+1}, \sigma_{i+2}…\models P$ ，$0\le i\lt 1$</p><script type="math/tex; mode=display">\frac{\{∃ k \ge 0:(\sigma,i+k) \models Q\} \land \{ \forall k',0 \le k' \le k:(\sigma, i+k')\models P\} } {(\sigma,i) \models P \mathcal{U} Q}</script><h6 id="Diamond-P"><a href="#Diamond-P" class="headerlink" title="$\Diamond P$"></a>$\Diamond P$</h6><p>$(\sigma,i) \models \Diamond P$ 当且仅当<strong>存在</strong> $i \ge 0$使得 $\sigma_{j},\sigma_{j+1},\sigma_{j+2}…\models P$</p><script type="math/tex; mode=display">\frac{∃k \ge 0 :(\sigma ,i+k) \models P}{(\sigma,i) \models \Diamond P}</script><h6 id="Box-P"><a href="#Box-P" class="headerlink" title="$\Box P$"></a>$\Box P$</h6><p>$(\sigma,i) \models \Box P$ 当且仅当<strong>对所有</strong> $i \ge 0$使得 $\sigma_{j},\sigma_{j+1},\sigma_{j+2}…\models P$</p><script type="math/tex; mode=display">\frac{\forall k \ge 0 :(\sigma ,i+k) \models P}{(\sigma,i) \models \Box P}</script><h6 id="P-rightsquigarrow-Q"><a href="#P-rightsquigarrow-Q" class="headerlink" title="$P \rightsquigarrow Q$"></a>$P \rightsquigarrow Q$</h6><script type="math/tex; mode=display">\frac{\{\forall k \ge 0 :(\sigma ,i+k) \models P \} \Rightarrow \{∃ k' \ge k :(\sigma ,i+k') \models Q\} } { (\sigma,i) \models P \rightsquigarrow Q}</script><h5 id="简化为纯逻辑"><a href="#简化为纯逻辑" class="headerlink" title="简化为纯逻辑"></a>简化为纯逻辑</h5><p>线性时序逻辑具有这样的表达能力，以至于它可以准确地表示根据转换系统描述的任何操作规范，因此：</p><ul><li>检查变迁系统 M 是否具有时间属性 $F_{\mathcal{S}pec}$：</li></ul><script type="math/tex; mode=display">\mathcal{M} \models F_{\mathcal{S}pec}</script><ul><li>相当于确定以下各项的有效性：<script type="math/tex; mode=display">F_{\mathcal{M}} ⇒ F_{\mathcal{S}pec}</script>其中 $F_{\mathcal{M}}$ 是一个公式，准确地表示模型 ${\mathcal{M}}$ 的执行（即它的初始状态、它的转换、它的公平性约束）。</li></ul><h4 id="例题（考试必考）"><a href="#例题（考试必考）" class="headerlink" title="例题（考试必考）"></a>例题（考试必考）</h4><h5 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h5><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03 17.18.20.png" alt="2022-04-03 17.18.20" style="zoom:50%;"></p><div class="table-container"><table><thead><tr><th></th><th>无公平性</th><th>简单公平性($s_1,s_2$)</th></tr></thead><tbody><tr><td>$s_0 \land \bigcirc s_0$</td><td>$n (s_0→{s_1}^ω) $</td><td>n</td></tr><tr><td>$s_0 \land \bigcirc (s_0 \lor s_1)$</td><td>o</td><td>o</td></tr><tr><td>$\Box (s_0 ⇒ \bigcirc s_0)$</td><td>$n (s_0→{s_1}^ω) $</td><td>n</td></tr><tr><td>$\Box (s_0 ⇒ \bigcirc (s_0 \lor s_1)$</td><td>o</td><td>o</td></tr><tr><td>$\Box (s_0 ⇒ \bigcirc s_1)$</td><td>o</td><td>o</td></tr><tr><td>$\Diamond (s_0 ⇒ \bigcirc s_1)$</td><td>$n ({s_0}^ω) $</td><td>o</td></tr><tr><td>$\Box s_0$</td><td>$n (s_0→{s_1}^ω) $</td><td>n</td></tr><tr><td>$\Diamond \neg s_0$</td><td>$n ({s_0}^ω) $</td><td>o</td></tr><tr><td>$\Diamond \Box s_0$</td><td>$n ({s_0}^ω) $</td><td>o</td></tr><tr><td>$s_0 \mathcal{W} s_1$</td><td>o</td><td>o</td></tr><tr><td>$s_0 \mathcal{U} s_1$</td><td>$n ({s_0}^ω) $</td><td>o</td></tr></tbody></table></div><h5 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h5><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03 17.34.49.png" alt="2022-04-03 17.34.49" style="zoom:50%;"></p><p>$Exec(S) = ⟨s_0 \to {s_1}^w⟩, ⟨(s_0 \to {s_1}^+)^w⟩, ⟨(s_0 \to {s_1}^+)^+ \to {s_2}^w⟩$</p><div class="table-container"><table><thead><tr><th></th><th>无公平性</th><th>$\mathcal{W_{eak}F_{airness}}(s_1,s_2)$</th><th>$\mathcal{S_{trong}F_{airness}}(s_1,s_2)$</th></tr></thead><tbody><tr><td>$\Box \Diamond \neg s_1$</td><td>$n (s_0→{s_1}^ω) $</td><td>o</td><td>o</td></tr><tr><td>$\Box (s_1 ⇒ \Diamond s_2)$</td><td>$n (s_0→{s_1}^ω) $</td><td>$n ((s_0→s_1)^ω) $</td><td>o</td></tr><tr><td>$\Diamond \Box (s_1 \lor s_2)$</td><td>$n ((s_0→s_1)^ω) $</td><td>n</td><td>o</td></tr><tr><td>$\Box (s_1 \mathcal{U} s_2)$</td><td>$n (s_0→…) $</td><td>n</td><td>n</td></tr><tr><td>$\Box (s_0 ⇒ s_0 \mathcal{U} s_1)$</td><td>o</td><td>o</td><td>o</td></tr><tr><td>$\Box(s_0 \mathcal{U} (s_1 \lor s_2))$</td><td>o</td><td>o</td><td>o</td></tr><tr><td>$\Box (s_1 ⇒ s_1 \mathcal{U} s_2)$</td><td>$n (s_0→{s_1}^ω) $</td><td>$n ((s_0→s_1)^ω) $</td><td>$n (s0→s1→s0→s1→s2^ω) $</td></tr><tr><td>$\Diamond (s_1 \mathcal{U} s_2)$</td><td>$n (s_0→{s_1}^ω) $</td><td>$n ((s_0→s_1)^ω) $</td><td>o</td></tr><tr><td>$\Diamond (s_1 \mathcal{W} s_2)$</td><td>$n ((s_0→s_1)^ω) $</td><td>n</td><td>o</td></tr><tr><td>$\Box \Diamond (s_1 \mathcal{U} (s_0 \lor s_2))$</td><td>$n (s_0→{s_1}^ω) $</td><td>o</td><td>o</td></tr></tbody></table></div><blockquote><p>个人理解：以例1中的第一行 $\Box \Diamond \neg s_1 $ 为例，可以将其视为一个条件，意为在该条件下是否满足“无公平性” 和 “$WF(s_1,s_2)$”：</p><p>$\Box \Diamond \neg s_1 $ 意为 “对于所有迹，最终都会不出现 $s_1$” ，此时我们需要找出有否所有的迹都符合该条件。</p><ol><li><p>对于“无公平性”：由图可见存在一个迹 $\sigma = ⟨s_0 \to {s_1}^w⟩$ ，并不符合$\Box \Diamond \neg s_1 $ ，所以为<code>n(means no)</code>。</p></li><li><p>对于“$WF(s_1, s_2)$”：在转换 $s_0 \to s_1$ 下，条件 $\Box \Diamond \neg s_1 $ 并<strong>总是成立</strong></p></li><li><p>对于“$SF(s_1, s_2)$”：在转换 $s_0 \to s_1$ 下，条件 $\Box \Diamond \neg s_1 $ 并<strong>会成立</strong></p></li></ol></blockquote><h4 id="时间逻辑TL属性"><a href="#时间逻辑TL属性" class="headerlink" title="时间逻辑TL属性"></a>时间逻辑TL属性</h4><h5 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h5><p>没有什么不好的事情发生（<a href="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/#%E5%AE%89%E5%85%A8%E6%80%A7-safety">详见第三部分</a>）= 在执行的有限前缀上无效的属性：</p><ul><li>$\Box P$, $\Box (P ⇒ \Box P)$, $P \mathcal{W} Q$, …</li></ul><h5 id="活性"><a href="#活性" class="headerlink" title="活性"></a>活性</h5><p>美好的事情终会发生 = 始终可以通过扩展运行前缀来验证的属性：</p><ul><li>$\Diamond P$, $P \rightsquigarrow Q$, …</li></ul><h5 id="活性与安全性的组合属性"><a href="#活性与安全性的组合属性" class="headerlink" title="活性与安全性的组合属性"></a>活性与安全性的组合属性</h5><p> 一些活性与安全性的组合属性，例如</p><ul><li>$P \mathcal{U} Q$, $\Box P \land \Diamond Q$, …</li><li>Reponse: $\Box \Diamond P$</li><li>Persistance: $\Diamond \Box P$</li></ul><h5 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h5><p>指定系统可达状态的超集（<a href="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/#%E4%B8%8D%E5%8F%98%E6%80%A7-Invariants">详见第三部分</a>：</p><script type="math/tex; mode=display">\mathcal{S} \models \Box P</script><p>其中 P 是状态谓词。</p><h5 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h5><p>指定情况发生时的稳定性：</p><script type="math/tex; mode=display">\mathcal{S} \models \Box(P ⇒ \Box P)</script><p>其中 P 是状态谓词</p><h5 id="可能性"><a href="#可能性" class="headerlink" title="可能性"></a>可能性</h5><p>指定在某个执行中可能达到满足 $P$ 的某个状态：</p><ul><li>对于任意 $P$ 是不可能的，但对于 $P$ 是一个状态谓词：<script type="math/tex; mode=display">\mathcal{S} \nvDash \Box \neg P</script>请注意<strong>否定性</strong>：$\neg \Box P = \Diamond \neg P$  但是 $\mathcal{S} \nvDash \Box P \nRightarrow \mathcal{S} \models \Diamond \neg P$</li></ul><h5 id="否定性"><a href="#否定性" class="headerlink" title="否定性"></a>否定性</h5><ul><li><p>对于 $σ$ 执行：$σ \models ¬P ≡ σ \nvDash P$</p></li><li><p>对于 $\mathcal{S}$ 系统： $\mathcal{S} \models ¬P ⇒ \mathcal{S} \nvDash P$ , 但不是等价的！</p><blockquote><p>$\mathcal{S} \nvDash P$ 表示至少有一次执行使 Q 无效（  $¬Q$ 有效），但并非所有执行都如此。</p><p>在 LTL 中，我们可以有$ S \nvDash Q ∧ S \nvDash ¬Q$ : </p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03 17.18.20.png" alt="2022-04-03 17.18.20" style="zoom:50%;"></p><script type="math/tex; mode=display">\frac { {s_0}^+ → {s_1}^w \nvDash \Box s_0}{\mathcal{S} \nvDash \Box s_0} \qquad\frac { {s_0}^w \nvDash \Diamond \neg s_0}{\mathcal{S} \nvDash \Diamond \neg s_0}</script></blockquote></li></ul><h5 id="无限经常"><a href="#无限经常" class="headerlink" title="无限经常"></a>无限经常</h5><p>指定 $P$ 在任何执行中都无限地经常为真：</p><script type="math/tex; mode=display">\mathcal{S} \models \Box \Diamond P</script><h5 id="最终总是"><a href="#最终总是" class="headerlink" title="最终总是"></a>最终总是</h5><p>指定 $P$ 最终保持绝对真：</p><script type="math/tex; mode=display">\mathcal{S} \models \Diamond \Box P</script><h4 id="LTL公式的性质"><a href="#LTL公式的性质" class="headerlink" title="LTL公式的性质"></a>LTL公式的性质</h4><h5 id="对偶率-Duality-laws"><a href="#对偶率-Duality-laws" class="headerlink" title="对偶率(Duality laws)"></a>对偶率(Duality laws)</h5><script type="math/tex; mode=display">\lnot\Box\phi\equiv\Diamond\lnot\phi \\ \lnot\Diamond\phi\equiv\Box\lnot\phi \\ \lnot\bigcirc\phi\equiv\bigcirc\lnot\phi</script><h5 id="幂等律-Idempotence-laws"><a href="#幂等律-Idempotence-laws" class="headerlink" title="幂等律(Idempotence laws)"></a>幂等律(Idempotence laws)</h5><script type="math/tex; mode=display">\Box\Box\phi\equiv\Box\phi \\ \Diamond\Diamond\phi\equiv\Diamond\phi \\ \phi U(\phi U\psi)\equiv\phi U\psi \\ (\phi U\psi)U\psi\equiv\phi U\psi</script><h5 id="吸收率-Absorption-laws"><a href="#吸收率-Absorption-laws" class="headerlink" title="吸收率(Absorption laws)"></a>吸收率(Absorption laws)</h5><script type="math/tex; mode=display">\Diamond\Box\Diamond\phi\equiv\Box\Diamond\phi \\ \Box\Diamond\Box\phi\equiv\Diamond\Box\phi</script><h5 id="分配律-Distributive-laws"><a href="#分配律-Distributive-laws" class="headerlink" title="分配律(Distributive laws)"></a>分配律(Distributive laws)</h5><script type="math/tex; mode=display">\bigcirc(\phi U\psi)\equiv (\bigcirc\phi)U(\bigcirc\psi) \\ \Diamond(\phi \vee\psi)\equiv (\Diamond\phi)\vee(\Diamond\psi) \\ \Box(\phi\wedge\psi)\equiv\Box\phi\wedge\Box\psi</script><h5 id="扩展率-Expansion-laws"><a href="#扩展率-Expansion-laws" class="headerlink" title="扩展率(Expansion laws)"></a>扩展率(Expansion laws)</h5><script type="math/tex; mode=display">\phi U\psi\equiv\psi\vee(\phi\wedge\bigcirc(\phi U\psi)) \\ \Diamond\phi\equiv\phi\vee\bigcirc\Diamond\phi \\ \Box\phi\equiv\phi\wedge\bigcirc\Box\phi</script><p><strong>扩展率是非常重要的一条性质</strong>，之后的LTL模型检测都会基于此。</p><p>特别是这个第一条公式，我个人感觉其实它的意思就是基于当前项然后向后走了一步，就拿 $\phi \mathcal{U}\psi$ 来说，它代表 $\psi$ 成立前 $\phi$ 一直成立，</p><ol><li>首先看扩展出来的第一个 $\psi$ ，如果当前项是 $\psi$ 那么就代表到达了公式成立的条件，后面的也就可以不用管了；</li><li>然后再看第二项 $\phi\wedge\bigcirc(\phi U\psi)$ 如果当前项是 $\phi$ 还没有达到公式成立的条件，那么如果公式成立，对于下一步来说肯定是满足 $\phi \mathcal{U}\psi$ 的。</li></ol><h4 id="用公式来表示LT性质"><a href="#用公式来表示LT性质" class="headerlink" title="用公式来表示LT性质"></a>用公式来表示LT性质</h4><h5 id="公平性"><a href="#公平性" class="headerlink" title="公平性"></a>公平性</h5><p>例如我们可以用它来表示两进程互斥问题中的公平性：</p><ul><li>无条件的公平性：$\Box \Diamond crit_{i}$</li><li>强公平性：$\Box \Diamond wait_{i}\rightarrow \Box \Diamond crit_{i}$</li><li>弱公平性：$\Diamond\Box wait_{i}\rightarrow \Box \Diamond crit_{i}$</li></ul><h5 id="Weak-until"><a href="#Weak-until" class="headerlink" title="Weak until"></a>Weak until</h5><p>前面介绍的until操作，它是一种比较强的限制，而weak until操作（或者称为unless）定义为:</p><script type="math/tex; mode=display">\phi W\psi=(\phi U\psi)\vee\Box\phiϕWψ=(ϕUψ)∨□ϕ</script><p>也就是说 $\phi \mathcal{W} \psi$ 表示为 $\phi \mathcal{U} \psi$ 成立或者 $\Box\phi$ 成立</p><p>weak until和until操作是对偶的，具体表现为：</p><script type="math/tex; mode=display">\lnot(\phi \mathcal{U}\psi)=(\phi \wedge\lnot\psi)\mathcal{W}(\lnot\phi\wedge\lnot\psi) \\ \lnot(\phi \mathcal{W}\psi)=(\phi \wedge\lnot\psi)\mathcal{U}(\lnot\phi\wedge\lnot\psi)</script><p>weak until和until两者的表达能力是相同的，两者之间可以互换</p><script type="math/tex; mode=display">\phi \mathcal{U} \psi=(\phi \mathcal{W} \psi)\wedge\lnot\Box\lnot\psi</script><p>也可以用它来表示一些其他属性：</p><h5 id="可达性"><a href="#可达性" class="headerlink" title="可达性"></a>可达性</h5><h6 id="简单可达性"><a href="#简单可达性" class="headerlink" title="简单可达性"></a>简单可达性</h6><script type="math/tex; mode=display">\Diamond\psi</script><h6 id="带条件的可达性"><a href="#带条件的可达性" class="headerlink" title="带条件的可达性"></a>带条件的可达性</h6><script type="math/tex; mode=display">\phi \mathcal{U} \psi</script><h6 id="安全性中的不变性"><a href="#安全性中的不变性" class="headerlink" title="安全性中的不变性"></a>安全性中的不变性</h6><script type="math/tex; mode=display">\Box\phi</script><h6 id="活性-1"><a href="#活性-1" class="headerlink" title="活性"></a>活性</h6><script type="math/tex; mode=display">\Box(\phi\Rightarrow\Diamond\psi)</script><h4 id="LTL公式的一些例子"><a href="#LTL公式的一些例子" class="headerlink" title="LTL公式的一些例子"></a>LTL公式的一些例子</h4><h5 id="Client-Server"><a href="#Client-Server" class="headerlink" title="Client / Server"></a>Client / Server</h5><h6 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h6><p>指定系统（扮演服务器的角色）总是响应（Q）给定的请求（P）：</p><script type="math/tex; mode=display">\mathcal{S} \models \Box (P ⇒ \Diamond Q)</script><p>通常称为<code>lead-to</code>：</p><script type="math/tex; mode=display">\mathcal{S} \models P \rightsquigarrow Q</script><h6 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h6><p>指定来自系统（扮演客户端的角色）的请求 P 只要没有有利的响应 Q 就稳定：</p><script type="math/tex; mode=display">\mathcal{S} \models \Box (P ⇒ P \mathcal{W} Q)</script><h5 id="互斥问题"><a href="#互斥问题" class="headerlink" title="互斥问题"></a>互斥问题</h5><p>两个进程不能同时进入临界区：</p><script type="math/tex; mode=display">\Box(\lnot crit_{1}\vee \lnot crit_{2}) \\OR \qquad \Box(\forall i,j \in 0..N-1: state[i]=crit \;\land\;state[j]=crit \quad \Rightarrow \quad i=j )</script><h5 id="无饥饿"><a href="#无饥饿" class="headerlink" title="无饥饿"></a>无饥饿</h5><p>两个进程可以无限经常次访问临界区：</p><script type="math/tex; mode=display">(\Box\Diamond w_{1}\Rightarrow\Box\Diamond c_{1})\wedge(\Box\Diamond w_{2}\Rightarrow\Box\Diamond c_{2})\\OR \qquad \forall i \in 0..N-1:state[i]=waiting \;\rightsquigarrow\; state[i]=crit</script><h5 id="火车轨道通行问题"><a href="#火车轨道通行问题" class="headerlink" title="火车轨道通行问题"></a>火车轨道通行问题</h5><script type="math/tex; mode=display">\Box(train\_is\_near\rightarrow gate\_is\_close)</script><h5 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h5><script type="math/tex; mode=display"> \Box(request\rightarrow \Diamond response)</script><h3 id="第六部分：-TLA"><a href="#第六部分：-TLA" class="headerlink" title="第六部分：$TLA^+$"></a>第六部分：$TLA^+$</h3><h4 id="TLA-逻辑"><a href="#TLA-逻辑" class="headerlink" title="TLA+ 逻辑"></a>TLA+ 逻辑</h4><h5 id="逻辑表达式"><a href="#逻辑表达式" class="headerlink" title="逻辑表达式"></a>逻辑表达式</h5><p>带有 $\Box$ , $\Diamond$ , $\rightsquigarrow$的 LTL 表达式和引发变量+量词 $∀$，$∃$。</p><p>没有 $\mathcal{U}$，也没有 $\mathcal{W}$，但是：</p><ul><li>$\Box (p ⇒ (p \mathcal{W}q)) = \Box (p ⇒ (p’ \lor q))$</li><li>$\Box (p ⇒ (p \mathcal{U}q)) = \Box (p ⇒ (p’ \lor q)) \land \Box(p ⇒ \Diamond q)$</li></ul><h5 id="公平性-1"><a href="#公平性-1" class="headerlink" title="公平性"></a>公平性</h5><h6 id="ENABLE"><a href="#ENABLE" class="headerlink" title="ENABLE"></a>ENABLE</h6><p>$_{ENABLE} \mathcal{A}$ 是在状态 $s$ 中为真的状态函数，当且仅当存在通过动作 $\mathcal{A}$  从 $s$ 可访问的状态 t。</p><h6 id="弱-强公平"><a href="#弱-强公平" class="headerlink" title="弱/强公平"></a>弱/强公平</h6><ul><li><p>$\mathcal{WF}_e(\mathcal{A}) \triangleq \Box \Diamond \neg (_{ENABLE} ⟨\mathcal{A}⟩_e) \lor \Box \Diamond ⟨\mathcal{A}⟩_e$</p><p>如果 $\mathcal{A}$ 是持续可触发的，它将被触发。</p></li><li><p>$\mathcal{SF}_e(\mathcal{A}) \triangleq \Diamond \Box \neg (_{ENABLE} ⟨\mathcal{A}⟩_e) \lor \Box \Diamond ⟨\mathcal{A}⟩_e$</p><p>如果 A 是无限频繁可触发的，它将被触发。</p></li></ul><h5 id="TLA-规范的形式"><a href="#TLA-规范的形式" class="headerlink" title="TLA+ 规范的形式"></a>TLA+ 规范的形式</h5><p>通常，TLA+ 规范是一系列谓词的连词(conjonction)：</p><script type="math/tex; mode=display">\mathcal{I} \land \Box [\mathcal{N}]_v \land \mathcal{E}</script><ul><li>$\mathcal{I}$ = 描述初始状态的状态谓词；</li><li>$\mathcal{N}$ = 动作 $A_1 ∨ A_2 ∨ A_3 ∨… $的分解(disjonction)；</li><li>$\mathcal{E}$ = 行动公平性约束的合取(conjonction)：$\mathcal{WF}_v(\mathcal{A}_1) \land \mathcal{WF}_v(\mathcal{A}_3) \land …$</li></ul><h5 id="规约的细化"><a href="#规约的细化" class="headerlink" title="规约的细化"></a>规约的细化</h5><p>如果 $P_c ⇒ P_a$，则一个具体的规约 $P_c$ 细化（raffine）一个抽象的规约 $P_a$：$P_c$ 所做的一切在 $P_a$ 中都是可能的。</p><p>这意味着如果 $P_a \models P$ 满足 LTL 属性，则 $P_c \models P$ 也满足LTL属性。</p><h6 id="例1-1"><a href="#例1-1" class="headerlink" title="例1"></a>例1</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-----------------module somme1----------------</span><br><span class="line">EXTENDS Naturals</span><br><span class="line">CONSTANT N</span><br><span class="line">VARIABLE res</span><br><span class="line"></span><br><span class="line">TypeInvariant == res \in Nat</span><br><span class="line">Init == res = 0</span><br><span class="line">Next == res′ = ((N + 1) * N) / 2</span><br><span class="line">Spec == Init ∧ [][Next]_res /\ WF_res (Next)</span><br></pre></td></tr></table></figure><p>当 $N = 3$ 时的执行图:</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03 22.03.52.png" alt="2022-04-03 22.03.52" style="zoom:40%;"></p><h6 id="例2-1"><a href="#例2-1" class="headerlink" title="例2"></a>例2</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">----------------- module somme2 ----------------</span><br><span class="line">EXTENDS Naturals</span><br><span class="line">CONSTANT N</span><br><span class="line">VARIABLE res, acc, disp</span><br><span class="line"></span><br><span class="line">TypeInvariant == res \in Nat</span><br><span class="line">/\ acc \in Nat</span><br><span class="line">/\ disp \in SUBSET 1..N</span><br><span class="line">Init == res = 0</span><br><span class="line">/\ acc = 0</span><br><span class="line">/\ disp = 1..N</span><br><span class="line">Next == \/ \E i \in disp : acc&#x27; = acc + i /\ disp&#x27; = disp \ &#123;i&#125;</span><br><span class="line">/\ UNCHANGED res</span><br><span class="line">\/ disp = &#123;&#125; /\ res&#x27; = acc /\ UNCHANGED res</span><br><span class="line">Spec == Init ∧ [][Next]_&lt;&lt;res, disp, acc&gt;&gt; /\ WF_&lt;&lt;res, disp, acc&gt;&gt; (Next)</span><br></pre></td></tr></table></figure><p>当 $N = 3$ 时的执行图:</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03 22.11.22.png" alt="2022-04-03 22.11.22"></p><p>分解：引入中间转换</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---------------- module somme2_raffine_somme1 ----------------</span><br><span class="line">EXTENDS somme2</span><br><span class="line">Orig == INSTANCE somme1</span><br><span class="line">Raffinement == Orig ! Spec</span><br><span class="line">THEOREM Spec =&gt; Orig ! Spec</span><br></pre></td></tr></table></figure><h6 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">----------------- module somme3 ----------------</span><br><span class="line">EXTENDS Naturals</span><br><span class="line">CONSTANT N</span><br><span class="line">VARIABLE res, acc, i</span><br><span class="line"></span><br><span class="line">TypeInvariant == res \in Nat</span><br><span class="line">/\ acc \in Nat</span><br><span class="line">/\ i \in 1..N</span><br><span class="line">Init == res = 0</span><br><span class="line">/\ acc = 0</span><br><span class="line">/\ i = N</span><br><span class="line">Next == \/ i &gt; 0 /\ acc&#x27; = acc + i /\ i&#x27; = i - 1 /\ UNCHANGED res</span><br><span class="line">\/ i = 0 /\ res&#x27; = acc /\ UNCHANGED &lt;&lt;i, res&gt;&gt;</span><br><span class="line">Spec == Init ∧ [][Next]_&lt;&lt;res, i, acc&gt;&gt; /\ WF_&lt;&lt;res, i, acc&gt;&gt; (Next)</span><br></pre></td></tr></table></figure><p>当 $N = 3$ 时的执行图:</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03 22.19.49.png" alt="2022-04-03 22.19.49" style="zoom:50%;"></p><p>减少非确定性 + 表示变化（数据细化） $disp = 1..i$</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---------------- module somme3_raffine_somme2 ----------------</span><br><span class="line">EXTENDS somme3</span><br><span class="line">dispMapping == 1..i</span><br><span class="line">Orig == INSTANCE somme2 WITH disp &lt;- dispMapping</span><br><span class="line">Raffinement == Orig ! Spec</span><br><span class="line">THEOREM Spec =&gt; Orig ! Spec</span><br></pre></td></tr></table></figure><h4 id="公理证明"><a href="#公理证明" class="headerlink" title="公理证明"></a>公理证明</h4><h5 id="简单时序逻辑"><a href="#简单时序逻辑" class="headerlink" title="简单时序逻辑"></a>简单时序逻辑</h5><script type="math/tex; mode=display">\frac{F 在命题逻辑中可证明}{\Box F} \;STL1</script><p>意义：</p><script type="math/tex; mode=display">\frac{}{\Box F ⇒ F} \;STL2</script><script type="math/tex; mode=display">\frac{}{\Box \Box F = \Box G} \;STL3</script><script type="math/tex; mode=display">\frac{F ⇒ G}{\Box F ⇒ \Box G} \;STL4</script><script type="math/tex; mode=display">\frac{}{\Box (F \land G) = (\Box F) \land (\Box G)} \;STL5</script><script type="math/tex; mode=display">\frac{}{ (\Diamond \Box F) \land (\Diamond \Box G) = \Diamond \Box (F \land G)} \;STL6</script><h5 id="不变性-1"><a href="#不变性-1" class="headerlink" title="不变性"></a>不变性</h5><script type="math/tex; mode=display">\frac{P \land (v' = v) ⇒ P'}{\Box P = P \land \Box [P ⇒ P']_v} \;TLA1</script><script type="math/tex; mode=display">\frac{P \land [\mathcal{A}]_{v1} ⇒ Q \land [\mathcal{B}]_{v2}}{\Box P \land \Box [\mathcal{A}]_{v1} ⇒ \Box Q \land \Box[\mathcal{B}]_{v2}} \;TLA2</script><script type="math/tex; mode=display">\frac{I \land [\mathcal{N}]_{v} ⇒ I'}{I \land \Box[\mathcal{N}]_{v} ⇒ \Box I} \;INV1</script><script type="math/tex; mode=display">\frac{}{\Box I ⇒ (\Box[\mathcal{N}]_{v} = \Box [\mathcal{N} \land I \land I']_v)} \;INV2</script><h5 id="活性-2"><a href="#活性-2" class="headerlink" title="活性"></a>活性</h5><script type="math/tex; mode=display">\frac{\begin{aligned} P \land [\mathcal{N}]_v ⇒ (P' \lor Q') \\ P \land ⟨\mathcal{N} \land \mathcal{A}⟩_v ⇒ Q' \\ P ⇒ _{ENABLE} ⟨\mathcal{A}⟩_v\end{aligned}}{\Box [\mathcal{N}]_v) \land WF_v(\mathcal{A}) ⇒ (P \rightsquigarrow Q)} \;WF1</script><script type="math/tex; mode=display">\frac{\begin{aligned} P \land [\mathcal{N}]_v ⇒ (P' \lor Q') \\ P \land ⟨\mathcal{N} \land \mathcal{A}⟩_v ⇒ Q' \\ \Box P \land \Box [\mathcal{N}]_v \land \Box F ⇒ \Diamond  _{ENABLE} ⟨\mathcal{A}⟩_v\end{aligned}}{\Box [\mathcal{N}]_v) \land SF_v(\mathcal{A}) \land \Box F ⇒ (P \rightsquigarrow Q)} \;WF1</script><h5 id="推导规则"><a href="#推导规则" class="headerlink" title="推导规则"></a>推导规则</h5><script type="math/tex; mode=display">\frac{\Box(P ⇒ \Box P) \land \Diamond P}{\Diamond \Box P} \;LDSTBL</script><script type="math/tex; mode=display">\frac{P \rightsquigarrow Q \land Q \rightsquigarrow R}{P \rightsquigarrow R} \;TRANS</script><script type="math/tex; mode=display">\frac{\forall m \in W : P(m) \rightsquigarrow Q}{(∃ m \in W : P(m)) \rightsquigarrow Q} \;INFDIJ</script><h4 id="模型检查"><a href="#模型检查" class="headerlink" title="模型检查"></a>模型检查</h4><p>原则：构建执行图并研究属性。</p><ul><li>$\Box P$，其中 $P$ 是一个状态谓词（没有初始变量）：随着状态的构建。</li><li>$\Box P (v,v’)$，其中 $P(v,v’)$ 是一个转换谓词（具有带素变量和非素数变量的非时间谓词）：计算转换时。</li><li>活跃度 $\Diamond P$ ,  $P \rightsquigarrow Q$ , … ：一旦建立了图，寻找一个尊重公平约束并使属性无效的循环。</li></ul><h5 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h5><p>让系统 $\mathcal{S} = ⟨S, I, R⟩$ 的状态数$|S|$ 和 LTL的 $\mathcal{F}$ 公式的大小$|F|$（时间运算符的数量）。</p><p>验证 $\mathcal{S} \models \mathcal{F}$ 的时间（和空间）复杂度为</p><script type="math/tex; mode=display">O(|S| × 2^{|F|})</script><h5 id="TLC检查器"><a href="#TLC检查器" class="headerlink" title="TLC检查器"></a>TLC检查器</h5><p>TLC 模型检查器可以检查：</p><ol><li><p>带有保护的动作的规约；</p></li><li><p>没有初始变量的不变量 $\Box P$，其中 P 是状态谓词；</p></li><li><p>带有素变量（prime variables ）和重复（begaiement）的纯安全公式 $\Box [P]_v$ , 其中 P 是转换谓词；</p></li><li><p>$P \rightsquigarrow Q$ , 其中 P 和 Q 是状态谓词（没有素变量）；</p></li><li><p>将 $\Box$、$\Diamond $ 组合在一起的公式，没有带底数的变量。</p><p>注意：系统和公式的状态空间必须是有限的：例如任何有界量化。</p></li></ol><h3 id="第七部分：-CTL"><a href="#第七部分：-CTL" class="headerlink" title="第七部分：$CTL$"></a>第七部分：$CTL$</h3><p>在前面我们已经介绍了线性属性，为了方便地去描述这个线性属性，我们又介绍了线性时序逻辑，本节要介绍一种新的逻辑计算树逻辑（CTL），这种逻辑可以描述LTL不能描述的部分。</p><p>如果用文氏图来表示的话就是：</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/20201209125629367.png" alt="20201209125629367" style="zoom:40%;"></p><hr><p>让我们先来回想一下LTL之所以称为线性的，是因为时间的定性概念是<strong>基于路径</strong>的，并且被视为<strong>线性的</strong>：在每个时刻只有唯一的一个可能的后继状态，因此每个时刻都有一个唯一的可能的未来。 从技术上讲，这是基于以下事实：<u>LTL公式的解释是根据路径（即状态序列）定义的</u>。</p><p>但是路径本身可能<strong>存在着分支</strong>，例如在一个TS系统中，一个状态也许有着多个后继状态，从这个角度来看这种解释是基于状态分支的。我们想到，某些时候在一个状态的所有可能计算都满足某个条件，或者有些时候一个状态的部分可能计算满足某个条件，为了表述这些个性质，我们加入$\forall$ 和 $∃$ 符号。</p><p>LTL描述的从某个状态开始所有的路径情况，例如$s \models \Box(x\le 20)$，它表示对于从s开始的所有路径都满足 $x\le 20$</p><p>而<u>CTL描述的是从某个状态开始的所有或部分路径情况</u></p><p>例如$s\models \forall\Box(x\le 20)$,它表示对于从s开始的所有路径都满足$x\le 20$ , 而 $s\models∃\Box(x\le 20)$表示对于从s开始的某些路径满足$x\le 20$</p><h5 id="线性时间-vs-分支时间"><a href="#线性时间-vs-分支时间" class="headerlink" title="线性时间 vs 分支时间"></a>线性时间 vs 分支时间</h5><div class="table-container"><table><thead><tr><th></th><th>linear time</th><th>branching time</th></tr></thead><tbody><tr><td>行为behavior</td><td>path-based:trace(s)</td><td>state-based:computation tree of s</td></tr><tr><td>时间逻辑temporal logic</td><td>LTL path formulas</td><td>CTL state formulas</td></tr><tr><td>模型检测</td><td>$PSPACE-complete O(size(TS)·2^{\mid\phi\mid})$</td><td>$PTIME O(size(TS)·\mid\phi\mid)$</td></tr><tr><td>公平性</td><td>可以直接表示</td><td>需要额外的技术</td></tr></tbody></table></div><h5 id="执行集-vs-执行树"><a href="#执行集-vs-执行树" class="headerlink" title="执行集 vs 执行树"></a>执行集 vs 执行树</h5><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-04 22.04.31.png" alt="2022-04-04 22.04.31" style="zoom:50%;"></p><ul><li><p>执行集：$Exec(S) = ⟨({s_0}^+ → s_1 → s_2)^∗ → {s_0}^ω⟩,⟨({s_0}^+ → s_1 → s_2)^ω⟩,⟨({s_0}^+ → s_1 → s_2)^+ → s_3^ω⟩$</p></li><li><p>执行树：</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-04 22.10.01.png" alt="2022-04-04 22.10.01" style="zoom:50%;"></p></li></ul><h4 id="计算树逻辑CTL"><a href="#计算树逻辑CTL" class="headerlink" title="计算树逻辑CTL"></a>计算树逻辑CTL</h4><h5 id="模型描述"><a href="#模型描述" class="headerlink" title="模型描述"></a>模型描述</h5><p>CTL 公式始终与系统的给定状态 s 相关，迹 Trace(s) 源自该状态。S 的状态构成了这个逻辑的模型。</p><p>与 LTL 的区别（从句法上讲）在于迹量词的时间运算符的出现。</p><h4 id="CTL-语义"><a href="#CTL-语义" class="headerlink" title="CTL 语义"></a>CTL 语义</h4><h5 id="CTL状态公式的语义"><a href="#CTL状态公式的语义" class="headerlink" title="CTL状态公式的语义"></a>CTL状态公式的语义</h5><h6 id="s-models-a"><a href="#s-models-a" class="headerlink" title="$ s\models a$"></a>$ s\models a$</h6><p>当且仅当 $a∈L_(s)$</p><script type="math/tex; mode=display">\frac{}{s \models a}</script><h6 id="s-models-P-land-Q"><a href="#s-models-P-land-Q" class="headerlink" title="$s\models P \land Q$"></a>$s\models P \land Q$</h6><p>当且仅当 $s\models P$ 并且 $s\models Q$</p><script type="math/tex; mode=display">\frac{s \models P \qquad s \models Q}{s \models P \land Q}</script><h6 id="s-models-P-lor-Q"><a href="#s-models-P-lor-Q" class="headerlink" title="$s \models P \lor Q$"></a>$s \models P \lor Q$</h6><p>当且仅当 $s \models P$ 或者 $s \models Q$</p><script type="math/tex; mode=display">\frac{s \models P}{s \models P \lor Q} \qquad\frac{s \models Q}{s \models P \lor Q}</script><h6 id="s-nvDash-neg-P"><a href="#s-nvDash-neg-P" class="headerlink" title="$s\nvDash \neg P$"></a>$s\nvDash \neg P$</h6><p>当且仅当 $ s\models P$</p><script type="math/tex; mode=display">\frac{s \models P}{s \nvDash \neg P}</script><h6 id="s-models-∃-φ"><a href="#s-models-∃-φ" class="headerlink" title="$s\models ∃ φ$"></a>$s\models ∃ φ$</h6><p>当且仅当 $\pi\vDash\phi$ 对于<strong>某些</strong>从s开始的路径成立</p><h6 id="s-models-forall-φ"><a href="#s-models-forall-φ" class="headerlink" title="$s\models \forall φ$"></a>$s\models \forall φ$</h6><p>当且仅当 $\pi\vDash\phi$ 对于<strong>所有</strong>从s开始的路径成立</p><h5 id="CTL路径公式的语义"><a href="#CTL路径公式的语义" class="headerlink" title="CTL路径公式的语义"></a>CTL路径公式的语义</h5><ul><li>$\pi\vDash\bigcirc P$ 当且仅当 $\pi[1]=P$</li><li>$\pi\vDash P \mathcal{U} Q$ 当且仅当<strong>存在</strong> $j\ge0$ 使得 $s_{j}\vDash Q$ 且对于 $0\le k\lt j,\pi[k]\vDash P$</li></ul><h5 id="CTL在TS上的语义"><a href="#CTL在TS上的语义" class="headerlink" title="CTL在TS上的语义"></a>CTL在TS上的语义</h5><p>对于一个CTL公式 $\phi$，它的可满足集合(satisfaction set) $Sat(\phi)$ 定义为 :</p><script type="math/tex; mode=display">Sat(\phi)=\{s\in S | s\vDash \phi\}</script><p>说白了就是一些满足CTL公式$\phi$的状态的集合</p><p>如果我们说一个TS满足CTL公式 $\phi$ , 那么当且仅当公式 $\phi$ 在所有的初始状态上成立，用公式表示为：</p><script type="math/tex; mode=display">TS\vDash\phi\text{ 当且仅当 }S_{0}\subseteq Sat(\phi) \text{ 当且仅当 }\forall s_{0}\in S_{0}.s_{0}\vDash\phi</script><p>上面的 $S_{0}$ 就是初始状态的集合</p><h5 id="全称量词-从-s-开始的任何轨迹（对于-s-状态）"><a href="#全称量词-从-s-开始的任何轨迹（对于-s-状态）" class="headerlink" title="全称量词 : 从 s 开始的任何轨迹（对于 s 状态）"></a>全称量词 : 从 s 开始的任何轨迹（对于 s 状态）</h5><p>提醒：对于迹 $\sigma$，$\sigma_i$ 是从 0 开始的 $\sigma$ 的第 i 个元素，对于状态 s，Traces(s) 是来自 s 的迹线集合）</p><h6 id="s-models-forall-bigcirc-P"><a href="#s-models-forall-bigcirc-P" class="headerlink" title="$s \models \forall \bigcirc P$"></a>$s \models \forall \bigcirc P$</h6><p> P 在下一瞬间为真</p><script type="math/tex; mode=display">\frac{\forall \sigma \in Traces(S) :a_1 \models P}{s \models \forall \bigcirc P}</script><h6 id="s-models-forall-Box-P"><a href="#s-models-forall-Box-P" class="headerlink" title="$s \models \forall \Box P$"></a>$s \models \forall \Box P$</h6><p>P 在每个状态下始终为真</p><script type="math/tex; mode=display">\frac{\forall \sigma \in Traces(S) : \forall i \ge 0 :a_i \models P}{s \models \forall \Box P}</script><h6 id="s-models-forall-Diamond-P"><a href="#s-models-forall-Diamond-P" class="headerlink" title="$s \models \forall \Diamond P$"></a>$s \models \forall \Diamond P$</h6><p>P 最终为真（未来）</p><script type="math/tex; mode=display">\frac{\forall \sigma \in Traces(S) : ∃ i \ge 0 :a_i \models P}{s \models \forall \Diamond P}</script><h6 id="s-models-P-forall-mathcal-U-Q"><a href="#s-models-P-forall-mathcal-U-Q" class="headerlink" title="$s \models P\;\forall\;\mathcal{U}\;Q$"></a>$s \models P\;\forall\;\mathcal{U}\;Q$</h6><p>P 最终为真，同时 P 仍然为真</p><script type="math/tex; mode=display">\frac{\forall \sigma \in Traces(S) : ∃ j \ge 0 :a_j \models Q \land \forall i < j : \sigma_i \models P}{s \models P\;\forall\;\mathcal{U}\;Q}</script><h5 id="存在量词-从-s-开始的至少一条迹线（对于-s-状态）"><a href="#存在量词-从-s-开始的至少一条迹线（对于-s-状态）" class="headerlink" title="存在量词 : 从 s 开始的至少一条迹线（对于 s 状态）"></a>存在量词 : 从 s 开始的至少一条迹线（对于 s 状态）</h5><h6 id="s-models-∃-bigcirc-P"><a href="#s-models-∃-bigcirc-P" class="headerlink" title="$s \models ∃ \bigcirc P$"></a>$s \models ∃ \bigcirc P$</h6><p>P 在下一瞬间为真</p><script type="math/tex; mode=display">\frac{∃ \sigma \in Traces(S) :a_1 \models P}{s \models ∃ \bigcirc P}</script><h6 id="s-models-∃-Box-P"><a href="#s-models-∃-Box-P" class="headerlink" title="$s \models ∃ \Box P$"></a>$s \models ∃ \Box P$</h6><p>P 在每个状态下始终为真</p><script type="math/tex; mode=display">\frac{∃ \sigma \in Traces(S) : \forall i \ge 0 :a_i \models P}{s \models ∃ \Box P}</script><h6 id="s-models-∃-Diamond-P"><a href="#s-models-∃-Diamond-P" class="headerlink" title="$s \models ∃ \Diamond P$"></a>$s \models ∃ \Diamond P$</h6><p>P 最终为真（未来）</p><script type="math/tex; mode=display">\frac{∃ \sigma \in Traces(S) : ∃ i \ge 0 :a_i \models P}{s \models ∃ \Diamond P}</script><h6 id="s-models-P-∃-mathcal-U-Q"><a href="#s-models-P-∃-mathcal-U-Q" class="headerlink" title="$s \models P\;∃\;\mathcal{U}\;Q$"></a>$s \models P\;∃\;\mathcal{U}\;Q$</h6><p>Q 最终为真，同时 P 仍然为真</p><script type="math/tex; mode=display">\frac{∃ \sigma \in Traces(S) : ∃ j \ge 0 :a_j \models Q \land \forall i < j : \sigma_i \models P}{s \models P\;∃\;\mathcal{U}\;Q}</script><h5 id="forall-bigcirc-，-∃-bigcirc-图解"><a href="#forall-bigcirc-，-∃-bigcirc-图解" class="headerlink" title="$\forall \bigcirc$，$∃ \bigcirc$ 图解"></a>$\forall \bigcirc$，$∃ \bigcirc$ 图解</h5><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-04 23.03.07.png" alt="2022-04-04 23.03.07" style="zoom:40%;"></p><h5 id="forall-Box-，-∃-Box-图解"><a href="#forall-Box-，-∃-Box-图解" class="headerlink" title="$\forall \Box$，$∃ \Box$ 图解"></a>$\forall \Box$，$∃ \Box$ 图解</h5><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-04 23.07.21.png" alt="2022-04-04 23.07.21" style="zoom:40%;"></p><h5 id="forall-Diamond-，-∃-Diamond-图解"><a href="#forall-Diamond-，-∃-Diamond-图解" class="headerlink" title="$\forall \Diamond$，$∃ \Diamond$ 图解"></a>$\forall \Diamond$，$∃ \Diamond$ 图解</h5><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-04 23.08.46.png" alt="2022-04-04 23.08.46" style="zoom:40%;"></p><p>$\forall \mathcal{U}$，$∃ \mathcal{U}$ 图解</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-04 23.08.46.png" alt="2022-04-04 23.08.46" style="zoom:45%;"></p><h4 id="CTL-语法"><a href="#CTL-语法" class="headerlink" title="CTL 语法"></a>CTL 语法</h4><h5 id="最小运算符"><a href="#最小运算符" class="headerlink" title="最小运算符"></a>最小运算符</h5><p>$\{ \forall \bigcirc , \forall \mathcal{U}, ∃ \mathcal{U}\} \lor \{ ∃  \bigcirc , ∃ \Box, ∃ \mathcal{U}\} \lor \{ ∃  \diamond , ∃ \mathcal{U}, ∃ \bigcirc \}$</p><ul><li>$∃ \bigcirc P \triangleq \neg \forall \neg P$</li><li>$\forall \Diamond P \triangleq True \; \forall \mathcal{U} P$</li><li>$∃ \Diamond P \triangleq True \; ∃  \mathcal{U} P$</li><li>$\forall \Box P \triangleq \neg ∃ \Diamond \neg P$</li><li>$∃ \Box P \triangleq \neg \forall \Diamond \neg P$</li></ul><h5 id="替代语法-1"><a href="#替代语法-1" class="headerlink" title="替代语法"></a>替代语法</h5><ul><li>$∀ ↔ A$ (all) </li><li>$∃ ↔ E$ (exists) </li><li>$\Box ↔ G$ (globally)</li><li>$\Diamond ↔ F$ (finally)</li><li>$\bigcirc ↔ X$ (next)</li><li>$\mathcal{U} ↔ U$ (until)</li></ul><h5 id="互补运算符-1"><a href="#互补运算符-1" class="headerlink" title="互补运算符"></a>互补运算符</h5><ul><li>$P∃ \mathcal{W}Q \triangleq ∃ \Box P \lor P ∃ \mathcal{U} Q$</li><li>$P\forall \mathcal{W}Q $ 不等于 $  \forall \Box P \lor P \forall \mathcal{U} Q$；$P\forall \mathcal{W}Q \triangleq \neg (\neg Q ∃ \mathcal{U} (\neg P \land \neg Q))$</li></ul><h5 id="否定性-1"><a href="#否定性-1" class="headerlink" title="否定性"></a>否定性</h5><p>与 LTL 不同，对于任何 CTL 属性，我们有：</p><script type="math/tex; mode=display">S \models F，或\; S \models \neg F，或\; S \nvDash F ≡ S \models ¬F。</script><p>公式的否定$ ∀, ∃, \Box, \Diamond$</p><p>对基于 $ ∀, ∃, \Box, \Diamond$ 的公式的求反只需将每个运算符反转为对偶即可。</p><p>例：</p><ul><li><p>$¬(∀ \Diamond ∃ \Box p) = ∃\Box ∀\Diamond ¬p$</p></li><li><p>$(∀\Diamond ¬s_0 ⇒ ∀\Diamond s_3) = (∃\Box s_0 ∨ ∀\Diamond s_3) \qquad 因为 (p ⇒ q) = (¬p ∨ q)$</p></li></ul><h5 id="定点定义"><a href="#定点定义" class="headerlink" title="定点定义"></a>定点定义</h5><p>一旦定义了 $∃\bigcirc$ 和 $∀\bigcirc$，每个操作符就是最小的点</p><p>其归纳定义：</p><ul><li><p>$∀ \Box f = f ∧ ∀ \bigcirc ∀ \Box f$</p></li><li><p>$∃ \Box f = f ∧ ∃ \bigcirc ∃ \Box f$</p></li><li><p>$∀ \Diamond f = f ∨ ∀ \bigcirc ∀ \Diamond \Box f$</p></li><li><p>$∃ \Diamond f = f ∨ ∃ \bigcirc ∃ \Diamond \Box f$</p></li><li><p>$f ∀ \mathcal{U} g = g ∨ (f ∧ ∀\bigcirc (f ∀ \mathcal{U} g))$</p></li><li><p>$f ∃ \mathcal{U} g = g ∨ (f ∧ ∃\bigcirc (f ∃ \mathcal{U} g))$</p><p>（对于实现模型检查器特别有用）</p></li></ul><h3 id="第八部分：-LTL-vs-CTL"><a href="#第八部分：-LTL-vs-CTL" class="headerlink" title="第八部分：$LTL \; vs \; CTL$"></a>第八部分：$LTL \; vs \; CTL$</h3><h4 id="LTL和CTL的等价"><a href="#LTL和CTL的等价" class="headerlink" title="LTL和CTL的等价"></a>LTL和CTL的等价</h4><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/20201209125629367.png" alt="20201209125629367" style="zoom:50%;"></p><p>由之前的一张图我们看到，CTL和LTL有部分的表达是有交集的，这部分既可以用LTL表达，又可以用CTL表达，那么如何形式化地定义等价这个概念呢？</p><p>如果一个LTL公式 $φ$ 和一个CTL公式 $\Phi$ 是等价的（记为 $φ\equiv\Phi$），那么当且仅当，对于AP上的TS来说</p><script type="math/tex; mode=display">TS\vDash φ\Leftrightarrow TS\vDash\Phi</script><p>例如有这些个公式是等价的</p><div class="table-container"><table><thead><tr><th style="text-align:center">CTL公式 $\Phi$</th><th style="text-align:center">LTL公式 $φ$</th></tr></thead><tbody><tr><td style="text-align:center">$a$</td><td style="text-align:center">$a$</td></tr><tr><td style="text-align:center">$ \forall\bigcirc a$</td><td style="text-align:center">$\bigcirc a$</td></tr><tr><td style="text-align:center">$\forall(a\mathcal{U}b)$</td><td style="text-align:center">$a\mathcal{U}b$</td></tr><tr><td style="text-align:center">$\forall\Box a$</td><td style="text-align:center">$\Box a$</td></tr><tr><td style="text-align:center">$\forall\Diamond a$</td><td style="text-align:center">$\Diamond a$</td></tr><tr><td style="text-align:center">$\forall(a\mathcal{W}b)$</td><td style="text-align:center">$a\mathcal{W}b$</td></tr><tr><td style="text-align:center">$\forall\Box\forall\Diamond a$</td><td style="text-align:center">$\Box\Diamond a$</td></tr></tbody></table></div><h4 id="LTL和CTL各自能表达的部分"><a href="#LTL和CTL各自能表达的部分" class="headerlink" title="LTL和CTL各自能表达的部分"></a>LTL和CTL各自能表达的部分</h4><p>由上面的文氏图我们知道，LTL和CTL的表达能力并不完全等价，因为存在着只要有各自能够表达的部分</p><p>某些LTL公式不能表示成CTL公式，例如</p><ul><li>$\Diamond\Box a$</li><li>$\Diamond(a\land\bigcirc a)$</li></ul><p>某些CTL公式不能表示成LTL公式，例如</p><ul><li>$\forall\Diamond\forall\Box a$</li><li>$ \forall\Diamond(a\land\forall\bigcirc a)$</li><li>$\forall\Box\exist\Diamond a$</li></ul><h4 id="不等价案例"><a href="#不等价案例" class="headerlink" title="不等价案例"></a>不等价案例</h4><p>$\Diamond(a\wedge\bigcirc a)$ 与 $ \forall\Diamond(a\wedge\forall\bigcirc a)$ 不等价</p><p>例如下面这张图：</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2020121517502211.png" alt="2020121517502211" style="zoom:40%;"></p><p>我们可以看到它能表示LTL公式 $ \Diamond(a\land\bigcirc a)$，但是不能表示CTL公式$\forall\Diamond(a\land\forall\bigcirc a)$，因为看到 $S_{0},S_{3}$这条路径，对于用CTL表示的 $\forall\Diamond(a\wedge\forall\bigcirc a)$ 来说，从 $S_{0}$ 的角度看，它不满足所有的下一个状态 $a$ 成立。</p><p>再看另一个例子，$\Diamond\Box a$ 和 $\forall\Diamond\forall\Box a$ 不等价</p><p>就如下图所示</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/20201215203132106.png" alt="20201215203132106" style="zoom:40%;"></p><p>它能够表示LTL公式 $\Diamond\Box a$，但是不能表示CTL公式 $\forall\Diamond\forall\Box a$，我们把它的计算树画出来</p><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/20201215204837482.png" alt="20201215204837482"></p><p>我们看到最左边的那条路径，也就是说如果走的路径为 $S_{0}S_{0}S_{0}S_{0}S_{0}S_{0}…$ S 那么就会有一条路径不满足$\forall\Diamond\forall\Box a$。</p><h4 id="模型检测的复杂度"><a href="#模型检测的复杂度" class="headerlink" title="模型检测的复杂度"></a>模型检测的复杂度</h4><p>LTL模型检测的时间复杂度为</p><script type="math/tex; mode=display">O(|TS|·2^{|\phi|})</script><p>CTL模型检测的时间复杂度为</p><script type="math/tex; mode=display">O(|TS|·|\phi|)</script>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Transition-System-变迁系统-与-TLA&quot;&gt;&lt;a href=&quot;#Transition-System-变迁系统-与-TLA&quot; class=&quot;headerlink&quot; title=&quot;Transition System(变迁系统) 与 TLA+&quot;&gt;&lt;/a&gt;Transition System(变迁系统) 与 TLA+&lt;/h2&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/&quot;&gt;本文章&lt;/a&gt;是根据法国国立高等电力技术、电子学、计算机、水力学与电信学校 (E.N.S.E.E.I.H.T.) 第八学期课程“Système de Transition”总结而来的课程笔记。碍于本人学识有限，部分叙述难免存在纰漏，请读者注意甄别。&lt;/p&gt;
&lt;p&gt;参考：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://blog.csdn.net/campsisgrandiflora/category_10509594.html&quot;&gt;系统分析与验证 - Campsisgrandiflora的博客&lt;/a&gt; &lt;/li&gt;
&lt;li&gt;《 Introduction to TLA 》- Lesie Lamport&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="课程笔记" scheme="https://dave0126.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="课程笔记" scheme="https://dave0126.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    <category term="系统" scheme="https://dave0126.github.io/tags/%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="TLA+" scheme="https://dave0126.github.io/tags/TLA/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发多线程编程 (JUC) (三)</title>
    <link href="https://dave0126.github.io/2022/03/28/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-3/"/>
    <id>https://dave0126.github.io/2022/03/28/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-3/</id>
    <published>2022-03-28T20:37:36.000Z</published>
    <updated>2022-03-28T20:44:51.888Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-并发多线程编程"><a href="#Java-并发多线程编程" class="headerlink" title="Java 并发多线程编程"></a>Java 并发多线程编程</h2><p>视频课程: <a href="https://www.bilibili.com/video/BV16J411h7Rd?p=50">BiliBili - 黑马程序员Java并发编程 JUC</a></p><p>笔记参考: <a href="https://nyimac.gitee.io/2020/06/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发 - Nyima’s Blog</a></p><ul><li>注：本课程笔记基于JDK8，采用lsf4j打印日志</li></ul><span id="more"></span><h3 id="4-共享模型之内存"><a href="#4-共享模型之内存" class="headerlink" title="4 共享模型之内存"></a>4 共享模型之内存</h3><p>上一章讲解的 Monitor 主要关注的是访问共享变量时，保证临界区代码的原子性</p><p>这一章我们将进一步学习共享变量在多线程间的【可见性】问题与多条指令执行时的【有序性】问题</p><h4 id="4-1-Java-内存模型"><a href="#4-1-Java-内存模型" class="headerlink" title="4.1 Java 内存模型"></a>4.1 Java 内存模型</h4><p>JMM 即 Java Memory Model，它定义了<strong>主存（共享内存）、工作内存（线程私有）</strong>抽象概念，底层对应着 CPU 寄存器、缓存、硬件内存、 CPU 指令优化等。</p><p><strong>JMM体现在以下几个方面</strong></p><ul><li>原子性 - 保证指令不会受到线程上下文切换的影响</li><li>可见性 - 保证指令不会受 cpu 缓存的影响</li><li>有序性 - 保证指令不会受 cpu 指令并行优化的影响</li></ul><p>更新中。。。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Java-并发多线程编程&quot;&gt;&lt;a href=&quot;#Java-并发多线程编程&quot; class=&quot;headerlink&quot; title=&quot;Java 并发多线程编程&quot;&gt;&lt;/a&gt;Java 并发多线程编程&lt;/h2&gt;&lt;p&gt;视频课程: &lt;a href=&quot;https://www.bilibili.com/video/BV16J411h7Rd?p=50&quot;&gt;BiliBili - 黑马程序员Java并发编程 JUC&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;笔记参考: &lt;a href=&quot;https://nyimac.gitee.io/2020/06/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/&quot;&gt;Java并发 - Nyima’s Blog&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注：本课程笔记基于JDK8，采用lsf4j打印日志&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="JUC" scheme="https://dave0126.github.io/categories/JUC/"/>
    
    
    <category term="Java" scheme="https://dave0126.github.io/tags/Java/"/>
    
    <category term="JUC" scheme="https://dave0126.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发多线程编程 (JUC) (二)</title>
    <link href="https://dave0126.github.io/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/"/>
    <id>https://dave0126.github.io/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/</id>
    <published>2022-03-26T14:38:56.000Z</published>
    <updated>2022-03-28T20:48:00.059Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-并发多线程编程"><a href="#Java-并发多线程编程" class="headerlink" title="Java 并发多线程编程"></a>Java 并发多线程编程</h2><p>视频课程: <a href="https://www.bilibili.com/video/BV16J411h7Rd?p=50">BiliBili - 黑马程序员Java并发编程 JUC</a></p><p>笔记参考: <a href="https://nyimac.gitee.io/2020/06/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发 - Nyima’s Blog</a></p><ul><li>注：本课程笔记基于JDK8，采用lsf4j打印日志</li></ul><span id="more"></span><h3 id="3-共享模型-之-管程"><a href="#3-共享模型-之-管程" class="headerlink" title="3 共享模型 之 管程"></a>3 共享模型 之 管程</h3><h4 id="3-1-共享带来的问题"><a href="#3-1-共享带来的问题" class="headerlink" title="3.1 共享带来的问题"></a>3.1 共享带来的问题</h4><p>JAVA代码中的体现</p><p>两个线程对初始值为0的全局静态变量, 一个做自增操作, 一个做自减操作, 各执行5000次, 最终的结果是0吗?</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">5000</span>; i++)&#123;</span><br><span class="line">      counter++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">5000</span>; i++)&#123;</span><br><span class="line">      counter--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  t1.start();</span><br><span class="line">  t2.start();</span><br><span class="line">  t1.join();</span><br><span class="line">  t2.join();</span><br><span class="line">  </span><br><span class="line">  Log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, counter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果大概率不为<code>0</code></p><pre class="mermaid">sequenceDiagram    participant 线程1    participant 线程2    participant 静态变量 i    静态变量 i ->> 线程2 :getstatic i 读取0    线程2 ->> 线程2 :iconst_1 准备常数 1    线程2 ->> 线程2 :isub 减法, 线程内 i= -1    线程2 -x 静态变量 i :!!!还没来得及将i的结果写入    线程2 -->> 线程1 :上下文切换    线程1 ->> 线程1 :iconst_1 准备常数 1    线程1 ->> 线程1 :iadd 加法, 线程内 i= 1    线程1 ->> 静态变量 i :putstatic i 写入 1    线程1 -->> 线程2 :上下文切换    线程2 ->> 静态变量 i :putstatic i 写入 -1</pre><p>最终结果为<code>-1</code>.</p><h5 id="3-1-1-临界区-Critical-Section"><a href="#3-1-1-临界区-Critical-Section" class="headerlink" title="3.1.1 临界区 Critical Section"></a>3.1.1 临界区 Critical Section</h5><ul><li>一个程序运行多个线程本身是没有问题的</li><li>问题出在多个线程访问共享资源<ul><li>多个线程读共享资源其实也没有问题</li><li>在多个线程对共享资源读写操作时发生指令交错，就会出现问题</li></ul></li><li>一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为<strong>临界区</strong></li></ul><p>例如，下面代码中的临界区</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 临界资源</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> </span><br><span class="line"><span class="comment">// 临界区 </span></span><br><span class="line">&#123;   </span><br><span class="line">    counter++; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> </span><br><span class="line"><span class="comment">// 临界区 </span></span><br><span class="line">&#123; </span><br><span class="line">    counter--; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-1-2-竞态条件-Race-Condition"><a href="#3-1-2-竞态条件-Race-Condition" class="headerlink" title="3.1.2 竞态条件 Race Condition"></a>3.1.2 竞态条件 Race Condition</h5><p>多个线程在<strong>临界区</strong>内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了<strong>竞态条件</strong></p><h4 id="3-2-Synchronized-解决方案"><a href="#3-2-Synchronized-解决方案" class="headerlink" title="3.2 Synchronized 解决方案"></a>3.2 Synchronized 解决方案</h4><h5 id="3-2-1-解决手段"><a href="#3-2-1-解决手段" class="headerlink" title="3.2.1 解决手段"></a>3.2.1 解决手段</h5><p>为了避免临界区的竞态条件发生，有多种手段可以达到目的。</p><ul><li>【阻塞式】的解决方案：synchronized，Lock</li><li>【非阻塞式】的解决方案：原子变量</li></ul><p>本次课使用阻塞式的解决方案：<strong>synchronized</strong>，来解决上述问题，即俗称的<strong>【对象锁】</strong>，它采用互斥的方式让同一 时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住(blocked)。这样就能保证拥有锁 的线程可以安全的执行临界区内的代码，不用担心线程上下文切换</p><h5 id="3-2-2-Synchronized-语法"><a href="#3-2-2-Synchronized-语法" class="headerlink" title="3.2.2 Synchronized 语法"></a>3.2.2 Synchronized 语法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(Object) &#123; <span class="comment">// 例如, 当线程1持有锁时, 线程2被阻塞; 等待线程1释放锁</span></span><br><span class="line"><span class="comment">//临界区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举例如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line"><span class="comment">//创建一个公共对象，作为对象锁的对象</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;    </span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;            </span><br><span class="line">        <span class="keyword">synchronized</span> (room) &#123; <span class="comment">// 上锁</span></span><br><span class="line">        counter++;            </span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;    </span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;       </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;         </span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123; <span class="comment">// 上锁</span></span><br><span class="line">            counter--;          </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    t1.start();    </span><br><span class="line">    t2.start(); </span><br><span class="line">    t1.join();   </span><br><span class="line">    t2.join();    </span><br><span class="line">    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,counter); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序流程如下图: </p><pre class="mermaid">sequenceDiagram    participant 线程1    participant 线程2    participant 静态变量 i    participant 🔒锁对象    线程2 ->> 🔒锁对象 :尝试获取锁    Note over 🔒锁对象,线程2 :拥有锁    静态变量 i ->> 线程2 :getstatic i 读取0    线程2 ->> 线程2 :iconst_1 准备常数 1    线程2 ->> 线程2 :isub 减法, 线程内 i= 0-1 = -1    线程2 -->> 线程1 :上下文切换    线程1 ->> 🔒锁对象 :尝试获取锁, 但是被阻塞(BLOCKED)    线程1 -->> 线程2 :上下文切换    线程2 ->> 静态变量 i :putstatic i 写入 -1    Note over 🔒锁对象,线程2 :拥有锁    线程2 ->> 🔒锁对象 :释放锁, 并唤醒阻塞的线程    Note over 🔒锁对象,线程1 :拥有锁    静态变量 i ->> 线程1 :getstatic i 读取-1    线程1 ->> 线程1 :iconst_1 准备常数 1    线程1 ->> 线程1 :iadd 加法, 线程内 i= -1+1 = 0    线程1 ->> 静态变量 i :putstatic i 写入 0    Note over 🔒锁对象,线程1 :拥有锁    线程1 ->> 🔒锁对象 :释放锁, 并唤醒阻塞的线程</pre><p><strong>思考</strong></p><p>Synchronized 实际是用<strong>对象锁</strong>保证了<strong>临界区内代码的原子性</strong>, 临界区内的代码对外是不可分割的, 不会被线程切换所打断. </p><p>将上一个代码块的例子解藕, 使其资源类和任务类分开:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Room</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">      counter++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">      counter--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCounter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">  <span class="type">Room</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Room</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;            </span><br><span class="line">      room.increment();</span><br><span class="line">    &#125;    </span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;       </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">          room.decrement();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    t1.start();    </span><br><span class="line">    t2.start(); </span><br><span class="line">    t1.join();   </span><br><span class="line">    t2.join();    </span><br><span class="line">    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,room.getCounter()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-2-3-Synchronized-在方法上"><a href="#3-2-3-Synchronized-在方法上" class="headerlink" title="3.2.3 Synchronized 在方法上"></a>3.2.3 Synchronized 在方法上</h5><p>我们必须知道, <strong><code>Synchronized</code> 锁住的始终是对象</strong>. 以下两个例子看似是与方法有关, 实则依然是为对象加锁.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*1. 在成员方法上*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123; <span class="comment">// 锁住this对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*2. 在静态方法上*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Test.class) &#123; <span class="comment">// 锁住Test类对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意:</strong></p><ul><li><code>sleep()</code> 方法不会释放锁</li></ul><h4 id="3-3-变量的线程安全分析"><a href="#3-3-变量的线程安全分析" class="headerlink" title="3.3 变量的线程安全分析"></a>3.3 变量的线程安全分析</h4><h5 id="3-3-1-成员变量和静态变量的线程安全分析"><a href="#3-3-1-成员变量和静态变量的线程安全分析" class="headerlink" title="3.3.1 成员变量和静态变量的线程安全分析"></a>3.3.1 成员变量和静态变量的线程安全分析</h5><ul><li>如果没有变量没有在线程间共享，那么变量是安全的</li><li>如果变量在线程间共享<ul><li>如果只有读操作，则线程安全</li><li>如果有读写操作，则这段代码是临界区，需要考虑线程安全</li></ul></li></ul><h5 id="3-3-2-局部变量线程安全分析"><a href="#3-3-2-局部变量线程安全分析" class="headerlink" title="3.3.2 局部变量线程安全分析"></a>3.3.2 局部变量线程安全分析</h5><p>1) 局部变量【局部变量被初始化为基本数据类型】是<strong>安全</strong>的</p><ol><li><strong>局部变量引用的对象未必</strong>是安全的</li></ol><ul><li>如果局部变量引用的对象没有引用线程共享的对象，那么是线程安全的</li><li>如果局部变量引用的对象引用了一个线程共享的对象，那么要考虑线程安全的</li></ul><ol><li>局部变量是线程安全的——每个方法都在对应线程的栈中创建栈帧，不会被其他线程共享</li></ol><p><img src="/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/20200608144636.png" alt="20200608144636" style="zoom:75%;"></p><ol><li>如果局部变量<a href="https://dave0126.github.io/2022/03/22/JVM-2/#1-3-%E4%BA%94%E7%A7%8D%E5%BC%95%E7%94%A8">引用的对象</a>被共享，且执行了读写操作，则<strong>线程不安全</strong></li></ol><p><img src="/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/20200608144649.png" alt="20200608144649" style="zoom:60%;"></p><ol><li>如果是局部变量，则会在<a href="https://dave0126.github.io/2022/03/22/JVM-1/#4-%E5%A0%86">堆</a>中创建对应的对象，不会存在线程安全问题。</li></ol><p><img src="/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/20200608144702.png" alt="20200608144702" style="zoom:60%;"></p><h5 id="3-3-3-常见线程安全类"><a href="#3-3-3-常见线程安全类" class="headerlink" title="3.3.3 常见线程安全类"></a>3.3.3 常见线程安全类</h5><ul><li>String</li><li>Integer</li><li>StringBuffer</li><li>Random</li><li>Vector</li><li>Hashtable</li><li>java.util.concurrent 包下的类 </li></ul><p>这里说它们是线程安全的是指，多个线程调用它们同一个实例的某个方法时，是线程安全的。也可以理解为</p><ul><li>它们的每个方法是原子的</li><li>但多个方法组合在一起就不是原子的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Hashtable</span> <span class="variable">table</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line"><span class="comment">// thread1, thread2</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"> <span class="keyword">if</span> (table.get(<span class="string">&quot;key&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">  table.put(<span class="string">&quot;key&quot;</span>,value1)</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"> <span class="keyword">if</span> (table.get(<span class="string">&quot;key&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">  table.put(<span class="string">&quot;key&quot;</span>,value2)</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre class="mermaid">sequenceDiagram    participant 线程1    participant 线程2    participant table    线程1 ->> table :get("key") == null    线程2 ->> table :get("key") == null    线程2 ->> table :put("key", value2)    线程1 ->> table :put("key", value1)</pre><h5 id="3-3-4-不可变类线程安全性"><a href="#3-3-4-不可变类线程安全性" class="headerlink" title="3.3.4 不可变类线程安全性"></a>3.3.4 不可变类线程安全性</h5><p>String、Integer 等都是<strong>不可变类</strong>，因为其内部的状态不可以改变，因此它们的方法都是线程安全的</p><p><strong>思考:</strong></p><p>Q 问: String 有 replace，substring 等方法可以改变值，那么这些方法又是如何保证线程安全的呢？</p><p>A 答: 这是因为这些方法的返回值都<strong>创建了一个新的对象</strong>，而不是直接改变String、Integer对象本身。</p><h5 id="3-3-5-习题"><a href="#3-3-5-习题" class="headerlink" title="3.3.5 习题"></a>3.3.5 习题</h5><p>找出临界区代码，加锁</p><ul><li>买票：BiliBili - 黑马程序员全面深入学习Java并发编程，JUC并发编程全套教程 <a href="https://www.bilibili.com/video/BV16J411h7Rd?p=71">买票问题</a></li><li>转账：BiliBili - 黑马程序员全面深入学习Java并发编程，JUC并发编程全套教程 <a href="https://www.bilibili.com/video/BV16J411h7Rd?p=74">转账问题</a></li></ul><h4 id="3-4-Monitor"><a href="#3-4-Monitor" class="headerlink" title="3.4 Monitor"></a>3.4 Monitor</h4><h5 id="3-4-1-Monitor原理"><a href="#3-4-1-Monitor原理" class="headerlink" title="3.4.1 Monitor原理"></a>3.4.1 Monitor原理</h5><p>Monitor 又称为监视器或<strong>管程</strong>, 是Synchronized实现的底层原理, 由<strong>操作系统提供</strong></p><p>每个Java对象都会关联一个Monitor对象, 如果使用synchronized关键字给对象上锁 (重量级) 之后, 该对象与Monitor关联.</p><p><img src="/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/20200608144917.png" alt="20200608144917"></p><ul><li>刚开始时, Monitor 的 Owner 为 null</li><li>当线程执行到临界区代码时，如果使用了synchronized，会先查询synchronized中所指定的对象(obj)<strong>是否绑定了Monitor</strong>。<ul><li>如果<strong>没有绑定</strong>，则会先去去与Monitor绑定，并且将Owner设为当前线程。</li><li>如果已经绑定，则会去查询该Monitor是否已经有了Owner<ul><li>如果没有，则Owner与将当前线程绑定</li><li>如果有，则放入EntryList，进入阻塞状态(blocked)</li></ul></li></ul></li><li>当Monitor的Owner将临界区中代码执行完毕后，Owner便会被清空，此时EntryList中处于<strong>阻塞</strong>状态的线程会被<strong>叫醒并竞争</strong>，此时的竞争是<strong>非公平的</strong></li><li><strong>注意</strong>：<ul><li>对象在使用了synchronized后与Monitor绑定时，会将对象头中的<strong>Mark Word</strong>置为Monitor指针。</li><li>每个对象都会绑定一个<strong>唯一的Monitor</strong>，如果synchronized中所指定的对象(obj)<strong>不同</strong>，则会绑定<strong>不同</strong>的Monitor</li></ul></li></ul><h5 id="3-4-2-轻量级锁"><a href="#3-4-2-轻量级锁" class="headerlink" title="3.4.2 轻量级锁"></a>3.4.2 轻量级锁</h5><p><strong>轻量级锁使用场景：</strong>当一个对象被多个线程所访问，但访问的时间是<strong>错开的（不存在竞争）</strong>，此时就可以使用<strong>轻量级锁</strong>来优化。</p><p>因为重量级锁由操作系统提供, 使用时系统开销较大, 所以在使用 synchronized 时优先使用轻量级锁</p><p>轻量级锁对使用者是透明的, 即语法依然是<code>synchronized</code>, 优先使用轻量级锁, 如若失败则改用其他类型</p><ul><li>创建<strong>锁记录</strong>（Lock Record）对象，每个线程的栈帧都会包含一个锁记录对象，内部可以存储锁定对象的mark word(不再一开始就使用Monitor)</li></ul><p><img src="/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/20200608144942.png" alt="20200608144942" style="zoom:75%;"></p><ul><li>让锁记录中的Object reference指向锁对象（Object），并尝试用cas去替换Object中的mark word，将此mark word放入lock record中保存</li></ul><p><img src="/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/20200608144950.png" alt="20200608144950" style="zoom:75%;"></p><ul><li>如果cas替换成功，则将Object的对象头替换为<strong>锁记录的地址</strong>和<strong>状态 00（轻量级锁状态）</strong>，并由该线程给对象加锁</li></ul><p><img src="/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/20200608144957.png" alt="20200608144957" style="zoom:75%;"></p><ul><li><p>如果cas失败, 有两种情况:</p><ul><li>如果是其他线程已经持有了该Object的轻量级锁, 这时表明有竞争, 进入下一小节的<strong>锁膨胀</strong>过程</li><li>如果是自己执行了synchronized<strong>锁重入</strong>, 那么再添加一条Lock Record 作为重入的计数</li></ul><p><img src="/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/image-20220326175731138-8313862.png" alt="image-20220326175731138" style="zoom:75%;"></p></li><li><p>当退出Synchronized (解锁) 时, 如果有取值为null的锁记录, 表示有重入, 这时重置锁记录, 表示重入计数 -1</p></li></ul><p><img src="/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/20200608144957.png" alt="20200608144957" style="zoom:75%;"></p><ul><li>当退出Synchronized (解锁)锁记录的值为不为null时, 这时使用cas将 Mark Word 的值恢复给对象头<ul><li>成功, 则解锁成功</li><li>失败, 说明轻量级锁进行了锁膨胀或者已经升级为重量级锁, 进入重量级锁解锁流程</li></ul></li></ul><h5 id="3-4-3-锁膨胀"><a href="#3-4-3-锁膨胀" class="headerlink" title="3.4.3 锁膨胀"></a>3.4.3 锁膨胀</h5><ul><li>如果一个线程在给一个对象加轻量级锁时，<strong>cas替换操作失败</strong>（因为此时其他线程已经给对象加了轻量级锁），此时该线程就会进入<strong>锁膨胀</strong>过程</li></ul><p><img src="/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/20200608145004.png" alt="20200608145004" style="zoom:75%;"></p><ul><li>此时便会给对象加上重量级锁 (使用Monitor)<ul><li>将对象头的Mark Word改为Monitor的地址，并且状态改为01(重量级锁)</li><li>并且该线程放入Monitor 的 EntryList中，并进入阻塞状态(blocked)</li></ul></li></ul><p><img src="/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/20200608145148.png" alt="20200608145148" style="zoom:75%;"></p><ul><li>当线程退出同步块解锁时, 使用cas将 Mark Word 的值恢复给对象头, 失败. 这是会进入重量级解锁流程, 即按照Monitor地址找到Monitor对象, 设置Owner 为 null, 唤醒EntryList中的BLOCKED线程</li></ul><h5 id="3-4-4-自旋优化"><a href="#3-4-4-自旋优化" class="headerlink" title="3.4.4 自旋优化"></a>3.4.4 自旋优化</h5><p><strong>重量级锁</strong>竞争时，还可以使用自旋来优化(在多核心cpu中才有意义)，如果当前线程在<strong>自旋成功</strong>（使用锁的线程退出了同步块，<strong>释放了锁</strong>，即当前线程可以直接成为新的Owner），这时就可以避免线程进入阻塞状态。</p><h6 id="自旋成功的情况"><a href="#自旋成功的情况" class="headerlink" title="自旋成功的情况"></a>自旋成功的情况</h6><pre class="mermaid">sequenceDiagram    participant t1 as 线程1(cpu1)    participant obj as Obj    participant t2 as 线程2    Note over obj :10 (重量级锁)    t1 ->> +obj :访问同步块， 获取 Monitor    t1 ->> obj :成功加锁    Note over obj :10 (重量级锁) 重量级锁指针    t2 -x obj :访问同步块， 获取 Monitor    t2 ->> t2 :自旋重试    Note over t1 :执行临界区代码块    t2 ->> t2 :自旋重试    obj ->> -t1 :成功解锁    Note over obj :01 (无锁)    t2 ->> +obj :成功加锁    Note over obj :10 (重量级锁) 重量级锁指针    Note over t2 :执行临界区代码块    obj ->> -t2 : 成功解锁</pre><h6 id="自旋重试失败的情况"><a href="#自旋重试失败的情况" class="headerlink" title="自旋重试失败的情况"></a>自旋重试失败的情况</h6><pre class="mermaid">sequenceDiagram    participant t1 as 线程1(cpu1)    participant obj as Obj    participant t2 as 线程2    Note over obj :10 (重量级锁)    t1 ->> +obj :访问同步块， 获取 Monitor    t1 ->> obj :成功加锁    Note over obj :10 (重量级锁) 重量级锁指针    t2 -x obj :访问同步块， 获取 Monitor    t2 ->> t2 :自旋重试    Note over t1 :执行临界区代码块    t2 ->> t2 :自旋重试    t2 ->> t2 :自旋重试    t2 ->> t2 :自旋重试    Note over t2 :阻塞    obj ->> -t1 :成功解锁    Note over obj :01 (无锁)</pre><h5 id="3-4-5-偏向锁"><a href="#3-4-5-偏向锁" class="headerlink" title="3.4.5 偏向锁"></a>3.4.5 偏向锁</h5><p>轻量级锁在没有竞争时，每次<strong>重入</strong>（该线程执行的方法中再次锁住该对象）操作仍需要cas替换操作，这样是会使性能降低的。</p><p>所以引入了<strong>偏向锁</strong>对性能进行优化：在<strong>第一次</strong>cas时会将<strong>线程的ID</strong>写入对象的Mark Word中。此后发现这个线程ID就是自己的，就表示没有竞争，就不需要再次cas，以后只要不发生竞争，这个对象就归该线程所有。</p><p>（相当于在临界资源上刻上进程的名字， 该资源归此进程所有）</p><h6 id="偏向状态"><a href="#偏向状态" class="headerlink" title="偏向状态"></a>偏向状态</h6><ul><li>Normal：一般状态，没有加任何锁，前面62位保存的是对象的信息，<strong>最后2位为状态（01），倒数第三位表示是否使用偏向锁（未使用：0）</strong></li><li>Biased：偏向状态，使用偏向锁，前面54位保存的当前线程的ID，<strong>最后2位为状态（01），倒数第三位表示是否使用偏向锁（使用：1）</strong></li><li>Lightweight：使用轻量级锁，前62位保存的是锁记录的指针，<strong>最后两位为状态（00）</strong></li><li>Heavyweight：使用重量级锁，前62位保存的是Monitor的地址指针，<strong>后两位为状态(10)</strong></li></ul><p><img src="/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/20200608145101.png" alt="img" style="zoom:75%;"></p><ul><li>如果开启了偏向锁（默认开启），在创建对象时，对象的Mark Word后三位应该是101</li><li>但是偏向锁默认是<strong>有延迟</strong>的，不会再程序一启动就生效，而是会在程序运行一段时间（几秒之后），才会对创建的对象设置为偏向状态</li><li>如果没有开启偏向锁，对象的Mark Word后三位应该是001</li></ul><h6 id="撤销偏向"><a href="#撤销偏向" class="headerlink" title="撤销偏向"></a>撤销偏向</h6><p>以下几种情况会使对象的偏向锁失效</p><ul><li>调用对象的hashCode方法</li><li>多个线程使用该对象</li><li><strong>调用了wait/notify方法</strong>（调用wait方法会导致锁膨胀而使用<strong>重量级锁</strong>）</li></ul><h6 id="批量重偏向"><a href="#批量重偏向" class="headerlink" title="批量重偏向"></a>批量重偏向</h6><ul><li>如果对象虽然被多个线程访问，但是线程间不存在竞争，这时偏向T1的对象仍有机会重新偏向T2<ul><li>重偏向会重置Thread ID</li></ul></li><li>当撤销超过20次后（超过阈值），JVM会觉得是不是偏向错了，这时会在给对象加锁时，重新偏向至加锁线程。</li></ul><h6 id="批量撤销"><a href="#批量撤销" class="headerlink" title="批量撤销"></a>批量撤销</h6><p>当撤销偏向锁的阈值超过40以后，就会将<strong>整个类的对象都改为不可偏向的</strong></p><h4 id="3-5-Wait-Notify"><a href="#3-5-Wait-Notify" class="headerlink" title="3.5 Wait / Notify"></a>3.5 Wait / Notify</h4><p><img src="/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/20200608144917.png" alt="20200608144917" style="zoom:75%;"></p><ul><li><p>Owner线程发现执行条件不满足，锁对象调用<code>wait()</code>方法（obj.wait），就会使当前线程进入WaitSet中，变为<code>WAITING</code>状态。</p></li><li><p>处于<code>BLOCKED</code>和<code>WAITING</code>状态的线程都为阻塞</p><p>状态，CPU都不会分给他们时间片。但是有所区别：</p><ul><li><strong><code>BLOCKED</code>状态的线程是在竞争对象</strong>时，发现Monitor的Owner已经是别的线程了，此时就会进入EntryList中，并处于BLOCKED状态</li><li><strong><code>WAITING</code>状态的线程是获得了对象的锁</strong>，但是自身因为某些原因需要进入阻塞状态时，锁对象调用了<code>wait()</code>方法而进入了WaitSet中，处于<code>WAITING</code>状态</li></ul></li><li><p>BLOCKED状态的线程会在锁被释放的时候被唤醒，但是处于<code>WAITING</code>状态的线程只有被锁对象调用了<code>notify()</code>或<code>notifyAll()</code>方法(obj.notify/obj.notifyAll)，才会被唤醒。</p></li></ul><h5 id="3-5-1-API介绍"><a href="#3-5-1-API介绍" class="headerlink" title="3.5.1 API介绍"></a>3.5.1 API介绍</h5><ol><li><code>obj.wait()</code>：让进入Monitor的线程到waitSet等待</li><li><code>obj.wait(long timeout)</code> 让进入obj监视器的线程到waitSet<strong>等待 timeout时间长度</strong>，继续执行</li><li><code>obj.notify()</code>：在object上正在waitSet等待的线程中<strong>挑一个</strong>唤醒</li><li><code>obj.notifyAll()</code>：在object上正在waitSet等待的线程<strong>全部</strong>唤醒</li></ol><p>注意⚠️：他们都是线程之间进行协作的手段，都属于Object对象的方法。<strong>必须获得此对象的锁</strong>，才能调用这几个方法。<strong>只有当对象被锁以后，才能调用wait和notify方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span> ();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span> (() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.wait(); <span class="comment">// 让线程t1在lock上一直等待下去</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span> (() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.wait(); <span class="comment">// 让线程t2在lock上一直等待下去</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123; <span class="comment">// 主线程</span></span><br><span class="line">        lock.notify(); <span class="comment">// 随机唤醒一个</span></span><br><span class="line">        lock.notifyAll(); <span class="comment">// 唤醒所有</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-5-2-wait-和sleep-的区别"><a href="#3-5-2-wait-和sleep-的区别" class="headerlink" title="3.5.2 wait() 和sleep()的区别"></a>3.5.2 wait() 和sleep()的区别</h5><ul><li><p>不同点：</p><ol><li>从API角度：sleep是Thread的静态方法，wait是所有对象（Object）的方法</li><li>sleep不用与synchronized一起用，wait需要与synchronized一起用</li><li>sleep<strong>不会释放锁</strong>，wait在等待时<strong>会释放锁</strong></li></ol></li><li><p>相同点：</p><ol><li>进入的线程状态都是TIMED_WAITING</li></ol></li></ul><p>为了解决wait的虚假唤醒，代码结构如下：(while)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">   <span class="keyword">while</span> (条件不成立) &#123;</span><br><span class="line">       lock.wait();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个线程</span></span><br><span class="line"><span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">    lock.notify();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestCorrectPosture&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCorrectPostureStep4</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasCigarette</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasTakeout</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">                <span class="keyword">while</span> (!hasCigarette) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        room.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">                <span class="keyword">if</span> (hasCigarette) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没干成活...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                log.debug(<span class="string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);</span><br><span class="line">                <span class="keyword">while</span> (!hasTakeout) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没外卖，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        room.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);</span><br><span class="line">                <span class="keyword">if</span> (hasTakeout) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没干成活...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小女&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                hasTakeout = <span class="literal">true</span>;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖到了噢！&quot;</span>);</span><br><span class="line">                room.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;送外卖的&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-6-同步模式-之-保护性暂停"><a href="#3-6-同步模式-之-保护性暂停" class="headerlink" title="3.6 同步模式 之 保护性暂停"></a>3.6 同步模式 之 保护性暂停</h4><p>即Guarded Suspension，用于一个线程等待另一个线程的执行结果时。如下图。</p><p><img src="/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/image-20220327195520317-8403730.png" alt="image-20220327195520317" style="zoom:67%;"></p><p>要点：</p><ul><li>有一个结果想从一个线程传递到另一个线程，可以让他们关联同一个GuardedObject</li><li>如果有结果不断的从一个结果到另一个结果，那么可以使用<strong>消息队列</strong>（见消费者/生产者）</li><li>JDK中，<code>join()</code>的实现、<code>future</code>的实现，采用的就是该模式</li><li>因为要等待另一方的结果，因此归类到该模式</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="string">&quot;hello thread!&quot;</span>;</span><br><span class="line"><span class="type">Guarded</span> <span class="variable">guarded</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Guarded</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// thread 1</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;想要得到结果&quot;</span>);</span><br><span class="line"><span class="keyword">synchronized</span> (guarded) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;结果是：&quot;</span>+guarded.getResponse());</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;得到结果&quot;</span>);</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//thread 2</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">System.out.println(<span class="string">&quot;设置结果&quot;</span>);</span><br><span class="line"><span class="keyword">synchronized</span> (guarded) &#123;</span><br><span class="line">guarded.setResponse(hello);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Guarded</span> &#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 要返回的结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> Object response;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//优雅地使用wait/notify</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getResponse</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//如果返回结果为空就一直等待，避免虚假唤醒</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line"><span class="keyword">while</span>(response == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="built_in">this</span>.wait();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setResponse</span><span class="params">(Object response)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.response = response;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line"><span class="comment">//唤醒休眠的线程</span></span><br><span class="line"><span class="built_in">this</span>.notifyAll();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;Guarded&#123;&quot;</span> +</span><br><span class="line"><span class="string">&quot;response=&quot;</span> + response +</span><br><span class="line"><span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>带超时判断的暂停</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改上面代码块中的 getResponse() 方法</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getResponse</span><span class="params">(<span class="type">long</span> time)</span> &#123;</span><br><span class="line"><span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line"><span class="comment">//获取开始时间</span></span><br><span class="line"><span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line"><span class="comment">//用于保存已经等待了的时间</span></span><br><span class="line"><span class="type">long</span> <span class="variable">passedTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(response == <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//看经过的时间-开始时间是否超过了指定时间</span></span><br><span class="line"><span class="type">long</span> <span class="variable">waitTime</span> <span class="operator">=</span> time -passedTime;</span><br><span class="line"><span class="keyword">if</span>(waitTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">                   <span class="comment">//等待剩余时间</span></span><br><span class="line"><span class="built_in">this</span>.wait(waitTime);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取当前时间</span></span><br><span class="line">passedTime = System.currentTimeMillis()-currentTime</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-6-1-join-：使用保护性暂停模式"><a href="#3-6-1-join-：使用保护性暂停模式" class="headerlink" title="3.6.1 join()：使用保护性暂停模式"></a>3.6.1 join()：使用保护性暂停模式</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis - now;</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay);</span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="3-6-2-扩展-Future"><a href="#3-6-2-扩展-Future" class="headerlink" title="3.6.2 扩展 - Future"></a>3.6.2 扩展 - Future</h5><p>图中的Future就好比居民楼一楼的信箱（每个信箱都有自己的编号），左边的t0，t2，t4就好比等待邮件的居民，右侧的t1，t3，t5就好比邮递员。</p><p>如果需要再多个雷之间使用GuardedObject对象，作为参数传递不是很方便，因此设计一个用来解耦的中间类，这样不仅可以解耦【结果等待者】和【结果生产者】，还能够同时支持多个任务的处理。</p><p><img src="/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/image-20220327202425832-8405470.png" alt="image-20220327202425832" style="zoom:67%;"></p><h4 id="3-7-异步模式-之-生产者-消费者"><a href="#3-7-异步模式-之-生产者-消费者" class="headerlink" title="3.7 异步模式 之 生产者/消费者"></a>3.7 异步模式 之 生产者/消费者</h4><h5 id="3-7-1-要点"><a href="#3-7-1-要点" class="headerlink" title="3.7.1 要点"></a>3.7.1 要点</h5><ul><li>与前面的保护性暂停中的 Guardobject 不同，不需要产生结果和消费结果的线程一一对应</li><li>消费队列可以用来平衡生产和消费的线程资源</li><li>生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据</li><li>消息队列是有容量限制的，满时不会再加入数据（生产者阻塞），空时不会再消耗数据（消费者阻塞）</li><li>JDK 中各种阻塞队列，采用的就是这种模式</li></ul><p><img src="/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/image-20220327204404520-8406649.png" alt="image-20220327204404520"></p><p>如上图所示，左边的三个线程是生产者，右边的是消费者。</p><h5 id="3-7-2-实现"><a href="#3-7-2-实现" class="headerlink" title="3.7.2 实现"></a>3.7.2 实现</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MessageQueue</span> &#123;</span><br><span class="line">  <span class="comment">// 消息的队列集合</span></span><br><span class="line">  <span class="keyword">private</span> LinkedList&lt;Message&gt;list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">  <span class="comment">// 队列容量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> capcity;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Message <span class="title function_">take</span><span class="params">()</span> &#123; <span class="comment">// 取消息</span></span><br><span class="line">  <span class="comment">// 检查队列是否为空</span></span><br><span class="line">    <span class="keyword">synchronized</span>(list)&#123;</span><br><span class="line">      <span class="keyword">while</span>(list.isEmply())&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;消息队列为空，消费者等待\n&quot;</span>);</span><br><span class="line">          list.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">      <span class="comment">// 从队列头获取消息并返回</span></span><br><span class="line">      <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> list.removeFrist();</span><br><span class="line">      System.out.println(<span class="string">&quot;已经消费一个消息\n&quot;</span> +message);</span><br><span class="line">      list.notifyAll();</span><br><span class="line">      <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Message message)</span> &#123; <span class="comment">// 存消息</span></span><br><span class="line">    <span class="comment">// 检查队列是否已满</span></span><br><span class="line">    <span class="keyword">synchronized</span>(list)&#123;</span><br><span class="line">      <span class="keyword">while</span>(list.size() == capcity) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;消息队列已满，生产者等待\n&quot;</span>);</span><br><span class="line">          list.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将消息加入队列尾部</span></span><br><span class="line">      list.addLast(message);</span><br><span class="line">      System.out.println(<span class="string">&quot;已经生产了一个消息：\n&quot;</span> +message);</span><br><span class="line">      list.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Message</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">  <span class="keyword">private</span> Object value;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Message</span> <span class="params">(<span class="type">int</span> id, Object value)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.id;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Message: id:&quot;</span>+id+<span class="string">&quot;, value:&quot;</span>+value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(<span class="number">2</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">      queue.put(<span class="keyword">new</span> <span class="title class_">Message</span>(id, <span class="string">&quot;value&quot;</span>+id));</span><br><span class="line">    &#125;, <span class="string">&quot;生产者&quot;</span>+i).start();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">      <span class="type">Message</span> <span class="variable">massage</span> <span class="operator">=</span> queue.take();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="string">&quot;消费者&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-8-Park-amp-Unpark"><a href="#3-8-Park-amp-Unpark" class="headerlink" title="3.8 Park &amp; Unpark"></a>3.8 Park &amp; Unpark</h4><h5 id="3-8-1-基本使用"><a href="#3-8-1-基本使用" class="headerlink" title="3.8.1 基本使用"></a>3.8.1 基本使用</h5><p><strong>park/unpark都是LockSupport类中的的方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暂停线程运行</span></span><br><span class="line">LockSupport.park;</span><br><span class="line"></span><br><span class="line"><span class="comment">//恢复线程运行</span></span><br><span class="line">LockSupport.unpark(thread);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;park&quot;</span>);</span><br><span class="line">      <span class="comment">//暂停线程运行</span></span><br><span class="line">LockSupport.park();</span><br><span class="line">System.out.println(<span class="string">&quot;resume&quot;</span>);</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">thread.start();</span><br><span class="line"></span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;unpark&quot;</span>);</span><br><span class="line">    <span class="comment">//恢复线程运行</span></span><br><span class="line">LockSupport.unpark(thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-8-2-特点"><a href="#3-8-2-特点" class="headerlink" title="3.8.2 特点"></a>3.8.2 特点</h5><p><strong>与wait/notify的区别</strong></p><ul><li>wait，notify 和 notifyAll 必须配合<strong>Object Monitor</strong>一起使用，而park，unpark不必</li><li>park ，unpark 是以<strong>线程为单位</strong>来<strong>【阻塞】</strong>和<strong>【唤醒】</strong>线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么【精确】</li><li>park &amp; unpark 可以<strong>先 unpark</strong>，而 wait &amp; notify 不能先 notify</li><li><strong>park不会释放锁</strong>，而wait会释放锁</li></ul><h5 id="3-8-3-原理"><a href="#3-8-3-原理" class="headerlink" title="3.8.3 原理"></a>3.8.3 原理</h5><p>每个线程都有一个自己的<strong>Park对象</strong>，并且该对象<code>_counter</code>,  <code>_cond</code>, <code>_mutex</code>组成</p><ul><li><p>先调用park再调用unpark时</p><ol><li>先调用park<ul><li>线程运行时，会将Park对象中<code>_counter</code>的值设为0；</li><li>调用park时，会先查看<code>_counter</code>的值是否为0，如果为0，则将线程放入阻塞队列<code>_cond</code>中</li><li>放入阻塞队列中后，会<strong>再次</strong>将<code>_counter</code>设置为0</li></ul></li></ol><p><img src="/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/20200608145250.png" alt="20200608145250" style="zoom:70%;"></p><ol><li>然后调用unpark<ul><li>调用unpark方法后，会将<code>_counter</code>的值设置为1</li><li>去唤醒阻塞队列<code>_cond</code>中的线程</li><li>线程继续运行并将<code>_counter</code>的值设为0</li></ul></li></ol><p><img src="/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/20200608145303.png" alt="20200608145303" style="zoom:60%;"></p></li><li><p>先调用unpark，再调用park</p><ol><li><p>调用unpark</p><ul><li>会将<code>_counter</code>设置为1（运行时0）</li></ul></li><li><p>调用park方法</p><ul><li>查看<code>_counter</code>是否为0</li><li>因为unpark已经把<code>_counter</code>设置为1，所以此时将<code>_counter</code>设置为0，但<strong>不放入</strong>阻塞队列<code>_cond</code>中</li></ul></li></ol></li></ul><p><img src="/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/20200608145313.png" alt="20200608145313" style="zoom:60%;"></p><h4 id="3-9-线程状态转换"><a href="#3-9-线程状态转换" class="headerlink" title="3.9 线程状态转换"></a>3.9 线程状态转换</h4><p><img src="/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/20200608144621-8409900.png" alt="20200608144621" style="zoom:75%;"></p><h5 id="情况一：NEW-gt-RUNNABLE"><a href="#情况一：NEW-gt-RUNNABLE" class="headerlink" title="情况一：NEW --&gt; RUNNABLE"></a>情况一：<code>NEW --&gt; RUNNABLE</code></h5><ul><li>当调用了<code>t.start()</code>方法时，由<code>NEW</code> –&gt; <code>RUNNABLE</code></li></ul><h5 id="情况二：RUNNABLE-lt-gt-WAITING"><a href="#情况二：RUNNABLE-lt-gt-WAITING" class="headerlink" title="情况二：RUNNABLE &lt;--&gt; WAITING"></a>情况二：<code>RUNNABLE &lt;--&gt; WAITING</code></h5><ul><li>当调用了t 线程用 <code>synchronized(obj)</code> 获取了对象锁后<ul><li>调用 <code>obj.wait()</code> 方法时，t 线程从 <code>RUNNABLE</code> –&gt;<code>WAITING</code></li><li>调用 <code>obj.notify()</code> ， <code>obj.notifyAll()</code> ，<code>t.interrupt()</code> 时<ul><li>竞争锁成功，t 线程从 <code>WAITING</code> –&gt; <code>RUNNABLE</code></li><li>竞争锁失败，t 线程从 <code>WAITING</code> –&gt; <code>BLOCKED</code></li></ul></li></ul></li></ul><h5 id="情况三：RUNNABLE-lt-gt-WAITING"><a href="#情况三：RUNNABLE-lt-gt-WAITING" class="headerlink" title="情况三：RUNNABLE &lt;--&gt; WAITING"></a>情况三：<code>RUNNABLE &lt;--&gt; WAITING</code></h5><ul><li><p>当前线程</p><p>调用 <code>t.join()</code> 方法时，当前线程从 <code>RUNNABLE</code> –&gt; <code>WAITING</code></p><ul><li>注意是<strong>当前线程</strong>在t 线程对象的监视器上等待</li></ul></li><li><p>t 线程<strong>运行结束</strong>，或调用了<strong>当前线程</strong>的 <code>interrupt()</code> 时，当前线程从 <code>WAITING</code> –&gt; <code>RUNNABLE</code></p></li></ul><h5 id="情况四：-RUNNABLE-lt-gt-WAITING"><a href="#情况四：-RUNNABLE-lt-gt-WAITING" class="headerlink" title="情况四： RUNNABLE &lt;--&gt; WAITING"></a>情况四： <code>RUNNABLE &lt;--&gt; WAITING</code></h5><ul><li>当前线程调用 <code>LockSupport.park()</code> 方法会让当前线程从 <code>RUNNABLE</code> –&gt; <code>WAITING</code></li><li>调用 <code>LockSupport.unpark(目标线程)</code> 或调用了线程 的 <code>interrupt()</code> ，会让目标线程从 <code>WAITING</code> –&gt; <code>RUNNABLE</code></li></ul><h5 id="情况五：-RUNNABLE-lt-gt-TIMED-WAITING"><a href="#情况五：-RUNNABLE-lt-gt-TIMED-WAITING" class="headerlink" title="情况五： RUNNABLE &lt;--&gt; TIMED_WAITING"></a>情况五： <code>RUNNABLE &lt;--&gt; TIMED_WAITING</code></h5><p>t 线程用 <code>synchronized(obj)</code> 获取了对象锁后</p><ul><li>调用 <code>obj.wait(long n)</code> 方法时，t 线程从 <code>RUNNABLE</code> –&gt; <code>TIMED_WAITING</code></li><li>t 线程等待时间超过了 n 毫秒，或调用 <code>obj.notify()</code>， <code>obj.notifyAll()</code> ，<code>t.interrupt()</code> 时<ul><li>竞争锁成功，t 线程从 <code>TIMED_WAITING</code> –&gt; <code>RUNNABLE</code></li><li>竞争锁失败，t 线程从 <code>TIMED_WAITING</code> –&gt; <code>BLOCKED</code></li></ul></li></ul><h5 id="情况六：RUNNABLE-lt-gt-TIMED-WAITING"><a href="#情况六：RUNNABLE-lt-gt-TIMED-WAITING" class="headerlink" title="情况六：RUNNABLE &lt;--&gt; TIMED_WAITING"></a>情况六：<code>RUNNABLE &lt;--&gt; TIMED_WAITING</code></h5><ul><li>当前线程调用 <code>t.join(long n)</code> 方法时，当前线程从 <code>RUNNABLE</code> –&gt; <code>TIMED_WAITING</code><ul><li>注意是当前线程在t 线程对象的监视器上等待</li></ul></li><li>当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 <code>interrupt()</code> 时，当前线程从 <code>TIMED_WAITING</code> –&gt; <code>RUNNABLE</code></li></ul><h5 id="情况七：RUNNABLE-lt-gt-TIMED-WAITING"><a href="#情况七：RUNNABLE-lt-gt-TIMED-WAITING" class="headerlink" title="情况七：RUNNABLE &lt;--&gt; TIMED_WAITING"></a>情况七：<code>RUNNABLE &lt;--&gt; TIMED_WAITING</code></h5><ul><li>当前线程调用 <code>Thread.sleep(long n)</code>，当前线程从 <code>RUNNABLE</code> –&gt; <code>TIMED_WAITING</code></li><li>当前线程等待时间超过了 n 毫秒，当前线程从 <code>TIMED_WAITING</code> –&gt; <code>RUNNABLE</code></li></ul><h5 id="情况八：RUNNABLE-lt-gt-TIMED-WAITING"><a href="#情况八：RUNNABLE-lt-gt-TIMED-WAITING" class="headerlink" title="情况八：RUNNABLE &lt;--&gt; TIMED_WAITING"></a>情况八：<code>RUNNABLE &lt;--&gt; TIMED_WAITING</code></h5><ul><li>当前线程调用 <code>LockSupport.parkNanos(long nanos)</code> 或 <code>LockSupport.parkUntil(long millis)</code> 时，当前线 程从 <code>RUNNABLE</code>–&gt; <code>TIMED_WAITING</code></li><li>调用 <code>LockSupport.unpark(目标线程)</code> 或调用了线程 的 <code>interrupt()</code> ，或是等待超时，会让目标线程从 <code>TIMED_WAITING</code> –&gt; <code>RUNNABLE</code></li></ul><h5 id="情况九：RUNNABLE-lt-gt-BLOCKED"><a href="#情况九：RUNNABLE-lt-gt-BLOCKED" class="headerlink" title="情况九：RUNNABLE &lt;--&gt; BLOCKED"></a>情况九：<code>RUNNABLE &lt;--&gt; BLOCKED</code></h5><ul><li>t 线程用 <code>synchronized(obj)</code> 获取了对象锁时如果<strong>竞争失败</strong>，从 <code>RUNNABLE</code> –&gt; <code>BLOCKED</code></li><li>持 obj 锁线程的同步代码块执行完毕，会唤醒该对象上所有 <code>BLOCKED</code> 的线程重新竞争，如果其中 t 线程竞争 成功，从 <code>BLOCKED</code> –&gt; <code>RUNNABLE</code> ，其它<strong>失败</strong>的线程仍然 <code>BLOCKED</code></li></ul><h5 id="情况十：-RUNNABLE-lt-gt-TERMINATED"><a href="#情况十：-RUNNABLE-lt-gt-TERMINATED" class="headerlink" title="情况十： RUNNABLE &lt;--&gt; TERMINATED"></a>情况十： <code>RUNNABLE &lt;--&gt; TERMINATED</code></h5><p>当前线<strong>程所有代码运行完毕</strong>，进入 <code>TERMINATED</code></p><h4 id="3-10-多把锁"><a href="#3-10-多把锁" class="headerlink" title="3.10 多把锁"></a>3.10 多把锁</h4><p><strong>将锁的粒度细分</strong></p><p>例如一套房子中有多个房间，书房和卧室的功能毫不相干。所以我们可以把锁分别加在卧室和书房上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BigRoom</span> &#123;</span><br><span class="line">    <span class="comment">//额外创建对象来作为锁</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">studyRoom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">bedRoom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-11-线程的活跃性"><a href="#3-11-线程的活跃性" class="headerlink" title="3.11 线程的活跃性"></a>3.11 线程的活跃性</h4><h5 id="3-11-1-死锁"><a href="#3-11-1-死锁" class="headerlink" title="3.11.1 死锁"></a>3.11.1 死锁</h5><p>有这样的情况：一个线程需要<strong>同时获取多把锁</strong>，这时就容易发生死锁</p><p>如：</p><ul><li><code>t1线程</code> 获得 <code>A对象锁</code>，接下来想获取 <code>B对象的锁</code></li><li><code>t2线程</code> 获得 <code>B对象锁</code>，接下来想获取 <code>A对象的锁</code></li></ul><p>在并发环境下，各进程因竞争资源而造成的一种<strong>互相等待对方手里的资源，导致各进程都阻塞，都无法向前推进的现象</strong>，就是死锁。</p><p>每个人都占有一个资源，同时又在等待另一个人手里的资源。发生“死锁”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">Object</span> <span class="variable">A</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">final</span> <span class="type">Object</span> <span class="variable">B</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;TODO&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;TODO&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="发生死锁的必要条件"><a href="#发生死锁的必要条件" class="headerlink" title="发生死锁的必要条件"></a>发生死锁的必要条件</h6><ul><li><p><strong>死锁产生的必要条件：</strong></p><ol><li><p>互斥条件：只有对必须互斥使用的资源的争抢才会产生死锁。</p></li><li><p>不可剥夺条件：进程所获得的资源在未使用完之前，不能<strong>由其他进程强行夺走</strong></p></li><li><p>请求和保持条件：进程已经<strong>保持了至少一个资源</strong>，但<strong>又提出了新的资源请求</strong>，而该资源又被其他进程占有，此时请求进程被阻塞，但又<strong>对自己已有的资源保持不放</strong></p></li><li><p>循环等待条件：存在一种进程</p><p>资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。</p><ul><li><strong>死锁 -&gt; 一定有循环等待； 循环等待 不一定 发生死锁</strong></li></ul></li></ol></li><li><p><strong>预防死锁：</strong> 破坏<strong>死锁产生的必要条件</strong>，即可预防死锁。</p></li></ul><h6 id="避免死锁的方法"><a href="#避免死锁的方法" class="headerlink" title="避免死锁的方法"></a>避免死锁的方法</h6><p>在线程使用锁对象时<strong>，顺序加锁</strong>即可避免死锁。线程1按顺序获得A，B对象的锁：</p><pre class="mermaid">sequenceDiagram    participant t1 as 线程1    participant t2 as 线程2    participant obj1 as 对象1    participant obj2 as 对象2    t1 -->> obj1 : 尝试获取锁    Note over t1,obj1 :拥有锁    t2 --x obj1 : 尝试获取锁（失败）    t2 -->> obj1 : 阻塞    t1 -->> obj2 : 尝试获取锁    Note over t1,obj2 :拥有锁</pre><h5 id="3-11-2-活锁"><a href="#3-11-2-活锁" class="headerlink" title="3.11.2 活锁"></a>3.11.2 活锁</h5><p>活锁出现在两个线程<strong>互相改变对方的结束条件</strong>，后谁也无法结束。</p><h6 id="避免活锁的方法"><a href="#避免活锁的方法" class="headerlink" title="避免活锁的方法"></a>避免活锁的方法</h6><p>在线程执行时，中途给予<strong>不同的间隔时间</strong>即可。</p><h6 id="死锁与活锁的区别"><a href="#死锁与活锁的区别" class="headerlink" title="死锁与活锁的区别"></a>死锁与活锁的区别</h6><ul><li>死锁是因为线程互相持有对象想要的锁，并且都不释放，最后到时<strong>线程阻塞</strong>，<strong>停止运行</strong>的现象。</li><li>活锁是因为线程间修改了对方的结束条件，而导致代码<strong>一直在运行</strong>，却一直<strong>运行不完</strong>的现象。</li></ul><h5 id="3-11-3-饥饿"><a href="#3-11-3-饥饿" class="headerlink" title="3.11.3 饥饿"></a>3.11.3 饥饿</h5><p>某些线程因为优先级太低，导致一直无法获得资源的现象。</p><p>为了避免死锁而使用顺序加锁时，可能会出现饥饿现象</p><h5 id="3-11-4-死锁、饥饿和死循环的异同点"><a href="#3-11-4-死锁、饥饿和死循环的异同点" class="headerlink" title="3.11.4 死锁、饥饿和死循环的异同点"></a>3.11.4 死锁、饥饿和死循环的异同点</h5><div class="table-container"><table><thead><tr><th></th><th>共同点</th><th>区别</th></tr></thead><tbody><tr><td>死锁</td><td>都是进程无法顺利向前推进的现象</td><td>死锁一定是“循环等待对方手里的资源”导致的，因此如果有死锁现象，那<strong>至少有两个或两个以上的进程同时发生死锁</strong>。另外，发生死锁的进程一定处于阻塞态</td></tr><tr><td>饥饿</td><td><strong>可能只有一个进程发生饥饿</strong>。发生饥饿的进程可能是阻塞态（如长期得不到需要的IO设备），也可能是就绪态（长期得不到处理机）</td><td></td></tr><tr><td>死循环</td><td>可能只有一个进程发生死循环。死循环可以是运行态，只不过无法继续推进。死锁和饥饿是由于操作系统分配资源的策略不合理导致的，而死循环是由代码逻辑错误导致的。<strong>死锁和饥饿是管理者(操作系统)的问题，死循环是被管理者的问题。</strong></td></tr></tbody></table></div><h5 id="3-11-5-预防死锁-静态策略"><a href="#3-11-5-预防死锁-静态策略" class="headerlink" title="3.11.5 预防死锁 - 静态策略"></a>3.11.5 预防死锁 - 静态策略</h5><h6 id="3-11-5-1-资源分配图（Graphe-d’allocation）"><a href="#3-11-5-1-资源分配图（Graphe-d’allocation）" class="headerlink" title="3.11.5.1 资源分配图（Graphe d’allocation）"></a>3.11.5.1 资源分配图（Graphe d’allocation）</h6><ul><li>两种结点<ul><li>进程结点：对应一个进程</li><li>资源结点：对应一类资源，一类资源可能有多个。（一般用矩形代表资源结点，矩形中的小圆圈代表该类资源的数量）</li></ul></li><li>两种边：<ul><li>进程结点 -&gt; 资源结点：<strong>请求边</strong>，表示进程<strong>想申请几个资源</strong>（一条边代表一个）</li><li>资源结点 -&gt; 进程结点：<strong>分配边</strong>，表示<strong>已经为进程分配了几个资源</strong></li></ul></li></ul><pre class="mermaid">graph LR  A(P1) --> B  B[R2:2] --> C  C(P2) --> D  D[R1:3] --> C  D --> A  D --> A</pre><p>如果系统中剩余的可用资源数足够满足进程的需求，那么这个进程暂时是不会阻塞的，可以顺利地执行下去。</p><pre class="mermaid">graph LR;  A(P1)   B[R2:2] --> C  C(P2) --> D  D[R1:3] --> C</pre><p>如果这个进程执行结束了把资源归还系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去。<br>相应的，这些被激活的进程执行完了之后又会归还一些资源，这样可能又会激活另外一些阻塞的进程….</p><pre class="mermaid">graph TB;  A(P1)   B[R2:2]  C(P2)  D[R1:3]</pre><p>如果按上述过程分析，最终<strong>能消除所有边</strong>，就称这个图是<strong>可完全简化的</strong>。此时一定<strong>没有发生死锁</strong>（相当于能找到一个安全序列）</p><p>另一个例子：</p><pre class="mermaid">graph LR;  A(P1)  B[R2:2]  C(P2)  D[R1:3]  E(P3)  E --> B  A --> B  A --> B  B --> C  C --> D  D --> C  D --> A  D --> A</pre><p>如果最终<strong>不能消除所有边</strong>，那么此时就是<strong>发生了死锁</strong>。 <strong>最终没有被消除的边所连的进程就发生了死锁</strong>。</p><h6 id="3-11-5-2-死锁的解除"><a href="#3-11-5-2-死锁的解除" class="headerlink" title="3.11.5.2 死锁的解除"></a>3.11.5.2 死锁的解除</h6><p>用死锁检测算法化简资源分配图后，还连着边的那此进程就是死锁进程。 解除死锁的主要方法有：</p><ol><li>资源剥夺法。挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</li><li>撤销进程法（或称终止进程法）。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源，这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，己经接近结束了，旦被终止可谓功亏一篑，以后还得从头再来。</li><li>进程回退法。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统耍记录进程的历史信息，设置还原点</li></ol><h5 id="3-11-6-避免死锁-动态策略"><a href="#3-11-6-避免死锁-动态策略" class="headerlink" title="3.11.6 避免死锁 - 动态策略"></a>3.11.6 避免死锁 - 动态策略</h5><h6 id="3-11-6-1-安全序列"><a href="#3-11-6-1-安全序列" class="headerlink" title="3.11.6.1 安全序列"></a>3.11.6.1 安全序列</h6><p>所谓<strong>安全序列</strong>，就是值如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是<strong>安全状态</strong>。当然，<strong>安全序列可能有多个</strong>。<br>如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了<strong>不安全状态</strong>。这就意味着之后<strong>可能</strong>所有进程都无法顺利的进行下去。当然，如果有进程提前归还了一些资源，那系统也<strong>有可能重新回到安全状态</strong>，不过我们在分配资源之前总是要考虑到最坏的情况。</p><p>因此可以<strong>在资源分配之前前预判这次分配是否会导致系统进入不安全状态</strong>，一次决定是否答应资源分配的请求。这也是“<strong>银行家算法</strong>”的核心思想。</p><h6 id="3-11-6-2-银行家算法"><a href="#3-11-6-2-银行家算法" class="headerlink" title="3.11.6.2 银行家算法"></a>3.11.6.2 银行家算法</h6><p>假设系统中有<code>n</code>个进程，<code>m</code>种资源每个进程在运行前先声明对各种资源的最大需求数，则可用一个<code>n*m</code>的矩阵（可用二维数组实现） 表示所有进程对各种资源的最大需求数。不妨称为<strong>最大需求矩阵</strong> <code>Max</code>， <code>Max[i,j] = K</code> 表示进程<code>P_i</code>最多需要K个资源<code>R_j</code>。同理，系统可以用一个<code>n*m</code> 的<strong>分配矩阵 Allocation</strong> 表示对所有进程的资源分配情况。<code>Max - Allocation = Need</code> 矩阵，表示各进程最多还需要多少各类资源。<br>另外，还要用一个长度为<code>m</code>的一维数组 <code>Available(...)</code> 表示当前系统中<strong>还有多少可用资源</strong><br>某进程pi向系统申请资源，可用1个长度为<code>m</code>的一维数组 <code>Request(...)</code>， 表示<strong>本次申请的各种资源量</strong>。</p><div class="table-container"><table><thead><tr><th>进程</th><th>最大需求(Max 矩阵)</th><th>已分配(Allocation 矩阵)</th><th>最多还需要(Need 矩阵)</th></tr></thead><tbody><tr><td>P0</td><td>(7,5,3)</td><td>(0,1,0)</td><td>(7,4,3)</td></tr><tr><td>P1</td><td>(3,2,2)</td><td>(2,0,0)</td><td>(1,2,2)</td></tr><tr><td>P2</td><td>(9,0,2)</td><td>(3,0,2)</td><td>(6,0,0)</td></tr><tr><td>P3</td><td>(2,2,2)</td><td>(2,1,1)</td><td>(0,1,1)</td></tr><tr><td>P4</td><td>(4,3,3)</td><td>(0,0,2)</td><td>(4,3,1)</td></tr></tbody></table></div><p>可用<strong>银行家算法</strong>预判本次分配是否会导致系统进入不安全状态：</p><ol><li>如果 <code>Request_i[j] &lt; Need[i,j] (0 &lt;= j &lt; m)</code>便转向②：否则认为出错</li><li>如果 <code>Request_i[j] &lt; Available[i,j] (0 &lt;= j &lt; m)</code>，便转向③：否则表示尚无足够资源，p必须等待</li><li>系统试探着把资源分配给进程Pi，并修改相应的数据（并非真的分配，修改数值只是为了做预判)：<ul><li><code>Available = Available - Request_j;</code></li><li><code>Allocation[i,j] = Allocation[i,j] + Request_i[j];</code></li><li><code>Need[i,j] = Need[i,j] - Request_i[j]</code></li></ul></li><li>操作系统执行<strong>安全性算法</strong>，检查此次资源分配后，系统是<strong>否处于安全状态</strong>。若安全，才正式分配;否则，恢复相应数据，让进程阻塞等待。</li></ol><p>银行家算法步骤：</p><ol><li>检查此次申请是否超过了之前声明的最大需求数</li><li>检查此时系统剩余的可用资源是否还能满足这次请求</li><li>试探着分配，更改各数据结构</li><li>用安全性算法检查此次分配是否会导致系统进入不安全状态</li></ol><p>安全性算法步骤： 检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该讲程持有的资源全部回收。 不断重复上述过程，看最终是否能让所有进程都加入安全序列。</p><h4 id="3-12-ReentrantLock-可重入锁"><a href="#3-12-ReentrantLock-可重入锁" class="headerlink" title="3.12 ReentrantLock (可重入锁)"></a>3.12 ReentrantLock (可重入锁)</h4><p><strong>和synchronized相比具有的的特点</strong></p><ul><li>可被别的线程中断</li><li>可以设置超时时间</li><li>可以设置为公平锁 (先到先得)</li><li>支持多个条件变量( 具有<strong>多个</strong>waitSet)</li></ul><h5 id="3-12-1-基本语法"><a href="#3-12-1-基本语法" class="headerlink" title="3.12.1 基本语法"></a>3.12.1 基本语法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取ReentrantLock对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">//加锁</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//需要执行的代码</span></span><br><span class="line">&#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">//释放锁</span></span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-12-2-可重入"><a href="#3-12-2-可重入" class="headerlink" title="3.12.2 可重入"></a>3.12.2 可重入</h5><ul><li>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁</li><li>如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">    method1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123; </span><br><span class="line">    lock.lock(); <span class="comment">// 锁的重入</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;execute method1&quot;</span>); </span><br><span class="line">        method2(); <span class="comment">// 调用method2</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">finally</span> &#123; </span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123; </span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;execute method2&quot;</span>); </span><br><span class="line">        method3(); <span class="comment">// 调用method3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; </span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span> &#123; </span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;execute method3&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; </span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">17:59:11.862 [main] c.TestReentrant - execute method1</span><br><span class="line">17:59:11.865 [main] c.TestReentrant - execute method2</span><br><span class="line">17:59:11.865 [main] c.TestReentrant - execute method3</span><br></pre></td></tr></table></figure><h5 id="3-12-3-可打断"><a href="#3-12-3-可打断" class="headerlink" title="3.12.3 可打断"></a>3.12.3 可打断</h5><p>被动避免死等。</p><p>如果某个线程处于阻塞状态，可以调用其interrupt方法让其停止阻塞，获得锁失败</p><p><strong>简而言之</strong>就是：处于阻塞状态的线程，被打断了就不用阻塞了，直接停止运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); </span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;启动...&quot;</span>); </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有竞争，那么此方法就会获得lock对象锁</span></span><br><span class="line">        <span class="comment">// 如果有竞争就进入阻塞队列，可以被其他进程用 interrupt 方法打断</span></span><br><span class="line">        lock.lockInterruptibly(); <span class="comment">// 可中断锁</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace(); </span><br><span class="line">        log.debug(<span class="string">&quot;等锁的过程中被打断&quot;</span>); </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获得了锁&quot;</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">lock.lock(); </span><br><span class="line">log.debug(<span class="string">&quot;获得了锁&quot;</span>); </span><br><span class="line">t1.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    t1.interrupt(); <span class="comment">// 执行中断</span></span><br><span class="line">    log.debug(<span class="string">&quot;执行打断&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">finally</span> &#123; </span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">18:02:40.520 [main] c.TestInterrupt - 获得了锁 </span><br><span class="line">18:02:40.524 [t1] c.TestInterrupt - 启动... </span><br><span class="line">18:02:41.530 [main] c.TestInterrupt - 执行打断</span><br><span class="line">java.lang.InterruptedException</span><br><span class="line">    at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchr onizer.java:898)</span><br><span class="line">    at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchron izer.java:1222)</span><br><span class="line">    at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:335) at cn.itcast.n4.reentrant.TestInterrupt.lambda$main$0(TestInterrupt.java:17)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">18:02:41.532 [t1] c.TestInterrupt - 等锁的过程中被打断</span><br></pre></td></tr></table></figure><p>注意如果是不可中断模式，那么即使使用了 <code>interrupt</code> 也不会让等待中断</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;启动...&quot;</span>);</span><br><span class="line">    lock.lock(); <span class="comment">// 普通锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获得了锁&quot;</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">lock.lock(); </span><br><span class="line">log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    t1.interrupt(); <span class="comment">// 执行中断</span></span><br><span class="line">    log.debug(<span class="string">&quot;执行打断&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">finally</span> &#123; </span><br><span class="line">    log.debug(<span class="string">&quot;释放了锁&quot;</span>); </span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">18:06:56.261 [main] c.TestInterrupt - 获得了锁</span><br><span class="line">18:06:56.265 [t1] c.TestInterrupt - 启动...</span><br><span class="line">18:06:57.266 [main] c.TestInterrupt - 执行打断 // 这时 t1 并没有被真正打断, 而是仍继续等待锁</span><br><span class="line">18:06:58.267 [main] c.TestInterrupt - 释放了锁</span><br><span class="line">18:06:58.267 [t1] c.TestInterrupt - 获得了锁</span><br></pre></td></tr></table></figure><h5 id="3-12-4-锁超时"><a href="#3-12-4-锁超时" class="headerlink" title="3.12.4 锁超时"></a>3.12.4 锁超时</h5><p>主动避免死等</p><p>使用<strong>lock.tryLock</strong>方法会返回获取锁是否成功。如果成功则返回true，反之则返回false。</p><p>并且tryLock方法可以<strong>指定等待时间</strong>，参数为：<code>tryLock(long timeout, TimeUnit unit)</code>, 其中<code>timeout</code>为最长等待时间，<code>TimeUnit</code>为时间单位</p><p><strong>简而言之</strong>就是：获取失败了、获取超时了或者被打断了，不再阻塞，直接停止运行</p><p>例：不设置等待时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); </span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;启动...&quot;</span>); </span><br><span class="line">    <span class="keyword">if</span> (!lock.tryLock()) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获取立刻失败，返回&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; </span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line">log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">t1.start(); </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    sleep(<span class="number">2</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">18:15:02.918 [main] c.TestTimeout - 获得了锁</span><br><span class="line">18:15:02.921 [t1] c.TestTimeout - 启动...</span><br><span class="line">18:15:02.921 [t1] c.TestTimeout - 获取立刻失败，返回</span><br></pre></td></tr></table></figure><p>例：设置等待时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">//判断获取锁是否成功，最多等待1秒</span></span><br><span class="line"><span class="keyword">if</span>(!lock.tryLock(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;获取失败&quot;</span>);</span><br><span class="line"><span class="comment">//获取失败，不再向下执行，直接返回</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line"><span class="comment">//被打断，不再向下执行，直接返回</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;得到了锁&quot;</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// TODO : 临界区代码</span></span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">t1.start();</span><br><span class="line"><span class="comment">//打断等待</span></span><br><span class="line">t1.interrupt();</span><br><span class="line">Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">lock.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-12-5-公平锁"><a href="#3-12-5-公平锁" class="headerlink" title="3.12.5 公平锁"></a>3.12.5 公平锁</h5><p>在线程获取锁失败，进入阻塞队列时，<strong>先进入</strong>的会在锁被释放后<strong>先获得</strong>锁。这样的获取方式就是<strong>公平</strong>的。但会降低并发度。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认是不公平锁，需要在创建时指定为公平锁</span></span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="type">boolean</span> fair);</span><br></pre></td></tr></table></figure><h5 id="3-12-6-条件变量"><a href="#3-12-6-条件变量" class="headerlink" title="3.12.6 条件变量"></a>3.12.6 条件变量</h5><p>synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入waitSet 等待</p><p>ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持<strong>多个</strong>条件变量的，这就好比</p><ul><li>synchronized 是那些不满足条件的线程都在一间休息室等消息</li><li>而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒</li></ul><p>使用要点：</p><ul><li><code>await()</code> 前需要<strong>获得锁</strong></li><li><code>await()</code> 执行后，会释放锁，进入 conditionObject 等待</li><li>await 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁</li><li>竞争 lock 锁成功后，从 await 后继续执行</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">// 创建新的条件变量（休息室）</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">condition1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">condition2</span> <span class="operator">=</span> lock.newCondition(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line"></span><br><span class="line">    condition1.await(); <span class="comment">// 进入“休息室”等待</span></span><br><span class="line"></span><br><span class="line">    condition1.signal(); <span class="comment">// 从“休息室”唤醒</span></span><br><span class="line"></span><br><span class="line">    condition1.signalAll();<span class="comment">// 从“休息室”唤醒所有</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestCorrectPosture&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCorrectPostureStep4</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasCigarette</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasTakeout</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">ROOM</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">  <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">waitCigaretteSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Condition</span>();</span><br><span class="line">  <span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">waitTakeOutSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Condition</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            ROOM.lock();</span><br><span class="line">          <span class="keyword">try</span>&#123;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">                <span class="keyword">while</span> (!hasCigarette) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        waitCigaretteSet.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              ROOM.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            ROOM.lock();</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);</span><br><span class="line">                <span class="keyword">while</span> (!hasTakeout) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没外卖，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        waitTakeOutSet.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              ROOM.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小女&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            ROOM.lock();</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">                hasTakeout = <span class="literal">true</span>;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖到了噢！&quot;</span>);</span><br><span class="line">                waitTakeOutSet.signal();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              ROOM.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;送外卖的&quot;</span>).start();</span><br><span class="line">      </span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            ROOM.lock();</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">                hasTakeout = <span class="literal">true</span>;</span><br><span class="line">                log.debug(<span class="string">&quot;烟到了噢！&quot;</span>);</span><br><span class="line">                waitCigaretteSet.signal();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              ROOM.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;送烟的&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">15:34:20.249 c.Test24[小女] - 外卖送到没？ [false]</span><br><span class="line">15:34:20.260 c.Test24[小女] - 没外卖，先歇会！</span><br><span class="line">15:34:20.303 c.Test24[小南] - 有烟没？[false]</span><br><span class="line">15:34:20.303 c.Test24[小南] - 没烟，先歇会！</span><br><span class="line">15:34:21.238 c.Test24[小女] - 可以开始干活了</span><br><span class="line">15:34:22.241 c.Test24[小南] - 可以开始干活了</span><br></pre></td></tr></table></figure><h4 id="3-13-同步模式-之-顺序控制"><a href="#3-13-同步模式-之-顺序控制" class="headerlink" title="3.13 同步模式 之 顺序控制"></a>3.13 同步模式 之 顺序控制</h4><h5 id="3-13-1-固定运行顺序"><a href="#3-13-1-固定运行顺序" class="headerlink" title="3.13.1 固定运行顺序"></a>3.13.1 固定运行顺序</h5><p>比如先打印“2”，再打印“1”</p><h6 id="wait-notify-方法"><a href="#wait-notify-方法" class="headerlink" title="wait / notify 方法"></a><code>wait / notify 方法</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="comment">//判断先执行的内容是否执行完毕</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">Boolean</span> <span class="variable">t2Runned</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line"><span class="keyword">while</span> (!t2Runned) &#123; <span class="comment">// 判断 2 是否打印过</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">LOCK.wait();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"><span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">t2Runned = <span class="literal">true</span>;</span><br><span class="line">LOCK.notify(); <span class="comment">//执行完毕，唤醒所有等待线程</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="park-unpark方法"><a href="#park-unpark方法" class="headerlink" title="park / unpark方法"></a><code>park / unpark方法</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span> (() -&gt; &#123;</span><br><span class="line">    LockSupport.park();</span><br><span class="line">    System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">  &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">  </span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span> (() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    LockSupport.unpark(t1);</span><br><span class="line">  &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="3-13-2-交替输出"><a href="#3-13-2-交替输出" class="headerlink" title="3.13.2 交替输出"></a>3.13.2 交替输出</h5><p>线程 1 输出a 5次，线程2输出b 5次，线程3 输出c 5次。现在要求输出 abcabcabcabcabc 怎么实现？</p><h6 id="wait-notify-方法-1"><a href="#wait-notify-方法-1" class="headerlink" title="wait / notify 方法"></a><code>wait / notify 方法</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">输出内容等待标记下一个标记</span></span><br><span class="line"><span class="comment">a12</span></span><br><span class="line"><span class="comment">b23</span></span><br><span class="line"><span class="comment">c31</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WaitSymbol</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> flag; <span class="comment">// 等待标记</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> loopNum; <span class="comment">// 循环次数</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">WaitSymbol</span> <span class="params">(<span class="type">int</span> flag, <span class="type">int</span> loopNum)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.flag = flag;</span><br><span class="line">    <span class="built_in">this</span>.loopNum = loopNum;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str, <span class="type">int</span> waitFlag, <span class="type">int</span> nextFlag)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;loopNum; i++) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(flag != waitFlag) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(str);</span><br><span class="line">        flag = nextFlag;</span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">WaitSymbol</span> <span class="variable">ws</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitSymbol</span>(<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span> (() -&gt; &#123;</span><br><span class="line">    ws.print(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">  </span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span> (() -&gt; &#123;</span><br><span class="line">    ws.print(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">  &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">  </span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span> (() -&gt; &#123;</span><br><span class="line">    ws.print(<span class="string">&quot;c&quot;</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;, <span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abcabcabcabcabc</span><br></pre></td></tr></table></figure><h6 id="ReentrantLock-方法"><a href="#ReentrantLock-方法" class="headerlink" title="ReentrantLock 方法"></a><code>ReentrantLock 方法</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AwaitSignal</span> <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="type">int</span> <span class="variable">loopNum</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">AwaitSignal</span> <span class="params">(<span class="type">int</span> loopNum)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loopNum = loopNum;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 参数1：打印内容参数2：进入哪一间休息室参数3：下一间休息室</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str, Condition current, Condition next)</span> &#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;loopNumber; i++) &#123;</span><br><span class="line">lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">current.await();</span><br><span class="line">System.out.print(str);</span><br><span class="line">next.signal();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">AwaitSignal</span> <span class="variable">awaitSignal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AwaitSignal</span>();</span><br><span class="line"><span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">conditionA</span> <span class="operator">=</span> awaitSignal.newCondition();</span><br><span class="line"><span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">conditionB</span> <span class="operator">=</span> awaitSignal.newCondition();</span><br><span class="line"><span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">conditionC</span> <span class="operator">=</span> awaitSignal.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    </span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">awaitSignal.print(<span class="string">&quot;a&quot;</span>, conditionA, conditionB);</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">awaitSignal.print(<span class="string">&quot;b&quot;</span>, conditionB, conditionC);</span><br><span class="line">&#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">awaitSignal.print(<span class="string">&quot;c&quot;</span>, conditionC, conditionA);</span><br><span class="line">&#125;, <span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">awaitSignal.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;开始...&quot;</span>);</span><br><span class="line">conditionA.signal(); <span class="comment">// 唤醒一个等待的线程</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">awaitSignal.unlock();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abcabcabcabcabc</span><br></pre></td></tr></table></figure><h6 id="park-unpark-方法"><a href="#park-unpark-方法" class="headerlink" title="park / unpark 方法"></a><code>park / unpark 方法</code></h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ParkUnpark</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> loopNum;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ParkUnpark</span><span class="params">(<span class="type">int</span> loopNum)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loopNum = loopNum;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str, thread next)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;loopNum; i++) &#123;</span><br><span class="line">      LockSupport.park();</span><br><span class="line">      System.out.print(str);</span><br><span class="line">      LockSupport.unpark(next);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Thread t1;</span><br><span class="line"><span class="keyword">static</span> Thread t2;</span><br><span class="line"><span class="keyword">static</span> Thread t3;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">ParkUnpark</span> <span class="variable">pu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParkUnpark</span>(<span class="number">5</span>);</span><br><span class="line">  t1 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    pu.print(<span class="string">&quot;a&quot;</span>, t2);</span><br><span class="line">  &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">t2 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    pu.print(<span class="string">&quot;b&quot;</span>, t3);</span><br><span class="line">  &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">t3 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    pu.run(<span class="string">&quot;c&quot;</span>, t1);</span><br><span class="line">  &#125;, <span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line">  </span><br><span class="line">  LockSupport.unpark(t1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abcabcabcabcabc</span><br></pre></td></tr></table></figure><h4 id="3-14-经典问题：哲学家就餐问题"><a href="#3-14-经典问题：哲学家就餐问题" class="headerlink" title="3.14 经典问题：哲学家就餐问题"></a>3.14 经典问题：哲学家就餐问题</h4><p><img src="/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/image-20220327221126928.png" alt="image-20220327221126928" style="zoom:50%;"></p><p>圆桌上坐着5名哲学家，每两个哲学家之问的桌上摆一根筷子，桌子的中间是一碗米饭。哲学们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时才试图拿起左、右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐。当进餐完毕后，放下筷子继续思考。</p><ol><li>关系分析。系统中有5个哲学家进程，5位哲学家<strong>与左右邻居对其中间筷子的访问</strong>是<strong>互斥关系</strong></li><li>整理思路。这个问题中只有互斥关系，但与之前遇到的问题不同的事，每个哲学家进程需要同时持有两个临界资源才能开始吃饭。如何<strong>避免临界资源分配不当造成的死锁现象</strong>，是哲学家问题的精髓。</li><li>信号量设置。定义互斥信号量数组<code>chopstick [5] = &#123;1,1,1,1,1&#125;</code>用于实现对5个筷子的互斥访问。并对哲学家按<code>0~4</code>编号，哲学家<code>i</code>左边的筷子编号为<code>i</code>，右边的筷子编号为<code>(i+1) % 5</code>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Semaphore chopstick[<span class="number">5</span>] = <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">Semaphore</span> <span class="variable">mutex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line">Philosoph_i () &#123;    <span class="comment">// i号哲学家进程</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        chopstick[i].down();            <span class="comment">// 拿起左边筷子</span></span><br><span class="line">        chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>].down();      <span class="comment">// 拿起右边筷子</span></span><br><span class="line">        吃饭；</span><br><span class="line">        chopstick[i].up();              <span class="comment">// 放下左边筷子</span></span><br><span class="line">        chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>].up();        <span class="comment">// 放下右边筷子</span></span><br><span class="line">        思考；</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    这种情况下，所有哲学家都会拿起左边的筷子，会造成死锁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>这种情况下，所有哲学家都会拿起左边的筷子，会造成 <strong>死锁</strong>。这种解决方案不合理。</p><p><strong>如何防止死锁的发生呢？</strong></p><ol><li>可以对哲学家进程施加一些限制条件，比如最多允许<strong>四个哲学家同时进餐</strong>。这样可以<strong>保证至少有一个哲学家是可以拿到左右两只筷子</strong>的</li><li>要求<strong>奇数号哲学家先拿左边的筷子，然后再拿右边的筷子</strong>，而<strong>偶数号哲学家刚好相反</strong>。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一支后再等待另一只的情况。</li><li>当且仅当一个哲学家<strong>左右两只筷子都可用时才允许他挂起筷子</strong>。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Semaphore chopstick[<span class="number">5</span>] = <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">Semaphore</span> <span class="variable">mutex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>); <span class="comment">// 互斥地取筷子</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    实现方法3.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Philosoph_i () &#123;    <span class="comment">// i号哲学家进程</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        mutex.down();                   <span class="comment">// 拿两个筷子的锁</span></span><br><span class="line">        chopstick[i].down();            <span class="comment">// 拿起左边筷子</span></span><br><span class="line">        chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>].down();      <span class="comment">// 拿起右边筷子</span></span><br><span class="line">        mutex.up();</span><br><span class="line">        吃饭；</span><br><span class="line">        chopstick[i].up();              <span class="comment">// 放下左边筷子</span></span><br><span class="line">        chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>].up();        <span class="comment">// 放下右边筷子</span></span><br><span class="line">        思考；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>总结：</strong></p><ul><li>这些<strong>进程之间只存在互斥关系</strong>，但是与之前接触到的互斥关系不同的是，每个进程都需要同时持有两个临界资源，因此就有“死锁”问题的隐患。</li><li>如果在考试中遇到了一个进程需要同时持有<strong>多个临界资源的情况</strong>，应该<strong>参考哲学家问题的思想</strong>，分析题中给出的进程之间<strong>是否会发生循环等待，是否会发生死锁</strong>。</li><li>可以参考哲学家就餐问题解决死锁的三种思路</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Java-并发多线程编程&quot;&gt;&lt;a href=&quot;#Java-并发多线程编程&quot; class=&quot;headerlink&quot; title=&quot;Java 并发多线程编程&quot;&gt;&lt;/a&gt;Java 并发多线程编程&lt;/h2&gt;&lt;p&gt;视频课程: &lt;a href=&quot;https://www.bilibili.com/video/BV16J411h7Rd?p=50&quot;&gt;BiliBili - 黑马程序员Java并发编程 JUC&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;笔记参考: &lt;a href=&quot;https://nyimac.gitee.io/2020/06/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/&quot;&gt;Java并发 - Nyima’s Blog&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注：本课程笔记基于JDK8，采用lsf4j打印日志&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="JUC" scheme="https://dave0126.github.io/categories/JUC/"/>
    
    
    <category term="Java" scheme="https://dave0126.github.io/tags/Java/"/>
    
    <category term="JUC" scheme="https://dave0126.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发多线程编程 (JUC) (一)</title>
    <link href="https://dave0126.github.io/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/"/>
    <id>https://dave0126.github.io/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/</id>
    <published>2022-03-23T20:13:13.000Z</published>
    <updated>2022-03-27T20:25:31.735Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-并发多线程编程"><a href="#Java-并发多线程编程" class="headerlink" title="Java 并发多线程编程"></a>Java 并发多线程编程</h2><p>视频课程: <a href="https://www.bilibili.com/video/BV16J411h7Rd?p=1">BiliBili - 黑马程序员Java并发编程 JUC</a></p><p>笔记参考: <a href="https://nyimac.gitee.io/2020/06/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发 - Nyima’s Blog</a></p><ul><li>注：本课程笔记基于JDK8，采用lsf4j打印日志</li></ul><span id="more"></span><h3 id="1-线程与进程"><a href="#1-线程与进程" class="headerlink" title="1 线程与进程"></a>1 线程与进程</h3><h4 id="1-1-进程"><a href="#1-1-进程" class="headerlink" title="1.1 进程"></a>1.1 进程</h4><ul><li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来<strong>加载指令、管理内存、管理 IO 的</strong>。</li><li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。</li><li>进程就可以视为<strong>程序的一个实例</strong>（程序是静态的，进程是动态的）。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器 等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）</li></ul><h4 id="1-2-线程"><a href="#1-2-线程" class="headerlink" title="1.2 线程"></a>1.2 线程</h4><ul><li>一个进程可以分为一到多个线程。</li><li><strong>一个线程就是一个指令流</strong>，将指令流中的一条条指令以一定的顺序交给 CPU 执行 。</li><li>Java 中，线程作为最小<strong>调度单位</strong>（执行指令），进程作为<strong>资源分配</strong>的最小单位。 在 windows 中进程是不活动的，只是作 为线程的容器</li></ul><h4 id="1-3-两者对比"><a href="#1-3-两者对比" class="headerlink" title="1.3 两者对比"></a>1.3 两者对比</h4><ul><li><strong>进程基本上相互独立的</strong>，而<strong>线程存在于进程内</strong>，是进程的一个子集</li><li>进程拥有共享的资源，如内存空间等，供其<strong>内部的线程共享</strong><ul><li>进程间通信较为复杂 同一台计算机的进程通信称为 IPC（Inter-process communication）</li><li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP</li></ul></li><li>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量</li><li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</li></ul><h5 id="1-3-1-进程和线程的切换"><a href="#1-3-1-进程和线程的切换" class="headerlink" title="1.3.1 进程和线程的切换"></a>1.3.1 进程和线程的切换</h5><h6 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h6><p>内核为每一个进程维持一个上下文。<strong>上下文就是内核重新启动一个被抢占的进程所需的状态。</strong>包括以下内容：</p><ul><li>通用目的寄存器</li><li>浮点寄存器</li><li>程序计数器</li><li>用户栈</li><li>状态寄存器</li><li>内核栈</li><li>各种内核数据结构：比如描绘地址空间的<strong>页表</strong>，包含有关当前进程信息的<strong>进程表</strong>，以及包含进程已打开文件的信息的<strong>文件表</strong></li></ul><h6 id="进程切换和线程切换的主要区别"><a href="#进程切换和线程切换的主要区别" class="headerlink" title="进程切换和线程切换的主要区别"></a>进程切换和线程切换的主要区别</h6><p>最主要的一个区别在于<strong>进程切换涉及虚拟地址空间的切换而线程不会</strong>。因为每个进程都有自己的虚拟地址空间，而<strong>线程是共享所在进程的虚拟地址空间的</strong>，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换</p><p>页表查找是一个很慢的过程，因此通常使用cache来缓存常用的地址映射，这样可以加速页表查找，这个cache就是快表TLB（translation Lookaside Buffer，用来加速页表查找）。由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么<strong>当进程切换后页表也要进行切换，页表切换后TLB就失效了</strong>，cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致TLB失效，因为线程线程无需切换地址空间，因此我们通常说线程切换要比较进程切换快</p><p>而且还可能出现<strong>缺页中断</strong>，这就需要操作系统将需要的内容调入内存中，若内存已满则还需要将不用的内容调出内存，这也需要花费时间</p><h6 id="为什么TLB能加快访问速度"><a href="#为什么TLB能加快访问速度" class="headerlink" title="为什么TLB能加快访问速度"></a><strong>为什么TLB能加快访问速度</strong></h6><p>快表可以避免每次都对页号进行地址的有效性判断。快表中保存了对应的物理块号，可以直接计算出物理地址，无需再进行有效性检查</p><h4 id="1-4-并行与并发"><a href="#1-4-并行与并发" class="headerlink" title="1.4 并行与并发"></a>1.4 并行与并发</h4><ol><li><p>单核cpu 下，线程实际还是<strong>串行执行</strong>的。操作系统中有一个组件叫做任务调度器，将cpu 的时间片（windows 下时间片最小约为 15 毫秒）分给不同的线程使用，只是由于 cpu在线程间（时间片很短）的切换非常快，人类感觉是<strong>同时运行</strong>的。总结为一句话就是：“<strong>微观串行，宏观并行</strong>”<br>一般会将这种<strong>线程轮流使用 CPU</strong>的做法称为并发，Concurrent。</p></li><li><p>多核cpu下，每个核心都可以调度运行线程，此时线程间是可以<strong>并行</strong>(Parallel)的。</p></li></ol><p><strong>并发</strong>(Concurrent) 是一个CPU在不同的时间去不同线程中执行指令。</p><p><strong>并行</strong>(Parallel)是多个CPU同时处理不同的线程。</p><h4 id="1-5-应用"><a href="#1-5-应用" class="headerlink" title="1.5 应用"></a>1.5 应用</h4><h5 id="1-5-1-应用之异步调用（案例1）"><a href="#1-5-1-应用之异步调用（案例1）" class="headerlink" title="1.5.1 应用之异步调用（案例1）"></a>1.5.1 应用之异步调用（案例1）</h5><p>以<strong>调用方角度</strong>来讲，如果</p><ul><li>需要等待结果返回，才能继续运行就是同步</li><li>不需要等待结果返回，就能继续运行就是异步</li></ul><p>注意：同步在多线程中还有另外一层意思，即让多个线程步调一致</p><h6 id="1-设计"><a href="#1-设计" class="headerlink" title="1) 设计"></a>1) 设计</h6><p>多线程可以让方法执行变为异步的（即不要巴巴干等着）比如说读取磁盘文件时，假设读取操作花费了 5 秒钟，如果没有线程调度机制，这 5 秒 cpu 什么都做不了，其它代码都得暂停…</p><p>一般来讲，大文件的读写、耗时较长的工作可以异步执行</p><h6 id="2-结论"><a href="#2-结论" class="headerlink" title="2) 结论"></a>2) 结论</h6><ul><li>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程</li><li>tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞</li><li>tomcat 的工作线程 ui 程序中，开线程进行其他操作，避免阻塞 ui 线程</li></ul><h5 id="1-5-2-应用之提高效率（案例1）"><a href="#1-5-2-应用之提高效率（案例1）" class="headerlink" title="1.5.2 应用之提高效率（案例1）"></a>1.5.2 应用之提高效率（案例1）</h5><p>充分利用多核 cpu 的优势，提高运行效率。想象下面的场景，执行3个计算，最后将计算结果汇总。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">计算 1 花费10ms</span><br><span class="line">计算 2 花费11ms</span><br><span class="line">计算 3 花费9ms</span><br><span class="line">汇总需要1ms</span><br></pre></td></tr></table></figure><p>如果是串行执行，那么总共花费的时间是 <code>10 + 11 + 9 + 1 = 31ms</code></p><ul><li>但如果是四核 cpu，各个核心分别使用线程1 执行计算1，线程2执行计算2，线程3执行计算3，那么3个线程是并行的，花费时间只取决于最长的那个线程运行的时间，即<code>11ms</code> 。最后加上汇总时间，只会花费<code>12ms</code>。</li></ul><p><strong>注意</strong>：需要在多核cpu 才能提高效率，单核仍然时是轮流执行</p><h6 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h6><ol><li>单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用 cpu ，不至于一个线程总占用 cpu，别的线程没法干活</li><li>多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的<ul><li>有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任 务都能拆分（参考后文的【阿姆达尔定律】）</li><li>也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义</li></ul></li><li>IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一 直等待 IO 结束，没能充分利用线程。所以才有后面的【非阻塞 IO】和【异步 IO】优化。</li></ol><h3 id="2-Java-线程"><a href="#2-Java-线程" class="headerlink" title="2 Java 线程"></a>2 Java 线程</h3><h4 id="2-1-创建和运行线程"><a href="#2-1-创建和运行线程" class="headerlink" title="2.1 创建和运行线程"></a>2.1 创建和运行线程</h4><h5 id="方法一：直接使用构造器创建一个线程"><a href="#方法一：直接使用构造器创建一个线程" class="headerlink" title="方法一：直接使用构造器创建一个线程"></a>方法一：直接使用构造器创建一个线程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateThread</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">Thread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        Log.debug(<span class="string">&quot;my thread running...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">myThread.start();  <span class="comment">// 启动线程</span></span><br><span class="line">    Log.debug(<span class="string">&quot;main thread running...&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用继承方式的好处是，在<code>run()</code>方法内获取当前线程直接使用this就可以了，无须使用<code>Thread.currentThread()</code>方法；</p><p>不好的地方是Java不支持多继承，如果继承了Thread类，那么就不能再继承其他类。另外任务与代码没有分离，当多个线程执行一样的任务时需要多份任务代码</p><h5 id="方法二：使用Runnable配合Thread-推荐"><a href="#方法二：使用Runnable配合Thread-推荐" class="headerlink" title="方法二：使用Runnable配合Thread(推荐)"></a>方法二：使用Runnable配合Thread(推荐)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//创建线程任务</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Runnable running&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//将Runnable对象传给Thread</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">t.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过实现Runnable接口，并且实现<code>run()</code>方法。好处是<strong>将任务和线程分离</strong>，更为灵活。在创建线程时作为参数传入该类的实例即可。</p><h5 id="方法二的简化：使用lambda表达式简化操作"><a href="#方法二的简化：使用lambda表达式简化操作" class="headerlink" title="方法二的简化：使用lambda表达式简化操作"></a>方法二的简化：使用lambda表达式简化操作</h5><p>当<strong>只有一个抽象方法的接口</strong>可以用<code>@FunctionalInterface</code>注解。当有该注解时，可以<strong>使用lambda来简化操作</strong></p><p>所以方法二中的代码可以被简化为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">//创建线程任务</span></span><br><span class="line"><span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="comment">//直接写方法体即可</span></span><br><span class="line">System.out.println(<span class="string">&quot;Runnable running&quot;</span>);</span><br><span class="line">System.out.println(<span class="string">&quot;Hello Thread&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//将Runnable对象传给Thread</span></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line"><span class="comment">//启动线程</span></span><br><span class="line">t.start();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在IDEA中，可以在<code>Runnable</code>上使用<code>Alt + Enter</code>自动转换成lambda表达式。</p><h6 id="Thread-与-Runnable-的关系"><a href="#Thread-与-Runnable-的关系" class="headerlink" title="Thread 与 Runnable 的关系"></a>Thread 与 Runnable 的关系</h6><p>分析 Thread 的源码，理清它与 Runnable 的关系</p><ul><li>方法1 是把线程和任务合并在了一起</li><li>方法2 是把线程和任务分开了</li><li>用 Runnable 更容易与线程池等高级 API 配合 用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</li></ul><h5 id="方法三：使用FutureTask与Thread结合"><a href="#方法三：使用FutureTask与Thread结合" class="headerlink" title="方法三：使用FutureTask与Thread结合"></a>方法三：使用FutureTask与Thread结合</h5><p>使用<strong>FutureTask</strong>可以用泛型指定<strong>线程的返回值</strong>类型（<strong>Runnable的run方法没有返回值</strong>）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">//需要传入一个Callable对象</span></span><br><span class="line">FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Integer&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;线程执行!&quot;</span>);</span><br><span class="line">Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">r1.start();</span><br><span class="line"><span class="comment">//获取线程中方法执行后的返回结果</span></span><br><span class="line">System.out.println(task.get());</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>使用<strong>继承方式的好处是方便传参</strong>，你可以在子类里面添加成员变量，通过set方法设置参数或者通过构造函数进行传递，而如果使用Runnable方式，则只能使用主线程里面被声明为final的变量。</p><p><strong>不好的地方是Java不支持多继承</strong>，如果继承了Thread类，那么子类不能再继承其他类，而Runable则没有这个限制。<strong>前两种方式都没办法拿到任务的返回结果，但是Futuretask方式可以</strong></p><h4 id="2-2-原理之线程运行"><a href="#2-2-原理之线程运行" class="headerlink" title="2.2 原理之线程运行"></a>2.2 原理之线程运行</h4><h5 id="2-2-1-栈与栈帧"><a href="#2-2-1-栈与栈帧" class="headerlink" title="2.2.1 栈与栈帧"></a>2.2.1 栈与栈帧</h5><p><a href="https://dave0126.github.io/2022/03/22/JVM-1/#2-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88">Java Virtual Machine Stacks</a> （Java 虚拟机栈） 我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？</p><ul><li>其实就是线程，每个线程启动后，虚拟机就会为其分配一块<strong>栈内存</strong></li><li>每个栈由多个栈帧（Frame）组成，对应着每次<strong>方法调用时所占用的内存</strong></li><li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li></ul><h5 id="2-2-2-线程上下文切换"><a href="#2-2-2-线程上下文切换" class="headerlink" title="2.2.2 线程上下文切换"></a>2.2.2 线程上下文切换</h5><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p><ul><li>线程的 cpu 时间片用完</li><li>垃圾回收 有更高优先级的线程需要运行</li><li>线程自己调用了 <code>sleep</code>、<code>yield</code>、<code>wait</code>、<code>join</code>、<code>park</code>、<code>synchronized</code>、<code>lock</code> 等方法</li></ul><p>当 Context Switch 发生时，需要由操作系统<strong>保存当前线程的状态</strong>，并<strong>恢复另一个线程的状态</strong>，Java 中对应的概念 就是程序计数器（Program Counter Register），它的作用是记住下一条 JVM 指令的执行地址，是线程私有的</p><ul><li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li><li>Context Switch 频繁发生会影响性能</li></ul><h4 id="2-3-常见方法"><a href="#2-3-常见方法" class="headerlink" title="2.3 常见方法"></a>2.3 常见方法</h4><div class="table-container"><table><thead><tr><th><strong>方法名</strong></th><th><strong>功能说明</strong></th><th style="text-align:left"><strong>注意</strong></th></tr></thead><tbody><tr><td><code>start()</code></td><td>启动一个新线程，在新线程上运行<code>run()</code>方法中的代码</td><td style="text-align:left"><code>start()</code> 方法只是让线程进入就绪，里面代码不一定立刻运行（CPU 的时间片还没分给它）。每个线程对象的<strong><code>start()</code>方法只能调用一次</strong>，如果调用了多次会出现 IllegalThreadStateException</td></tr><tr><td><code>run()</code></td><td>新线程启动后会调用的方法</td><td style="text-align:left">如果在构造 Thread 对象时传递了 Runnable 参数，则线程启动后会调用 Runnable 中的<code>run()</code> 方法，否则默认不执行任何操作。但可以创建 Thread 的子类对象，来覆盖默认行为</td></tr><tr><td><code>join()</code></td><td>等待线程运行结束</td><td style="text-align:left"></td></tr><tr><td><code>join(long n)</code></td><td>等待线程运行结束最多等待n毫秒</td><td style="text-align:left"></td></tr><tr><td><code>getId()</code></td><td>获取线程长整型的id</td><td style="text-align:left">id唯一</td></tr><tr><td><code>getName()</code></td><td>获取线程名</td><td style="text-align:left"></td></tr><tr><td><code>setName(String)</code></td><td>修改线程名</td><td style="text-align:left"></td></tr><tr><td><code>getPriority()</code></td><td>获取线程优先级</td><td style="text-align:left"></td></tr><tr><td><code>setPriority(int)</code></td><td>设置线程优先级</td><td style="text-align:left">java中规定线程优先级是1~10的整数，较大的优先级能提高该线程被 CPU 调度的机率</td></tr><tr><td><code>getState()</code></td><td>获取线程状态</td><td style="text-align:left">Java中线程状态使用6个enum表示：NEW，RUNNABLE，BLOCKED，WATING，TIMED_WAITING，TERMINATED</td></tr><tr><td><code>isInterrupted()</code></td><td>判断是否被打断</td><td style="text-align:left">不会清除打断标记</td></tr><tr><td><code>isAlive()</code></td><td>线程是否存活（还没有运行完毕）</td><td style="text-align:left"></td></tr><tr><td><code>interrupt()</code></td><td>打断线程</td><td style="text-align:left">如果被打断线程正在 sleep, wait, join 会导致被打断的线程抛出 InterruptedException，并<strong>清除打断标记</strong>；如果打断的正在运行的线程，则会<strong>设置打断标记</strong>；park 的线程被打断，也会<strong>设置打断标记</strong></td></tr><tr><td><code>currentThread()</code></td><td>获取当前正在执行的线程</td><td style="text-align:left"></td></tr><tr><td><code>sleep(long n)</code></td><td>让当前执行的线程休眠n毫秒，休眠时让出 cpu 的时间片给其它线程</td><td style="text-align:left">不会释放<strong>锁</strong>操作</td></tr><tr><td><code>yield()</code></td><td>提线程调度器让出当前线程对CPU的使用</td><td style="text-align:left">主要是为了测试和调试</td></tr></tbody></table></div><h5 id="2-3-1-start-vs-run"><a href="#2-3-1-start-vs-run" class="headerlink" title="2.3.1 start() vs run()"></a>2.3.1 start() vs run()</h5><p>被创建的Thread对象直接调用重写的<code>run()</code>方法时， run方法是在<strong>主线程</strong>中被执行的，而不是在我们所创建的线程中执行。</p><p>所以如果想要在所创建的线程中执行<code>run()</code>方法，<strong>需要使用Thread对象的start()方法。</strong></p><h5 id="2-3-2-sleep-vs-yield"><a href="#2-3-2-sleep-vs-yield" class="headerlink" title="2.3.2 sleep() vs yield()"></a>2.3.2 sleep() vs yield()</h5><h6 id="sleep-使线程阻塞"><a href="#sleep-使线程阻塞" class="headerlink" title="sleep (使线程阻塞)"></a><strong>sleep</strong> (使线程阻塞)</h6><ol><li><p>调用 <code>sleep()</code> 会让当前线程从 <strong>Running 进入 Timed Waiting 状态（阻塞）</strong>，可通过<code>state()</code>方法查看</p></li><li><p>其它线程可以使用 <strong><code>interrupt()</code></strong> 方法打断正在睡眠的线程，这时 <code>sleep()</code> 方法会抛出 InterruptedException</p></li><li><p>睡眠结束后的线程未必会立刻得到执行(Runnable状态)</p></li><li><p>建议用 <strong>TimeUnit 的 <code>sleep()</code></strong> 代替 Thread 的 <code>sleep()</code> 来获得更好的可读性 。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//休眠一秒</span></span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//休眠一分钟</span></span><br><span class="line">TimeUnit.MINUTES.sleep(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></li></ol><h6 id="yield-（让出当前线程）"><a href="#yield-（让出当前线程）" class="headerlink" title="yield （让出当前线程）"></a>yield （让出当前线程）</h6><ol><li>调用 yield 会让当前线程从 <strong>Running 进入 Runnable 就绪状态</strong>（仍然有可能被执行），然后调度执行其它线程</li><li>具体的实现依赖于操作系统的任务调度器</li></ol><h6 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h6><ul><li><p>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它</p></li><li><p>如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</p></li><li><p>设置方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread1.setPriority(Thread.MAX_PRIORITY); <span class="comment">//设置为优先级int(1~10)</span></span><br></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">Runnable</span> <span class="variable">task1</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;----&gt; task1&quot;</span> + count++);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="type">Runnable</span> <span class="variable">task2</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">      Thread.yield();</span><br><span class="line">      System.out.println(<span class="string">&quot;----&gt; task1&quot;</span> + count++);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task1, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task1, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  t1.start();</span><br><span class="line">  t2.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">输出结果应为 t1打印的count 远大于 t2打印的count</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h5 id="2-3-3-join"><a href="#2-3-3-join" class="headerlink" title="2.3.3 join()"></a>2.3.3 join()</h5><pre class="mermaid">graph TDA1[main]--瞬间完成-->E1[r=0]E1 --> B1[t1.join]A1 --> C1[t1.start]C1 --1s后---> D1[r=10]D1 --t1结束--> B1B1 --> R1[res: r=10]</pre><p><code>join()</code>的底层原理就是<code>wait()</code>。</p><p>用于等待某个线程结束。哪个线程内调用join()方法，就等待哪个线程结束，然后再去执行其他线程。</p><p>如在主线程中调用ti.join()，则是主线程等待t1线程结束</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>();</span><br><span class="line"><span class="comment">//等待thread线程执行结束</span></span><br><span class="line">thread.join();</span><br><span class="line"><span class="comment">//最多等待1000ms,如果1000ms内线程执行完毕，则会直接执行下面的语句，不会等够1000ms</span></span><br><span class="line">thread.join(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h5 id="2-3-4-interrupt"><a href="#2-3-4-interrupt" class="headerlink" title="2.3.4 interrupt()"></a>2.3.4 interrupt()</h5><p>用于打断<strong>阻塞</strong>(sleep wait join…)的线程。 处于<strong>阻塞状态</strong>的线程，CPU不会给其分配时间片。</p><ul><li>如果一个线程在在运行中被打断，打断标记会被置为<code>true</code>。</li><li>如果是打断因<code>sleep(), wait(), join()</code>方法而被阻塞的线程，会将打断标记会被清空，置为<code>false</code></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于查看打断标记，返回值被boolean类型</span></span><br><span class="line">t1.isInterrupted();</span><br></pre></td></tr></table></figure><p>正常运行的线程在被打断后，<strong>不会停止</strong>，会继续执行。如果要让线程在被打断后停下来，需要<strong>使用打断标记来判断</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throw</span> InterruptedException&#123;</span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  t1.start();</span><br><span class="line">  </span><br><span class="line">  Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  Log.debug(<span class="string">&quot;interrupted&quot;</span>);</span><br><span class="line">  t1.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="interrupt-的应用——两阶段终止模式"><a href="#interrupt-的应用——两阶段终止模式" class="headerlink" title="interrupt() 的应用——两阶段终止模式"></a>interrupt() 的应用——两阶段终止模式</h6><p>当我们在执行线程一时，想要终止线程二，这是就需要使用interrupt方法来<strong>优雅</strong>的停止线程二（料理后事: 释放锁和临界资源等）。</p><ol><li><p>错误思路</p><ul><li><code>stop()</code>：该方法会直接杀死线程，若线程对临界区资源上锁，则永远解锁，其他线程也无法获取锁。</li><li><code>suspend()</code>暂停线程 和 <code>resume()</code>恢复线程, 原因同<code>stop()</code></li><li><code>System.exit(int)</code>：该方法会直接<strong>停止进程</strong>。</li></ul></li><li><p>两阶段终止模式</p></li></ol><pre class="mermaid">graph TDA["while(true)"]B{是否被打断?}C[料理后事]D[睡眠2s]E(结束循环)F[执行监控记录]G[设置打断标记]A --> BB --yes--> CB --no--> DC --> ED --无异常--> FD --有异常--> GF --> AG --> A</pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  两阶段终止模式（Two Phase Termination）：在进程T1中终止进程T2</span></span><br><span class="line"><span class="comment">    在终止进程T2之前让T2释放锁和临界资源</span></span><br><span class="line"><span class="comment">    不用stop（） 和 System.exit（）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TwoPhaseTermination</span> &#123;</span><br><span class="line">    <span class="comment">// 监控线程</span></span><br><span class="line">    privite Thread monitor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动监控线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        monitor = <span class="keyword">new</span> <span class="title class_">Thread</span> (() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                <span class="keyword">if</span> (current.isInterrupted()) &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    TODO 释放锁和临界资源</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;释放锁和临界资源&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>); <span class="comment">// 情况1</span></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                        TODO 正常功能的代码块</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="comment">// 情况2</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="comment">// 若sleep时被打断，会捕获错误e，此时的isInterrupted标记为false，程序会重复执行。所以有以下操作</span></span><br><span class="line">                    current.interrupt(); <span class="comment">// 重新设置isInterrupted打断标记, true -&gt; false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        monitor.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止监控线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        monitor.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="2-3-5-主线程与守护线程"><a href="#2-3-5-主线程与守护线程" class="headerlink" title="2.3.5 主线程与守护线程"></a>2.3.5 主线程与守护线程</h5><ul><li><p>主线程: 当JAVA进程中有多个线程在执行时，只有当所有非守护线程都执行完毕后，JAVA进程才会结束。</p></li><li><p>守护线程: <strong>但当非守护线程全部执行完毕后，守护线程无论是否执行完毕，也会一同结束。</strong>(垃圾回收线程)</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将线程设置为守护线程, 默认为false</span></span><br><span class="line">monitor.setDaemon(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure><h4 id="2-4-线程的状态"><a href="#2-4-线程的状态" class="headerlink" title="2.4 线程的状态"></a>2.4 线程的状态</h4><h5 id="2-4-1-五种状态-操作系统层面"><a href="#2-4-1-五种状态-操作系统层面" class="headerlink" title="2.4.1 五种状态(操作系统层面)"></a>2.4.1 五种状态(操作系统层面)</h5><p><img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/20200608144606.png" alt="20200608144606" style="zoom:75%;"></p><ol><li>【初始状态】：在<strong>语言层面创建了线程对象</strong>，但未与操作系统线程关联</li><li>【可运行状态】：（就需状态），已与操作系统线程关联，可由cpu调度执行</li><li>【运行状态】：获得cpu时间片，正在执行。<ul><li>当cpu时间片用完，由【运行状态】转为【可运行状态】，导致线程的上下文切换</li></ul></li><li>【阻塞状态】：该状态下的线程不会占用cpu，会导致线程的上下文切换<ul><li>等阻塞操作结束，系统唤醒阻塞状态，切换至【可运行状态】</li></ul></li><li>【终止状态】</li></ol><h5 id="2-4-2-六种状态-JAVA-API层面"><a href="#2-4-2-六种状态-JAVA-API层面" class="headerlink" title="2.4.2 六种状态(JAVA API层面)"></a>2.4.2 六种状态(JAVA API层面)</h5><p><img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/20200608144621.png" alt="20200608144621" style="zoom:75%;"></p><p>详见<a href="https://dave0126.github.io//2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/#3-9-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2">第三章 3.9【线程状态转换】</a></p><ol><li><p>【NEW】：线程被创建，还没有调用<code>strat()</code>方法</p></li><li><p>【RUNNABLE】：调用了<code>start()</code>方法后。该状态涵盖了<strong>操作系统层面</strong>的<em>【可运行状态】、【运行状态】和【阻塞状态】</em></p></li><li><p>三种“java中的阻塞状态”：后面会在状态转换一节详述。</p><p>(1) 【BLOCKED】：</p><p>(2)【WAITING】：<code>join()</code></p><p>(3)【TIMED_WAITING】：<code>sleep()</code></p></li><li><p>【TERMINATED】：代码运行结束</p></li></ol><h4 id="2-5-习题"><a href="#2-5-习题" class="headerlink" title="2.5 习题"></a>2.5 习题</h4><h5 id="2-5-1-统筹方法（烧水泡茶）"><a href="#2-5-1-统筹方法（烧水泡茶）" class="headerlink" title="2.5.1 统筹方法（烧水泡茶）"></a>2.5.1 统筹方法（烧水泡茶）</h5><p>阅读华罗庚《统筹方法》，给出烧水泡茶的多线程解决方案，提示：</p><ul><li>参考图二，用两个线程（两个人协作）模拟烧水泡茶过程<ul><li>文中办法乙、丙都相当于任务串行</li><li>而图一相当于启动了 4 个线程，有点浪费</li></ul></li><li>用<code>sleep(n)</code>模拟洗茶壶、洗水壶等耗费的时间</li></ul><p>附：华罗庚《统筹方法》</p><hr><p>统筹方法，是一种安排工作进程的数学方法。它的实用范围极广泛，在企业管理和基本建设中，以及关系复杂的科研项目的组织与管理中，都可以应用。</p><p>怎样应用呢？主要是把工序安排好。</p><p>比如，想泡壶茶喝。当时的情况是：开水没有；水壶要洗，茶壶、茶杯要洗;火已生了，茶叶也有了。<br>怎么办？</p><ul><li>办法甲：洗好水壶，灌上凉水，放在火上；在等待水开的时间里，洗茶壶、洗茶杯、 拿茶叶；等水开了，泡茶喝。</li><li>办法乙：先做好一些准备工作，洗水壶，洗茶壶茶杯，拿茶叶；一切就绪，灌水烧水；坐待水开了，泡茶喝。</li><li>办法丙：洗净水壶，灌上凉水，放在火上，坐待水开；水开了之后，急急忙忙找茶叶，洗茶壶茶杯，泡茶喝。</li></ul><p>哪一种办法省时间？我们能一眼看出，第一种办法好，后两种办法都窝了工。</p><p>这是小事，但这是引子，可以引出生产管理等方面有用的方法来。</p><p>水壶不洗，不能烧开水，因而洗水壶是烧开水的前提。没开水、没茶叶、不洗茶壶茶杯，就不能泡茶，因而这些又是泡茶的前提。它们的相互关系，可以用下图来表示：</p><pre class="mermaid">graph LR;A[洗水壶 1min]--> B[烧开水 15mins];B--> R[泡茶];C[洗茶壶 1min]--> R;D[洗茶杯 1min]--> R;E[拿茶叶 1min]--> R;</pre><p>从这个图上可以一眼看出，办法甲总共要16分钟（而办法乙、丙需要20分钟）。如果要缩短工时．提高工作效率，应当主要抓烧开水这个环节，而不是抓拿茶叶等环节。同时，洗茶壶茶杯、拿茶叶总共不过3分钟，大可利用“等水开”的时间来做。</p><p>是的，这好像是废话，卑之无甚高论。有如走路要用两条腿走，吃饭要一口一口吃，这些道理谁都懂得。但稍有变化，临事而迷的情况，常常是存任的。在近代工业的错综夏杂的工艺过程中，往往就不是像泡茶喝这么简单了。任务多了，几百几千，甚至有好几万个任务。关系多了，错综复杂，千头万绪，往往出现 “万事俱备，只欠东风” 的情况。由于一两个零件没完成，耽误了一台复杂机器的出厂时间。或往往因为抓的不是关键，连夜三班，急急忙忙，完成这一环节之后，还得等待旁的环节才能装配。</p><p>洗茶壶，洗茶杯，拿茶叶，或先或后，关系不大，而且同是一个人的活儿，因币可以合并成为：</p><pre class="mermaid">graph LR;A[洗水壶 1min]--> B[烧开水 15mins];B--> R[泡茶];C[洗茶壶, 洗茶杯, 拿茶叶 3mins]--> R;</pre><p>看来这是“小题大做”，但在工作环节太多的时候，这样做就非常必要了。</p><p>这里讲的主要是时间方面的事，但在具体生产实践中，还有其他方面的许多事。这种方法里然不一定能直接解决所有问题，但是，我们利用这种方法来考虑问题，也是不无裨益的。</p><hr><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pubilc <span class="keyword">static</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    Log.debug(<span class="string">&quot;洗水壶&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    Log.debug(<span class="string">&quot;烧开水&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">15000</span>);</span><br><span class="line">  &#125;, <span class="string">&quot;小明&quot;</span>);</span><br><span class="line">    </span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    Log.debug(<span class="string">&quot;洗茶壶&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    Log.debug(<span class="string">&quot;洗茶杯&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    Log.debug(<span class="string">&quot;拿茶叶&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">     t1.join(); <span class="comment">// 由 小王 来泡茶 </span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="string">&quot;小王&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  t1.start();</span><br><span class="line">  t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">19:19:37.547[小明]c.TestMakeTea -洗茶壶</span><br><span class="line">19:19:37.547[小王]c.TestMakeTea - 洗水壶</span><br><span class="line">19:19:38.552[小明]c.TestMakeTea - 洗茶杯</span><br><span class="line">19:19:38.552[小王]c.TestMakeTea - 烧开水</span><br><span class="line">19:19:49.553[小明]c.TestMakeTea - 拿茶叶</span><br><span class="line">19:19:53.553[小明]c.TestMakeTea -泡茶</span><br></pre></td></tr></table></figure><p>解法1的缺陷：</p><ul><li>上面模拟的是小明等小王的水烧开了，小明泡茶，如果反过来要实现小王等小明的茶叶拿来了，小王泡茶呢？代码最好能适应两种情况</li><li>上面的两个线程其实是各执行各的，如果要模拟小王把水壶交给小明泡茶，或模拟小明把茶叶交给小王泡茶</li></ul><h4 id="2-6-小结"><a href="#2-6-小结" class="headerlink" title="2.6 小结"></a>2.6 小结</h4><p>本章的重点在于掌握</p><ul><li>线程创建</li><li>线程重要api， 如<code>start, run, sleep, join, interrupt</code>等</li><li>线程状态</li><li>应用方面<ul><li>异步调用：主线程执行期间，其它线程异步执行耗时操作</li><li>提高效率：并行计算，缩短运算时间</li><li>同步等待：join</li><li>统筹规划：合理使用线程，得到最优效果</li></ul></li><li>原理方面<ul><li>线程运行流程：栈、栈帧、上下文切换、程序计数器</li><li>Thread 两种创建方式 的源码</li></ul></li><li>模式方面<ul><li>两阶段终止</li></ul></li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;Java-并发多线程编程&quot;&gt;&lt;a href=&quot;#Java-并发多线程编程&quot; class=&quot;headerlink&quot; title=&quot;Java 并发多线程编程&quot;&gt;&lt;/a&gt;Java 并发多线程编程&lt;/h2&gt;&lt;p&gt;视频课程: &lt;a href=&quot;https://www.bilibili.com/video/BV16J411h7Rd?p=1&quot;&gt;BiliBili - 黑马程序员Java并发编程 JUC&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;笔记参考: &lt;a href=&quot;https://nyimac.gitee.io/2020/06/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/&quot;&gt;Java并发 - Nyima’s Blog&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注：本课程笔记基于JDK8，采用lsf4j打印日志&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="JUC" scheme="https://dave0126.github.io/categories/JUC/"/>
    
    
    <category term="Java" scheme="https://dave0126.github.io/tags/Java/"/>
    
    <category term="JUC" scheme="https://dave0126.github.io/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>Java 虚拟机 - JVM 第二讲</title>
    <link href="https://dave0126.github.io/2022/03/22/JVM-2/"/>
    <id>https://dave0126.github.io/2022/03/22/JVM-2/</id>
    <published>2022-03-22T21:36:23.000Z</published>
    <updated>2022-03-23T22:59:50.384Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM-基础学习"><a href="#JVM-基础学习" class="headerlink" title="JVM 基础学习"></a>JVM 基础学习</h1><p>视频课程: <a href="https://www.bilibili.com/video/BV1yE411Z7AP?p=48">BiliBili - 黑马程序员JVM完整教程: JVM垃圾回收</a></p><h2 id="三、JVM-垃圾回收"><a href="#三、JVM-垃圾回收" class="headerlink" title="三、JVM 垃圾回收"></a>三、JVM 垃圾回收</h2><h3 id="0-主要内容大纲"><a href="#0-主要内容大纲" class="headerlink" title="0 主要内容大纲"></a>0 主要内容大纲</h3><ol><li>如何判断对象可以回收</li><li>垃圾回收算法</li><li>分代垃圾回收</li><li>垃圾回收器</li><li>垃圾回收调优</li></ol><span id="more"></span><h3 id="1-如何判断对象可以被回收"><a href="#1-如何判断对象可以被回收" class="headerlink" title="1 如何判断对象可以被回收"></a>1 如何判断对象可以被回收</h3><h4 id="1-1-引用计数法"><a href="#1-1-引用计数法" class="headerlink" title="1.1 引用计数法"></a>1.1 引用计数法</h4><p>只要一个对象被其他变量所引用，那我们就让这个对象的计数加1，如果被引用两次，该计数就为2。如果某个变量不再引用这个对象，该对象的引用计数减1。当计数为0时，表示没有变量引用这个对象了，则可作为垃圾回收掉。</p><p><img src="/2022/03/22/JVM-2/20200608150750 (1).png" alt="20200608150750 (1)" style="zoom:75%;"></p><ul><li>弊端：在例如上图的循环引用时，两个对象的计数都为1，导致两个对象都无法被释放</li></ul><h4 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2 可达性分析算法"></a>1.2 可达性分析算法</h4><p>首先先要确定根对象。那么什么是根对象呢？就是那些肯定不能被当成垃圾回收的对象。</p><p>在垃圾回收之前，我们先扫描堆内存中的所有对象，检查对象是否被根对象直接或者间接的引用。若是，则不能被回收；反之则可以被回收。</p><ul><li>JVM中的垃圾回收器通过<strong>可达性分析</strong>来探索所有存活的对象</li><li>扫描堆中的对象，看能否沿着GC Root对象（根对象）为起点的引用链找到该对象，如果<strong>找不到，则表示可以回收</strong></li><li>可以作为GC Root的对象：<ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。　</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li></ul></li></ul><h4 id="1-3-五种引用"><a href="#1-3-五种引用" class="headerlink" title="1.3 五种引用"></a>1.3 五种引用</h4><p><img src="/2022/03/22/JVM-2/20200608150800.png" alt="20200608150800"></p><h5 id="1-3-1-强引用"><a href="#1-3-1-强引用" class="headerlink" title="1.3.1 强引用"></a>1.3.1 强引用</h5><p>如上图，实线箭头表示强引用。日常使用中的引用都属于强引用。例如，new一个对象，使用“=”将该对象赋值给一个变量，那么这个变量就强引用该对象。</p><p>只有GC Root<strong>都不引用</strong>该对象时，才会回收<strong>强引用</strong>对象</p><ul><li>如上图B、C对象都不引用A1对象时，A1对象才会被回收</li></ul><h5 id="1-3-2-软引用-SoftReference"><a href="#1-3-2-软引用-SoftReference" class="headerlink" title="1.3.2 软引用 (SoftReference)"></a>1.3.2 软引用 (SoftReference)</h5><p>当内存空间有限时，一些不重要的资源可以用软引用。</p><p>只要A2、A3两个对象没有被直接的强引用所引用，当垃圾回收发生时，都有可以被回收。</p><p>当GC Root指向软引用对象（垃圾回收）时，在<strong>内存不足时</strong>，会<strong>回收软引用所引用的对象</strong>。（先回收一次，如果内存还不够，回收软引用所引用的对象）</p><ul><li>如上图如果B对象不再引用A2对象且内存不足时，软引用所引用的A2对象就会被回收</li></ul><p>案列1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoSortReference1</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">_4M</span> <span class="operator">=</span> <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="comment">//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span></span><br><span class="line">List&lt;SoftReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 强引用</span></span><br><span class="line">SoftReference&lt;<span class="type">byte</span>[]&gt; ref= <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[_4M]); <span class="comment">// 软引用</span></span><br><span class="line">    <span class="comment">// List list --强--&gt; SoftReference ref --软--&gt; byte[_4M]</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果在垃圾回收时发现内存不足，在回收软引用所指向的对象时，<strong>软引用本身不会被清理</strong></p><p>如果想要<strong>清理软引用</strong>，需要使<strong>用引用队列</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoSortReference2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">_4M</span> <span class="operator">=</span> <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//使用引用队列，用于移除引用为空的软引用对象</span></span><br><span class="line">ReferenceQueue&lt;<span class="type">byte</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;(); <span class="comment">// 引用队列</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span></span><br><span class="line">List&lt;SoftReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 强引用</span></span><br><span class="line">SoftReference&lt;<span class="type">byte</span>[]&gt; ref= <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[_4M]); <span class="comment">// 软引用</span></span><br><span class="line">    <span class="comment">// List list --强--&gt; SoftReference ref --软--&gt; byte[_4M]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//遍历引用队列，如果有元素，则取出</span></span><br><span class="line">Reference&lt;? <span class="keyword">extends</span> <span class="title class_">byte</span>[]&gt; poll = queue.poll(); <span class="comment">// poll(), 取出最先放入队列的元素，返回类型Reference</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span>(poll != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//引用队列不为空，则从集合中移除该元素</span></span><br><span class="line">list.remove(poll);</span><br><span class="line"><span class="comment">//移动到引用队列中的下一个元素</span></span><br><span class="line">poll = queue.poll();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>大概思路为：</strong>查看引用队列中有无软引用，如果有，则将该软引用从存放它的集合中移除（这里为一个list集合）</p><h5 id="1-3-3-弱引用-WeakReferrnce"><a href="#1-3-3-弱引用-WeakReferrnce" class="headerlink" title="1.3.3 弱引用 (WeakReferrnce)"></a>1.3.3 弱引用 (WeakReferrnce)</h5><p>只有弱引用引用该对象时，在垃圾回收时，<strong>无论内存是否充足</strong>，都会回收弱引用所引用的对象</p><ul><li>如上图如果B对象不再引用A3对象，则A3对象会被回收</li></ul><p><strong>弱引用的使用和软引用类似</strong>，只是将 <strong>SoftReference 换为了 WeakReference</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoWeakReference1</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="keyword">final</span> <span class="type">int</span> <span class="variable">_4M</span> <span class="operator">=</span> <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"><span class="comment">//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是弱引用</span></span><br><span class="line">List&lt;WeakReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 强引用</span></span><br><span class="line">WeakReference&lt;<span class="type">byte</span>[]&gt; ref= <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[_4M]); <span class="comment">// 弱引用</span></span><br><span class="line">    <span class="comment">// List list --强--&gt; WeakReference ref --弱--&gt; byte[_4M]</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//使用引用队列，用于移除引用为空的软引用对象</span></span><br><span class="line">ReferenceQueue&lt;<span class="type">byte</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;(); <span class="comment">// 引用队列</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历引用队列，如果有元素，则取出</span></span><br><span class="line">Reference&lt;? <span class="keyword">extends</span> <span class="title class_">byte</span>[]&gt; poll = queue.poll(); <span class="comment">// poll(), 取出最先放入队列的元素，返回类型Reference</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">while</span>(poll != <span class="literal">null</span>) &#123;</span><br><span class="line"><span class="comment">//引用队列不为空，则从集合中移除该元素</span></span><br><span class="line">list.remove(poll);</span><br><span class="line"><span class="comment">//移动到引用队列中的下一个元素</span></span><br><span class="line">poll = queue.poll();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="1-3-4-虚引用-PhantomReference"><a href="#1-3-4-虚引用-PhantomReference" class="headerlink" title="1.3.4 虚引用 (PhantomReference)"></a>1.3.4 虚引用 (PhantomReference)</h5><p>必须配合引用队列一同使用。当虚（终结器）引用被创建时，会关联一个引用队列。</p><p>当虚引用对象所引用的对象被回收以后，虚引用对象就会被放入引用队列中，调用虚引用的方法</p><ul><li>虚引用的一个体现是<strong>释放直接内存所分配的内存</strong>，当引用的对象ByteBuffer被垃圾回收以后，虚引用对象Cleaner就会被放入引用队列中，然后调用Cleaner的clean()方法来释放直接内存</li><li>如上图，B对象不再引用ByteBuffer对象，ByteBuffer就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象Cleaner放入引用队列中，然后调用它的clean方法来释放直接内存</li></ul><h5 id="1-3-5-终结器引用-FinalReference"><a href="#1-3-5-终结器引用-FinalReference" class="headerlink" title="1.3.5 终结器引用 (FinalReference)"></a>1.3.5 终结器引用 (FinalReference)</h5><p>所有的对象都继承自Object类，Object类有一个finalize()方法。当某个对象不再被其他的对象所引用时，会先将终结器引用对象放入引用队列中(处理这个引用队列的<em>FinalizeHandler线程</em>优先级很低)，然后根据终结器引用对象找到它所引用的对象，然后调用该对象的finalize()方法。调用以后，该对象就可以被垃圾回收了。</p><ul><li>如上图，B对象不再引用A4对象。这是终结器对象就会被放入引用队列中，引用队列会根据它，找到它所引用的对象。然后调用被引用对象的finalize()方法。调用以后，该对象就可以被垃圾回收了</li></ul><h3 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2 垃圾回收算法"></a>2 垃圾回收算法</h3><h4 id="2-1-标记-清除-算法-Mark-Sweep"><a href="#2-1-标记-清除-算法-Mark-Sweep" class="headerlink" title="2.1 标记 - 清除 算法 (Mark - Sweep)"></a>2.1 标记 - 清除 算法 (Mark - Sweep)</h4><p><img src="/2022/03/22/JVM-2/20200608150813.png" alt="20200608150813" style="zoom:67%;"></p><p><strong>定义</strong>：标记清除算法顾名思义，是指在虚拟机执行垃圾回收的过程中，先采用标记算法确定可回收对象（图中为没有GC Root引用的块），然后垃圾收集器根据标识清除相应的内容，给堆内存腾出相应的空间。</p><ul><li>这里的腾出内存空间并不是将内存空间的字节清0，而是记录下这段内存的起始结束地址，下次分配内存的时候，会直接<strong>覆盖</strong>这段内存。同理于操作系统中的内存管理</li></ul><p>优点：垃圾回收速度快</p><p><strong>缺点</strong>：<strong>容易产生大量的内存碎片</strong>，可能无法满足大对象的内存分配，一旦导致无法分配对象，那就会导致jvm启动gc，一旦启动gc，我们的应用程序就会暂停，这就导致应用的响应速度变慢。同理于操作系统中的内存碎片。</p><h4 id="2-2-标记-整理-算法-Mark-Compact"><a href="#2-2-标记-整理-算法-Mark-Compact" class="headerlink" title="2.2 标记 - 整理 算法 (Mark - Compact)"></a>2.2 标记 - 整理 算法 (Mark - Compact)</h4><p><img src="/2022/03/22/JVM-2/20200608150827.png" alt="20200608150827"></p><p><strong>标记-整理</strong> 会将不被GC Root引用的对象回收，清理其占用的内存空间。然后整理剩余的对象（将其地址向前移动，使内存更为紧凑，连续空间更多），可以<strong>有效避免因内存碎片而导致的问题</strong>，但是因为整体需要消耗一定的时间，所以<strong>效率较低</strong></p><h4 id="2-3-复制-算法-Copy"><a href="#2-3-复制-算法-Copy" class="headerlink" title="2.3 复制 算法 (Copy)"></a>2.3 复制 算法 (Copy)</h4><p>将内存分为等大小的两个区域，FROM和TO（TO中为空）。</p><p>先将被GC Root引用的对象从FROM放入TO中，再回收不被GC Root引用的对象。然后交换FROM和TO。这样也可以避免内存碎片的问题，但是会<strong>占用双倍的内存空间</strong>。</p><ol><li>如下图，先采用标记算法确定可回收对象（图中为没有GC Root引用的块）</li></ol><p><img src="/2022/03/22/JVM-2/20200608150842.png" alt="20200608150842" style="zoom:75%;"></p><ol><li>将FROM区域中存活的对象复制到TO区域</li></ol><p><img src="/2022/03/22/JVM-2/20200608150856.png" alt="20200608150856" style="zoom:75%;"></p><ol><li>此时由于FROM区域中全是垃圾，全部清空</li></ol><p><img src="/2022/03/22/JVM-2/20200608150907.png" alt="20200608150907" style="zoom:75%;"></p><ol><li>交换 FROM 区域 和 TO 区域 的位置</li></ol><p><img src="/2022/03/22/JVM-2/20200608150919.png" alt="20200608150919" style="zoom:75%;"></p><h3 id="3-分代垃圾回收机制"><a href="#3-分代垃圾回收机制" class="headerlink" title="3 分代垃圾回收机制"></a>3 分代垃圾回收机制</h3><p><img src="/2022/03/22/JVM-2/20200608150931.png" alt="20200608150931"></p><p>如上图，我们将堆内存划分成两个部分，一个是左边的YoungGeneration新生代 (新生代又分为伊甸园Edin、幸存区FROM 和 幸存区TO 三个部分)，另一个是老年代OldGeneration。</p><p>Java中，长时间使用的对象放在老年代中，用完就可以丢弃的对象放在新生代中。这样就可以根据对象的存活时间的不同特点进行不用的回收策略。老年代中的垃圾回收很久发生一次，而新生代中回收更频繁。</p><h4 id="3-1-分代回收流程"><a href="#3-1-分代回收流程" class="headerlink" title="3.1 分代回收流程"></a>3.1 分代回收流程</h4><ol><li>新创建的对象都被放在了<strong>新生代的伊甸园</strong>中，伊甸园逐渐就会被占满。</li></ol><p><img src="/2022/03/22/JVM-2/20200608150939.png" alt="20200608150939"></p><p><img src="/2022/03/22/JVM-2/20200608150946.png" alt="20200608150946"></p><ol><li><p>当伊甸园中的内存不足时，就会进行一次垃圾回收，这时新生代的垃圾回收叫做 <strong>Minor GC</strong></p><p>(1) Minor GC触发后，采用“可达性分析算法”，沿着以GC Root对象（根对象）为起点的引用链，采用“标记算法”确定可回收对象；</p><p>(2) 标记完成后，采用“复制算法”将<strong>伊甸园和幸存区FROM</strong>存活的对象<strong>先</strong>复制到 <strong>幸存区 TO</strong>中， 并让其<strong>寿命加1</strong>；</p><p>(3) 根据复制算法，我们将交换 幸存区FROM 和 幸存区TO 的位置</p><p><img src="/2022/03/22/JVM-2/20200608150955.png" alt="20200608150955"></p></li></ol><p><img src="/2022/03/22/JVM-2/20200608151002.png" alt="20200608151002"></p><ol><li><p>再次创建对象，若新生代的伊甸园又满了，则会<strong>再次触发 Minor GC</strong>（会触发 <strong>“Stop the world”</strong>， 暂停其他用户线程，只让垃圾回收线程工作）；</p><p>这时不仅会回收伊甸园中的垃圾，<strong>还会回收幸存区中的垃圾</strong>，再将活跃对象复制到幸存区TO中；</p><p>回收以后会交换两个幸存区，并让幸存区中的对象<strong>寿命加1</strong></p></li></ol><p><img src="/2022/03/22/JVM-2/20200608151010.png" alt="20200608151010"></p><ol><li>如果幸存区中的对象的<strong>寿命超过某个阈值</strong>（最大为15，4bit），就会<strong>晋升到老年代</strong>中</li></ol><p><img src="/2022/03/22/JVM-2/20200608151018.png" alt="20200608151018"></p><ol><li>如果新生代老年代中的内存都满了，就会先触发Minor GC，再触发<strong>Full GC</strong> (整体清理)，也会触发“Stop the world”，时间更长，以扫描<strong>新生代和老年代中</strong>所有不再使用的对象并回收</li><li>如果老年代的内存也不够，内存分配失败，触发 <code>java.lang.OutOfMemoryError</code>。</li></ol><p><img src="/2022/03/22/JVM-2/IMG_FB5339E468EB-1.jpeg" alt="IMG_FB5339E468EB-1"></p><h4 id="3-2-相关虚拟机参数"><a href="#3-2-相关虚拟机参数" class="headerlink" title="3.2 相关虚拟机参数"></a>3.2 相关虚拟机参数</h4><div class="table-container"><table><thead><tr><th style="text-align:left">含义</th><th style="text-align:left">参数</th></tr></thead><tbody><tr><td style="text-align:left">堆初始大小</td><td style="text-align:left"><code>-Xms</code></td></tr><tr><td style="text-align:left">堆最大大小</td><td style="text-align:left"><code>-Xmx</code> 或 <code>-XX:MaxHeapSize=size</code></td></tr><tr><td style="text-align:left">新生代大小</td><td style="text-align:left"><code>-Xmn</code> 或 <code>-XX:NewSize=size + XX:MaxNewSize=size</code></td></tr><tr><td style="text-align:left">幸存区比例（动态）</td><td style="text-align:left"><code>-XX:InitialSurvivorRatio=ratio</code> 和 <code>-XX:+UseAdaptiveSizePolicy</code></td></tr><tr><td style="text-align:left">幸存区比例</td><td style="text-align:left"><code>-XX:SurvivorRatio=ratio</code></td></tr><tr><td style="text-align:left">晋升阈值</td><td style="text-align:left"><code>-XX:MaxTenuringThreshold=threshold</code></td></tr><tr><td style="text-align:left">晋升详情</td><td style="text-align:left"><code>-XX:+PrintTenuringDistribution</code></td></tr><tr><td style="text-align:left">GC详情</td><td style="text-align:left"><code>-XX:+PrintGCDetails -verbose:gc</code></td></tr><tr><td style="text-align:left">FullGC 前 MinorGC</td><td style="text-align:left"><code>-XX:+ScavengeBeforeFullGC</code></td></tr><tr><td style="text-align:left"></td></tr></tbody></table></div><h4 id="3-3-GC分析"><a href="#3-3-GC分析" class="headerlink" title="3.3  GC分析"></a>3.3  GC分析</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line">def new generationtotal 9216K, used 2309K [0x00000000fec00000, 0x00000000ff600000, 0x00000000ff600000)</span><br><span class="line">edenspace 8192K,28% used [0x00000000fec00000, 0x00000000fee41460, 0x00000000ff400000)</span><br><span class="line">fromspace 1024K, 0% used [0x00000000ff400000, 0x00000000ff400000, 0x00000000ff500000)</span><br><span class="line">tospace 1024K, 0% used [0x00000000ff500000, 0x00000000ff500000, 0x00000000ff600000)</span><br><span class="line">tenured generationtotal 10240K, used 0K [0x00000000ff600000, 0x00000000ff600200, 0x0000000100000000)</span><br><span class="line"> the space 10240K, 0% used [0x00000000ff600000, 0x00000000ff600000, 0x00000000ff600200, 0x0000000100000000)</span><br><span class="line">Metaspaceused 3279K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">class spaceused 359K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure><h5 id="3-3-1-大对象处理策略"><a href="#3-3-1-大对象处理策略" class="headerlink" title="3.3.1 大对象处理策略"></a>3.3.1 大对象处理策略</h5><p>当遇到一个<strong>较大的对象</strong>时，就算新生代的<strong>伊甸园</strong>为空，也<strong>无法容纳该对象</strong>时，会将该对象<strong>直接晋升为老年代</strong></p><h5 id="3-3-2-线程内存溢出"><a href="#3-3-2-线程内存溢出" class="headerlink" title="3.3.2 线程内存溢出"></a>3.3.2 线程内存溢出</h5><p>某个线程的内存溢出了而抛异常 (<code>java.lang.OutOfMemoryError</code>)，不会让其他的线程结束运行，原因如下：</p><ul><li>当一个线程<strong>抛出OOM异常后</strong>，<strong>它所占据的内存资源会全部被释放掉</strong>，从而不会影响其他线程的运行，<strong>其他进程依然正常</strong></li></ul><h3 id="4-垃圾回收器"><a href="#4-垃圾回收器" class="headerlink" title="4 垃圾回收器"></a>4 垃圾回收器</h3><p>更新中…</p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;JVM-基础学习&quot;&gt;&lt;a href=&quot;#JVM-基础学习&quot; class=&quot;headerlink&quot; title=&quot;JVM 基础学习&quot;&gt;&lt;/a&gt;JVM 基础学习&lt;/h1&gt;&lt;p&gt;视频课程: &lt;a href=&quot;https://www.bilibili.com/video/BV1yE411Z7AP?p=48&quot;&gt;BiliBili - 黑马程序员JVM完整教程: JVM垃圾回收&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;三、JVM-垃圾回收&quot;&gt;&lt;a href=&quot;#三、JVM-垃圾回收&quot; class=&quot;headerlink&quot; title=&quot;三、JVM 垃圾回收&quot;&gt;&lt;/a&gt;三、JVM 垃圾回收&lt;/h2&gt;&lt;h3 id=&quot;0-主要内容大纲&quot;&gt;&lt;a href=&quot;#0-主要内容大纲&quot; class=&quot;headerlink&quot; title=&quot;0 主要内容大纲&quot;&gt;&lt;/a&gt;0 主要内容大纲&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;如何判断对象可以回收&lt;/li&gt;
&lt;li&gt;垃圾回收算法&lt;/li&gt;
&lt;li&gt;分代垃圾回收&lt;/li&gt;
&lt;li&gt;垃圾回收器&lt;/li&gt;
&lt;li&gt;垃圾回收调优&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://dave0126.github.io/categories/JVM/"/>
    
    
    <category term="Java" scheme="https://dave0126.github.io/tags/Java/"/>
    
    <category term="JVM" scheme="https://dave0126.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java 虚拟机 - JVM 第一讲</title>
    <link href="https://dave0126.github.io/2022/03/22/JVM-1/"/>
    <id>https://dave0126.github.io/2022/03/22/JVM-1/</id>
    <published>2022-03-22T20:52:44.000Z</published>
    <updated>2022-03-23T22:59:48.864Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM-基础学习"><a href="#JVM-基础学习" class="headerlink" title="JVM 基础学习"></a>JVM 基础学习</h1><p>视频课程: <a href="https://www.bilibili.com/video/BV1yE411Z7AP">BiliBili - 黑马程序员JVM完整教程</a></p><p>Java Virtual Machine - java 程序的运行环境(Java 二进制字节码的运行环境)</p><p><strong>好处:</strong></p><ul><li>可以提供一个跨平台的一致的运行环境, 达到平台无关性;</li><li>提供内存管理, 垃圾回收功能;</li></ul><p>JRE = JVM + 基础类库<br>JDK = JVM + 基础类库 + 编译工具</p><span id="more"></span><h2 id="一、JVM-结构"><a href="#一、JVM-结构" class="headerlink" title="一、JVM 结构"></a>一、JVM 结构</h2><p><img src="/2022/03/22/JVM-1/1.png" alt="arch"></p><h2 id="二、JVM-内存结构"><a href="#二、JVM-内存结构" class="headerlink" title="二、JVM 内存结构"></a>二、JVM 内存结构</h2><ol><li>程序计数器 (Program Counter Register)</li><li>虚拟机栈 (JVM Stacks)</li><li>本地方法栈 (Native Method Stacks)</li><li>堆 (Heap)</li><li>方法区 (Method Area)</li></ol><h3 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1 程序计数器"></a>1 程序计数器</h3><p>作用: 在指令的执行中, 记住<strong>下一条JVM指令的执行地址</strong>. 在物理上可使用<strong>寄存器</strong>实现.</p><p>特点:</p><ul><li>线程私有. 在多线程下, 线程间切换时需要保存当前环境, 需要用到程序计数器记住下一条JVM指令的执行地址</li><li>不会存在内存溢出.</li></ul><h3 id="2-虚拟机栈"><a href="#2-虚拟机栈" class="headerlink" title="2 虚拟机栈"></a>2 虚拟机栈</h3><h4 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h4><p>回忆数据结构中“栈”的结构: 先进后出</p><p>虚拟机栈是<strong>线程运行需要的内存空间</strong>, <strong>一个栈由多个栈帧组成</strong>. 一个栈帧对应一次方法的调用, <strong>栈帧(Frame)</strong>即<strong>每个方法运行时需要的内存(参数、局部变量、返回地址等)</strong>.</p><ul><li>每个线程只能有一个活动栈帧,对应着当前正在执行的那个方法.</li></ul><p>可以在idea用debug模式下的“Debugger”视图中看到栈和栈帧.</p><p><strong>思考:</strong></p><ul><li>在函数的调用中, <ol><li>先把主调函数入栈, 调用被调函数, 紧接着被调函数入栈, 活动栈帧为被调函数;</li><li>等被调函数返回返回值时, 被调函数出栈, 活动栈帧为主调函数.</li></ol></li><li>垃圾回收不涉及栈内存, 因为每次执行后栈内存都会被清空(出栈)</li><li>栈内存越大, 线程数越小 (默认 1024KB)</li></ul><h4 id="2-2-栈内存溢出"><a href="#2-2-栈内存溢出" class="headerlink" title="2.2 栈内存溢出"></a>2.2 栈内存溢出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.StackOverflowError</span><br></pre></td></tr></table></figure><ol><li>栈帧过多导致内存溢出<ul><li>想象一下, 在不断的调用方法时, 一直入栈没有出栈, 直到某一次调用时无法分配新的栈帧内存. e.g.无递归终止条件的<strong>递归调用</strong></li></ul></li><li>栈帧过大导致内存溢出, 栈帧 &gt; 栈内存</li></ol><h4 id="2-3-线程运行诊断"><a href="#2-3-线程运行诊断" class="headerlink" title="2.3 线程运行诊断"></a>2.3 线程运行诊断</h4><p>JDK 自带一个工具“JStack“命令, 用于定位CPU占用过多的Java线程(TID). 根据线程id(TID)找到有问题的线程,即可能有问题的代码行数. 也可以发现<strong>有死锁的进程</strong>.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack 进程id(PID)</span><br></pre></td></tr></table></figure><h3 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3 本地方法栈"></a>3 本地方法栈</h3><p>不是由Java代码编写的方法, 由于java语言限制, 不能直接和os底层“打交道”, 所以需要c/c++语言编写的方法直接与底层os“打交道”, 而java代码可以使用本地方法调用来调用这些方法.<br>本地方法使用的内存就是本地方法栈.</p><ul><li>e.g. <code>hashCode()</code>, <code>wait()</code>, <code>notify()</code>, <code>notifyAll()</code> 等</li><li>由 <code>native</code> 修饰</li></ul><h3 id="4-堆"><a href="#4-堆" class="headerlink" title="4 堆"></a>4 堆</h3><p>线程共享的区域</p><h4 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h4><ul><li>通过 <code>new</code> 关键字 -&gt; 创建一个堆, 都会使用堆的内存</li></ul><p>特点:</p><ul><li><strong>线程共享</strong>, 堆中对象都要考虑线程安全问题</li><li>有垃圾回收机制, 当对象不再被时, 其占用的内存会被回收</li></ul><h4 id="4-2-堆内存溢出"><a href="#4-2-堆内存溢出" class="headerlink" title="4.2 堆内存溢出"></a>4.2 堆内存溢出</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 创建堆</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            list.add(a);</span><br><span class="line">            a = a + a; <span class="comment">// Hello, HelloHello, HelloHelloHelloHello, ....</span></span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="4-3-堆内存诊断"><a href="#4-3-堆内存诊断" class="headerlink" title="4.3 堆内存诊断"></a>4.3 堆内存诊断</h4><p>java常用工具:</p><ol><li>jps 工具<ul><li>查看当前系统中有哪些java进程</li></ul></li><li>jmap 工具 <ul><li>查看某一时刻下,堆内存的占用情况</li></ul></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ jps</span><br><span class="line">$ jmap -heap 进程id(PID)</span><br></pre></td></tr></table></figure><ol><li>jconsole 工具<ul><li>图形界面的, 多功能的检查工具, 可以连续监测</li></ul></li><li>jvisualvm 工具 (需要自行下载)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;1....&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">    <span class="type">byte</span>[] array = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>];  <span class="comment">// 堆中内存占用新增10MB</span></span><br><span class="line">    System.out.println(<span class="string">&quot;2....&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">    array = <span class="literal">null</span>;</span><br><span class="line">    System.gc();                                <span class="comment">// 垃圾回收</span></span><br><span class="line">    System.out.println(<span class="string">&quot;3....&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5 方法区"></a>5 方法区</h3><h4 id="5-1-定义"><a href="#5-1-定义" class="headerlink" title="5.1 定义"></a>5.1 定义</h4><p>方法区是JVM中<strong>所有线程共享</strong>的区域.</p><p>存储了<strong>与类结构相关的信息</strong>: </p><ul><li>成员变量(field)</li><li>方法的数据(method data)</li><li>方法的代码(code of method)</li><li>构造器的代码(code of constructor)</li><li>运行时常量池(run-time constant pool)</li></ul><p>方法区在JVM启动时创建, 逻辑上是堆的一部分.</p><h4 id="5-2-组成"><a href="#5-2-组成" class="headerlink" title="5.2 组成"></a>5.2 组成</h4><p>JDK1.6 与 JDK1.8<br><img src="/2022/03/22/JVM-1/IMG_6B2CE85A4DCA-1.jpeg" alt="methodArea"></p><h4 id="5-3-方法区的内存溢出"><a href="#5-3-方法区的内存溢出" class="headerlink" title="5.3 方法区的内存溢出"></a>5.3 方法区的内存溢出</h4><ul><li>永久代内存溢出（JDK 1.8以前）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: PermGen space</span><br><span class="line">-XX:MaxPermSize=8m</span><br></pre></td></tr></table></figure><ul><li>元空间内存溢出（JDK 1.8以后）</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Metaspace</span><br><span class="line">-XX:MaxMetaspaceSize=8m</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123; <span class="comment">// 类加载器: 可以用来加载类的二进制字节码, 动态加载</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Demo</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++, j++) &#123;</span><br><span class="line">                <span class="type">ClassWriter</span> <span class="variable">cw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(<span class="number">0</span>); <span class="comment">// ClassWriter作用是生成类的二进制字节码</span></span><br><span class="line">                <span class="comment">// 版本号, public, 类名:1~10000, 包名:null, 父类: 继承自&quot;java/lang/Object&quot;, 接口名:null</span></span><br><span class="line">                cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, <span class="string">&quot;Class&quot;</span> + i, <span class="literal">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="literal">null</span>);</span><br><span class="line">                <span class="comment">//返回 byte[]</span></span><br><span class="line">                <span class="type">byte</span>[] code = cw.toByteArray();</span><br><span class="line">                <span class="comment">// 只执行类的加载, 而不链接</span></span><br><span class="line">                test.defineClass(<span class="string">&quot;Class&quot;</span> + i, code, <span class="number">0</span>, code.length); <span class="comment">// class 对象</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有可能的溢出场景：实际生产中，动态产生并加载类时容易产生这种内存溢出</p><ol><li>Spring框架 中的cglib字节码技术，AOP的核心 - 生成动态代理类</li><li>Mybatis框架 中的cglib字节码技术</li></ol><h4 id="5-4-运行时常量池"><a href="#5-4-运行时常量池" class="headerlink" title="5.4 运行时常量池"></a>5.4 运行时常量池</h4><p>编译后的二进制字节码包含: 类基本信息、常量池、类方法定义、虚拟机指令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -v &lt;xxx.class&gt; // -v 显示反编译后的详细信息</span><br></pre></td></tr></table></figure><p>例如:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后的详细信息: </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line">Classfile /学习笔记/JVM学习笔记/test.class</span><br><span class="line">  Last modified 2022年3月6日; size 413 bytes</span><br><span class="line">  SHA-256 checksum 7ab757ee2d78f0e76a52ba8b03b43fee2fe9d7994d74bc7d133b2e309ceed8f3</span><br><span class="line">  Compiled from <span class="string">&quot;test.java&quot;</span></span><br><span class="line">public class <span class="built_in">test</span></span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 59</span><br><span class="line">  flags: (0x0021) ACC_PUBLIC, ACC_SUPER// 访问修饰符</span><br><span class="line">  this_class: <span class="comment">#21                         // test</span></span><br><span class="line">  super_class: <span class="comment">#2                         // 父类:java/lang/Object</span></span><br><span class="line">  interfaces: 0, fields: 0, methods: 2, attributes: 1</span><br><span class="line">Constant pool:// 常量池</span><br><span class="line">   <span class="comment">#1 = Methodref          #2.#3          // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   <span class="comment">#2 = Class              #4             // java/lang/Object</span></span><br><span class="line">   <span class="comment">#3 = NameAndType        #5:#6          // &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">   <span class="comment">#4 = Utf8               java/lang/Object</span></span><br><span class="line">   <span class="comment">#5 = Utf8               &lt;init&gt;</span></span><br><span class="line">   <span class="comment">#6 = Utf8               ()V</span></span><br><span class="line">   <span class="comment">#7 = Fieldref           #8.#9          // java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">   <span class="comment">#8 = Class              #10            // java/lang/System</span></span><br><span class="line">   <span class="comment">#9 = NameAndType        #11:#12        // out:Ljava/io/PrintStream;</span></span><br><span class="line">  <span class="comment">#10 = Utf8               java/lang/System</span></span><br><span class="line">  <span class="comment">#11 = Utf8               out</span></span><br><span class="line">  <span class="comment">#12 = Utf8               Ljava/io/PrintStream;</span></span><br><span class="line">  <span class="comment">#13 = String             #14            // Hello World</span></span><br><span class="line">  <span class="comment">#14 = Utf8               Hello World</span></span><br><span class="line">  <span class="comment">#15 = Methodref          #16.#17        // java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">  <span class="comment">#16 = Class              #18            // java/io/PrintStream</span></span><br><span class="line">  <span class="comment">#17 = NameAndType        #19:#20        // println:(Ljava/lang/String;)V</span></span><br><span class="line">  <span class="comment">#18 = Utf8               java/io/PrintStream</span></span><br><span class="line">  <span class="comment">#19 = Utf8               println</span></span><br><span class="line">  <span class="comment">#20 = Utf8               (Ljava/lang/String;)V</span></span><br><span class="line">  <span class="comment">#21 = Class              #22            // test</span></span><br><span class="line">  <span class="comment">#22 = Utf8               test</span></span><br><span class="line">  <span class="comment">#23 = Utf8               Code</span></span><br><span class="line">  <span class="comment">#24 = Utf8               LineNumberTable</span></span><br><span class="line">  <span class="comment">#25 = Utf8               main</span></span><br><span class="line">  <span class="comment">#26 = Utf8               ([Ljava/lang/String;)V</span></span><br><span class="line">  <span class="comment">#27 = Utf8               SourceFile</span></span><br><span class="line">  <span class="comment">#28 = Utf8               test.java</span></span><br><span class="line">&#123;</span><br><span class="line">  public <span class="built_in">test</span>();// 当程序没有构造方法时, 编译器会自动生成一个无参的构造方法</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (0x0001) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial <span class="comment">#1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         4: <span class="built_in">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 1: 0</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);// main方法</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: (0x0009) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">      // 虚拟机指令<span class="comment">#n: 对应着常量池中的变量</span></span><br><span class="line">         0: getstatic     <span class="comment">#7                  // Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">         3: ldc           <span class="comment">#13                 // String Hello World 加载引用地址</span></span><br><span class="line">         5: invokevirtual <span class="comment">#15                 // Method java/io/PrintStream.println:(Ljava/lang/String;方法的参数类型)V 虚拟方法调用</span></span><br><span class="line">         8: <span class="built_in">return</span></span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">        line 4: 8</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: <span class="string">&quot;test.java&quot;</span></span><br></pre></td></tr></table></figure><ul><li>以上的例子表明, <strong>常量池</strong>就是一张常量表, 虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量(如字符串、整型、bool类型等)等信息</li><li>运行时常量池, 就是当该类被加载时, 它的常量池信息会放入运行常量池, 地址会替换为真正的内存地址</li></ul><h4 id="5-5-StringTable串池"><a href="#5-5-StringTable串池" class="headerlink" title="5.5 StringTable串池"></a>5.5 StringTable串池</h4><p>特征：</p><ul><li><p>常量池中的信息，都会被加载到运行时常量池中。这时a b ab都是常量池中的符号，<strong>还不是 java字符串对象</strong></p></li><li><p>常量池中的字符串仅是符号，只有<strong>在被第一次引用到时才会转化为对象</strong>，ldc</p></li><li><p>StringTable在内存结构上是哈希表，不能扩容</p></li><li><p>利用串池的机制，来避免重复创建字符串对象</p></li><li><p>字符串<strong>变量</strong>拼接的原理是<strong>StringBuilder</strong></p></li><li><p>字符串<strong>常量</strong>拼接的原理是<strong>编译器优化</strong></p></li><li><p>可以使用<strong>intern方法</strong>，主动将串池中还没有的字符串对象放入串池中</p><p><strong>注意</strong>：无论是串池还是堆里面的字符串，都是对象</p></li></ul><h5 id="5-5-1-串池"><a href="#5-5-1-串池" class="headerlink" title="5.5.1 串池"></a>5.5.1 串池</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableStudy</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>; </span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">ab</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常量池中的信息:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0: ldc           <span class="comment">#2                  // String a</span></span><br><span class="line">2: astore_1// 把 a符号 变成 “a”字符串对象</span><br><span class="line">3: ldc           <span class="comment">#3                 // String b</span></span><br><span class="line">5: astore_2// 把 b符号 变成 “b”字符串对象</span><br><span class="line">6: ldc           <span class="comment">#4                  // String ab</span></span><br><span class="line">8: astore_3// 把 ab符号 变成 “ab”字符串对象</span><br><span class="line">9: <span class="built_in">return</span></span><br></pre></td></tr></table></figure><ol><li><p>当执行到 ldc #2 时，会把符号 a 变为 “a” 字符串对象，<strong>并放入串池中</strong>（hashtable结构 不可扩容）</p></li><li><p>当执行到 ldc #3 时，会把符号 b 变为 “b” 字符串对象，并放入串池中</p></li><li><p>当执行到 ldc #4 时，会把符号 ab 变为 “ab” 字符串对象，并放入串池中</p></li><li><p>最终<strong>StringTable [“a”, “b”, “ab”]</strong></p><p><strong>注意</strong>：字符串对象的创建都是<strong>懒惰的</strong>，只有当运行到那一行字符串且在串池中不存在的时候（如 ldc #2）时，该字符串才会被创建并放入串池中。</p></li></ol><h5 id="5-5-2-串池：拼接变量字符串对象创建字符串"><a href="#5-5-2-串池：拼接变量字符串对象创建字符串" class="headerlink" title="5.5.2 串池：拼接变量字符串对象创建字符串"></a>5.5.2 串池：拼接变量字符串对象创建字符串</h5><p>使用拼接<strong>字符串变量对象</strong>创建字符串的过程: </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableStudy</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">ab</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">ab2</span> <span class="operator">=</span> a+b;  <span class="comment">// 拼接字符串对象来创建新的字符串 new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toSrting()</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(ab == ab2); <span class="comment">// 结果为false</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">    stack=2, locals=5, args_size=1</span><br><span class="line">       0: ldc           <span class="comment">#2                  // String a</span></span><br><span class="line">       2: astore_1</span><br><span class="line">       3: ldc           <span class="comment">#3                  // String b</span></span><br><span class="line">       5: astore_2</span><br><span class="line">       6: ldc           <span class="comment">#4                  // String ab</span></span><br><span class="line">       8: astore_3</span><br><span class="line">       9: new           <span class="comment">#5                  // class java/lang/StringBuilder</span></span><br><span class="line">      12: dup</span><br><span class="line">      13: invokespecial <span class="comment">#6                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">      16: aload_1</span><br><span class="line">      17: invokevirtual <span class="comment">#7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">      20: aload_2</span><br><span class="line">      21: invokevirtual <span class="comment">#7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">      24: invokevirtual <span class="comment">#8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">      27: astore        4</span><br><span class="line">      29: <span class="built_in">return</span></span><br></pre></td></tr></table></figure><p>通过拼接的方式来创建字符串的<strong>过程</strong>是：new StringBuilder().append(“a”).append(“b”).toString()，地址应该在<strong>堆</strong>中</p><p>最后的toString方法的返回值是一个<strong>新的字符串</strong>，但字符串的<strong>值</strong>和拼接的字符串一致，但是两个不同的字符串，<strong>一个存在于串池之中，一个存在于堆内存之中</strong></p><h5 id="5-5-3-串池：拼接常量字符串对象的方法创建字符串"><a href="#5-5-3-串池：拼接常量字符串对象的方法创建字符串" class="headerlink" title="5.5.3 串池：拼接常量字符串对象的方法创建字符串"></a>5.5.3 串池：<strong>拼接常量字符串对象</strong>的方法创建字符串</h5><p>使用<strong>拼接字符串常量对象</strong>的方法创建字符串</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableStudy</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">ab</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ab2</span> <span class="operator">=</span> a+b;</span><br><span class="line"><span class="type">String</span> <span class="variable">ab3</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>; <span class="comment">// 使用拼接字符串的方法创建字符串，由于编译期间的优化</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(ab == ab3); <span class="comment">// 结果为true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>反编译后的结果</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">  stack=2, locals=6, args_size=1</span><br><span class="line">     0: ldc           <span class="comment">#2                  // String a</span></span><br><span class="line">     2: astore_1</span><br><span class="line">     3: ldc           <span class="comment">#3                  // String b</span></span><br><span class="line">     5: astore_2</span><br><span class="line">     6: ldc           <span class="comment">#4                  // String ab</span></span><br><span class="line">     8: astore_3</span><br><span class="line">     9: new           <span class="comment">#5                  // class java/lang/StringBuilder</span></span><br><span class="line">    12: dup</span><br><span class="line">    13: invokespecial <span class="comment">#6                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">    16: aload_1</span><br><span class="line">    17: invokevirtual <span class="comment">#7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">    20: aload_2</span><br><span class="line">    21: invokevirtual <span class="comment">#7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span><br><span class="line">    24: invokevirtual <span class="comment">#8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span></span><br><span class="line">    27: astore        4//ab3初始化时直接从串池中获取字符串</span><br><span class="line">    29: ldc           <span class="comment">#4                  // String ab</span></span><br><span class="line">    31: astore        5</span><br><span class="line">    33: <span class="built_in">return</span></span><br></pre></td></tr></table></figure><ul><li><p>当虚拟机执行到<strong>第0、3、5行</strong>时，会将“a” “b“ ”ab“放入串池。当执行到<strong>29行</strong>时我们可以看到，虚拟机不会先找“a” 再找“b”然后再将它们拼接起来，而是之间找到拼接后的“ab”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringTable[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;ab&quot;</span>]</span><br></pre></td></tr></table></figure></li><li><p>使用<strong>拼接字符串常量</strong>的方法来创建新的字符串时，因为<strong>内容是常量，javac在编译期会进行优化，结果已在编译期确定为ab</strong>，而创建ab的时候已经在串池中放入了“ab”，所以ab3直接从串池中获取值，所以进行的操作和 ab = “ab” 一致。</p></li><li><p>使用<strong>拼接字符串变量</strong>的方法来创建新的字符串时，因为内容是变量，只能<strong>在运行期确定它的值，所以需要使用StringBuilder来创建</strong></p></li></ul><h5 id="5-5-4-串池：intern方法-JDK1-8"><a href="#5-5-4-串池：intern方法-JDK1-8" class="headerlink" title="5.5.4 串池：intern方法(JDK1.8)"></a>5.5.4 串池：intern方法(JDK1.8)</h5><p>调用字符串对象的intern()方法，会将该字符串对象尝试放入到串池中</p><ul><li>如果串池中没有该字符串对象，则放入成功</li><li>如果有该字符串对象，则放入失败</li><li>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</li></ul><p>Example1</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableInternMethod1</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">/* &quot;a&quot; &quot;b&quot; 被放入串池中，str则存在于堆内存之中 */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 调用str的intern方法，这时串池中没有&quot;ab&quot;，则会将该字符串对象放入到串池中，此时堆内存与串池中的&quot;ab&quot;是同一个对象*/</span></span><br><span class="line"><span class="type">String</span> <span class="variable">st2</span> <span class="operator">=</span> str.intern();</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 给str3赋值，因为此时串池中已有&quot;ab&quot;，则直接将串池中的内容返回 */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    </span><br><span class="line"><span class="comment">/* 因为堆内存与串池中的&quot;ab&quot;是同一个对象，所以以下两条语句打印的都为true */</span></span><br><span class="line">System.out.println(str == st2);</span><br><span class="line">System.out.println(str == str3);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Example2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SringTableInternMethod2</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">/* 此处创建字符串对象&quot;ab&quot;，因为串池中还没有&quot;ab&quot;，所以将其放入串池中 */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="comment">/* &quot;a&quot; &quot;b&quot; 被放入串池中，str则存在于堆内存之中 */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="comment">/* 此时因为在创建str3时，&quot;ab&quot;已存在与串池中，所以放入失败，但是会返回串池中的&quot;ab&quot; */</span></span><br><span class="line"><span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> str.intern();</span><br><span class="line">    </span><br><span class="line">System.out.println(str == str2); <span class="comment">//false</span></span><br><span class="line">System.out.println(str == str3); <span class="comment">//false</span></span><br><span class="line">System.out.println(str2 == str3); <span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="5-5-5-串池的位置"><a href="#5-5-5-串池的位置" class="headerlink" title="5.5.5 串池的位置"></a>5.5.5 串池的位置</h5><p>在JDK1.8中：</p><p><img src="/2022/03/22/JVM-1/IMG_42907AA7BAF6-1.jpeg" alt="StringTable1.8"></p><p>在JDK1.6中：</p><p><img src="/2022/03/22/JVM-1/IMG_9A689689FB20-1.jpeg" alt="1.6" style="zoom: 60%;"></p><h5 id="5-5-6-串池的垃圾回收"><a href="#5-5-6-串池的垃圾回收" class="headerlink" title="5.5.6 串池的垃圾回收"></a>5.5.6 串池的垃圾回收</h5><p>StringTable在内存紧张时，会发生垃圾回收。</p><h5 id="5-5-7-串池的性能调优"><a href="#5-5-7-串池的性能调优" class="headerlink" title="5.5.7 串池的性能调优"></a>5.5.7 串池的性能调优</h5><ul><li><p>因为StringTable是用HashTable实现的，所以我们可以<strong>适当增加HashTable的桶的个数</strong>，来减少字符串放入串池所需要的时间</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:StringTableSize=xxxx</span><br></pre></td></tr></table></figure></li><li><p>考虑是否需要将字符串对象入池，可以通过<strong>intern()方法减少重复入池</strong></p></li></ul><h3 id="6-直接内存"><a href="#6-直接内存" class="headerlink" title="6 直接内存"></a>6 直接内存</h3><h4 id="6-1-定义"><a href="#6-1-定义" class="headerlink" title="6.1 定义"></a>6.1 定义</h4><p>直接内存不属于JVM内存结构，而是<strong>操作系统的内存</strong>。</p><ul><li>属于操作系统，常见于NIO操作时，<strong>用于数据缓冲区</strong></li><li>分配回收成本较高，但读写性能高</li><li>不受JVM内存回收管理</li></ul><h4 id="6-2-基本使用"><a href="#6-2-基本使用" class="headerlink" title="6.2 基本使用"></a>6.2 基本使用</h4><p><img src="/2022/03/22/JVM-1/20200608150715.png" alt="123" style="zoom:60%;"></p><p>使用了DirectBuffer后</p><p><img src="/2022/03/22/JVM-1/20200608150736.png" alt="234" style="zoom:60%;"></p><p>直接内存是操作系统和Java代码<strong>都可以访问的一块区域</strong>，无需将代码从系统内存复制到Java堆内存，从而提高了效率</p><h4 id="6-3-分配和回收原理"><a href="#6-3-分配和回收原理" class="headerlink" title="6.3 分配和回收原理"></a>6.3 分配和回收原理</h4><ul><li>使用了Unsafe类来完成直接内存的分配回收，而且回收需要主动调用<strong>unsafe.freeMemory()</strong>方法</li><li>ByteBuffer的实现内部使用了Cleaner（虚引用）来检测ByteBuffer。一旦ByteBuffer被垃圾回收，那么会由ReferenceHandler来调用Cleaner的clean方法调用freeMemory来释放内存</li></ul><p>直接内存的回收不是通过JVM的垃圾回收来释放的，而是通过<strong>unsafe.freeMemory()</strong>来手动释放</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过ByteBuffer申请1M的直接内存</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(_1M);</span><br></pre></td></tr></table></figure><p>申请直接内存，但JVM并不能回收直接内存中的内容，它是如何实现回收的呢？</p><h5 id="allocateDirect-的实现底层源码分析"><a href="#allocateDirect-的实现底层源码分析" class="headerlink" title="allocateDirect() 的实现底层源码分析"></a>allocateDirect() 的实现底层源码分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title function_">allocateDirect</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectByteBuffer</span>(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DirectByteBuffer类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">DirectByteBuffer(<span class="type">int</span> cap) &#123;   <span class="comment">// package-private</span></span><br><span class="line">   </span><br><span class="line">    <span class="built_in">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">pa</span> <span class="operator">=</span> VM.isDirectMemoryPageAligned();</span><br><span class="line">    <span class="type">int</span> <span class="variable">ps</span> <span class="operator">=</span> Bits.pageSize();</span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> Math.max(<span class="number">1L</span>, (<span class="type">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        base = unsafe.allocateMemory(size); <span class="comment">//申请内存</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.setMemory(base, size, (<span class="type">byte</span>) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// Round up to page boundary</span></span><br><span class="line">        address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    cleaner = Cleaner.create(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">Deallocator</span>(base, size, cap)); <span class="comment">//通过虚引用，来实现直接内存的释放，this为虚引用的实际对象</span></span><br><span class="line">    att = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里调用了一个Cleaner的create()方法，且后台线程还会对虚引用的对象监测，如果虚引用的实际对象（这里是DirectByteBuffer）被回收以后，就会调用Cleaner的clean()方法，来清除直接内存中占用的内存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clean</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (remove(<span class="built_in">this</span>)) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="built_in">this</span>.thunk.run(); <span class="comment">//调用run方法</span></span><br><span class="line">           &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable var2) &#123;</span><br><span class="line">               AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">                   <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                       <span class="keyword">if</span> (System.err != <span class="literal">null</span>) &#123;</span><br><span class="line">                           (<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Cleaner terminated abnormally&quot;</span>, var2)).printStackTrace();</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       System.exit(<span class="number">1</span>);</span><br><span class="line">                       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><p>对应对象的run()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (address == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Paranoia</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.freeMemory(address); <span class="comment">//释放直接内存中占用的内存</span></span><br><span class="line">    address = <span class="number">0</span>;</span><br><span class="line">    Bits.unreserveMemory(size, capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;JVM-基础学习&quot;&gt;&lt;a href=&quot;#JVM-基础学习&quot; class=&quot;headerlink&quot; title=&quot;JVM 基础学习&quot;&gt;&lt;/a&gt;JVM 基础学习&lt;/h1&gt;&lt;p&gt;视频课程: &lt;a href=&quot;https://www.bilibili.com/video/BV1yE411Z7AP&quot;&gt;BiliBili - 黑马程序员JVM完整教程&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Java Virtual Machine - java 程序的运行环境(Java 二进制字节码的运行环境)&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;好处:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可以提供一个跨平台的一致的运行环境, 达到平台无关性;&lt;/li&gt;
&lt;li&gt;提供内存管理, 垃圾回收功能;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;JRE = JVM + 基础类库&lt;br&gt;JDK = JVM + 基础类库 + 编译工具&lt;/p&gt;</summary>
    
    
    
    <category term="JVM" scheme="https://dave0126.github.io/categories/JVM/"/>
    
    
    <category term="Java" scheme="https://dave0126.github.io/tags/Java/"/>
    
    <category term="JVM" scheme="https://dave0126.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>图论 复习笔记</title>
    <link href="https://dave0126.github.io/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/"/>
    <id>https://dave0126.github.io/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/</id>
    <published>2022-01-16T13:08:24.000Z</published>
    <updated>2022-04-25T08:14:45.803Z</updated>
    
    <content type="html"><![CDATA[<h2 id="图论"><a href="#图论" class="headerlink" title="图论"></a>图论</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p><a href="https://dave0126.github.io/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/">本文章</a>是根据法国国立高等电力技术、电子学、计算机、水力学与电信学校 (E.N.S.E.E.I.H.T.) 第七学期课程<em>“Graph Theory”</em> 总结而来的课程笔记。碍于本人学识有限，部分叙述难免存在纰漏，请读者注意甄别。</p><span id="more"></span><h3 id="第一部分：基本概念及定义"><a href="#第一部分：基本概念及定义" class="headerlink" title="第一部分：基本概念及定义"></a>第一部分：基本概念及定义</h3><h4 id="无向图"><a href="#无向图" class="headerlink" title="无向图"></a>无向图</h4><h5 id="图"><a href="#图" class="headerlink" title="图"></a>图</h5><p>一个有限图 $G = (V,E)$ 由<strong>非空</strong>(non vide) <strong>有限</strong>(fini) <strong>顶点集</strong> (sommets / vertex) $V$</p><script type="math/tex; mode=display">V = \{ v_0, v_1,...,v_{n-1}\}</script><p>和<strong>有限边集</strong>(Arête / Edge) $E$ 组成。</p><script type="math/tex; mode=display">E = \{ e_0, e_1,...,e_{n-1}\}</script><p>其中，每个<strong>边</strong>由一对<strong>顶点</strong> $\{ v_i, v_j\}$ 构成。<strong>顶点数</strong>又被称为图的<strong>阶数</strong>(ordre)。</p><p><strong>相关概念：</strong></p><ul><li>如果 $n = nb(V)$，那么我们称该图 $G = (V,E)$ 是一个 <strong>$n阶图$ (ordre)</strong>;</li><li>如果 $e = \{v_i, v_j\}$，我们说边 $e$ 与顶点 $v_i$ 和  $v_j$ <strong>相关 (incidente)</strong>;</li><li>如果 $e = \{v_i,v_j\}$，我们说 $v_i$ 和 $v_j$ 是<strong>邻接的 (adjacents)</strong>;</li><li>两条<strong>边</strong>是<strong>相邻</strong>的当且仅当它们有一个<strong>共同的顶点</strong>;</li><li>$e = \{v_i, v_i\}$ 是一个<strong>环 (boucle)</strong>;</li><li>两个节点之间可能有多条边的图称为<strong>多重图 (multigraphe)</strong>。</li><li>一个图是<strong>简单的 (simple)</strong>，当且仅当<ul><li>没有<strong>环 (boucle)</strong>，</li><li>两个顶点之间最多有一条边 (无重边);</li></ul></li><li>一个顶点在图中的<strong>度</strong> (<strong>degree</strong>) $δ(v_i)$ 为 与这个顶点 $v_i$ 相<strong>连接的边的数目</strong>;</li><li>如果每个顶点彼此相邻，即每两个顶点间都有边相连，则称该图是<strong>完全(complet)</strong>图;</li></ul><blockquote><p>Q1 : n阶简单完全图的边数是多少？</p><script type="math/tex; mode=display">\# E(n阶简单完全图) = \tfrac{n(n-1)}{2}</script></blockquote><ul><li>无向图中，所有顶点度数之和 $∑deg(v)=2|E|$，即<strong>奇数度的顶点数必是偶数</strong>。</li></ul><blockquote><p>思考：一种“从无到有”的推广假设</p><ol><li>连接两个偶度顶点，这个时候奇度顶点的数量增加2；</li><li>连接两个奇度顶点，这个时候奇度顶点的数量减少2；</li><li>连接一个奇度顶点和一个偶度顶点，奇度顶点的数量不变。</li></ol></blockquote><ul><li><strong>$k$-正则图 (k-regulier)</strong>是指所有顶点的度都为 $k$ 的图;</li></ul><h4 id="有向图"><a href="#有向图" class="headerlink" title="有向图"></a>有向图</h4><p>如果一个图 $G = (V,E)$ 的点对(或边)是有序的，那么图 $G$ 就是<strong>有向的(orienté)</strong>。</p><p><strong>相关概念：</strong></p><ul><li>在一个有向弧 $e =(i,j)$ 中，$i$ 被称为 $e$ 的起点(l’origine), $j$ 是 $e$ 的终点( l’arrivée);</li><li>对于顶点$v$，<strong>出度</strong> $δ^+(v)$ 是以 $v$ 为起点的弧的数量;</li><li><strong>入度</strong> $δ^−(v)$ 是以 $v$ 为终点的弧的数量;</li><li>总度数 $δ(v) = δ^+(v) + δ^−(v)$ , $∑_{v \in V} δ(v) = 2 \times nb(E)$。</li></ul><h4 id="子图（sous-graphe）"><a href="#子图（sous-graphe）" class="headerlink" title="子图（sous-graphe）"></a>子图（sous-graphe）</h4><p>由图 $G = (V,E)$ 的顶点 $V$的子集 $V ‘ ⊂ V$ 生成的 $G’ = (V’ , E’ )$ 是 $G$ 的子图。其中 $E’$ 表示 $E$ 的两个端点都在 $V’$ 中的所有边。</p><script type="math/tex; mode=display">G=(V,E) \quad \stackrel{V'⊂V} \longrightarrow \quad G'=(V',E')</script><ul><li>子图：点和边都能在原图中找到</li><li>母图：原图</li><li>真子图：不等于母图的子图</li><li>生成子图：包含所有顶点的子图</li><li>基础简单图：从一个图中去掉所有重边及环后所得的剩余图称为基础简单图</li><li>点导出子图：顶点是原图顶点的子集且加入两端都在子集中的边构成的图</li><li>边导出子图：由原图边集的子集及其所有端点构成的图</li></ul><h5 id="完全子图"><a href="#完全子图" class="headerlink" title="完全子图"></a>完全子图</h5><script type="math/tex; mode=display">IF(子图 \; is\; 完全图)\quad THEN(完全子图)</script><h5 id="团（clique）"><a href="#团（clique）" class="headerlink" title="团（clique）"></a>团（clique）</h5><p>$G$ 的完全子图是 $G$ 的团，当且仅当 $G’$ 不包含在 $G$ 的更大的完全子图中，也就是说 $G’$ 是 $G$ 的极大完全子图。</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-16 16.15.46.png" alt="2022-04-16 16.15.46" style="zoom:40%;"></p><p>由上图所示，1 和 2 就是原图的两个团。其中 1 是最大团。</p><h5 id="最大团"><a href="#最大团" class="headerlink" title="最大团"></a>最大团</h5><p>$G$ 的最大团是指 $G$ 的所有团中，含顶点数最大的团，比如说 1 就是最大团。</p><h4 id="部分图（graphe-partiel）"><a href="#部分图（graphe-partiel）" class="headerlink" title="部分图（graphe partiel）"></a>部分图（graphe partiel）</h4><p>由 $E’ ⊂ E$ 生成的 $G = (V,E)$ 的部分图是图 $G’= (V,E’)$。</p><script type="math/tex; mode=display">G=(V,E) \quad \stackrel{E'⊂E} \longrightarrow \quad G'=(V,E')</script><h4 id="关联矩阵（matrice-d’incidence）"><a href="#关联矩阵（matrice-d’incidence）" class="headerlink" title="关联矩阵（matrice d’incidence）"></a>关联矩阵（matrice d’incidence）</h4><p>设任意图 $G=(V,E)$，其中顶点集 $V=v_1,v_2,…,v_n$，边集 $E=e_1,e_2,…,e_ε$。用 $m_{ij}$ 表示顶点 $v_i$ 与边 $e_j$ 关联的次数，可能取值为 $0,1,2,…$，称所得矩阵 $\mathcal{M}(G)=(m_{ij})_{n×ε}$ 为图G的<strong>关联矩阵</strong></p><p>类似地，有向图 $D$ 的关联矩阵 $\mathcal{M}(D)=(m_{ij})_{n×ε}$的元素 $m_{i×j}$定义为：</p><script type="math/tex; mode=display">m_{ij}=\begin{cases}1 \qquad v_i是有向边a_j的始点\\-1 \qquad v_i是有向边a_j的终点\\0 \qquad v_i是有向边a_j的不关联点\end{cases}</script><h4 id="邻接矩阵（matrice-d’adjacence）"><a href="#邻接矩阵（matrice-d’adjacence）" class="headerlink" title="邻接矩阵（matrice d’adjacence）"></a>邻接矩阵（matrice d’adjacence）</h4><p>设无向图 $G=(V,E)$ ，其中顶点集$V=v_1,v_2,…,v_n$，边集 $E=e_1,e_2,…,e_ε$。用 $a_{ij}$ 表示顶点 $v_i$ 与顶点 $v_j$ 之间的边数，可能取值为 $0,1,2,…$，称所得矩阵 $A=A(G)=(a_{ij})_{n×n}$ 为图$G$ 的邻接矩阵</p><p><strong>若干性质：</strong></p><ul><li>$\mathcal{A}(G)$ 为对称矩阵</li><li>若 $G$ 为无环图，则 $\mathcal{A}(G)$ 中第 $i$ 行（列）的元素之和等于顶点 $v_i$ 的度</li><li>两图 $G$ 和 $H$ <strong>同构</strong>的充要条件是存在置换矩阵 $\mathcal{P}$ 使得 $\mathcal{A}(G) = \mathcal{P}^T\mathcal{A}(H) \mathcal{P}$</li></ul><p>类似地，有向图 $D$ 的邻接矩阵$=\mathcal{A}(D)(a_{ij})_{n×n}$， $a_{ij}$ 表示从始点 $v_i$ 到终点 $v_j$ 的<strong>有向边的条数</strong>，其中 $v_i$ 和 $v_j$ 为 $D$ 的顶点。</p><blockquote><p>示例，求图中有向图的邻接矩阵和关联矩阵（图中边上的数字为<em>边的编号</em>，而非权重）：</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/4-tournament.svg.png" alt="4-tournament.svg" style="zoom:15%;"></p><p>邻接矩阵为：</p><script type="math/tex; mode=display">\begin{bmatrix}0 & 1 & 0 & 1\\0 & 0 & 0 & 1\\1 & 1 & 0 & 0\\0 & 0 & 1 & 0\end{bmatrix}</script><p>关联矩阵为：</p><script type="math/tex; mode=display">\begin{bmatrix}1 & 0 & 0 & -1 & 1 & 0\\-1 & 1 & 0 & 0 & 0 & -1\\0 & 0 & -1 & 1 & 0 & 1\\0 & -1 & 1 & 0 & -1 & 0\end{bmatrix}</script></blockquote><h4 id="加权图（graphe-pondere）"><a href="#加权图（graphe-pondere）" class="headerlink" title="加权图（graphe pondéré）"></a>加权图（graphe pondéré）</h4><p>如果每条弧与<strong>正</strong>的实际权重 (poids) 相关联，则对图进行加权。</p><h3 id="第二部分：连通"><a href="#第二部分：连通" class="headerlink" title="第二部分：连通"></a>第二部分：连通</h3><h4 id="链（Chaine）"><a href="#链（Chaine）" class="headerlink" title="链（Chaîne）"></a>链（Chaîne）</h4><p>长度为 $q ∈ N$ 的链 $(e_1, …, e_q)$ 是 $q$ 个<strong>连续相邻边的序列</strong>。 因此存在一个顶点序列 $(v_1,…,v_{q+1})$，使得 $v_i$ 是 $e_{i-1}$ 和 $e_i$ 的端点。</p><p><strong>相关概念：</strong></p><ul><li>该链被称为连接 顶点 $v_1$ 和 $v_{q+1}$ 的链；</li><li><p><strong>简单链 (simple)</strong>：在边的序列中各边互不相同</p><ul><li>简单链也可称其为 <strong>迹</strong> (trace)</li></ul></li><li><p><strong>基本链 (élémentaire)</strong>：在顶点的序列中各顶点互不相同</p><ul><li>基本简单链可以称其为 <strong>路</strong> (chemin)：序列中的<strong>边</strong>和<strong>顶点</strong>都<strong>不相同</strong></li></ul></li><li><p>如果 $v_1 = v_{q+1}$，则链是<strong>闭合 (fermée)</strong>的；</p></li><li>$q$ 是链的长度。</li></ul><h4 id="环（Cycle）"><a href="#环（Cycle）" class="headerlink" title="环（Cycle）"></a>环（Cycle）</h4><ul><li><p>环是一个<strong>闭合 (fermée)</strong>的单链；</p></li><li><p>两个顶点间的<strong>距离 (Distance)</strong> 是两个顶点间<strong>最短链的长度</strong>；</p></li><li><p>图的<strong>直径 (Diamètre)</strong> 是图的两个顶点之间的<strong>最大距离</strong>。 如果有未连接的顶点，则为 $+∞$（连接性的定义在后面）。</p></li><li><p><u>无环图 $G$ <strong>最多</strong>有 $n-1$ 条边</u></p><blockquote><p>proof：</p><script type="math/tex; mode=display">\# E_{一般无环图} \le \# E_{无环连通图} = n-1</script></blockquote></li><li><p>如果遍历的顶点除了第一个和最后一个之外是互不相同的，则环是<strong>基本的 (élémentaire)</strong>。</p></li></ul><blockquote><p>​    例1：在下图的无向图中，</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-16 18.25.30.png" alt="截屏2022-04-16 18.25.30" style="zoom:30%;"></p><ol><li>链 $(1,2,5,1,3,5,1)$ 是一条<strong>非基本 (non-élémentaire) 闭合 (fermée) 链</strong></li><li>链 $(1,2,5,1,3,)$ 是一条<strong>非基本 (non-élémentaire) 非闭合 (non-fermée) 链</strong></li><li>基本环（基本闭合链）：$(1,2,5,1)$</li><li>非基本环（非基本闭合链）：$(1,2,5,1,3,5,4,1)$</li></ol><p>例2 ：在下图的有向图中，</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-16 18.36.59.png" alt="2022-04-16 18.36.59" style="zoom:33%;"></p><ol><li><strong>基本路径 (chemin: non-fermée)</strong> ：$(1,4,2,3)$</li><li>非基本路径：$(1,3,1,4)$</li><li>基本<strong>环 (circuit)</strong>：$(1,4,2,3,1)$</li><li>非基本<strong>环 (circuit)</strong>：$(1,3,1,4,2,1)$</li></ol></blockquote><h4 id="割点及割边"><a href="#割点及割边" class="headerlink" title="割点及割边"></a>割点及割边</h4><h5 id="割点"><a href="#割点" class="headerlink" title="割点"></a>割点</h5><p>【定义】设连通图 $G=(V,E)$ 中有 $v_i \in V$，如果 $G - v_i$ 的分支数大于 $G$ 的分支数，即在图 $G$ 中删去 $v_i$ 点后 $G$ 不再连通，则我们称 $v_i$ 是 $G$ 的一个割点。</p><ul><li><p>每个非平凡图至少有两个顶点不是割点</p><blockquote><p>证明：</p><p>由于 $G$ 是无环非平凡连通图，所以存在非平凡生成树．非平凡生成树至少两片树叶，它们不能为生成树的割点．显然，它们也不能为 $G$ 的割点．</p><p>注：非平凡树一定有割边，不一定有割点 ($K_2$).</p></blockquote></li><li><p>有割点的图不是哈密顿图</p></li></ul><p>【性质】设连通图 $G=(V,E)$ 中有 $v_i \in V$ ，则下列命题等价</p><ul><li>$v_i$ 是 $G$ 的一个割点</li><li>$∃ v_x,v_y \in V， v_x \ne v_y， v_x 与 v_y 间所有的路均通过 v_i$</li><li>（上一条的普遍推广）$∃ \; V \setminus \{v_i\} 的划分\{U,W\}(U \cap W = \emptyset)，使得\forall u \in U, \forall w \in W: u,w间的路均通过v_i$</li></ul><h5 id="割边（桥）"><a href="#割边（桥）" class="headerlink" title="割边（桥）"></a>割边（桥）</h5><p>设图 $G=(V,E)$ 中有 $e_i \in E$，如果 $G - e_i$ 的分支数大于 $G$ 的分支数，即在图 $G$ 中删去 $e_i$ 点后 $G$ 不再连通，则我们称 $e_i$ 是 $G$ 的一个割边，也称做桥。</p><p>【性质】设连通图 $G=(V,E)$ 中有 $e_i \in E$ ，则下列命题等价</p><ul><li>$e_i$ 是 $G$ 的一个割边</li><li>$∃ e_x,e_y \in E， e_x \ne e_y， e_x 与 e_y 间所有的路均”通过” e_i$</li><li>（上一条的普遍推广）$∃ \; E \setminus \{e_i\} 的划分\{U_E,W_E\}(U_E \cap W_E = \emptyset)，使得\forall u_e \in U, \forall w_e \in W: u_e,w_e间的路均”通过”e_i$</li><li>$e_i$ 不在 $G$ 的任何圈中</li></ul><h4 id="连通度"><a href="#连通度" class="headerlink" title="连通度"></a>连通度</h4><ul><li><p><strong>点连通度</strong>可描述为“<strong>使图不连通或成为平凡图，最少需要删去的点数</strong>”，记作 $\kappa (G)$</p></li><li><p><strong>边连通度</strong>可描述为“<strong>使图不连通或成为平凡图，最少需要删去的边数</strong>”，记作 $\lambda (G)$</p></li></ul><p>【性质】</p><ol><li>对于不连通或平凡图 $G$ ：$\kappa (G) = \lambda (G) = 0$</li><li>对于树 $T$：$\kappa (G) = \lambda (G) = 1$</li><li>对于有割点的图 $G$ ：$\kappa (G) = 1$</li><li>对于有割边（桥）的图 $G$ ：$\lambda (G) = 1$</li><li>对于完全图 $K_p$ ：$\kappa (G) = \lambda (G) = p-1$</li><li>$图G连通 \Leftrightarrow \kappa (G) \ge 1$</li><li>对于一个环（圈）$C_n, n ≥ 3$：$κ(C_n) = 2$</li></ol><p>除了 $\kappa (G)$ 和 $\lambda (G)$ 以外，图的最小度 $\delta (G)$ 也可以用来描述图 $G$ 的连通程度。即</p><script type="math/tex; mode=display">设 G 是 n 阶简单图，若 δ(G) ≥ ⌊\frac{n}{2}⌋，则 G 必连通，且 λ(G) = δ(G)．</script><blockquote><p>证明：</p><p>若 $G$ 不连通，则 $G$ 至少有两个连通分支，从而必有一个分支 H 满足</p><script type="math/tex; mode=display">|V(H)| ≤ ⌊\frac{n}{2}⌋</script><p>因 $G$ 是简单图，从而</p><script type="math/tex; mode=display">∆(H) ≤ ⌊\frac{n}{2}⌋ − 1 < ⌊\frac{n}{2}⌋</script><p>于是</p><script type="math/tex; mode=display">δ(G) ≤ δ(H) ≤ ∆(H) < ⌊\frac{n}{2}⌋</script><p>这与已知矛盾，所以 $G$ 必连通．</p></blockquote><p>【定理】对任意的图 $G=(V,E)$，有</p><script type="math/tex; mode=display">κ(G) ≤ λ(G) ≤ δ(G)</script><h4 id="连通图（Graphe-connexe）"><a href="#连通图（Graphe-connexe）" class="headerlink" title="连通图（Graphe connexe）"></a>连通图（Graphe connexe）</h4><ul><li><p>在一个<strong>无向图</strong> $G$ 中，若从顶点 ${ v_{i}}$ 到顶点 $v_{j}$ 有路径<strong>相连</strong>（当然从 $v_{j}$ 到 $ v_{i}$也一定有路径），则称$ v_{i}$ 和 $v_{j}$ 是<strong>连通 (connexe)</strong>的。</p><ul><li>如果 $G$ 是<strong>有向图</strong>，那么连接 $v_{i}$ 和 $v_{j}$ 的路径中所有的边都必须<strong>同向</strong>。</li></ul></li><li><p>如果图中<strong>任意两点都是连通的</strong>，那么图被称作<strong>连通图</strong>。图的连通性是图的基本性质。<strong>连通度</strong>是指为了让图分解成孤立的子图所要删除的顶点数的最小值。</p></li><li><p><u>设连通图 $G$ 有 $n$ 个顶点，则该图 $G$ <strong>至少</strong>有 $n-1$ 条边</u></p><blockquote><p>Proof:</p><p>A graph with $n$ vertices and no edge has $n$ components. Adding an edge reduces the number of components by <em>at most</em> one. So beginning with a graph with no edge, adding one edge at a time till the graph has $k$ edges results in reducing the number of components by <em>at most</em> $k$. Thus, a graph with $n$ vertices and $k$ edges has <em>at least</em> $n−k$ components. Hence every graph with $n$ vertices and fewer than $n-1$ edges has <em>at least</em> two components, and is disconnected. Therefore every connected graph with $n$ vertices must have <em>at least</em> $n-1$ edges; the path $P_n$ is an example of such a graph</p></blockquote></li></ul><h5 id="弱连通"><a href="#弱连通" class="headerlink" title="弱连通"></a>弱连通</h5><p>一个有向图被称作<strong>弱连通</strong>(<strong>weakly connected</strong>)的，如果将所有有向边替换为无向边之后的无向图是连通的，如果对于任意一对顶点 $u$ ，$v$，或者存在一条从 $u$ 到 $v$ 的有向路径，或者存在一条从 $u$ 到 $v$ 的有向路径，则该图是<strong>单连通</strong>(<strong>unilaterally conncected</strong>)的。</p><script type="math/tex; mode=display">对于任意一对顶点(u,v),\; 存在路径u \to v,\; 不存在路径v\to u</script><h5 id="强连通"><a href="#强连通" class="headerlink" title="强连通"></a>强连通</h5><p>如果对于如果对于任意一对顶点 $u$，$v$，同时存在一条从 $u$ 到 $v$ 的有向路径和一条从 $v$ 到 $u$ 的有向路径，则该图是<strong>强连通</strong>(<strong>strongly connected</strong>)的</p><script type="math/tex; mode=display">对于任意一对顶点(u,v),\; 存在路径u \to v,\; 且存在路径v\to u</script><h5 id="二元关系"><a href="#二元关系" class="headerlink" title="二元关系"></a>二元关系</h5><p>集合 $X$ 与集合 $Y$ 上的二元关系是 $\mathcal{R}=(X,Y,G(\mathcal{R}))$，其中 $G(\mathcal{R})$，称为 $\mathcal{R}$ 的<strong>图</strong>，是笛卡儿积 $X\times Y$ 的子集。若 $(x,y) ∈ G(\mathcal{R})$ ，则称 $x\;与\;y\;有关系于 \mathcal{R}$，并记作 $x\mathcal{R}y$ 或 $\mathcal{R}(x,y)$。</p><p>否则称 $x \; 与 \; y \; 无关系\mathcal{R}$。但经常地我们把关系与其图等同起来，即：若 $\mathcal{R}⊆X×Y$，则 $\mathcal{R}$ 是一个关系。</p><h6 id="关系的性质"><a href="#关系的性质" class="headerlink" title="关系的性质"></a>关系的性质</h6><p>关系的性质主要有以下五种：自反性，反自反性，对称性，反对称性和传递性。</p><ul><li><strong>自反性 (réfexivité)</strong>：在集合 $X$ 上的关系 $\mathcal{R}$ ，如对任意 $x \in E$，有 $(x,x) \in \mathcal{R}$，则称<em>R</em>是自反的。</li></ul><script type="math/tex; mode=display">\forall x \in E,\quad x \mathcal{R} x</script><ul><li>非自反性（自反性的否定的强型式）：在集合 $X$ 上的关系 $\mathcal{R}$ ，如对任意 $x\in X$，有 $(x,x)\notin R$，则称R是非自反的。</li></ul><script type="math/tex; mode=display">\forall x\in A, (x,x)\notin \mathcal{R}</script><ul><li><strong>对称性 (symétrie)</strong>：在集合 $X$ 上的关系 $\mathcal{R}$，如果有 $(x,y) \in \mathcal{R}$ 则必有  $(y,x) \in \mathcal{R}$，则称R是对称的。</li></ul><script type="math/tex; mode=display">\forall (x,y) \in E^2,\quad x \mathcal{R} y \Rightarrow y \mathcal{R} x</script><ul><li>非对称性（对称性的否定的强形式）：</li></ul><script type="math/tex; mode=display">\forall (x,y) \in E^2, \quad (x,y) \in \mathcal{R} \Rightarrow (y,x) \notin \mathcal{R}</script><ul><li>反对称性（不是对称性的否定）：</li></ul><script type="math/tex; mode=display">\forall (x,y) \in E^2, \quad ((x \mathcal{R} y) \land (y \mathcal{R} x) \Rightarrow x=y)</script><ul><li><strong>传递性 (transitivité)</strong>：</li></ul><script type="math/tex; mode=display">\forall (x,y,z) \in E^3, \quad ((x \mathcal{R} y) \land (y \mathcal{R} z) \Rightarrow x \mathcal{R} z</script><p>设 $\mathcal{R}$ 为集合 $E$ 上的关系，下面给出 $\mathcal{R}$ 的五种性质成立的<strong>充要条件</strong>：</p><ol><li>$\mathcal{R}$ 在 $E$ 上自反，当且仅当$I_{E}\subseteq \mathcal{R}$</li><li>$\mathcal{R}$ 在 $E$ 上非自反，当且仅当 $\mathcal{R} \cap I_{E}=\emptyset $</li><li>$\mathcal{R}$ 在 $E$ 上对称，当且仅当 $\mathcal{R} = \mathcal{R} ^{-1}$</li><li>$\mathcal{R}$ 在 $E$ 上反对称，当且仅当 $ \mathcal{R} \cap \mathcal{R}^{-1}\subseteq I_{E}$</li><li>$\mathcal{R}$ 在 $E$ 上非对称，当且仅当 $\mathcal{R} \cap \mathcal{R}^{-1}= \emptyset$</li><li>$\mathcal{R}$ 在 $E$ 上传递，当且仅当 $\mathcal{R} \circ \mathcal{R}\subseteq \mathcal{R}$</li></ol><h6 id="等价关系（-Relation-d’equivalence）"><a href="#等价关系（-Relation-d’equivalence）" class="headerlink" title="等价关系（ Relation d’équivalence）"></a>等价关系（ Relation d’équivalence）</h6><p><strong>等价关系</strong>也称为同值关系（英语：Equivalence relation）即设 $\mathcal{R}$ 是某个集合 $E$ 上的一个二元关系。若 $\mathcal{R}$ 满足以下条件（充分必要）：</p><ol><li>自反性 (réfexivité)：$\forall x \in E, \quad x \mathcal{R} x$</li><li>对称性 (symétrie)：$\forall (x,y) \in E^2, \quad x \mathcal{R} y \Rightarrow y \mathcal{R}x$</li><li>传递性 (transitivité)：$\forall (x,y,z) \in E^3, \quad ((x \mathcal{R} y) \land (y \mathcal{R} z) \Rightarrow x \mathcal{R} z$</li></ol><blockquote><p>例如，设 $E={1,2,…,8}$，定义 $E$上的关系 $\mathcal{R}$ 如下：</p><script type="math/tex; mode=display">x \mathcal{R} y \Longleftrightarrow \forall (x,y) \in E, x \equiv y(mod \; 3)</script><p>其中，$x \equiv y(mod \; 3)$ 叫做 $x$ 与 $y模3$ 同余，即 $x$ 除以3的余数 与 $y$ 除以3的余数相等。例子有$1\mathcal{R} 4$，$2\mathcal{R}5$，$3\mathcal{R}6$。不难验证 $\mathcal{R}$ 为 $E$ 上的等价关系。</p><p>并非所有的二元关系都是等价关系。一个简单的反例是<strong>比较两个数中哪个较大</strong>：</p><ul><li>没有自反性：任何一个数不能比自身为较大 $n\ngtr n$</li><li>没有对称性：如果 $m&gt;n$，就肯定不能有 $n&gt;m$</li></ul></blockquote><h6 id="等价类（Classe-d’equivalence）"><a href="#等价类（Classe-d’equivalence）" class="headerlink" title="等价类（Classe d’équivalence）"></a>等价类（Classe d’équivalence）</h6><p>令 $\mathcal{R}$ 是集合 $E$ 上的等价关系，$x$ 是 $E$ 的元素。我们称 $x$ 的等价类为 $E$ 中与 $x$ 相关的所有元素的集 $[x]$：</p><script type="math/tex; mode=display">[x] = {y ∈ E,x\mathcal{R}y}</script><ul><li><p>设 $\mathcal{R}$ 为集合 $E$ 上的等价关系，两个等价类不相交或相等。</p><blockquote><p>证明：</p><script type="math/tex; mode=display">\begin{aligned} IF (v_k = \{v_j\} \cup \{v_i\}) \quad & THEN(v_i \mathcal{R} v_k,\;v_j \mathcal{R} v_k \Rightarrow v_i \mathcal{R} v_j \Rightarrow [v_i]=[v_j]) \\& ELSE(\{v_j\} \cap \{v_i\} = \emptyset)\end{aligned}</script></blockquote></li><li><p>设 $\mathcal{R}$ 是集合 $E$ 上的等价关系，等价类的集合是 $E$ 的一个部分。</p></li><li>设 $G$ 是一个无向图（或有向图），当且仅当存在一条连接 $v_i$ 到 $v_j$ 的链（分别是从 $v_i$ 到 $v_j$ 的路径和从 $v_j$ 到 $v_i$ 的路径）时，由 $v_i \mathcal{R} v_j$ 在顶点集上定义的关系 $\mathcal{R}$ 到 $v_i$ 是等价关系。</li></ul><h5 id="连通分量（Composantes-connexes）"><a href="#连通分量（Composantes-connexes）" class="headerlink" title="连通分量（Composantes connexes）"></a>连通分量（Composantes connexes）</h5><p><strong>无向图</strong> $G$ 的<strong>极大连通子图</strong>称为 $G$ 的<strong>连通分量</strong>( Connected Component)。任何连通图的连通分量只有一个，即是其自身，非连通的无向图有多个连通分量。对于分量中任意两点 $u,v$，必然可以从 $u$ 走到 $v$，且从 $v$ 走到 $u$。</p><p>如下图所示，</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-17 14.33.24.png" alt="2022-04-17 14.33.24" style="zoom:40%;"></p><h5 id="强连通分量（Composantes-fortement-connexes）"><a href="#强连通分量（Composantes-fortement-connexes）" class="headerlink" title="强连通分量（Composantes fortement connexes）"></a>强连通分量（Composantes fortement connexes）</h5><p><strong>有向图</strong> $G= (V,E)$ 的<strong>极大强连通子图</strong>称为 $G$ 的<strong>强连通分量</strong>，强连通图只有一个强连通分量，即是其自身。非强连通的有向图有多个强连通分量。极大连通分量。一个连通分量加上任何一些点都不是连通分量了，该连通分量就是强连通分量。</p><p>强连通分量的作用： 将任意有向图通过 <u>缩点(将所有连通分量缩成一个点)</u> 转换成有向无环图( $DAG$ )。如下图所示，</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/v2-03765039364c4af19f5f35b7c3433d4c_1440w.jpeg" alt="v2-03765039364c4af19f5f35b7c3433d4c_1440w" style="zoom:70%;"></p><ul><li>前驱：$Pred (S \subseteq V_{ertex}) = \{v’ | v \in S, (v’,v) \in E_{dge}\}$</li><li>后继：$Succ (S \subseteq V_{ertex}) = \{v’ | v \in S, (v,v’) \in E_{dge}\}$</li></ul><p>我们还通过以下方式定义<strong>前驱</strong>和<strong>后继</strong>的自反和传递闭包：</p><ul><li>$Pred^<em> (S \subseteq V_{ertex}) = S \cup Pred^</em> (Pred(S))$</li><li>$Succ^<em> (S \subseteq V_{ertex}) = S \cup Succ^</em> (Succ(S))$</li></ul><h5 id="Demoucron-算法"><a href="#Demoucron-算法" class="headerlink" title="Demoucron 算法"></a>Demoucron 算法</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">CFG_G &lt;- ∅空集</span><br><span class="line">WHILE (有一个顶点不在 CFC_G 子集的并集中)</span><br><span class="line">DO</span><br><span class="line">选择 v ∈ V 不出现 CFC_G 子集的并集</span><br><span class="line">CFC_v &lt;- SUCC*(&#123;v&#125;) ∩交集 Pred*(&#123;v&#125;)</span><br><span class="line">CFC_G &lt;- CFC_G ∪并集 &#123;CFC_v&#125;</span><br><span class="line">END</span><br></pre></td></tr></table></figure><p>例：应用 Demoucron 算法找出下图中的强连通分量：</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-17 15.36.10.png" alt="2022-04-17 15.36.10" style="zoom:45%;"></p><ul><li>$CFC_G = \emptyset$</li><li>$\begin{aligned} CFC_{v_1} &amp; = \{1,2,3,7,5,6,8,4,10,9\}  \quad \leftarrow 顺箭头方向_{Succ} \\ &amp; \quad \cap \; \{ 1,4,5,3,6,2,7,9,10\} \quad \leftarrow 逆箭头方向_{Pred} \\ &amp; = \{ 1,2,3,4,5,6,7,9,10\} \end{aligned}$</li><li>$v_8 \;并不在上一轮的\;CFC_v 中$</li><li>$CFC_G = \{ [1] , [8] \} \rightarrow \{ [8] \}_{seul}$</li></ul><h4 id="树（Arbre）"><a href="#树（Arbre）" class="headerlink" title="树（Arbre）"></a>树（Arbre）</h4><p><strong>树</strong>是一个<strong>无环连通图</strong>。<strong>森林</strong>由<strong>若干个树连接</strong>得来（无环）。</p><ul><li>由 $k$ 颗树组成的森林满足 $m = n − k$，其中 $n$ 为 $G$ 的顶点数，$m$ 为 $G$ 的边数．</li></ul><blockquote><p><strong>Theorem:</strong> </p><script type="math/tex; mode=display">每棵非平凡树至少有两片树叶</script><p>证明 :</p><p>设 $d_1 ≤ d_2 ≤ · · · ≤ dn$ 是树 $T$ 的度序列，因为 $T$ 是连通的，所以树 $T$ 的最小度 $δ(T) = d_1 ≥ 1$. 如果树 $T$ 中至多有一片树叶，那么 $2n − 2 = 2m(T) = \sum_{i=1}^n d_i ≥ 1 + 2(n − 1)$ , 出现矛盾．</p><script type="math/tex; mode=display">n := \text{NB of vertex}\\m := \text{NB of Edge}\\t := \text{NB of vertex with 1 degre}\\\because \text{G is a tree}\quad \therefore \text{G is a connected graph}\\\therefore \sum \delta(v) = 2m = 2(n-1) \quad \text{according to n=m-1} \\\because \sum_{\delta(v) \ge 2} \delta(v) \ge 2(n-t)+t \\\therefore 2(n-1) \ge 2(n-t)+t  \quad \Rightarrow \quad t \ge 2</script></blockquote><p>设 $G$ 是具有 $n$ 个点 $m$ 条边的图，则下列命题<strong>等价</strong>：</p><ol><li>$G$ 是树；</li><li>$G$ <strong>无环</strong>且任意两个不同点之间存在唯一的路；</li><li>$G$ 连通，删去任一边便不连通；</li><li>$G$ <strong>连通</strong>，且 $n = m - 1$；</li><li>$G$ <strong>无圈</strong>，且 $n = m - 1$；</li><li>$G$ 无圈，添加任何一条边可得<strong>唯一</strong>的圈。</li></ol><h5 id="生成树"><a href="#生成树" class="headerlink" title="生成树"></a>生成树</h5><p>$G$ 的<strong>生成树</strong>（arbre couvrant）是具有 $G$ 的<strong>全部顶点</strong>，但<strong>边数最少</strong>的<strong>连通子图</strong>。</p><p>若有图 $G=(V_G, E_G)$ 和树 $T = (V_T, E_T)$，有 $V_T = V_G$ 且 $E_T \subset E_G$，那么我们说树 $T$ 是图 $G$ 的生成树。</p><h5 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h5><p>带权图的生成树中，总权重最小的称为<strong>最小生成树</strong>。</p><blockquote><p> 求取最小生成树的算法：一种<strong>贪心算法</strong></p><ol><li>新建图 $G$， $G$ 中拥有原图中相同的节点，但没有边；</li><li>将原图中所有的边<strong>按权值从小到大升序</strong>；</li><li><strong>从权值最小的边开始</strong>，如果这条边连接的两个节点于图 $G$ 中不在同一个连通分量中，则添加这条边到图 $G$ 中；</li><li>重复3，直至图 $G$ 中所有的节点都在同一个连通分量中；</li></ol><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/MST_kruskal_en.gif" alt="MST_kruskal_en" style="zoom:40%;"></p></blockquote><h3 id="第三部分：Euler-图与-Hamilton-图"><a href="#第三部分：Euler-图与-Hamilton-图" class="headerlink" title="第三部分：Euler 图与 Hamilton 图"></a>第三部分：Euler 图与 Hamilton 图</h3><h4 id="欧拉图"><a href="#欧拉图" class="headerlink" title="欧拉图"></a>欧拉图</h4><ul><li><p>无向图</p><ol><li>经过 $G$ 的<strong>所有边</strong>的链被称为 Euler 链</li><li>经过 $G$ 的<strong>所有边</strong>的环（闭合的链）被称为 Euler 回路</li></ol></li><li><p>有向图</p><ol><li>经过 $G$ 的<strong>所有边</strong>的通路被称为 Euler 通路</li><li>经过 $G$ 的<strong>所有边</strong>的回路（闭合的通路）被称为 Euler 回路</li></ol></li><li>存在 Euler 环或 Euler 回路的图叫做 Euler 图。</li></ul><blockquote><p><strong>Theorem</strong></p><p>假定 $G$ 是一个<strong>连通图</strong>，则下列命题等价：</p><ol><li><p>$G$ 是<strong>欧拉图</strong>；</p></li><li><p>$G$ 的每个点的度<strong>都是偶数</strong> 或 <strong>只有 2 个顶点是奇数度，其余均为偶数度</strong>；</p><ul><li><p>连通无向图 $G$ 是欧拉图当且仅当 $G$ 的每个顶点都是偶度顶点</p></li><li><p>连通无向图 $G$ 中存在连接顶点 $u,v$ 的欧拉链当且仅当只有 $u$ 和 $v$ 是奇度顶点</p></li></ul></li><li><p>$G$ 的边集能划分为边不重的环的并。</p></li></ol></blockquote><h5 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h5><ul><li><p>无向图</p><ol><li>连通无向图 $G$ 是欧拉图当且仅当 $G$ 的每个顶点都是偶度顶点</li><li>连通无向图 $G$ 中存在连接顶点 $u,v$ 的欧拉链当且仅当只有 $u$ 和 $v$ 是奇度顶点</li></ol></li><li><p>有向图</p><ol><li><strong>强连通图有向图</strong> $D$ 是<strong>欧拉回路</strong> 当且仅当 $D$ 中的<strong><u>每个顶点的出度数和入读数相同</u></strong></li><li>单向<strong>连通有向图</strong> $D$ 有从顶点 $u$ 到 $v$ 的<strong>欧拉通路</strong>当且仅当 <u>$u$ 的<strong>出度数</strong>比入度数大 1</u>， <u>$v$ 的<strong>入度数</strong>比<strong>出度数</strong>大 1</u>， <u>$D$ 中其他顶点<strong>入度数</strong>和<strong>出度数</strong>相同</u></li></ol></li></ul><h5 id="寻找-Euler-回路算法：Hierholzer-算法"><a href="#寻找-Euler-回路算法：Hierholzer-算法" class="headerlink" title="寻找 Euler 回路算法：Hierholzer 算法"></a>寻找 Euler 回路算法：Hierholzer 算法</h5><p>Hierholzer算法用于在连通图寻找欧拉迹，其流程非常简单。</p><blockquote><p>从一个可能的起点出发，进行<strong>深度优先搜索</strong>，但是每次沿着辅助边从某个顶点移动到另外一个顶点的时候，都需要删除这个辅助边。如果没有可移动的路径，则将所在结点加入到栈中，并返回。</p><p>最后得到的栈中保存的就是整个欧拉闭迹中的顶点。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dfs(node, trace)&#123;</span><br><span class="line"><span class="keyword">while</span>(!node.adj.isEmpty())&#123;</span><br><span class="line"><span class="type">Node</span> <span class="variable">next</span> <span class="operator">=</span> node.adj.removeLast();</span><br><span class="line">dfs(next, trace);</span><br><span class="line">&#125;</span><br><span class="line">trace.addLast(node);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="哈密顿图"><a href="#哈密顿图" class="headerlink" title="哈密顿图"></a>哈密顿图</h4><ul><li>无向图：<ol><li>经过 $G$ 的<strong>每个结点一次且仅一次</strong>的链被称为 Hamilton 链</li><li>经过 $G$ 的<strong>每个结点一次且仅一次</strong>的环为 Hamilton 环</li></ol></li><li><p>有向图</p><ol><li>经过 $G$ 的<strong>每个结点一次且仅一次</strong>的链基本通路被称为 Hamilton 通路</li><li>经过 $G$ 的<strong>每个结点一次且仅一次</strong>的基本回路为 Hamilton 回路</li></ol></li><li><p>Hamilton 图：存在 Hamilton 回路 或 Hamilton 环的图叫做 Hamilton 图。</p></li></ul><h5 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h5><ul><li>若存在 $v_i \in V$，当 $v_i$ 的度数 $\delta(v_i) =1$ 且阶数 $n&gt;1$ 时，不为哈密顿图</li><li>若存在 $v_i ∈ V$，当 $v_i$ 的度数 $δ(v) = 2$，那么与 $v_i$ 相关的两条边属于任何哈密顿环。</li><li>$K_n$ 是哈密顿图</li><li>有向完全图中必存在哈密顿通路</li><li>强连通的有向完全图中必存在哈密顿回路</li></ul><h5 id="哈密顿图的判断方法"><a href="#哈密顿图的判断方法" class="headerlink" title="哈密顿图的判断方法"></a>哈密顿图的判断方法</h5><ul><li><p><strong>Theorem (Ore，充分条件)</strong></p><p>对于阶 $n ≥ 3$ 的简单图 $G$，如果 $G$ 中的<strong>任意</strong>两个不相邻顶点 $u$ 与 $v$，都有：</p><script type="math/tex; mode=display">\delta(u) + \delta(v) ≥ n，</script><p>那么 $G$ 是哈密顿图。( 注：上述定理只是充分条件，而非必要条件，例如长度为 5 的圈．)</p><blockquote><p><strong>证明</strong>：</p><p>等效地表明，每个非哈密顿图G都不满足条件。因此，令 $G$ 为非哈密顿图的 $n≥3$ 个顶点上的图，并通过一次不增加哈密顿边数加一个边，由 $G$ 形成 $H$，直到无法再增加边。</p><p>令 $u$ 和 $v$ 为 $H$ 中的任何两个不相邻的顶点。然后将边 $(u, v)$ 添加到 $H$，将创建至少一个新的哈密顿回路，并且在 $H$ 中的此回路中的 $(u,v)$ 以外的边一定会形成哈密顿路径 $v_1, v_2, … v_n$，其中 $u = v_1$，$v = v_n$。</p><p>对于 $2≤i≤n$ 范围内的每个指数 $i$，考虑 $H$ 中从 $v_1$ 到 $v_i$ 和从 $v_(i-1)$ 到 $v_n$ 的两个可能边。在 $H$ 中最多可以存在这两个边之一，否则周期 $v_1,v_2 … v_(i-1), v_n, v_{(n-1)} … v_i$ 将是哈密顿回路。</p><p>因此，入射到 $v_1$ 或 $v_n$ 的边的总数最多等于 $i$ 的选择数，即 $n-1$。因此，$H$不服从属性，这要求该边的总数 $δ(v_1) + δ(v_n)$ 大于或等于 $n$。由于 $G$ 的顶点度最多等于 $H$ 的度数，因此得出 $G$ 也没有服从特性的结论。</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-17 21.58.22.png" alt="2022-04-17 21.58.22" style="zoom:40%;"></p></blockquote></li><li><p><strong>Theorem (Dirac，充分条件)</strong></p><p>对于 $n ≥ 3$ 的简单图 $G$，如果 $G$ 中有：</p><script type="math/tex; mode=display">\delta(G) ≥ \frac{n}{2}</script><p>那么 $G$ 是哈密顿图。( 注：上述定理只是充分条件，而非必要条件，例如长度为 5 的圈．)</p></li></ul><h5 id="二分图（Graphe-biparti）"><a href="#二分图（Graphe-biparti）" class="headerlink" title="二分图（Graphe biparti）"></a>二分图（Graphe biparti）</h5><p>二分图又称作二部图，是图论中的一种特殊模型。 设 $G=(V,E)$ 是一个无向图，如果顶点 $V$ 可分割为两个<strong>互不相交的子集</strong>$A$,$B$)，并且图中的每条边 $(v_i, v_j)$ 所关联的两个顶点 $v_i$ 和 $v_j $ 分别属于这两个不同的顶点集 ($v_i \in A$ , $v_j \in B$)，则称图 $G$ 为一个<strong>二分图</strong>。</p><p>简而言之，就是顶点集 $V$ 可分割为<strong>两个互不相交的子集</strong>，并且图中每条边依附的两个顶点都分属于这两个互不相交的子集，两个<strong>子集内的顶点不相邻</strong>。</p><blockquote><p>如下图，</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-17 21.00.46.png" alt="2022-04-17 21.00.46" style="zoom:40%;"></p><p>完全二分图：$V_1$ 的所有顶点都链接到 $V_2$的任何顶点。互补顶点子集分别有 $p$ 个顶点和 $q$ 个顶点的完全二分图记为 $𝐾_{𝑝,𝑞}$</p></blockquote><p><strong>性质</strong></p><ul><li>如果一个图 $G=(V,E)$ 是二分图，且 $| nb(V_1) - nb(V_2)| &gt; 1$，则 $G$ 即不是哈密顿图，也不是半哈密顿图</li><li>若无向图 $G$ 中有长度为奇数的闭合链，则在 $G$ 中有长度为奇数的圈</li><li>非平凡无向图 $G$ 是二分图当且仅当 $G$ 中的每个圈的长度都是偶数</li></ul><h3 id="第四部分：最短路径问题"><a href="#第四部分：最短路径问题" class="headerlink" title="第四部分：最短路径问题"></a>第四部分：最短路径问题</h3><h4 id="Dijkstra-最短路径算法"><a href="#Dijkstra-最短路径算法" class="headerlink" title="Dijkstra 最短路径算法"></a>Dijkstra 最短路径算法</h4><p>Dijkstra算法是一种经典的基于<strong>贪心</strong>的单源最短路算法，其要求图中的边全部非负。</p><h5 id="算法描述"><a href="#算法描述" class="headerlink" title="算法描述"></a>算法描述</h5><h6 id="1-算法思想："><a href="#1-算法思想：" class="headerlink" title="1. 算法思想："></a>1. 算法思想：</h6><p>设 $G=(V,E)$ 是一个带权有向图（或无向图），把图中顶点集合 $V$ 分成两组，</p><ol><li>第一组为<strong>已求出最短路径的顶点集合</strong>（用 $S$ 表示，初始时 $S$ 中只有一个<strong>源点</strong>，以后每求得一条最短路径 , 就将加入到集合 $S$ 中，直到全部顶点都加入到 $S$ 中，算法就结束了），</li><li>第二组为<strong>其余未确定最短路径的顶点集合</strong>（用 $U$ 表示），按最短路径长度的递增次序依次把第二组的顶点加入 $S$ 中。在加入的过程中，总保持从源点 $v_0$ 到 $S$ 中各顶点的最短路径长度不大于从源点 $v_0$ 到 $U$ 中任何顶点的最短路径长度。</li></ol><p>此外，每个顶点对应一个距离，$S$ 中的顶点的距离就是从 $v_0$ 到此顶点的最短路径长度，$U$ 中的顶点的距离，是从 $v_0$ 到此顶点只包括S中的顶点为中间顶点的当前最短路径长度。</p><h6 id="2-算法伪代码："><a href="#2-算法伪代码：" class="headerlink" title="2. 算法伪代码："></a>2. 算法伪代码：</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">DIJKSTRA(G, w, s)</span><br><span class="line">    // s的当前最短路长度是0，其他节点的当前最短路长度是+∞。</span><br><span class="line">    INITIALIZE-SINGLE-SOURCE(G, s)</span><br><span class="line">    // S是节点集合（V的子集），其中每个节点u都已经求得了全图最短路。</span><br><span class="line">    // 初期所有节点都没求得全图最短路。</span><br><span class="line">    S ← ∅</span><br><span class="line">    // Q是一个节点的优先队列，包含所有尚未求得全图最短路的节点。Q中的节点按照当前最短路的长度从小到大排序。</span><br><span class="line">    // 初期所有节点都没求得全图最短路，所以都在Q中。</span><br><span class="line">    Q ← V[G]</span><br><span class="line">    // 循环直到Q中所有节点都清空（都移动到S），即所有节点都已经求出全图最短路。</span><br><span class="line">    while Q ≠ ∅</span><br><span class="line">        // 从Q中取出当前最短路长度最小的节点u</span><br><span class="line">        // 并认为u的当前最短路就是全图最短路。（这个不是那么显然，后续有说明）</span><br><span class="line">        do u ← EXTRACT-MIN(Q)</span><br><span class="line">            // 将u放进集合S中，即标注为“已求得u的全图最短路”。</span><br><span class="line">            S ← S∪&#123;u&#125;</span><br><span class="line">            // 对于u的每个邻接点v</span><br><span class="line">            for each vertex v∈Adj[u]</span><br><span class="line">                // 更新v的当前最短路。</span><br><span class="line">                // 具体策略是：有一个从s到v的新路径，即“从s走全图最短路到u，再从u到v”。</span><br><span class="line">                // 这个新路径可能比v的当前最短路长，也可能比v的当前最短路短。（这个不那么显然，后续有说明）</span><br><span class="line">                // 如果新路径比v的当前最短路短，就把v的当前最短路替换为这条新路径。</span><br><span class="line">                do RELAX(u, v, w)</span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="3-算法步骤："><a href="#3-算法步骤：" class="headerlink" title="3. 算法步骤："></a>3. 算法步骤：</h6><ol><li>初始时，$S$ 只包含源点，即 $S＝\{v_0\}$，$v_0$ 的距离为 $0$。$U$ 包含除 $v_0$ 外的其他顶点，即 : $U=\{其余顶点\}$，若 $v_0$ 与 $U$ 中顶点 $v_i$ 有边，则 $(v_0,v_i)$ 正常有权值，若 $v_0$ 不是 $v_i$ 的出边邻接点，则 $(v_0,v_i)$ 权值为 $∞$。</li><li>从 $U$ 中选取一个距离 $v_0$ 最小的顶点 $v_k$ ，把 $v_k$ 加入 $S$ 中（该选定的距离就是 $v_0$ 到 $v_k$ 的最短路径长度）。</li><li>以 $v_k$ 为新考虑的中间点，修改 $U$ 中各顶点的距离；若从源点 $v_0$ 到顶点 $v_i$ 的距离（经过顶点 $v_k$）比原来距离（不经过顶点 $v_k$）短，则修改顶点 $v_i$ 的距离值，修改后的距离值的顶点 $v_k$ 的距离加上边上的权。</li><li>重复步骤 2 和 3，直到所有顶点都包含在 $S$ 中。</li></ol><blockquote><p>例：如下图所示，求出从 0 出发到 4 的最短路径。</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-18 09.34.04.png" alt="2022-04-18 09.34.04" style="zoom:40%;"></p><p><strong>【思路】</strong>：</p><ol><li>每次从没标记的节点中选择距离出发点最近的节点标记、收录到最优路径集合中；</li><li>计算刚加入的节点 A 到临近节点 B 的距离（不包含已标记节点），若 $(节点A的距离 + 节点A到节点B的距离) &lt; 节点B的距离$，则选择更小的那个路径，更新节点B的距离和前驱点pred</li><li>标记完所有的节点</li></ol><p>【解】</p><ol><li>将 [0] 放入集合：</li></ol></blockquote><div class="table-container"><table><thead><tr><th></th><th><u>0</u></th><th>[1]</th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>7</th><th>8</th></tr></thead><tbody><tr><td>dist</td><td>0</td><td>4</td><td>$∞$</td><td>$∞$</td><td>$∞$</td><td>$∞$</td><td>$∞$</td><td>8</td><td>$∞$</td></tr><tr><td>pred</td><td>\</td><td>0</td><td>\</td><td>\</td><td>\</td><td>\</td><td>\</td><td>0</td><td>\</td></tr></tbody></table></div><blockquote><ol><li>将 [1] 放入集合：</li></ol></blockquote><div class="table-container"><table><thead><tr><th></th><th><u>0</u></th><th><u>1</u></th><th>2</th><th>3</th><th>4</th><th>5</th><th>6</th><th>[7]</th><th>8</th></tr></thead><tbody><tr><td>dist</td><td>0</td><td>4</td><td>12</td><td>$∞$</td><td>$∞$</td><td>$∞$</td><td>$∞$</td><td>$8^*$</td><td>$∞$</td></tr><tr><td>pred</td><td>\</td><td>0</td><td>1</td><td>\</td><td>\</td><td>\</td><td>\</td><td>0</td><td>\</td></tr></tbody></table></div><blockquote><p>注意⚠️：* 路径 $0 \to 1 \to 7$ 的距离为 $4+11=15$，而有路径 $0 \to 7$ 的距离为 8，小于前者。所以我们选择路径 $0 \to 7$，并更新表。以下步骤与此类次，不再单独列出。</p><ol><li>将 [7] 放入集合：</li></ol></blockquote><div class="table-container"><table><thead><tr><th></th><th><u>0</u></th><th><u>1</u></th><th>2</th><th>3</th><th>4</th><th>5</th><th>[6]</th><th><u>7</u></th><th>8</th></tr></thead><tbody><tr><td>dist</td><td>0</td><td>4</td><td>12</td><td>$∞$</td><td>$∞$</td><td>$∞$</td><td>9</td><td>8</td><td>15</td></tr><tr><td>pred</td><td>\</td><td>0</td><td>1</td><td>\</td><td>\</td><td>\</td><td>7</td><td>0</td><td>7</td></tr></tbody></table></div><blockquote><ol><li>将 [6] 放入集合：</li></ol></blockquote><div class="table-container"><table><thead><tr><th></th><th><u>0</u></th><th><u>1</u></th><th>2</th><th>3</th><th>4</th><th>[5]</th><th><u>6</u></th><th><u>7</u></th><th>8</th></tr></thead><tbody><tr><td>dist</td><td>0</td><td>4</td><td>12</td><td>$∞$</td><td>$∞$</td><td>11</td><td>9</td><td>8</td><td>15</td></tr><tr><td>pred</td><td>\</td><td>0</td><td>1</td><td>\</td><td>\</td><td>6</td><td>7</td><td>0</td><td>7</td></tr></tbody></table></div><blockquote><ol><li>将 [5] 放入集合：</li></ol></blockquote><div class="table-container"><table><thead><tr><th></th><th><u>0</u></th><th><u>1</u></th><th>[2]</th><th>3</th><th>4</th><th><u>5</u></th><th><u>6</u></th><th><u>7</u></th><th>8</th></tr></thead><tbody><tr><td>dist</td><td>0</td><td>4</td><td>12</td><td>25</td><td>21</td><td>11</td><td>9</td><td>8</td><td>15</td></tr><tr><td>pred</td><td>\</td><td>0</td><td>1</td><td>5</td><td>5</td><td>6</td><td>7</td><td>0</td><td>7</td></tr></tbody></table></div><blockquote><ol><li>将 [2] 放入集合：</li></ol></blockquote><div class="table-container"><table><thead><tr><th></th><th><u>0</u></th><th><u>1</u></th><th><u>2</u></th><th>3</th><th>4</th><th><u>5</u></th><th><u>6</u></th><th><u>7</u></th><th>[8]</th></tr></thead><tbody><tr><td>dist</td><td>0</td><td>4</td><td>12</td><td>19</td><td>21</td><td>11</td><td>9</td><td>8</td><td>14</td></tr><tr><td>pred</td><td>\</td><td>0</td><td>1</td><td>2</td><td>5</td><td>6</td><td>7</td><td>0</td><td>2</td></tr></tbody></table></div><blockquote><ol><li>将 [8] 放入集合：由于与 8 相邻的节点都已经加入集合，所以可以跳过这一步</li></ol></blockquote><div class="table-container"><table><thead><tr><th></th><th><u>0</u></th><th><u>1</u></th><th><u>2</u></th><th>[3]</th><th>4</th><th><u>5</u></th><th><u>6</u></th><th><u>7</u></th><th><u>8</u></th></tr></thead><tbody><tr><td>dist</td><td>0</td><td>4</td><td>12</td><td>19</td><td>21</td><td>11</td><td>9</td><td>8</td><td>14</td></tr><tr><td>pred</td><td>\</td><td>0</td><td>1</td><td>2</td><td>5</td><td>6</td><td>7</td><td>0</td><td>2</td></tr></tbody></table></div><blockquote><ol><li>将 [3] 放入集合：</li></ol></blockquote><div class="table-container"><table><thead><tr><th></th><th><u>0</u></th><th><u>1</u></th><th><u>2</u></th><th><u>3</u></th><th>[4]</th><th><u>5</u></th><th><u>6</u></th><th><u>7</u></th><th>8</th></tr></thead><tbody><tr><td>dist</td><td>0</td><td>4</td><td>12</td><td>19</td><td>21</td><td>11</td><td>9</td><td>8</td><td>14</td></tr><tr><td>pred</td><td>\</td><td>0</td><td>1</td><td>2</td><td>5</td><td>6</td><td>7</td><td>0</td><td>2</td></tr></tbody></table></div><blockquote><ol><li>将 [4] 放入集合：</li></ol></blockquote><div class="table-container"><table><thead><tr><th></th><th><u>0</u></th><th><u>1</u></th><th><u>2</u></th><th><u>3</u></th><th><u>4</u></th><th><u>5</u></th><th><u>6</u></th><th><u>7</u></th><th>8</th></tr></thead><tbody><tr><td>dist</td><td>0</td><td>4</td><td>12</td><td>19</td><td>21</td><td>11</td><td>9</td><td>8</td><td>14</td></tr><tr><td>pred</td><td>\</td><td>0</td><td>1</td><td>2</td><td>5</td><td>6</td><td>7</td><td>0</td><td>2</td></tr></tbody></table></div><blockquote><ol><li>遍历完毕，我们现在就得到了从 0 到该图中所有点的最短路程 (shortest distance)。欲求出 $0 \to 4$ 的路径，我们可以从 4 出发，沿着 pred 的顺序到推出最短路径 (shortest path)，即</li></ol><script type="math/tex; mode=display">4 \leftarrow 5 \leftarrow 6 \leftarrow 7 \leftarrow 0</script><p>对于<strong>有向图</strong>，大体思路与无向图一致，注意边的方向即可，顺方向为可达，逆方向为不可达（即 $∞$ ）</p></blockquote><h3 id="第五部分：平面图-及-图的上色问题"><a href="#第五部分：平面图-及-图的上色问题" class="headerlink" title="第五部分：平面图 及 图的上色问题"></a>第五部分：平面图 及 图的上色问题</h3><h4 id="平面图（Graphe-planire）"><a href="#平面图（Graphe-planire）" class="headerlink" title="平面图（Graphe planire）"></a>平面图（Graphe planire）</h4><ul><li>如下图，如果一个图 $G$ 可以在<strong>平面上</strong>绘制，并且<strong>其边不相交</strong> （边不一定是直线），则称该图是<strong>平面图</strong>。<ul><li>平面图所在的特定平面称为地图（carte）；</li><li>将地图划分为几个区域称为面（face）；<ul><li>内部面：每个区域内部连同边界称为 $G$ 的内部面</li><li>外部面：无界的区域</li><li>注：每个平面图有且仅有一个外部面。 </li></ul></li></ul></li></ul><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-18 13.22.07.png" alt="2022-04-18 13.22.07" style="zoom:35%;"></p><ul><li><p>而如果一个图无论怎样都无法画在平面上，并使得不同的边互不交叠，那么这样的图不是平面图，或者称为非平面图。</p><ul><li>完全图 $K_5$和完全二分图 $K_{3,3}$ (汤玛森图) 是最“小”的非平面图。</li></ul></li><li><p>面的次数：设 $f$ 是 $G$ 的一个面，构成 $f$ 的<strong>边界的边数</strong>（割边算两次）称为 $f$ 的<strong>次数</strong>， 记作 $deg(f)$</p><ul><li>定理：设平面图 $G$ 有 $m$ 条边，$G$ 的所有面的集合为 $\psi$， 则<script type="math/tex; mode=display">\sum _{f \in \psi} deg(f) = 2m</script></li></ul></li><li><p>这实际上是一个研究图的拓扑方面的问题。 更一般地，人们可以问一个图形是否可以在表面 S 上表示的问题</p></li></ul><h5 id="欧拉公式"><a href="#欧拉公式" class="headerlink" title="欧拉公式"></a>欧拉公式</h5><p>设 $G$ 是具有 $n$ 个顶点，$m$ 条边，$f$ 个面，$p$ 个<strong>连通分支</strong>(composantes connexes) 的平面图，则：</p><script type="math/tex; mode=display">f = m-n+1+p \quad 即 \quad 面数=边数-顶点数+1+连通部分的数量</script><p><strong>【欧拉示性数 (Euler characteristic)】</strong>：具有 $n$ 个顶点 $m$ 条边 $f$ 个面的<strong>连通平面图</strong> $G$ 满足：</p><script type="math/tex; mode=display">n-m+f=2,\quad 即 \quad 顶点数-边数+面数=2</script><p>【推论】具有 $n$ 个顶点，$m$ 条边的简单可平面图，若 $n \ge 3$，则 $m \le 3n -6$</p><h5 id="极大可平面图"><a href="#极大可平面图" class="headerlink" title="极大可平面图"></a>极大可平面图</h5><p>【定义】设 $G$ 是简单可平面图，如果在 $G$ 中的<strong>任意两个不相邻的顶点</strong>之间添加一条边所得到的图均<strong>为不可平面图</strong>，则称该图 $G$ 为极大可平面图。</p><ul><li>（必要条件）$G$ 是极大可平面图，则 $G$ 一定是连通图；如果 $G$ 的阶数大于3，则 $G$ 无割边</li><li>设 $G$ 是至少有3个顶点的平面图，则 $G$ 是极大平面图的<strong>充要条件</strong>是 $G$ 中<strong>各个面的次数均为3</strong> 且 <strong>为简单图</strong></li><li>设 $G$ 是具有 $n$ 个顶点，$m$ 条边，$f$ 个面的极大平面图，则 $m=3n-6$，$f =2n-4$</li></ul><h4 id="图的顶点着色"><a href="#图的顶点着色" class="headerlink" title="图的顶点着色"></a>图的顶点着色</h4><p>【独立集】（Independent ensemble）是图论中的概念。一个独立集（也称为<strong>稳定集</strong>stable ensemble）是一个图中一些<strong>两两不相邻的顶点所形成的集合</strong>。换句话说，独立集 $S$ 由图中若干顶点组成，且 $S$ 中任两个顶点之间没有边。我们用 $\alpha (G)$ 表示稳定即的个数。</p><p>【着色】在一个图 $G$ 中，任意<strong>相邻的两个顶点不能着相同的颜色</strong>（即一条边两端的顶点不能着相同的颜色；也即当一个图的顶点可分为 $n$ 个独立集时，可着 $n$ 个颜色）。我们用 $\gamma (G)$ 表示颜色的个数。</p><p>如果一个图所需颜色 $\gamma (G)$ 的最小数量是 $k$，则我们称该图是 $k-点可着色的$ </p><ul><li>常见的图的着色所需颜色的数量：<ul><li>$\gamma (K_p) = p$</li><li>$\gamma (具有2n个顶点的环) = 2$</li><li>$\gamma (具有2n+1个顶点的环) = 3$</li><li>$\gamma (Tree) = 2$</li></ul></li></ul><blockquote><p>例：</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-18 15.10.59.png" alt="2022-04-18 15.10.59" style="zoom:40%;"></p><p>上图 $G$ 所示的独立集为 $\{0\},\quad  \{1\}, \quad \{2,3,4\}$</p><p>$\alpha (G) = 3$ , $\gamma (G) = 3$</p></blockquote><h5 id="色数的上下界"><a href="#色数的上下界" class="headerlink" title="色数的上下界"></a>色数的上下界</h5><h6 id="下界-1"><a href="#下界-1" class="headerlink" title="下界 (1)"></a>下界 (1)</h6><script type="math/tex; mode=display">\gamma (G) \ge \frac {nb(V)}{nb(V) - min_{v \in V} \delta(v)}</script><p>其中，</p><ul><li><p>$min_{v \in V} \delta(v)$ 是图 $G$ 中<strong>拥有最小度的顶点 $v$ 的度数</strong>，即 在一个图中，拥有最少相邻顶点的顶点 $v$ 的度数；</p></li><li><p>$nb(V) - min_{v \in V} \delta(v) - 1$ 是与顶点 $v$ <strong>不邻接的顶点数</strong>，而此时就可以知道<strong>最多的同色顶点数</strong>是 $nb(V) - min_{v \in V} \delta(v)$ </p></li><li>总共色数是 $\gamma (G)$ ，其与最多的同色顶点数 $nb(V) - min_{v \in V} \delta(v)$ 相乘，应该<strong>小于等于</strong>顶点数 $nb(V)$ ，即 $\gamma (G) \times nb(V) - min_{v \in V} \delta(v) \le nb(V)$</li><li>整理可得出上式</li></ul><h6 id="下界-2"><a href="#下界-2" class="headerlink" title="下界 (2)"></a>下界 (2)</h6><script type="math/tex; mode=display">\gamma (G) \ge \#(最大团_{(clique)}中的顶点数)</script><h6 id="上界-1"><a href="#上界-1" class="headerlink" title="上界 (1)"></a>上界 (1)</h6><script type="math/tex; mode=display">\gamma (G) \le max_{v \in V} \delta(v) + 1</script><p>其中，</p><ul><li>$max_{v \in V} \delta(v)$ 是图 $G$ 中<strong>拥有最大度的顶点 $v$ 的度数</strong>，也可写作 $\Delta (G)$ 。即 在一个图中，拥有最多相邻顶点的顶点 $v$ 的度数；</li></ul><blockquote><p>证明：（数学归纳法）</p><ul><li><p>当 $n=1或2$ 时，结论显然成立；</p></li><li><p>假设有 $p$ 个顶点时结论成立，当有 $p+1$ 个顶点时，假设 $v_i$ 是 $G$ 中的任意一个顶点。我们可以将 $v_i$ 顶点从 $G$ 中删去，得到 $G_1$，则 $G_1$ 的阶数为 $p$。$G_1$ 是 $G$ 的子图，所以 $G_1$ 的最大度不可能超过 $G$ 的最大度。由假设我们应该有</p><script type="math/tex; mode=display">\gamma (G_1)\quad \le \quad\Delta (G_1) + 1 \quad \le \quad\Delta (G) + 1</script><ul><li>当将 $G_1$ 还原成 $G$ 时，由于 $v$ 至多与 $G_1$ 中 $\Delta (G)$ 个顶点相邻， 而在 $G_1$ 的点着色中，$\Delta (G)$ 个顶点至多用了  $\Delta (G)$ 种颜色，于是在 $\Delta (G) + 1$ 种颜色中至少存在一种颜色给 $v$ 着色，使 $v$ 与相邻的顶点着不同的颜色 </li></ul></li></ul><p>Proof:</p><p>We use <u>induction</u> on the number of vertices in the graph, which we denote by $n$. Let $P(n)$ be the proposition that an <code>n-vertex</code> graph with maximum degree $\Delta(G)$ at most $k$ is $(k + 1)$-colorable.</p><p><strong>Base case (n = 1):</strong></p><ol><li>A <code>1-vertex</code> graph has maximum degree $0$ and is <code>1-colorable</code>, so $P (1)$ is true.</li></ol><p><strong>Inductive step:</strong></p><ol><li>Now assume that $P (n)$ is true, and let $G$ be an <code>(n + 1)-vertex</code> graph with maximum degree  $\Delta(G)$ at most $k$.</li><li>Remove a vertex $v$ (and all edges incident to it), leaving an <code>n-vertex</code> subgraph, $H$. The maximum degree of $H$, $\Delta H$ is at most $k$, and so $H$ is <code>(k + 1)-colorable</code>  by our assumption $P (n)$.</li><li>Now add back vertex $v$. We can assign $v$ a color (from the set of $k + 1$ colors) that is different from all its <u>adjacent vertices</u>, since there are at most $k$ vertices adjacent to $v$ and so at least one of the $k + 1$ colors is still available.</li><li>Therefore, $G$ is <code>(k + 1)-colorable</code>. This completes the inductive step, and the theorem follows by <u>induction</u>.</li></ol></blockquote><h6 id="上界-2-上界-1-的收紧"><a href="#上界-2-上界-1-的收紧" class="headerlink" title="上界 (2): 上界 (1) 的收紧"></a>上界 (2): 上界 (1) 的收紧</h6><p>【Brooks定理】</p><p>设连通图即不是完全图 $K_n(n \ge 3)$，也不是长度为奇数的环，则</p><script type="math/tex; mode=display">\gamma (G) \le \Delta (G)</script><h6 id="上界-3"><a href="#上界-3" class="headerlink" title="上界 (3)"></a>上界 (3)</h6><script type="math/tex; mode=display">\gamma (G) \le n + 1 - \alpha(G)</script><h4 id="图的边着色"><a href="#图的边着色" class="headerlink" title="图的边着色"></a>图的边着色</h4><p>在一个图 $G$ 中，任意<strong>相邻的两个边不能着相同的颜色</strong>（即与同一个顶点链接的边不能着相同的颜色）。我们用 $\gamma (G)$ 表示颜色的个数。</p><p>如果一个图对边着色所需颜色 $\gamma’ (G)$ 的最小数量是 $k$，则我们称该图是 $k-边可着色的$ </p><p>【性质】（维津定理）设G是简单图，则</p><script type="math/tex; mode=display">\Delta (G) \le \gamma'(G) \le \Delta (G) +1</script><h4 id="图的面着色"><a href="#图的面着色" class="headerlink" title="图的面着色"></a>图的面着色</h4><p>连通的<strong>无桥</strong>平面图的平面嵌入及其所有的面称为<strong>平面地图</strong>或<strong>地图</strong>，平面地图的面称为<strong>国家</strong>。若两个国家的边界至少有一条公共边，则称这两个国家是<strong>相邻</strong>的。</p><p>在一个平面地图 $G$ 中，任意<strong>相邻的两个面不能着相同的颜色</strong>。我们用 $\gamma^* (G)$ 表示颜色的个数。</p><p>如果一个地图所需颜色 $\gamma^* (G)$ 的最小数量是 $k$，则我们称该图是 $k-面可着色的$ </p><p>【定理】地图 $G$ 是 $k-面可着色的$ 当且仅当 他的对偶图 $G^*$ 是 $k-点可着色的$</p><p>【五色定理】任何一个平面图都是 $5-面可着色的$</p><blockquote><p>证明：</p></blockquote><h3 id="第六部分：网络流问题"><a href="#第六部分：网络流问题" class="headerlink" title="第六部分：网络流问题"></a>第六部分：网络流问题</h3><p>回顾第二部分的连通部分</p><h4 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h4><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-18 20.34.52.png" alt="2022-04-18 20.34.52" style="zoom:40%;"></p><p>在生活中，经常会遇到一类问题：我们有一个如上图所示的抽象的供水管网，有起点和终点，我们需要求解关于这个供水管网的一系列性能问题。那么我们可以将其网络模型视为一种有向图 $D$，而网络上的流可视为边上的权，所以我们可以将该问题建模为</p><script type="math/tex; mode=display">D=(V,E,\omega)</script><p> 其中：</p><ul><li>$s,t \in V$，$s$ 为原点 (source)，$t$ 为目的点 (target)</li><li>$\omega$ 为 $A \to R$ 的映射。任何一条边 $x \in A$，$\omega (x)$ 为边 $x$ 的容量 (Capacity)</li></ul><p>【名词解释】</p><ul><li>流量 (Flow)：<strong>实际</strong>在模型中管线里的<strong>流量</strong>，流量不能超过容量</li><li>容量 (Capacity)：模型中边的权重，为该条<strong>边</strong>所能够承受的<strong>最大流量</strong></li><li><p>残差 (Residual)：又称空闲量，指“该条边在当前流量下还可以继续承受的流量”，即 $R_{esidual} = C_{apacity} - F_{low}$</p></li><li><p>最大流 (Maximum Flow)：在当前模型中能流过的最大总流量</p></li><li>最小割</li></ul><h5 id="最大流问题"><a href="#最大流问题" class="headerlink" title="最大流问题"></a>最大流问题</h5><h6 id="简单算法"><a href="#简单算法" class="headerlink" title="简单算法"></a>简单算法</h6><ol><li><p>我们根据原图 (左) 创建一个残差图 (右)，其中空闲量 $R_{esidual} = C_{apacity} - F_{low}$，初始时 $F_{low}$ 均为 $0$；</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-18 20.50.35.png" alt="2022-04-18 20.50.35" style="zoom:30%;"></p><p>【第一轮循环】</p><p>|       节点       |  $v_1$  |  $v_2$  |    $v_4$    |      t      |<br>| :———————: | :——-: | :——-: | :————-: | :————-: |<br>| [前序,方向,权重] | [s,+,4] | [S,+,2] | [$v_2$,+,2] | [$v_4$,+,3] |</p><p>我们在残差图中找出一条从起点 $s$ 到终点 $t$ 的简单路径，其中不能有回路。例如，我们已经找到了一条最右边的路径 $s \stackrel{2}\longrightarrow v_2 \stackrel{2}\longrightarrow v_4 \stackrel{3}\longrightarrow t $ 。由于短板效应，该条路径最多只能输送 $2$ ，所以三条边的路径的残差量都会 $-2$，即 $s \stackrel{0}\longrightarrow v_2 \stackrel{0}\longrightarrow v_4 \stackrel{1}\longrightarrow t $。</p><p>当某一条边的饱和 (Staturated) 即残差量为 $0$ 时，就将其从残差图中<strong>移除</strong>。第一轮循环结束。</p></li><li><p>【第二轮循环】</p><p>|       节点       |  $v_1$  |    $v_4$    |    $v_3$    |      t      |<br>| :———————: | :——-: | :————-: | :————-: | :————-: |<br>| [前序,方向,权重] | [s,+,4] | [$v_1$,+,4] | [$v_1$,+,2] | [$v_3$,+,3] |</p><p>如下图所示，我们找到了一条从起点 $s$ 到终点 $t$ 的简单路径：$s \stackrel{4}\longrightarrow v_1 \stackrel{2}\longrightarrow v_3 \stackrel{3}\longrightarrow t $ ，</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-18 21.07.49.png" alt="2022-04-18 21.07.49" style="zoom:30%;"></p><p>由于短板效应，该条路径最多只能输送 $2$ ，所以三条边的路径的残差量都会 $-2$，即 $s \stackrel{2}\longrightarrow v_1 \stackrel{0}\longrightarrow v_3 \stackrel{1}\longrightarrow t $。更新残差图。第二轮循环结束。</p></li><li><p>【第三次循环】</p><p>|       节点       |  $v_1$  |    $v_4$    |      t      |<br>| :———————: | :——-: | :————-: | :————-: |<br>| [前序,方向,权重] | [s,+,2] | [$v_1$,+,4] | [$v_4$,+,1] |</p><p>如下图所示，我们找到了一条从起点 $s$ 到终点 $t$ 的简单路径：$s \stackrel{2}\longrightarrow v_1 \stackrel{4}\longrightarrow v_4 \stackrel{1}\longrightarrow t $ ，</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-18 21.14.31.png" alt="2022-04-18 21.14.31" style="zoom:30%;"></p><p>由于短板效应，该条路径最多只能输送 $1$ ，所以三条边的路径的残差量都会 $-1$，即 $s \stackrel{1}\longrightarrow v_1 \stackrel{3}\longrightarrow v_4 \stackrel{0}\longrightarrow t $。更新残差图。第三轮循环结束。</p></li><li><p>【第四次循环】</p><p>|       节点       |  $v_1$  |    $v_2$    |    $v_4$    |      t      |<br>| :———————: | :——-: | :————-: | :————-: | :————-: |<br>| [前序,方向,权重] | [s,+,1] | [$v_1$,+,1] | [$v_1$,+,3] | [$v_3$,+,1] |</p><p>如下图所示，我们<strong>无法找到</strong>一条从起点 $s$ 到终点 $t$ 的简单路径，终止程序。</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-18 21.17.50.png" alt="2022-04-18 21.17.50" style="zoom:30%;"></p></li><li><p>用最后一次循环结果更新的残差 (Residual) 图与原图 (Capacity) 比较，得出流量 (Flow) 图，即 $F_{low} = C_{apacity} - R_{esidual}$，如下图所示。</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-18 21.24.55.png" alt="2022-04-18 21.24.55" style="zoom:25%;"></p><p>其中，边上的权重为 $[F_{low}/C_{apacity}]$ ，我们也可以从图中看出，网络中的总流量 (Amount of Flow) $= 2+3 = 5$</p></li></ol><ul><li><p>注意⚠️：这种简单的算法<strong>不能保证</strong>结果的最优性，即总流量不一定是<strong>最大流</strong>。如下图所示的图的总流量就不是最大流，</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-18 21.37.51.png" alt="2022-04-18 21.37.51" style="zoom:25%;"></p><p>而图中红色的路径是阻塞流 (Blocking Flow)，即在当前流量下无法增加其他从源点到终点流，<strong>最大流也是一种阻塞流</strong>。</p></li></ul><h6 id="Ford-Fulkerson-算法"><a href="#Ford-Fulkerson-算法" class="headerlink" title="Ford-Fulkerson 算法"></a>Ford-Fulkerson 算法</h6><p>Ford-Fulkerson 算法一定能找到最大流，其与之前的简单算法的区别是：添加了一个<strong>回溯路径</strong>，一旦选择了“不好的”路径，就会撤销这个路径，沿着回溯路径回到源点。</p><p>【算法描述】</p><ol><li>我们根据原图 (左) 创建一个残差图 (右)，其中空闲量 $R_{esidual} = C_{apacity} - F_{low}$，初始时 $F_{low}$ 均为 $0$；</li></ol><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-18 20.50.35.png" alt="2022-04-18 20.50.35" style="zoom:30%;"></p><ol><li>【第一轮循环】</li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">节点</th><th style="text-align:center">$v_1$</th><th style="text-align:center">$v_2$</th><th style="text-align:center">$v_4$</th><th style="text-align:center">t</th></tr></thead><tbody><tr><td style="text-align:center">[前序,方向,权重]</td><td style="text-align:center">[s,+,4]</td><td style="text-align:center">[S,+,2]</td><td style="text-align:center">[$v_1$,+,4]</td><td style="text-align:center">[$v_4$,+,3]</td></tr><tr><td style="text-align:center">backtracking path (next)</td><td style="text-align:center">[S,-,0]</td><td style="text-align:center">[S,-,0]</td><td style="text-align:center">[$v_1$,-,0]</td><td style="text-align:center">[$v_4$,-,0]</td></tr></tbody></table></div><p>我们在残差图中找出一条从起点 $s$ 到终点 $t$ 的简单路径，其中不能有回路。例如，我们已经找到了一条路径 $s \stackrel{4}\longrightarrow v_1 \stackrel{4}\longrightarrow v_4 \stackrel{3}\longrightarrow t $ 。由于短板效应，该条路径最多只能输送 $3$ ，所以三条边的路径的残差量都会 $-3$，即 $s \stackrel{1}\longrightarrow v_1 \stackrel{1}\longrightarrow v_4 \stackrel{0}\longrightarrow t  $。更新残差图。</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-18 21.54.44.png" alt="2022-04-18 21.54.44" style="zoom:30%;"></p><p>如上图所示，添加一条绿色的<strong>回溯路径</strong>，每个边的权都为 $3$： $t \stackrel{3}\longrightarrow v_4\stackrel{3}\longrightarrow v_1 \stackrel{3}\longrightarrow s$    。第一轮循环结束。</p><ol><li><p>【第二轮循环】</p><p>|       节点        |  $v_1$  |  $v_2$  |    $v_3$    |      t      |<br>| :———————-: | :——-: | :——-: | :————-: | :————-: |<br>| [前序,方向,权重]  | [S,+,1] | [S,+,2] | [$v_1$,+,2] | [$v_3$,+,3] |<br>| backtracking path | [S,-,3] | [S,-,0] | [$v_1$,-,0] | [$v_3$,-,0] |</p></li></ol><p>如下图所示，我们找到了一条从起点 $s$ 到终点 $t$ 的简单路径：$s \stackrel{1}\longrightarrow v_1 \stackrel{2}\longrightarrow v_3 \stackrel{3}\longrightarrow t $ ，</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-18 21.55.35.png" alt="2022-04-18 21.55.35" style="zoom:30%;"></p><p>由于短板效应，该条路径最多只能输送 $1$ ，所以三条边的路径的残差量都会 $-1$，即 $s \stackrel{0}\longrightarrow v_1 \stackrel{1}\longrightarrow v_3 \stackrel{2}\longrightarrow t $。更新残差图。</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-18 22.00.24.png" alt="2022-04-18 22.00.24" style="zoom:30%;"></p><p>如上图所示，添加一条绿色的<strong>回溯路径</strong>，每个边的权都为 $1$： $t \stackrel{1}\longrightarrow v_3\stackrel{1}\longrightarrow v_1 \stackrel{1}\longrightarrow s$，并于之前的回溯路径合并。第二轮循环结束。</p><ol><li><p>【第三轮循环】</p><p>|       节点        |  $v_1$  |  $v_2$  |           $v_4$           |    $v_3$    |      t      |<br>| :———————-: | :——-: | :——-: | :———————————-: | :————-: | :————-: |<br>| [前序,方向,权重]  | [S,+,0] | [S,+,2] | [$v_2$,+,2] / [$v_1$,+,1] | [$v_1$,+,1] | [$v_3$,+,2] |<br>| backtracking path | [S,-,4] | [S,-,0] | [$v_2$,-,0] / [$v_1$,-,1] | [$v_1$,-,1] | [$v_3$,-,1] |</p></li></ol><p>如果此时我们将绿色的回溯路径去掉，我们就不能在起点和终点之间找到一条路径。Ford-Fulkerson 算法的关键就在于这些回溯路径。如下图所示，我们考虑回溯路径，我们找到了一条从起点 $s$ 到终点 $t$ 的简单路径：$s \stackrel{2}\longrightarrow v_2 \stackrel{2}\longrightarrow v_4 \stackrel{3^*}\longrightarrow v_1 \stackrel{1}\longrightarrow v_3 \stackrel{2}\longrightarrow t$ ，</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-18 22.15.53.png" alt="2022-04-18 22.15.53" style="zoom:25%;"></p><p>由于短板效应，该条路径最多只能输送 $1$ ，所以三条边的路径的残差量都会 $-1$，即 $s \stackrel{1}\longrightarrow v_2 \stackrel{1}\longrightarrow v_4 \stackrel{2^*}\longrightarrow v_1 \stackrel{0}\longrightarrow v_3 \stackrel{1}\longrightarrow t$。更新残差图。</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-18 22.18.14.png" alt="2022-04-18 22.18.14" style="zoom:25%;"></p><p>如上图所示，添加一条绿色的<strong>回溯路径</strong>，每个边的权都为 $1$： $t \stackrel{1}\longrightarrow v_3 \stackrel{1}\longrightarrow v_1 \stackrel{1^*}\longrightarrow v_4 \stackrel{1}\longrightarrow v_2 \stackrel{1}\longrightarrow s$，并于之前的回溯路径合并。第三轮循环结束。</p><ol><li>【第四轮循环】</li></ol><p>如第三轮循环末的图所示，没有任何路径通往红色区域 $v_3 \stackrel{1}\longrightarrow t$，说明现在不存在其他路径从起点流向终点，所以终止程序。</p><ol><li>用最后一次循环结果更新的残差 (Residual) 图<strong>去除所有回溯路径</strong>与原图 (Capacity) 比较，得出流量 (Flow) 图，即 $F_{low} = C_{apacity} - R_{esidual}$，如下图所示。</li></ol><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-18 22.25.31.png" alt="2022-04-18 22.25.31" style="zoom:25%;"></p><p>其中，边上的权重为 $[F_{low}/C_{apacity}]$ ，我们也可以从图中看出，网络中的总流量 (Amount of Flow) $= 2+3 = 5$，最大流的大小也等于 $5$。</p><ul><li>注意⚠️：Ford-Fulkerson 算法的时间复杂度较高。仍然有其他算法可以更快速的求解该问题，如 <a href="https://www.bilibili.com/video/BV1uQ4y197Le/">Edmonds-Karp 算法</a> 和 <a href="https://www.bilibili.com/video/BV1j64y1R7yK/">Dinic’s 算法</a>（详见B站视频讲解），在此不再赘述。</li></ul><h5 id="最小割问题"><a href="#最小割问题" class="headerlink" title="最小割问题"></a>最小割问题</h5><p>我们先回顾一下之前之前学习的割，可类比与今天的网络流中最小割问题。</p><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-18 20.34.52.png" alt="2022-04-18 20.34.52" style="zoom:40%;"></p><p>在如上图所示的网络流中，有向图 $D=(V,E,\omega)$</p><p>其中：</p><ul><li>$s,t \in V$，$s$ 为原点 (source)，$t$ 为目的点 (target)</li><li>$\omega$ 为 $A \to R$ 的映射。任何一条边 $x \in A$，$\omega (x)$ 为边 $x$ 的容量 (Capacity)</li></ul><p>【定义】S-T Cut：将所有的顶点分为两个集合 $S$ 和 $T$</p><ul><li>$S \cup P = V$ 并且 $S \cap P = \emptyset$</li><li>$s \in S$ 并且 $t \in T$</li><li>二元组集合 $(S,T)$ 被称作 “S-T Cut”</li></ul><p><img src="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/2022-04-18 22.56.54.png" alt="2022-04-18 22.56.54" style="zoom:30%;"></p><p>如上图所示，我们去除图中红色的边，使得<strong>不存在任意一套路径可以从起点 $s$ 到终点 $t$</strong> 。去除这些边后，定点集 $V$ 就会分裂成两部分 $_{Subset}S$ 和 $_{Subset}T$。<u>然而这样的集合划分<strong>并不唯一</strong></u>。</p><p>【注意⚠️】图中有一条边 $v_4 \stackrel{4}\longrightarrow s$ 连通  $_{Subset}S$ 和 $_{Subset}T$，但是即使有这条边的存在，依然<strong>不存在任意一套路径可以从起点 $s$ 到终点 $t$</strong> 。所以我们不用去管他。</p><ul><li>容量 $Capacity(S,T)$ 是所有从集合 $_{Subset}S$ 通向集合 $_{Subset}T$ 的<strong>边的权重之和</strong>，<ul><li>上图中左边的容量 $Capacity_左(S,T) = 2+1 =3$，</li><li>右边的“S-T Cut”容量 $Capacity_右(S,T) = 2+2+2 = 6$</li></ul></li></ul><p>【最小割】：Minimum S-T Cut (Min-Cut)，是在所有“S-T Cut” 中容量最小的那个。目标是用最小的“力气”（权）就可以截断水流（起点 $s$ 不到终点 $t$）。</p><h5 id="最大流-最小割问题"><a href="#最大流-最小割问题" class="headerlink" title="最大流 - 最小割问题"></a>最大流 - 最小割问题</h5><p>对于一个网络流问题，<strong>最大流的流量</strong> 就<strong>等于</strong> <strong>最小割的容量</strong>，即</p><script type="math/tex; mode=display">Max \;flow = Min\;cut</script><p>我们可以将 <strong>寻找最小割的问题</strong> 等价转化为 <strong>寻找最大流问题</strong>：</p><p>在 <strong>寻找最大流问题</strong> 中，在最后一次迭代中<strong>去除回溯路径</strong>的<strong>残差图</strong> (Residual Graph) 中，从起点 $s$ 出发，找到所有能达到的节点，将它们放入集合 $_{Subset}S$，将剩下的所有节点放入集合 $_{Subset}T$。这样就得到了最小割的二元组 $(S,T)$。</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;图论&quot;&gt;&lt;a href=&quot;#图论&quot; class=&quot;headerlink&quot; title=&quot;图论&quot;&gt;&lt;/a&gt;图论&lt;/h2&gt;&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://dave0126.github.io/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/&quot;&gt;本文章&lt;/a&gt;是根据法国国立高等电力技术、电子学、计算机、水力学与电信学校 (E.N.S.E.E.I.H.T.) 第七学期课程&lt;em&gt;“Graph Theory”&lt;/em&gt; 总结而来的课程笔记。碍于本人学识有限，部分叙述难免存在纰漏，请读者注意甄别。&lt;/p&gt;</summary>
    
    
    
    <category term="课程笔记" scheme="https://dave0126.github.io/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="图论" scheme="https://dave0126.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="课程笔记" scheme="https://dave0126.github.io/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
