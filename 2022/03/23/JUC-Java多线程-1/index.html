<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dave0126.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Java 并发多线程编程视频课程: BiliBili - 黑马程序员Java并发编程 JUC 笔记参考: Java并发 - Nyima’s Blog  注：本课程笔记基于JDK8，采用lsf4j打印日志">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 并发多线程编程 (JUC) (一)">
<meta property="og:url" content="https://dave0126.github.io/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/index.html">
<meta property="og:site_name" content="Lost N Found">
<meta property="og:description" content="Java 并发多线程编程视频课程: BiliBili - 黑马程序员Java并发编程 JUC 笔记参考: Java并发 - Nyima’s Blog  注：本课程笔记基于JDK8，采用lsf4j打印日志">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://dave0126.github.io/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/20200608144606.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/20200608144621.png">
<meta property="article:published_time" content="2022-03-23T20:13:13.000Z">
<meta property="article:modified_time" content="2022-03-27T20:25:31.735Z">
<meta property="article:author" content="Guohao">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="JUC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://dave0126.github.io/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/20200608144606.png">

<link rel="canonical" href="https://dave0126.github.io/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java 并发多线程编程 (JUC) (一) | Lost N Found</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Lost N Found" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Lost N Found</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/Dave0126" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dave0126.github.io/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Guohao">
      <meta itemprop="description" content="间歇性踌躇满志, 持续性划水摸鱼">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lost N Found">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java 并发多线程编程 (JUC) (一)
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-23 21:13:13" itemprop="dateCreated datePublished" datetime="2022-03-23T21:13:13+01:00">2022-03-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-03-27 22:25:31" itemprop="dateModified" datetime="2022-03-27T22:25:31+02:00">2022-03-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/JUC/" itemprop="url" rel="index"><span itemprop="name">JUC</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>12k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>11 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Java-并发多线程编程"><a href="#Java-并发多线程编程" class="headerlink" title="Java 并发多线程编程"></a>Java 并发多线程编程</h2><p>视频课程: <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV16J411h7Rd?p=1">BiliBili - 黑马程序员Java并发编程 JUC</a></p>
<p>笔记参考: <a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2020/06/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发 - Nyima’s Blog</a></p>
<ul>
<li>注：本课程笔记基于JDK8，采用lsf4j打印日志</li>
</ul>
<span id="more"></span>
<h3 id="1-线程与进程"><a href="#1-线程与进程" class="headerlink" title="1 线程与进程"></a>1 线程与进程</h3><h4 id="1-1-进程"><a href="#1-1-进程" class="headerlink" title="1.1 进程"></a>1.1 进程</h4><ul>
<li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来<strong>加载指令、管理内存、管理 IO 的</strong>。</li>
<li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。</li>
<li>进程就可以视为<strong>程序的一个实例</strong>（程序是静态的，进程是动态的）。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器 等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）</li>
</ul>
<h4 id="1-2-线程"><a href="#1-2-线程" class="headerlink" title="1.2 线程"></a>1.2 线程</h4><ul>
<li>一个进程可以分为一到多个线程。</li>
<li><strong>一个线程就是一个指令流</strong>，将指令流中的一条条指令以一定的顺序交给 CPU 执行 。</li>
<li>Java 中，线程作为最小<strong>调度单位</strong>（执行指令），进程作为<strong>资源分配</strong>的最小单位。 在 windows 中进程是不活动的，只是作 为线程的容器</li>
</ul>
<h4 id="1-3-两者对比"><a href="#1-3-两者对比" class="headerlink" title="1.3 两者对比"></a>1.3 两者对比</h4><ul>
<li><strong>进程基本上相互独立的</strong>，而<strong>线程存在于进程内</strong>，是进程的一个子集</li>
<li>进程拥有共享的资源，如内存空间等，供其<strong>内部的线程共享</strong><ul>
<li>进程间通信较为复杂 同一台计算机的进程通信称为 IPC（Inter-process communication）</li>
<li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP</li>
</ul>
</li>
<li>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量</li>
<li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</li>
</ul>
<h5 id="1-3-1-进程和线程的切换"><a href="#1-3-1-进程和线程的切换" class="headerlink" title="1.3.1 进程和线程的切换"></a>1.3.1 进程和线程的切换</h5><h6 id="上下文切换"><a href="#上下文切换" class="headerlink" title="上下文切换"></a>上下文切换</h6><p>内核为每一个进程维持一个上下文。<strong>上下文就是内核重新启动一个被抢占的进程所需的状态。</strong>包括以下内容：</p>
<ul>
<li>通用目的寄存器</li>
<li>浮点寄存器</li>
<li>程序计数器</li>
<li>用户栈</li>
<li>状态寄存器</li>
<li>内核栈</li>
<li>各种内核数据结构：比如描绘地址空间的<strong>页表</strong>，包含有关当前进程信息的<strong>进程表</strong>，以及包含进程已打开文件的信息的<strong>文件表</strong></li>
</ul>
<h6 id="进程切换和线程切换的主要区别"><a href="#进程切换和线程切换的主要区别" class="headerlink" title="进程切换和线程切换的主要区别"></a>进程切换和线程切换的主要区别</h6><p>最主要的一个区别在于<strong>进程切换涉及虚拟地址空间的切换而线程不会</strong>。因为每个进程都有自己的虚拟地址空间，而<strong>线程是共享所在进程的虚拟地址空间的</strong>，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换</p>
<p>页表查找是一个很慢的过程，因此通常使用cache来缓存常用的地址映射，这样可以加速页表查找，这个cache就是快表TLB（translation Lookaside Buffer，用来加速页表查找）。由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么<strong>当进程切换后页表也要进行切换，页表切换后TLB就失效了</strong>，cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致TLB失效，因为线程线程无需切换地址空间，因此我们通常说线程切换要比较进程切换快</p>
<p>而且还可能出现<strong>缺页中断</strong>，这就需要操作系统将需要的内容调入内存中，若内存已满则还需要将不用的内容调出内存，这也需要花费时间</p>
<h6 id="为什么TLB能加快访问速度"><a href="#为什么TLB能加快访问速度" class="headerlink" title="为什么TLB能加快访问速度"></a><strong>为什么TLB能加快访问速度</strong></h6><p>快表可以避免每次都对页号进行地址的有效性判断。快表中保存了对应的物理块号，可以直接计算出物理地址，无需再进行有效性检查</p>
<h4 id="1-4-并行与并发"><a href="#1-4-并行与并发" class="headerlink" title="1.4 并行与并发"></a>1.4 并行与并发</h4><ol>
<li><p>单核cpu 下，线程实际还是<strong>串行执行</strong>的。操作系统中有一个组件叫做任务调度器，将cpu 的时间片（windows 下时间片最小约为 15 毫秒）分给不同的线程使用，只是由于 cpu在线程间（时间片很短）的切换非常快，人类感觉是<strong>同时运行</strong>的。总结为一句话就是：“<strong>微观串行，宏观并行</strong>”<br>一般会将这种<strong>线程轮流使用 CPU</strong>的做法称为并发，Concurrent。</p>
</li>
<li><p>多核cpu下，每个核心都可以调度运行线程，此时线程间是可以<strong>并行</strong>(Parallel)的。</p>
</li>
</ol>
<p><strong>并发</strong>(Concurrent) 是一个CPU在不同的时间去不同线程中执行指令。</p>
<p><strong>并行</strong>(Parallel)是多个CPU同时处理不同的线程。</p>
<h4 id="1-5-应用"><a href="#1-5-应用" class="headerlink" title="1.5 应用"></a>1.5 应用</h4><h5 id="1-5-1-应用之异步调用（案例1）"><a href="#1-5-1-应用之异步调用（案例1）" class="headerlink" title="1.5.1 应用之异步调用（案例1）"></a>1.5.1 应用之异步调用（案例1）</h5><p>以<strong>调用方角度</strong>来讲，如果</p>
<ul>
<li>需要等待结果返回，才能继续运行就是同步</li>
<li>不需要等待结果返回，就能继续运行就是异步</li>
</ul>
<p>注意：同步在多线程中还有另外一层意思，即让多个线程步调一致</p>
<h6 id="1-设计"><a href="#1-设计" class="headerlink" title="1) 设计"></a>1) 设计</h6><p>多线程可以让方法执行变为异步的（即不要巴巴干等着）比如说读取磁盘文件时，假设读取操作花费了 5 秒钟，如果没有线程调度机制，这 5 秒 cpu 什么都做不了，其它代码都得暂停…</p>
<p>一般来讲，大文件的读写、耗时较长的工作可以异步执行</p>
<h6 id="2-结论"><a href="#2-结论" class="headerlink" title="2) 结论"></a>2) 结论</h6><ul>
<li>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程</li>
<li>tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞</li>
<li>tomcat 的工作线程 ui 程序中，开线程进行其他操作，避免阻塞 ui 线程</li>
</ul>
<h5 id="1-5-2-应用之提高效率（案例1）"><a href="#1-5-2-应用之提高效率（案例1）" class="headerlink" title="1.5.2 应用之提高效率（案例1）"></a>1.5.2 应用之提高效率（案例1）</h5><p>充分利用多核 cpu 的优势，提高运行效率。想象下面的场景，执行3个计算，最后将计算结果汇总。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">计算 1 花费	10ms</span><br><span class="line">计算 2 花费	11ms</span><br><span class="line">计算 3 花费	9ms</span><br><span class="line">汇总需要		1ms</span><br></pre></td></tr></table></figure>
<p>如果是串行执行，那么总共花费的时间是 <code>10 + 11 + 9 + 1 = 31ms</code></p>
<ul>
<li>但如果是四核 cpu，各个核心分别使用线程1 执行计算1，线程2执行计算2，线程3执行计算3，那么3个线程是并行的，花费时间只取决于最长的那个线程运行的时间，即<code>11ms</code> 。最后加上汇总时间，只会花费<code>12ms</code>。</li>
</ul>
<p><strong>注意</strong>：需要在多核cpu 才能提高效率，单核仍然时是轮流执行</p>
<h6 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h6><ol>
<li>单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用 cpu ，不至于一个线程总占用 cpu，别的线程没法干活</li>
<li>多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的<ul>
<li>有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任 务都能拆分（参考后文的【阿姆达尔定律】）</li>
<li>也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义</li>
</ul>
</li>
<li>IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 cpu，但需要一 直等待 IO 结束，没能充分利用线程。所以才有后面的【非阻塞 IO】和【异步 IO】优化。</li>
</ol>
<h3 id="2-Java-线程"><a href="#2-Java-线程" class="headerlink" title="2 Java 线程"></a>2 Java 线程</h3><h4 id="2-1-创建和运行线程"><a href="#2-1-创建和运行线程" class="headerlink" title="2.1 创建和运行线程"></a>2.1 创建和运行线程</h4><h5 id="方法一：直接使用构造器创建一个线程"><a href="#方法一：直接使用构造器创建一个线程" class="headerlink" title="方法一：直接使用构造器创建一个线程"></a>方法一：直接使用构造器创建一个线程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateThread</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        Log.debug(<span class="string">&quot;my thread running...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">		myThread.start();  <span class="comment">// 启动线程</span></span><br><span class="line">    Log.debug(<span class="string">&quot;main thread running...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用继承方式的好处是，在<code>run()</code>方法内获取当前线程直接使用this就可以了，无须使用<code>Thread.currentThread()</code>方法；</p>
<p>不好的地方是Java不支持多继承，如果继承了Thread类，那么就不能再继承其他类。另外任务与代码没有分离，当多个线程执行一样的任务时需要多份任务代码</p>
<h5 id="方法二：使用Runnable配合Thread-推荐"><a href="#方法二：使用Runnable配合Thread-推荐" class="headerlink" title="方法二：使用Runnable配合Thread(推荐)"></a>方法二：使用Runnable配合Thread(推荐)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//创建线程任务</span></span><br><span class="line">		<span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;Runnable running&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">//将Runnable对象传给Thread</span></span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">		<span class="comment">//启动线程</span></span><br><span class="line">		t.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过实现Runnable接口，并且实现<code>run()</code>方法。好处是<strong>将任务和线程分离</strong>，更为灵活。在创建线程时作为参数传入该类的实例即可。</p>
<h5 id="方法二的简化：使用lambda表达式简化操作"><a href="#方法二的简化：使用lambda表达式简化操作" class="headerlink" title="方法二的简化：使用lambda表达式简化操作"></a>方法二的简化：使用lambda表达式简化操作</h5><p>当<strong>只有一个抽象方法的接口</strong>可以用<code>@FunctionalInterface</code>注解。当有该注解时，可以<strong>使用lambda来简化操作</strong></p>
<p>所以方法二中的代码可以被简化为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//创建线程任务</span></span><br><span class="line">		<span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">            <span class="comment">//直接写方法体即可</span></span><br><span class="line">			System.out.println(<span class="string">&quot;Runnable running&quot;</span>);</span><br><span class="line">			System.out.println(<span class="string">&quot;Hello Thread&quot;</span>);</span><br><span class="line">		&#125;;</span><br><span class="line">		<span class="comment">//将Runnable对象传给Thread</span></span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">		<span class="comment">//启动线程</span></span><br><span class="line">		t.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在IDEA中，可以在<code>Runnable</code>上使用<code>Alt + Enter</code>自动转换成lambda表达式。</p>
<h6 id="Thread-与-Runnable-的关系"><a href="#Thread-与-Runnable-的关系" class="headerlink" title="Thread 与 Runnable 的关系"></a>Thread 与 Runnable 的关系</h6><p>分析 Thread 的源码，理清它与 Runnable 的关系</p>
<ul>
<li>方法1 是把线程和任务合并在了一起</li>
<li>方法2 是把线程和任务分开了</li>
<li>用 Runnable 更容易与线程池等高级 API 配合 用 Runnable 让任务类脱离了 Thread 继承体系，更灵活</li>
</ul>
<h5 id="方法三：使用FutureTask与Thread结合"><a href="#方法三：使用FutureTask与Thread结合" class="headerlink" title="方法三：使用FutureTask与Thread结合"></a>方法三：使用FutureTask与Thread结合</h5><p>使用<strong>FutureTask</strong>可以用泛型指定<strong>线程的返回值</strong>类型（<strong>Runnable的run方法没有返回值</strong>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">//需要传入一个Callable对象</span></span><br><span class="line">		FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Integer&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;线程执行!&quot;</span>);</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		<span class="type">Thread</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">		r1.start();</span><br><span class="line">		<span class="comment">//获取线程中方法执行后的返回结果</span></span><br><span class="line">		System.out.println(task.get());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h6><p>使用<strong>继承方式的好处是方便传参</strong>，你可以在子类里面添加成员变量，通过set方法设置参数或者通过构造函数进行传递，而如果使用Runnable方式，则只能使用主线程里面被声明为final的变量。</p>
<p><strong>不好的地方是Java不支持多继承</strong>，如果继承了Thread类，那么子类不能再继承其他类，而Runable则没有这个限制。<strong>前两种方式都没办法拿到任务的返回结果，但是Futuretask方式可以</strong></p>
<h4 id="2-2-原理之线程运行"><a href="#2-2-原理之线程运行" class="headerlink" title="2.2 原理之线程运行"></a>2.2 原理之线程运行</h4><h5 id="2-2-1-栈与栈帧"><a href="#2-2-1-栈与栈帧" class="headerlink" title="2.2.1 栈与栈帧"></a>2.2.1 栈与栈帧</h5><p><a href="https://dave0126.github.io/2022/03/22/JVM-1/#2-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88">Java Virtual Machine Stacks</a> （Java 虚拟机栈） 我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？</p>
<ul>
<li>其实就是线程，每个线程启动后，虚拟机就会为其分配一块<strong>栈内存</strong></li>
<li>每个栈由多个栈帧（Frame）组成，对应着每次<strong>方法调用时所占用的内存</strong></li>
<li>每个线程只能有一个活动栈帧，对应着当前正在执行的那个方法</li>
</ul>
<h5 id="2-2-2-线程上下文切换"><a href="#2-2-2-线程上下文切换" class="headerlink" title="2.2.2 线程上下文切换"></a>2.2.2 线程上下文切换</h5><p>因为以下一些原因导致 cpu 不再执行当前的线程，转而执行另一个线程的代码</p>
<ul>
<li>线程的 cpu 时间片用完</li>
<li>垃圾回收 有更高优先级的线程需要运行</li>
<li>线程自己调用了 <code>sleep</code>、<code>yield</code>、<code>wait</code>、<code>join</code>、<code>park</code>、<code>synchronized</code>、<code>lock</code> 等方法</li>
</ul>
<p>当 Context Switch 发生时，需要由操作系统<strong>保存当前线程的状态</strong>，并<strong>恢复另一个线程的状态</strong>，Java 中对应的概念 就是程序计数器（Program Counter Register），它的作用是记住下一条 JVM 指令的执行地址，是线程私有的</p>
<ul>
<li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li>
<li>Context Switch 频繁发生会影响性能</li>
</ul>
<h4 id="2-3-常见方法"><a href="#2-3-常见方法" class="headerlink" title="2.3 常见方法"></a>2.3 常见方法</h4><div class="table-container">
<table>
<thead>
<tr>
<th><strong>方法名</strong></th>
<th><strong>功能说明</strong></th>
<th style="text-align:left"><strong>注意</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>start()</code></td>
<td>启动一个新线程，在新线程上运行<code>run()</code>方法中的代码</td>
<td style="text-align:left"><code>start()</code> 方法只是让线程进入就绪，里面代码不一定立刻运行（CPU 的时间片还没分给它）。每个线程对象的<strong><code>start()</code>方法只能调用一次</strong>，如果调用了多次会出现 IllegalThreadStateException</td>
</tr>
<tr>
<td><code>run()</code></td>
<td>新线程启动后会调用的方法</td>
<td style="text-align:left">如果在构造 Thread 对象时传递了 Runnable 参数，则线程启动后会调用 Runnable 中的<code>run()</code> 方法，否则默认不执行任何操作。但可以创建 Thread 的子类对象，来覆盖默认行为</td>
</tr>
<tr>
<td><code>join()</code></td>
<td>等待线程运行结束</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td><code>join(long n)</code></td>
<td>等待线程运行结束最多等待n毫秒</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td><code>getId()</code></td>
<td>获取线程长整型的id</td>
<td style="text-align:left">id唯一</td>
</tr>
<tr>
<td><code>getName()</code></td>
<td>获取线程名</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td><code>setName(String)</code></td>
<td>修改线程名</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td><code>getPriority()</code></td>
<td>获取线程优先级</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td><code>setPriority(int)</code></td>
<td>设置线程优先级</td>
<td style="text-align:left">java中规定线程优先级是1~10的整数，较大的优先级能提高该线程被 CPU 调度的机率</td>
</tr>
<tr>
<td><code>getState()</code></td>
<td>获取线程状态</td>
<td style="text-align:left">Java中线程状态使用6个enum表示：NEW，RUNNABLE，BLOCKED，WATING，TIMED_WAITING，TERMINATED</td>
</tr>
<tr>
<td><code>isInterrupted()</code></td>
<td>判断是否被打断</td>
<td style="text-align:left">不会清除打断标记</td>
</tr>
<tr>
<td><code>isAlive()</code></td>
<td>线程是否存活（还没有运行完毕）</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td><code>interrupt()</code></td>
<td>打断线程</td>
<td style="text-align:left">如果被打断线程正在 sleep, wait, join 会导致被打断的线程抛出 InterruptedException，并<strong>清除打断标记</strong>；如果打断的正在运行的线程，则会<strong>设置打断标记</strong>；park 的线程被打断，也会<strong>设置打断标记</strong></td>
</tr>
<tr>
<td><code>currentThread()</code></td>
<td>获取当前正在执行的线程</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td><code>sleep(long n)</code></td>
<td>让当前执行的线程休眠n毫秒，休眠时让出 cpu 的时间片给其它线程</td>
<td style="text-align:left">不会释放<strong>锁</strong>操作</td>
</tr>
<tr>
<td><code>yield()</code></td>
<td>提线程调度器让出当前线程对CPU的使用</td>
<td style="text-align:left">主要是为了测试和调试</td>
</tr>
</tbody>
</table>
</div>
<h5 id="2-3-1-start-vs-run"><a href="#2-3-1-start-vs-run" class="headerlink" title="2.3.1 start() vs run()"></a>2.3.1 start() vs run()</h5><p>被创建的Thread对象直接调用重写的<code>run()</code>方法时， run方法是在<strong>主线程</strong>中被执行的，而不是在我们所创建的线程中执行。</p>
<p>所以如果想要在所创建的线程中执行<code>run()</code>方法，<strong>需要使用Thread对象的start()方法。</strong></p>
<h5 id="2-3-2-sleep-vs-yield"><a href="#2-3-2-sleep-vs-yield" class="headerlink" title="2.3.2 sleep() vs yield()"></a>2.3.2 sleep() vs yield()</h5><h6 id="sleep-使线程阻塞"><a href="#sleep-使线程阻塞" class="headerlink" title="sleep (使线程阻塞)"></a><strong>sleep</strong> (使线程阻塞)</h6><ol>
<li><p>调用 <code>sleep()</code> 会让当前线程从 <strong>Running 进入 Timed Waiting 状态（阻塞）</strong>，可通过<code>state()</code>方法查看</p>
</li>
<li><p>其它线程可以使用 <strong><code>interrupt()</code></strong> 方法打断正在睡眠的线程，这时 <code>sleep()</code> 方法会抛出 InterruptedException</p>
</li>
<li><p>睡眠结束后的线程未必会立刻得到执行(Runnable状态)</p>
</li>
<li><p>建议用 <strong>TimeUnit 的 <code>sleep()</code></strong> 代替 Thread 的 <code>sleep()</code> 来获得更好的可读性 。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//休眠一秒</span></span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line"><span class="comment">//休眠一分钟</span></span><br><span class="line">TimeUnit.MINUTES.sleep(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h6 id="yield-（让出当前线程）"><a href="#yield-（让出当前线程）" class="headerlink" title="yield （让出当前线程）"></a>yield （让出当前线程）</h6><ol>
<li>调用 yield 会让当前线程从 <strong>Running 进入 Runnable 就绪状态</strong>（仍然有可能被执行），然后调度执行其它线程</li>
<li>具体的实现依赖于操作系统的任务调度器</li>
</ol>
<h6 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h6><ul>
<li><p>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它</p>
</li>
<li><p>如果 cpu 比较忙，那么优先级高的线程会获得更多的时间片，但 cpu 闲时，优先级几乎没作用</p>
</li>
<li><p>设置方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread1.setPriority(Thread.MAX_PRIORITY); <span class="comment">//设置为优先级int(1~10)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">Runnable</span> <span class="variable">task1</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;----&gt; task1&quot;</span> + count++);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="type">Runnable</span> <span class="variable">task2</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">      Thread.yield();</span><br><span class="line">      System.out.println(<span class="string">&quot;----&gt; task1&quot;</span> + count++);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task1, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task1, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  t1.start();</span><br><span class="line">  t2.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	输出结果应为 t1打印的count 远大于 t2打印的count</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h5 id="2-3-3-join"><a href="#2-3-3-join" class="headerlink" title="2.3.3 join()"></a>2.3.3 join()</h5><pre class="mermaid">graph TD
A1[main]--瞬间完成-->E1[r=0]
E1 --> B1[t1.join]
A1 --> C1[t1.start]
C1 --1s后---> D1[r=10]
D1 --t1结束--> B1
B1 --> R1[res: r=10]</pre>



<p><code>join()</code>的底层原理就是<code>wait()</code>。</p>
<p>用于等待某个线程结束。哪个线程内调用join()方法，就等待哪个线程结束，然后再去执行其他线程。</p>
<p>如在主线程中调用ti.join()，则是主线程等待t1线程结束</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>();</span><br><span class="line"><span class="comment">//等待thread线程执行结束</span></span><br><span class="line">thread.join();</span><br><span class="line"><span class="comment">//最多等待1000ms,如果1000ms内线程执行完毕，则会直接执行下面的语句，不会等够1000ms</span></span><br><span class="line">thread.join(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<h5 id="2-3-4-interrupt"><a href="#2-3-4-interrupt" class="headerlink" title="2.3.4 interrupt()"></a>2.3.4 interrupt()</h5><p>用于打断<strong>阻塞</strong>(sleep wait join…)的线程。 处于<strong>阻塞状态</strong>的线程，CPU不会给其分配时间片。</p>
<ul>
<li>如果一个线程在在运行中被打断，打断标记会被置为<code>true</code>。</li>
<li>如果是打断因<code>sleep(), wait(), join()</code>方法而被阻塞的线程，会将打断标记会被清空，置为<code>false</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于查看打断标记，返回值被boolean类型</span></span><br><span class="line">t1.isInterrupted();</span><br></pre></td></tr></table></figure>
<p>正常运行的线程在被打断后，<strong>不会停止</strong>，会继续执行。如果要让线程在被打断后停下来，需要<strong>使用打断标记来判断</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throw</span> InterruptedException&#123;</span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  t1.start();</span><br><span class="line">  </span><br><span class="line">  Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  Log.debug(<span class="string">&quot;interrupted&quot;</span>);</span><br><span class="line">  t1.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="interrupt-的应用——两阶段终止模式"><a href="#interrupt-的应用——两阶段终止模式" class="headerlink" title="interrupt() 的应用——两阶段终止模式"></a>interrupt() 的应用——两阶段终止模式</h6><p>当我们在执行线程一时，想要终止线程二，这是就需要使用interrupt方法来<strong>优雅</strong>的停止线程二（料理后事: 释放锁和临界资源等）。</p>
<ol>
<li><p>错误思路</p>
<ul>
<li><code>stop()</code>：该方法会直接杀死线程，若线程对临界区资源上锁，则永远解锁，其他线程也无法获取锁。</li>
<li><code>suspend()</code>暂停线程 和 <code>resume()</code>恢复线程, 原因同<code>stop()</code></li>
<li><code>System.exit(int)</code>：该方法会直接<strong>停止进程</strong>。</li>
</ul>
</li>
<li><p>两阶段终止模式</p>
</li>
</ol>
<pre class="mermaid">graph TD

A["while(true)"]
B{是否被打断?}
C[料理后事]
D[睡眠2s]
E(结束循环)
F[执行监控记录]
G[设置打断标记]

A --> B
B --yes--> C
B --no--> D
C --> E
D --无异常--> F
D --有异常--> G
F --> A
G --> A</pre>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  两阶段终止模式（Two Phase Termination）：在进程T1中终止进程T2</span></span><br><span class="line"><span class="comment">    在终止进程T2之前让T2释放锁和临界资源</span></span><br><span class="line"><span class="comment">    不用stop（） 和 System.exit（）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TwoPhaseTermination</span> &#123;</span><br><span class="line">    <span class="comment">// 监控线程</span></span><br><span class="line">    privite Thread monitor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动监控线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        monitor = <span class="keyword">new</span> <span class="title class_">Thread</span> (() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                <span class="keyword">if</span> (current.isInterrupted()) &#123;</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                    		TODO 释放锁和临界资源</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;释放锁和临界资源&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>); <span class="comment">// 情况1</span></span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                        TODO 正常功能的代码块</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                    <span class="comment">// 情况2</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="comment">// 若sleep时被打断，会捕获错误e，此时的isInterrupted标记为false，程序会重复执行。所以有以下操作</span></span><br><span class="line">                    current.interrupt(); <span class="comment">// 重新设置isInterrupted打断标记, true -&gt; false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        monitor.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止监控线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        monitor.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-3-5-主线程与守护线程"><a href="#2-3-5-主线程与守护线程" class="headerlink" title="2.3.5 主线程与守护线程"></a>2.3.5 主线程与守护线程</h5><ul>
<li><p>主线程: 当JAVA进程中有多个线程在执行时，只有当所有非守护线程都执行完毕后，JAVA进程才会结束。</p>
</li>
<li><p>守护线程: <strong>但当非守护线程全部执行完毕后，守护线程无论是否执行完毕，也会一同结束。</strong>(垃圾回收线程)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将线程设置为守护线程, 默认为false</span></span><br><span class="line">monitor.setDaemon(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<h4 id="2-4-线程的状态"><a href="#2-4-线程的状态" class="headerlink" title="2.4 线程的状态"></a>2.4 线程的状态</h4><h5 id="2-4-1-五种状态-操作系统层面"><a href="#2-4-1-五种状态-操作系统层面" class="headerlink" title="2.4.1 五种状态(操作系统层面)"></a>2.4.1 五种状态(操作系统层面)</h5><p><img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/20200608144606.png" alt="20200608144606" style="zoom:75%;"></p>
<ol>
<li>【初始状态】：在<strong>语言层面创建了线程对象</strong>，但未与操作系统线程关联</li>
<li>【可运行状态】：（就需状态），已与操作系统线程关联，可由cpu调度执行</li>
<li>【运行状态】：获得cpu时间片，正在执行。<ul>
<li>当cpu时间片用完，由【运行状态】转为【可运行状态】，导致线程的上下文切换</li>
</ul>
</li>
<li>【阻塞状态】：该状态下的线程不会占用cpu，会导致线程的上下文切换<ul>
<li>等阻塞操作结束，系统唤醒阻塞状态，切换至【可运行状态】</li>
</ul>
</li>
<li>【终止状态】</li>
</ol>
<h5 id="2-4-2-六种状态-JAVA-API层面"><a href="#2-4-2-六种状态-JAVA-API层面" class="headerlink" title="2.4.2 六种状态(JAVA API层面)"></a>2.4.2 六种状态(JAVA API层面)</h5><p><img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/20200608144621.png" alt="20200608144621" style="zoom:75%;"></p>
<p>详见<a href="https://dave0126.github.io//2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/#3-9-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2">第三章 3.9【线程状态转换】</a></p>
<ol>
<li><p>【NEW】：线程被创建，还没有调用<code>strat()</code>方法</p>
</li>
<li><p>【RUNNABLE】：调用了<code>start()</code>方法后。该状态涵盖了<strong>操作系统层面</strong>的<em>【可运行状态】、【运行状态】和【阻塞状态】</em></p>
</li>
<li><p>三种“java中的阻塞状态”：后面会在状态转换一节详述。</p>
<p>(1) 【BLOCKED】：</p>
<p>(2)【WAITING】：<code>join()</code></p>
<p>(3)【TIMED_WAITING】：<code>sleep()</code></p>
</li>
<li><p>【TERMINATED】：代码运行结束</p>
</li>
</ol>
<h4 id="2-5-习题"><a href="#2-5-习题" class="headerlink" title="2.5 习题"></a>2.5 习题</h4><h5 id="2-5-1-统筹方法（烧水泡茶）"><a href="#2-5-1-统筹方法（烧水泡茶）" class="headerlink" title="2.5.1 统筹方法（烧水泡茶）"></a>2.5.1 统筹方法（烧水泡茶）</h5><p>阅读华罗庚《统筹方法》，给出烧水泡茶的多线程解决方案，提示：</p>
<ul>
<li>参考图二，用两个线程（两个人协作）模拟烧水泡茶过程<ul>
<li>文中办法乙、丙都相当于任务串行</li>
<li>而图一相当于启动了 4 个线程，有点浪费</li>
</ul>
</li>
<li>用<code>sleep(n)</code>模拟洗茶壶、洗水壶等耗费的时间</li>
</ul>
<p>附：华罗庚《统筹方法》</p>
<hr>
<p>统筹方法，是一种安排工作进程的数学方法。它的实用范围极广泛，在企业管理和基本建设中，以及关系复杂的科研项目的组织与管理中，都可以应用。</p>
<p>怎样应用呢？主要是把工序安排好。</p>
<p>比如，想泡壶茶喝。当时的情况是：开水没有；水壶要洗，茶壶、茶杯要洗;火已生了，茶叶也有了。<br>怎么办？</p>
<ul>
<li>办法甲：洗好水壶，灌上凉水，放在火上；在等待水开的时间里，洗茶壶、洗茶杯、 拿茶叶；等水开了，泡茶喝。</li>
<li>办法乙：先做好一些准备工作，洗水壶，洗茶壶茶杯，拿茶叶；一切就绪，灌水烧水；坐待水开了，泡茶喝。</li>
<li>办法丙：洗净水壶，灌上凉水，放在火上，坐待水开；水开了之后，急急忙忙找茶叶，洗茶壶茶杯，泡茶喝。</li>
</ul>
<p>哪一种办法省时间？我们能一眼看出，第一种办法好，后两种办法都窝了工。</p>
<p>这是小事，但这是引子，可以引出生产管理等方面有用的方法来。</p>
<p>水壶不洗，不能烧开水，因而洗水壶是烧开水的前提。没开水、没茶叶、不洗茶壶茶杯，就不能泡茶，因而这些又是泡茶的前提。它们的相互关系，可以用下图来表示：</p>
<pre class="mermaid">graph LR;
A[洗水壶 1min]--> B[烧开水 15mins];
B--> R[泡茶];
C[洗茶壶 1min]--> R;
D[洗茶杯 1min]--> R;
E[拿茶叶 1min]--> R;</pre>

<p>从这个图上可以一眼看出，办法甲总共要16分钟（而办法乙、丙需要20分钟）。如果要缩短工时．提高工作效率，应当主要抓烧开水这个环节，而不是抓拿茶叶等环节。同时，洗茶壶茶杯、拿茶叶总共不过3分钟，大可利用“等水开”的时间来做。</p>
<p>是的，这好像是废话，卑之无甚高论。有如走路要用两条腿走，吃饭要一口一口吃，这些道理谁都懂得。但稍有变化，临事而迷的情况，常常是存任的。在近代工业的错综夏杂的工艺过程中，往往就不是像泡茶喝这么简单了。任务多了，几百几千，甚至有好几万个任务。关系多了，错综复杂，千头万绪，往往出现 “万事俱备，只欠东风” 的情况。由于一两个零件没完成，耽误了一台复杂机器的出厂时间。或往往因为抓的不是关键，连夜三班，急急忙忙，完成这一环节之后，还得等待旁的环节才能装配。</p>
<p>洗茶壶，洗茶杯，拿茶叶，或先或后，关系不大，而且同是一个人的活儿，因币可以合并成为：</p>
<pre class="mermaid">graph LR;
A[洗水壶 1min]--> B[烧开水 15mins];
B--> R[泡茶];
C[洗茶壶, 洗茶杯, 拿茶叶 3mins]--> R;</pre>

<p>看来这是“小题大做”，但在工作环节太多的时候，这样做就非常必要了。</p>
<p>这里讲的主要是时间方面的事，但在具体生产实践中，还有其他方面的许多事。这种方法里然不一定能直接解决所有问题，但是，我们利用这种方法来考虑问题，也是不无裨益的。</p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pubilc <span class="keyword">static</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    Log.debug(<span class="string">&quot;洗水壶&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    Log.debug(<span class="string">&quot;烧开水&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">15000</span>);</span><br><span class="line">  &#125;, <span class="string">&quot;小明&quot;</span>);</span><br><span class="line">    </span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    Log.debug(<span class="string">&quot;洗茶壶&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    Log.debug(<span class="string">&quot;洗茶杯&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    Log.debug(<span class="string">&quot;拿茶叶&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">     t1.join(); <span class="comment">// 由 小王 来泡茶 </span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="string">&quot;小王&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  t1.start();</span><br><span class="line">  t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">19:19:37.547	[小明]	c.TestMakeTea -	洗茶壶</span><br><span class="line">19:19:37.547	[小王]	c.TestMakeTea - 洗水壶</span><br><span class="line">19:19:38.552	[小明]	c.TestMakeTea - 洗茶杯</span><br><span class="line">19:19:38.552	[小王]	c.TestMakeTea - 烧开水</span><br><span class="line">19:19:49.553	[小明]	c.TestMakeTea - 拿茶叶</span><br><span class="line">19:19:53.553	[小明]	c.TestMakeTea -	泡茶</span><br></pre></td></tr></table></figure>
<p>解法1的缺陷：</p>
<ul>
<li>上面模拟的是小明等小王的水烧开了，小明泡茶，如果反过来要实现小王等小明的茶叶拿来了，小王泡茶呢？代码最好能适应两种情况</li>
<li>上面的两个线程其实是各执行各的，如果要模拟小王把水壶交给小明泡茶，或模拟小明把茶叶交给小王泡茶</li>
</ul>
<h4 id="2-6-小结"><a href="#2-6-小结" class="headerlink" title="2.6 小结"></a>2.6 小结</h4><p>本章的重点在于掌握</p>
<ul>
<li>线程创建</li>
<li>线程重要api， 如<code>start, run, sleep, join, interrupt</code>等</li>
<li>线程状态</li>
<li>应用方面<ul>
<li>异步调用：主线程执行期间，其它线程异步执行耗时操作</li>
<li>提高效率：并行计算，缩短运算时间</li>
<li>同步等待：join</li>
<li>统筹规划：合理使用线程，得到最优效果</li>
</ul>
</li>
<li>原理方面<ul>
<li>线程运行流程：栈、栈帧、上下文切换、程序计数器</li>
<li>Thread 两种创建方式 的源码</li>
</ul>
</li>
<li>模式方面<ul>
<li>两阶段终止</li>
</ul>
</li>
</ul>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Guohao
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://dave0126.github.io/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/" title="Java 并发多线程编程 (JUC) (一)">https://dave0126.github.io/2022/03/23/JUC-Java多线程-1/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
              <a href="/tags/JUC/" rel="tag"># JUC</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/03/22/JVM-2/" rel="prev" title="Java 虚拟机 - JVM 第二讲">
      <i class="fa fa-chevron-left"></i> Java 虚拟机 - JVM 第二讲
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/03/26/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-2/" rel="next" title="Java 并发多线程编程 (JUC) (二)">
      Java 并发多线程编程 (JUC) (二) <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Java-%E5%B9%B6%E5%8F%91%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B"><span class="nav-text">Java 并发多线程编程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B"><span class="nav-text">1 线程与进程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-%E8%BF%9B%E7%A8%8B"><span class="nav-text">1.1 进程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-%E7%BA%BF%E7%A8%8B"><span class="nav-text">1.2 线程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-%E4%B8%A4%E8%80%85%E5%AF%B9%E6%AF%94"><span class="nav-text">1.3 两者对比</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-1-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%87%E6%8D%A2"><span class="nav-text">1.3.1 进程和线程的切换</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="nav-text">上下文切换</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB"><span class="nav-text">进程切换和线程切换的主要区别</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88TLB%E8%83%BD%E5%8A%A0%E5%BF%AB%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6"><span class="nav-text">为什么TLB能加快访问速度</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="nav-text">1.4 并行与并发</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-%E5%BA%94%E7%94%A8"><span class="nav-text">1.5 应用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-5-1-%E5%BA%94%E7%94%A8%E4%B9%8B%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%EF%BC%88%E6%A1%88%E4%BE%8B1%EF%BC%89"><span class="nav-text">1.5.1 应用之异步调用（案例1）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-%E8%AE%BE%E8%AE%A1"><span class="nav-text">1) 设计</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-%E7%BB%93%E8%AE%BA"><span class="nav-text">2) 结论</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-5-2-%E5%BA%94%E7%94%A8%E4%B9%8B%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%EF%BC%88%E6%A1%88%E4%BE%8B1%EF%BC%89"><span class="nav-text">1.5.2 应用之提高效率（案例1）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BB%93%E8%AE%BA"><span class="nav-text">结论</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-Java-%E7%BA%BF%E7%A8%8B"><span class="nav-text">2 Java 线程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-%E5%88%9B%E5%BB%BA%E5%92%8C%E8%BF%90%E8%A1%8C%E7%BA%BF%E7%A8%8B"><span class="nav-text">2.1 创建和运行线程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B"><span class="nav-text">方法一：直接使用构造器创建一个线程</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E4%BD%BF%E7%94%A8Runnable%E9%85%8D%E5%90%88Thread-%E6%8E%A8%E8%8D%90"><span class="nav-text">方法二：使用Runnable配合Thread(推荐)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E7%9A%84%E7%AE%80%E5%8C%96%EF%BC%9A%E4%BD%BF%E7%94%A8lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AE%80%E5%8C%96%E6%93%8D%E4%BD%9C"><span class="nav-text">方法二的简化：使用lambda表达式简化操作</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Thread-%E4%B8%8E-Runnable-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="nav-text">Thread 与 Runnable 的关系</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89%EF%BC%9A%E4%BD%BF%E7%94%A8FutureTask%E4%B8%8EThread%E7%BB%93%E5%90%88"><span class="nav-text">方法三：使用FutureTask与Thread结合</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%80%BB%E7%BB%93"><span class="nav-text">总结</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C"><span class="nav-text">2.2 原理之线程运行</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-1-%E6%A0%88%E4%B8%8E%E6%A0%88%E5%B8%A7"><span class="nav-text">2.2.1 栈与栈帧</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-2-2-%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="nav-text">2.2.2 线程上下文切换</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="nav-text">2.3 常见方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-1-start-vs-run"><span class="nav-text">2.3.1 start() vs run()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-2-sleep-vs-yield"><span class="nav-text">2.3.2 sleep() vs yield()</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#sleep-%E4%BD%BF%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E"><span class="nav-text">sleep (使线程阻塞)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#yield-%EF%BC%88%E8%AE%A9%E5%87%BA%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B%EF%BC%89"><span class="nav-text">yield （让出当前线程）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="nav-text">线程优先级</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-3-join"><span class="nav-text">2.3.3 join()</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-4-interrupt"><span class="nav-text">2.3.4 interrupt()</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#interrupt-%E7%9A%84%E5%BA%94%E7%94%A8%E2%80%94%E2%80%94%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F"><span class="nav-text">interrupt() 的应用——两阶段终止模式</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-5-%E4%B8%BB%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="nav-text">2.3.5 主线程与守护线程</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="nav-text">2.4 线程的状态</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4-1-%E4%BA%94%E7%A7%8D%E7%8A%B6%E6%80%81-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B1%82%E9%9D%A2"><span class="nav-text">2.4.1 五种状态(操作系统层面)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-4-2-%E5%85%AD%E7%A7%8D%E7%8A%B6%E6%80%81-JAVA-API%E5%B1%82%E9%9D%A2"><span class="nav-text">2.4.2 六种状态(JAVA API层面)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-%E4%B9%A0%E9%A2%98"><span class="nav-text">2.5 习题</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-5-1-%E7%BB%9F%E7%AD%B9%E6%96%B9%E6%B3%95%EF%BC%88%E7%83%A7%E6%B0%B4%E6%B3%A1%E8%8C%B6%EF%BC%89"><span class="nav-text">2.5.1 统筹方法（烧水泡茶）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-%E5%B0%8F%E7%BB%93"><span class="nav-text">2.6 小结</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Guohao</p>
  <div class="site-description" itemprop="description">间歇性踌躇满志, 持续性划水摸鱼</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">18</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">5</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Guohao</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">241k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">3:39</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>



        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  













<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : '[object Object]',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  

</body>
</html>
