<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Java 并发多线程编程 (JUC) | Lost N Found</title><meta name="author" content="Guohao"><meta name="copyright" content="Guohao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="本文主要通过以下几个方面来系统的介绍 Java 并发多线程编程：  线程与进程 Java 线程 共享模型之 Monitor 共享模型之 JMM 共享模型之 无锁（乐观锁） 并发工具之 线程池   【参考资料】: 视频课程: BiliBili - 黑马程序员Java并发编程 JUC 笔记参考: Java并发 - Nyima’s Blog  注：本课程笔记基于 JDK8，采用 lsf4j 打印日志">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 并发多线程编程 (JUC)">
<meta property="og:url" content="https://lostnfound.top/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/index.html">
<meta property="og:site_name" content="Lost N Found">
<meta property="og:description" content="本文主要通过以下几个方面来系统的介绍 Java 并发多线程编程：  线程与进程 Java 线程 共享模型之 Monitor 共享模型之 JMM 共享模型之 无锁（乐观锁） 并发工具之 线程池   【参考资料】: 视频课程: BiliBili - 黑马程序员Java并发编程 JUC 笔记参考: Java并发 - Nyima’s Blog  注：本课程笔记基于 JDK8，采用 lsf4j 打印日志">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lostnfound.top/linear-gradient(45deg,%20#8EC3B0,%20#9ED5C5,%20#F8C4B4,%20#FF8787)">
<meta property="article:published_time" content="2022-03-23T20:13:13.000Z">
<meta property="article:modified_time" content="2022-11-10T18:13:18.974Z">
<meta property="article:author" content="Guohao">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="JUC">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lostnfound.top/linear-gradient(45deg,%20#8EC3B0,%20#9ED5C5,%20#F8C4B4,%20#FF8787)"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://lostnfound.top/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":100,"languages":{"author":"作者: Guohao","link":"链接: ","source":"来源: Lost N Found","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Java 并发多线程编程 (JUC)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-11-10 19:13:18'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/atom.xml" title="Lost N Found" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-battery-full"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-calendar-check"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-hashtag"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user-circle"></i><span> 关于我</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/Dave0126"><i class="fa-fw fab fa-github"></i><span> Github</span></a></li><li><a class="site-page child" href="mailto:dave980126@outlook.com"><i class="fa-fw fas fa-envelope"></i><span> Mail</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: linear-gradient(45deg, #8EC3B0, #9ED5C5, #F8C4B4, #FF8787)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Lost N Found</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-battery-full"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-calendar-check"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-hashtag"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user-circle"></i><span> 关于我</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/Dave0126"><i class="fa-fw fab fa-github"></i><span> Github</span></a></li><li><a class="site-page child" href="mailto:dave980126@outlook.com"><i class="fa-fw fas fa-envelope"></i><span> Mail</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Java 并发多线程编程 (JUC)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-03-23T20:13:13.000Z" title="发表于 2022-03-23 21:13:13">2022-03-23</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-11-10T18:13:18.974Z" title="更新于 2022-11-10 19:13:18">2022-11-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Java/">Java</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">25.3k</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>本文主要通过以下几个方面来系统的介绍 Java 并发多线程编程：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://dave0126.github.io/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/#1-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B">线程与进程</a></li>
<li><a target="_blank" rel="noopener" href="https://dave0126.github.io/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/#2-java-%E7%BA%BF%E7%A8%8B">Java 线程</a></li>
<li><a target="_blank" rel="noopener" href="https://dave0126.github.io/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/#3-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B-monitor">共享模型之 <code>Monitor</code></a></li>
<li><a target="_blank" rel="noopener" href="https://dave0126.github.io/2022/08/26/JMM-Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">共享模型之 <code>JMM</code></a></li>
<li><a target="_blank" rel="noopener" href="https://dave0126.github.io/2022/09/15/Java%E4%B8%AD%E7%9A%84%E9%94%81%EF%BC%9A%E4%B9%90%E8%A7%82%E9%94%81/">共享模型之 无锁（乐观锁）</a></li>
<li><a target="_blank" rel="noopener" href="https://dave0126.github.io/2022/09/16/Java%E4%B8%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%88%86%E6%9E%90/">并发工具之 线程池</a></li>
</ol>
<hr>
<p>【参考资料】:</p>
<p>视频课程: <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV16J411h7Rd?p=1">BiliBili - 黑马程序员Java并发编程 JUC</a></p>
<p>笔记参考: <a target="_blank" rel="noopener" href="https://nyimac.gitee.io/2020/06/08/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/">Java并发 - Nyima’s Blog</a></p>
<ul>
<li>注：本课程笔记基于 JDK8，采用 <code>lsf4j</code> 打印日志</li>
</ul>
<span id="more"></span>
<h3 id="1-线程与进程"><a class="markdownIt-Anchor" href="#1-线程与进程"></a> 1 线程与进程</h3>
<h4 id="11-进程"><a class="markdownIt-Anchor" href="#11-进程"></a> 1.1 进程</h4>
<ul>
<li>程序由指令和数据组成，但这些指令要运行，数据要读写，就必须将指令加载至 CPU，数据加载至内存。在指令运行过程中还需要用到磁盘、网络等设备。进程就是用来<strong>加载指令、管理内存、管理 IO 的</strong>。</li>
<li>当一个程序被运行，从磁盘加载这个程序的代码至内存，这时就开启了一个进程。</li>
<li>进程就可以视为<strong>程序的一个实例</strong>（程序是静态的，进程是动态的）。大部分程序可以同时运行多个实例进程（例如记事本、画图、浏览器 等），也有的程序只能启动一个实例进程（例如网易云音乐、360 安全卫士等）</li>
</ul>
<h4 id="12-线程"><a class="markdownIt-Anchor" href="#12-线程"></a> 1.2 线程</h4>
<ul>
<li>一个进程可以分为一到多个线程。</li>
<li><strong>一个线程就是一个指令流</strong>，将指令流中的一条条指令以一定的顺序交给 CPU 执行 。</li>
<li>Java 中，线程作为最小<strong>调度单位</strong>（执行指令），进程作为<strong>资源分配</strong>的最小单位。 在 Windows 中进程是不活动的，只是作 为线程的容器</li>
</ul>
<h4 id="13-两者对比"><a class="markdownIt-Anchor" href="#13-两者对比"></a> 1.3 两者对比</h4>
<ul>
<li><strong>进程基本上相互独立的</strong>，而<strong>线程存在于进程内</strong>，是进程的一个子集</li>
<li>进程拥有共享的资源，如内存空间等，供其<strong>内部的线程共享</strong>
<ul>
<li>进程间通信较为复杂 同一台计算机的进程通信称为 IPC（Inter-process communication）</li>
<li>不同计算机之间的进程通信，需要通过网络，并遵守共同的协议，例如 HTTP</li>
</ul>
</li>
<li>线程通信相对简单，因为它们共享进程内的内存，一个例子是多个线程可以访问同一个共享变量</li>
<li>线程更轻量，线程上下文切换成本一般上要比进程上下文切换低</li>
</ul>
<h5 id="131-进程和线程的切换"><a class="markdownIt-Anchor" href="#131-进程和线程的切换"></a> 1.3.1 进程和线程的切换</h5>
<h6 id="上下文切换"><a class="markdownIt-Anchor" href="#上下文切换"></a> 上下文切换</h6>
<p>内核为每一个进程维持一个上下文。**上下文就是内核重新启动一个被抢占的进程所需的状态。**包括以下内容：</p>
<ul>
<li>通用目的寄存器</li>
<li>浮点寄存器</li>
<li>程序计数器</li>
<li>用户栈</li>
<li>状态寄存器</li>
<li>内核栈</li>
<li>各种内核数据结构：比如描绘地址空间的<strong>页表</strong>，包含有关当前进程信息的<strong>进程表</strong>，以及包含进程已打开文件的信息的<strong>文件表</strong></li>
</ul>
<h6 id="进程切换和线程切换的主要区别"><a class="markdownIt-Anchor" href="#进程切换和线程切换的主要区别"></a> 进程切换和线程切换的主要区别</h6>
<p>最主要的一个区别在于<strong>进程切换涉及虚拟地址空间的切换而线程不会</strong>。因为每个进程都有自己的虚拟地址空间，而<strong>线程是共享所在进程的虚拟地址空间的</strong>，因此同一个进程中的线程进行线程切换时不涉及虚拟地址空间的转换</p>
<p>页表查找是一个很慢的过程，因此通常使用cache来缓存常用的地址映射，这样可以加速页表查找，这个cache就是快表TLB（translation Lookaside Buffer，用来加速页表查找）。由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么<strong>当进程切换后页表也要进行切换，页表切换后TLB就失效了</strong>，cache失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致TLB失效，因为线程线程无需切换地址空间，因此我们通常说线程切换要比较进程切换快</p>
<p>而且还可能出现<strong>缺页中断</strong>，这就需要操作系统将需要的内容调入内存中，若内存已满则还需要将不用的内容调出内存，这也需要花费时间</p>
<h6 id="为什么tlb能加快访问速度"><a class="markdownIt-Anchor" href="#为什么tlb能加快访问速度"></a> <strong>为什么TLB能加快访问速度</strong></h6>
<p>快表可以避免每次都对页号进行地址的有效性判断。快表中保存了对应的物理块号，可以直接计算出物理地址，无需再进行有效性检查</p>
<h4 id="14-并行与并发"><a class="markdownIt-Anchor" href="#14-并行与并发"></a> 1.4 并行与并发</h4>
<ol>
<li>
<p>单核cpu 下，线程实际还是<strong>串行执行</strong>的。操作系统中有一个组件叫做任务调度器，将cpu 的时间片（windows 下时间片最小约为 15 毫秒）分给不同的线程使用，只是由于 cpu在线程间（时间片很短）的切换非常快，人类感觉是<strong>同时运行</strong>的。总结为一句话就是：“<strong>微观串行，宏观并行</strong>”<br>
一般会将这种<strong>线程轮流使用 CPU</strong>的做法称为并发，Concurrent。</p>
</li>
<li>
<p>多核cpu下，每个核心都可以调度运行线程，此时线程间是可以<strong>并行</strong>(Parallel)的。</p>
</li>
</ol>
<p><strong>并发</strong>(Concurrent) 是一个CPU在不同的时间去不同线程中执行指令。</p>
<p><strong>并行</strong>(Parallel)是多个CPU同时处理不同的线程。</p>
<h4 id="15-应用"><a class="markdownIt-Anchor" href="#15-应用"></a> 1.5 应用</h4>
<h5 id="151-应用之异步调用案例1"><a class="markdownIt-Anchor" href="#151-应用之异步调用案例1"></a> 1.5.1 应用之异步调用（案例1）</h5>
<p>以<strong>调用方角度</strong>来讲，如果</p>
<ul>
<li>需要等待结果返回，才能继续运行就是同步</li>
<li>不需要等待结果返回，就能继续运行就是异步</li>
</ul>
<p>注意：同步在多线程中还有另外一层意思，即让多个线程步调一致</p>
<h6 id="1-设计"><a class="markdownIt-Anchor" href="#1-设计"></a> 1) 设计</h6>
<p>多线程可以让方法执行变为异步的（即不要巴巴干等着）比如说读取磁盘文件时，假设读取操作花费了 5 秒钟，如果没有线程调度机制，这 5 秒 cpu 什么都做不了，其它代码都得暂停…</p>
<p>一般来讲，大文件的读写、耗时较长的工作可以异步执行</p>
<h6 id="2-结论"><a class="markdownIt-Anchor" href="#2-结论"></a> 2) 结论</h6>
<ul>
<li>比如在项目中，视频文件需要转换格式等操作比较费时，这时开一个新线程处理视频转换，避免阻塞主线程</li>
<li>tomcat 的异步 servlet 也是类似的目的，让用户线程处理耗时较长的操作，避免阻塞</li>
<li>tomcat 的工作线程 ui 程序中，开线程进行其他操作，避免阻塞 ui 线程</li>
</ul>
<h5 id="152-应用之提高效率案例1"><a class="markdownIt-Anchor" href="#152-应用之提高效率案例1"></a> 1.5.2 应用之提高效率（案例1）</h5>
<p>充分利用多核 cpu 的优势，提高运行效率。想象下面的场景，执行3个计算，最后将计算结果汇总。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">计算 1 花费	10ms</span><br><span class="line">计算 2 花费	11ms</span><br><span class="line">计算 3 花费	9ms</span><br><span class="line">汇总需要		1ms</span><br></pre></td></tr></table></figure>
<p>如果是串行执行，那么总共花费的时间是 <code>10 + 11 + 9 + 1 = 31ms</code></p>
<ul>
<li>但如果是四核 cpu，各个核心分别使用线程1 执行计算1，线程2执行计算2，线程3执行计算3，那么3个线程是并行的，花费时间只取决于最长的那个线程运行的时间，即<code>11ms</code> 。最后加上汇总时间，只会花费<code>12ms</code>。</li>
</ul>
<p><strong>注意</strong>：需要在多核cpu 才能提高效率，单核仍然时是轮流执行</p>
<h6 id="结论"><a class="markdownIt-Anchor" href="#结论"></a> 结论</h6>
<ol>
<li>单核 cpu 下，多线程不能实际提高程序运行效率，只是为了能够在不同的任务之间切换，不同线程轮流使用 cpu ，不至于一个线程总占用 cpu，别的线程没法干活</li>
<li>多核 cpu 可以并行跑多个线程，但能否提高程序运行效率还是要分情况的
<ul>
<li>有些任务，经过精心设计，将任务拆分，并行执行，当然可以提高程序的运行效率。但不是所有计算任 务都能拆分（参考后文的【阿姆达尔定律】）</li>
<li>也不是所有任务都需要拆分，任务的目的如果不同，谈拆分和效率没啥意义</li>
</ul>
</li>
<li>IO 操作不占用 cpu，只是我们一般拷贝文件使用的是【阻塞 IO】，这时相当于线程虽然不用 CPU，但需要一 直等待 IO 结束，没能充分利用线程。所以才有后面的【非阻塞 IO】和【异步 IO】优化。</li>
</ol>
<h3 id="2-java-线程"><a class="markdownIt-Anchor" href="#2-java-线程"></a> 2 Java 线程</h3>
<h4 id="21-创建和运行线程"><a class="markdownIt-Anchor" href="#21-创建和运行线程"></a> 2.1 创建和运行线程</h4>
<h5 id="方法一直接使用构造器创建一个线程"><a class="markdownIt-Anchor" href="#方法一直接使用构造器创建一个线程"></a> 方法一：直接使用构造器创建一个线程</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">CreateThread</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">myThread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;my thread running...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">		myThread.start();  <span class="comment">// 启动线程</span></span><br><span class="line">    System.out.println(<span class="string">&quot;main thread running...&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用继承方式的好处是，在<code>run()</code>方法内获取当前线程直接使用 <code>this</code> 就可以了，无须使用 <code>Thread.currentThread()</code>方法；</li>
<li>不好的地方是 Java 不支持多继承，如果<u>继承了 <code>Thread</code> 类</u>，那么就不能再继承其他类。另外<u>任务与代码没有分离</u>，当多个线程执行一样的任务时需要多份任务代码</li>
</ul>
<h5 id="方法二使用-runnable-配合-thread推荐"><a class="markdownIt-Anchor" href="#方法二使用-runnable-配合-thread推荐"></a> 方法二：使用 <code>Runnable</code> 配合 <code>Thread</code>（推荐）</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//创建线程任务</span></span><br><span class="line">		<span class="type">Runnable</span> <span class="variable">runnableInstance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Runnable</span>() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;Runnable running&quot;</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;;</span><br><span class="line">    </span><br><span class="line">		<span class="comment">//将Runnable对象传给Thread</span></span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(runnableInstannce);</span><br><span class="line">    </span><br><span class="line">		<span class="comment">//启动线程</span></span><br><span class="line">		t.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过实现 <code>Runnable</code> 接口，并且实现 <code>run()</code>方法。好处是<u>将任务和线程分离</u>，更为灵活。在创建线程时作为参数传入该类的实例即可。</p>
<h5 id="方法二的简化使用lambda表达式简化操作"><a class="markdownIt-Anchor" href="#方法二的简化使用lambda表达式简化操作"></a> 方法二的简化：使用lambda表达式简化操作</h5>
<p>当<strong>只有一个抽象方法的接口</strong>可以用 <code>@FunctionalInterface</code> 注解。当有该注解时，可以<strong>使用 lambda 来简化操作</strong>。所以方法二中的代码可以被简化为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="comment">//创建线程任务</span></span><br><span class="line">		<span class="type">Runnable</span> <span class="variable">r</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">      <span class="comment">//直接写方法体即可</span></span><br><span class="line">			System.out.println(<span class="string">&quot;Runnable running&quot;</span>);</span><br><span class="line">			System.out.println(<span class="string">&quot;Hello Thread&quot;</span>);</span><br><span class="line">		&#125;;</span><br><span class="line">    </span><br><span class="line">		<span class="comment">//将Runnable对象传给Thread</span></span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(r);</span><br><span class="line">    </span><br><span class="line">		<span class="comment">//启动线程</span></span><br><span class="line">		t.start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还可以继续简化上述代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello Thread!&quot;</span>);</span><br><span class="line">    &#125;,<span class="string">&quot;name_of_thread&quot;</span>).start();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 IDEA 中，可以在 <code>Runnable</code> 上使用<code>Alt + Enter</code>自动转换成 lambda 表达式。</p>
<h6 id="thread-与-runnable-的关系"><a class="markdownIt-Anchor" href="#thread-与-runnable-的关系"></a> Thread 与 Runnable 的关系</h6>
<p>分析 <code>Thread</code> 的源码，理清它与 <code>Runnable</code> 的关系。</p>
<p>【方法一】</p>
<ul>
<li>首先，<code>Thread</code> 实现了 <code>Runnable</code> 接口，我们可以类比静态代理，将 <code>new Thread</code> 看作是代理对象。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Thread</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;...&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>在方法 1 中，我们在  <code>new Thread</code> 对象中重写了 <code>run()</code> 方法。</li>
</ul>
<p>【方法二】</p>
<ul>
<li>在方法 2 中，<code>Thread</code> 的构造方法如下，会传入一个 <code>Runnable target</code> 对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Thread</span><span class="params">(Runnable target)</span> &#123;</span><br><span class="line">        init(<span class="literal">null</span>, target, <span class="string">&quot;Thread-&quot;</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">(ThreadGroup g, Runnable target, String name,<span class="type">long</span> stackSize)</span> &#123;</span><br><span class="line">        init(g, target, name, stackSize, <span class="literal">null</span>, <span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>而在 <code>Thread</code> 的 <code>run()</code> 方法中，会先判断 <code>Runnable target</code> 对象是否为空，如果非空，就调用 <code>target.run()</code> 方法，</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (target != <span class="literal">null</span>) &#123;</span><br><span class="line">           target.run();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>用 <code>Runnable</code> 更容易与线程池等高级 API 配合用 <code>Runnable</code> 让任务类脱离了 <code>Thread</code> 继承体系，更灵活。Java 推荐<u>组合优于继承</u></p>
</blockquote>
<h5 id="方法三使用-futuretask-与-thread-结合"><a class="markdownIt-Anchor" href="#方法三使用-futuretask-与-thread-结合"></a> 方法三：使用 <code>FutureTask</code> 与 <code>Thread</code> 结合</h5>
<p>分析 <code>FutureTask</code> 源码我们可以知道， <code>FutureTask</code> 间接实现了  <code>Runnable</code> 和 <code>Future</code> 接口，所以他也可以像方法二一样创建一个线程。 <code>Future</code> 接口的 <code>get()</code> 方法可以用来返回任务的执行结果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">FutureTask</span>&lt;V&gt; <span class="keyword">implements</span> <span class="title class_">RunnableFuture</span>&lt;V&gt; &#123;...&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">RunnableFuture</span>&lt;V&gt; <span class="keyword">extends</span> <span class="title class_">Runnable</span>, Future&lt;V&gt; &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【<u><code>FutureTask</code> 接收返回值</u>】</p>
<p>此外， <u><code>Runnable</code> 的 <code>run()</code> 方法没有返回值</u>，这样就没有办法在两个线程之间传递返回值。所以 <code>FutureTask</code> 可以与 <u><code>Callable</code> 接口</u>结合使用，就可以<u>将任务的结果转递给其他线程</u>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Callable</span>&lt;V&gt; &#123;</span><br><span class="line">    V <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 <code>FutureTask</code> 可以用泛型指定<strong>线程的返回值</strong>类型（<code>Runnable</code> 的 <code>run()</code> 方法没有返回值）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test3</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException &#123;</span><br><span class="line">        <span class="comment">//需要传入一个 Callable 对象，使得任务结束时可以返回值</span></span><br><span class="line">		FutureTask&lt;Integer&gt; task = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;Integer&gt;(<span class="keyword">new</span> <span class="title class_">Callable</span>&lt;Integer&gt;() &#123;</span><br><span class="line">			<span class="meta">@Override</span></span><br><span class="line">			<span class="keyword">public</span> Integer <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;线程执行!&quot;</span>);</span><br><span class="line">				Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">				<span class="keyword">return</span> <span class="number">100</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line">		<span class="type">Thread</span> <span class="variable">r1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">		r1.start();</span><br><span class="line">    </span><br><span class="line">		<span class="comment">//获取线程中方法执行后的返回结果</span></span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> task.get() <span class="comment">// 阻塞在此处等待结果的返回</span></span><br><span class="line">		System.out.println(res);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>【总结】</p>
<p>使用<strong>继承方式的好处是方便传参</strong>，你可以在子类里面添加成员变量，通过 <code>set()</code> 方法设置参数或者通过构造函数进行传递，而如果使用 <code>Runnable</code> 方式，则只能使用主线程里面被声明为 <code>final</code> 的变量。</p>
<p><strong>不好的地方是 Java 不支持多继承</strong>，如果继承了 <code>Thread</code> 类，那么子类不能再继承其他类，而 <code>Runable</code> 则没有这个限制。<strong>前两种方式都没办法拿到任务的返回结果，但是 <code>FutureTask</code> 方式可以</strong></p>
<h4 id="22-原理之线程运行"><a class="markdownIt-Anchor" href="#22-原理之线程运行"></a> 2.2 原理之线程运行</h4>
<h5 id="221-栈与栈帧"><a class="markdownIt-Anchor" href="#221-栈与栈帧"></a> 2.2.1 栈与栈帧</h5>
<p><a target="_blank" rel="noopener" href="https://dave0126.github.io/2022/03/22/JVM-1/#2-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88">Java Virtual Machine Stacks</a> （Java 虚拟机栈） 我们都知道 JVM 中由堆、栈、方法区所组成，其中栈内存是给谁用的呢？</p>
<ul>
<li>栈内存 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 线程。其实就是线程，每个线程启动后，虚拟机就会为其分配一块<u>栈内存</u></li>
<li>栈帧 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 调用方法。每个<u>栈由多个栈帧</u> (Frame) 组成，对应着每次<strong>方法调用时所占用的内存</strong></li>
<li>每个线程只能有<u>一个活动栈帧</u>，对应着当前正在执行的那个方法</li>
</ul>
<h6 id="jvm-工作流程"><a class="markdownIt-Anchor" href="#jvm-工作流程"></a> JVM 工作流程：</h6>
<p>当我们运行一个程序（类）时，</p>
<ol>
<li>我们先执行【类加载】，把该类的字节码放入方法区；</li>
<li>JVM 启动【主线程】，并且为其分配一个【主线程栈】内存空间；</li>
<li>从【主方法】开始，JVM 为主方法<u>在主线程栈内</u>分配一个【主方法栈帧】内存；</li>
<li>而在这个【主方法栈帧】内存中，存在着【局部变量表】【操作数栈】【锁记录】等</li>
<li>【局部变量表】用来存储方法内的局部变量；</li>
<li>当我们调用其他方法时，JVM 会为其在【主线程栈】中分配一块新的【栈帧】内存；</li>
<li>当我们【<code>new</code>】一个对象时，这个对象会被存储在【堆】，并将该对象的【引用】地址存入相应的地方（局部变量表等）</li>
<li>当我们创建一个线程时，JVM 会为其分配一个新的【栈】内存空间，不同的栈内存互不干扰。</li>
</ol>
<h5 id="222-线程上下文切换"><a class="markdownIt-Anchor" href="#222-线程上下文切换"></a> 2.2.2 线程上下文切换</h5>
<p>因为以下一些原因导致 CPU 不再执行当前的线程，转而执行另一个线程的代码</p>
<p>【被动】</p>
<ul>
<li>线程的 CPU 时间片用完</li>
<li>垃圾回收（“Stop the world”）</li>
<li>有更高优先级的线程需要运行</li>
</ul>
<p>【主动】</p>
<ul>
<li>线程自己调用了 <code>sleep</code>、<code>yield</code>、<code>wait</code>、<code>join</code>、<code>park</code>、<code>synchronized</code>、<code>lock</code> 等方法</li>
</ul>
<p>当【上下文切换】发生时，需要由操作系统<strong>保存当前线程的状态</strong>，并<strong>恢复另一个线程的状态</strong>，Java 中对应的概念就是程序计数器（Program Counter Register），它的作用是记住下一条 JVM 指令的执行地址，<u>是线程私有的</u></p>
<ul>
<li>状态包括程序计数器、虚拟机栈中每个栈帧的信息，如局部变量、操作数栈、返回地址等</li>
<li>上下文切换频繁发生会影响性能</li>
</ul>
<h4 id="23-常见方法"><a class="markdownIt-Anchor" href="#23-常见方法"></a> 2.3 常见方法</h4>
<table>
<thead>
<tr>
<th><strong>方法名</strong></th>
<th><strong>功能说明</strong></th>
<th style="text-align:left"><strong>注意</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><code>start()</code></td>
<td>启动一个新线程，在新线程上运行<code>run()</code>方法中的代码</td>
<td style="text-align:left"><code>start()</code> 方法只是让线程进入【就绪状态】，里面代码<u>不一定立刻运行</u>（<em>有可能 CPU 的时间片还没分给它</em>）。每个线程对象的**<code>start()</code>方法只能调用一次**，如果调用了多次会出现 <code>IllegalThreadStateException</code></td>
</tr>
<tr>
<td><code>run()</code></td>
<td>新线程启动后会调用的方法</td>
<td style="text-align:left">如果在构造 <code>Thread</code> 对象时传递了 <code>Runnable</code> 参数，则线程启动后会调用 <code>Runnable</code> 中的<code>run()</code> 方法，否则默认不执行任何操作。但可以创建 <code>Thread</code> 的子类对象，来覆盖默认行为</td>
</tr>
<tr>
<td><code>join()</code></td>
<td>阻塞等待线程运行结束</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td><code>join(long n)</code></td>
<td>阻塞等待线程运行结束最多等待 n 毫秒</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td><code>getId()</code></td>
<td>获取线程长整型的<code>id· |</code>id` 唯一</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td><code>getName()</code></td>
<td>获取线程名</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td><code>setName(String)</code></td>
<td>修改线程名</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td><code>getPriority()</code></td>
<td>获取线程优先级</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td><code>setPriority(int)</code></td>
<td>设置线程优先级</td>
<td style="text-align:left">java中规定线程优先级是 1~10 的整数，较大的优先级能提高该线程被 CPU 调度的机率</td>
</tr>
<tr>
<td><code>getState()</code></td>
<td>获取线程状态</td>
<td style="text-align:left">Java 中线程状态使用6个 enum 表示： <code>NEW</code>，<code>RUNNABLE</code>，<code>BLOCKED</code>，<code>WATING</code>，<code>TIMED_WAITING</code>，<code>TERMINATED</code></td>
</tr>
<tr>
<td><code>isInterrupted()</code></td>
<td>判断是否被打断</td>
<td style="text-align:left">不会清除打断标记</td>
</tr>
<tr>
<td><code>isAlive()</code></td>
<td>线程是否存活（还没有运行完毕）</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td><code>interrupt()</code></td>
<td>打断线程</td>
<td style="text-align:left">如果被打断线程正在 <code>sleep, wait, join</code> 会导致被打断的线程抛出 <code>InterruptedException</code>，并<strong>清除打断标记</strong>；如果打断的正在运行的线程，则会<strong>设置打断标记</strong>；<code>park</code> 的线程被打断，也会<strong>设置打断标记</strong></td>
</tr>
<tr>
<td><code>currentThread()</code></td>
<td>获取当前正在执行的线程</td>
<td style="text-align:left"></td>
</tr>
<tr>
<td><code>sleep(long n)</code></td>
<td>让当前执行的线程休眠 n 毫秒，休眠时让出 CPU 的时间片给其它线程</td>
<td style="text-align:left">不会释放<strong>锁</strong>操作</td>
</tr>
<tr>
<td><code>yield()</code></td>
<td>提示线程调度器让出当前线程对 CPU 的使用</td>
<td style="text-align:left">主要是为了测试和调试</td>
</tr>
</tbody>
</table>
<h5 id="231-start-vs-run"><a class="markdownIt-Anchor" href="#231-start-vs-run"></a> 2.3.1 <code>start()</code> vs <code>run()</code></h5>
<ul>
<li><code>start()</code> 用来启动线程， <code>run()</code> 是线程启动之后要执行的方法。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test4</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;RUNNING...&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">		</span><br><span class="line">    <span class="comment">// 不启动t1线程就直接run()</span></span><br><span class="line">    t1.run();</span><br><span class="line">    System.out.println(t1.getState());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RUNNING...</span><br></pre></td></tr></table></figure>
<p>我们可以看到，貌似没有 <code>start()</code> 来启动 <code>t1</code> 线程， <code>run()</code> 也成功执行了。但是我们需要注意，这里的 <code>run()</code> 方法其实是<u>主线程执行</u>的。</p>
<p>被创建的 <code>Thread</code> 对象不启动直接调用重写的 <code>run()</code> 方法时， <code>run()</code> 方法是在<strong>主线程</strong>中被执行的，而不是在我们所创建的线程中执行。</p>
<p>所以如果想要在所创建的线程中执行 <code>run()</code> 方法，<strong>需要使用 <code>Thread</code> 对象的 <code>start()</code> 方法。</strong></p>
<h5 id="232-sleep-vs-yield"><a class="markdownIt-Anchor" href="#232-sleep-vs-yield"></a> 2.3.2 <code>sleep()</code> vs <code>yield()</code></h5>
<ul>
<li><code>sleep()</code> ：当前线程从 <code>Running</code> 运行状态 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span>  <code>Timed Waiting</code> 阻塞状态 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover><mo><mo>⟶</mo></mo><mrow><mi mathvariant="normal">一</mi><mi mathvariant="normal">段</mi><mi mathvariant="normal">时</mi><mi mathvariant="normal">间</mi></mrow></mover></mrow><annotation encoding="application/x-tex">\stackrel{一段时间}{\longrightarrow}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8220000000000001em;vertical-align:-0.011em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.811em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">⟶</span></span></span><span style="top:-3.7110000000000003em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">一</span><span class="mord cjk_fallback mtight">段</span><span class="mord cjk_fallback mtight">时</span><span class="mord cjk_fallback mtight">间</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span></span></span></span></span>   <code>Runnable</code> 就绪状态</li>
<li><code>yield()</code>：当前线程从 <code>Running</code> 运行状态 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span>   <code>Runnable</code> 就绪状态</li>
</ul>
<blockquote>
<p>个人理解：</p>
<p><code>sleep()</code> 更偏向于阻塞一段时间，之后等待 CPU 执行到它再进入就绪状态；而 <code>yield()</code> 是让出当前这一次执行，进入就绪状态，不影响下一次执行。</p>
</blockquote>
<h6 id="sleep-使线程阻塞"><a class="markdownIt-Anchor" href="#sleep-使线程阻塞"></a> <code>sleep()</code> 使线程阻塞</h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test5</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;t1开始sleep&quot;</span>);</span><br><span class="line">          Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">          System.out.println(<span class="string">&quot;t1结束sleep&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;t1被唤醒&quot;</span>);</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t1.strat();</span><br><span class="line">    </span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    System.out.println(t1.getState());</span><br><span class="line">    t1.interrupt(); <span class="comment">// 打断t1的sleep</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t1开始sleep</span><br><span class="line">t1: Timed Waiting</span><br><span class="line">t1被唤醒</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>调用 <code>sleep()</code> 会让当前线程从 <strong><code>Running</code> 进入 <code>Timed Waiting</code> 状态（阻塞）</strong>，可通过<code>state()</code>方法查看</p>
</li>
<li>
<p>其它线程可以使用 <strong><code>interrupt()</code></strong> 方法打断正在睡眠的线程，这时 <code>sleep()</code> 方法会抛出 <code>InterruptedException</code></p>
</li>
<li>
<p>睡眠结束后的线程未必会立刻得到回到 <code>Runnable</code> 状态</p>
</li>
<li>
<p>建议用 <strong><code>TimeUnit</code> 的 <code>sleep()</code></strong> 代替 Thread 的 <code>sleep()</code> 来获得更好的可读性 。如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//休眠一秒</span></span><br><span class="line">TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">Thread.sleep(<span class="number">1</span>*<span class="number">1000</span>);</span><br><span class="line"><span class="comment">//休眠一分钟</span></span><br><span class="line">TimeUnit.MINUTES.sleep(<span class="number">1</span>);</span><br><span class="line">Thread.sleep(<span class="number">1</span>*<span class="number">60</span>*<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h6 id="yield-让出当前线程"><a class="markdownIt-Anchor" href="#yield-让出当前线程"></a> <code>yield()</code> 让出当前线程</h6>
<ol>
<li>调用 <code>yield()</code> 会让当前线程从 <strong><code>Running</code> 运行状态进入 <code>Runnable</code> 就绪状态</strong>（仍然有可能被执行），然后调度执行其它线程</li>
<li><u>具体的实现</u>依赖于操作系统的【任务调度器】</li>
</ol>
<h6 id="线程优先级"><a class="markdownIt-Anchor" href="#线程优先级"></a> 线程优先级</h6>
<ul>
<li>
<p>线程优先级会提示（hint）调度器优先调度该线程，但它仅仅是一个提示，调度器可以忽略它</p>
</li>
<li>
<p>如果 CPU 比较忙，那么优先级高的线程会获得更多的时间片，但 CPU 闲时，优先级几乎没作用</p>
</li>
<li>
<p>设置方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">thread1.setPriority(Thread.MAX_PRIORITY); <span class="comment">//设置为优先级int(1~10)</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">Runnable</span> <span class="variable">task1</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;----&gt; task1&quot;</span> + count++);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="type">Runnable</span> <span class="variable">task2</span> <span class="operator">=</span> () -&gt; &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">      Thread.yield();</span><br><span class="line">      System.out.println(<span class="string">&quot;===== task2&quot;</span> + count++);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task1, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(task1, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  t1.start();</span><br><span class="line">  t2.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	输出结果应为 t1打印的count 远大于 t2打印的count</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<h5 id="233-join"><a class="markdownIt-Anchor" href="#233-join"></a> 2.3.3 <code>join()</code></h5>
<p>我们先分析如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test5</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;t1开始sleep&quot;</span>);</span><br><span class="line">          Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">          System.out.println(<span class="string">&quot;t1结束sleep&quot;</span>);</span><br><span class="line">          res = <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    t1.strat();</span><br><span class="line">    System.out.println(res);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure>
<p>由于两个线程的执行次序与执行时间（操作系统线程调度）并不确定，所以我们不能够确定 <code>res</code> 取值。我们可以用 <code>join()</code> 方法等待其他线程的结束。流程图如下</p>
<pre class="mermaid">graph TD
A1[main]--瞬间完成-->E1[r=0]
E1 --> B1[t1.join]
A1 --> C1[t1.start]
C1 --1s后---> D1[r=10]
D1 --t1结束--> B1
B1 --> R1[res: r=10]</pre>
<p><code>join()</code>的底层原理就是 <code>wait()</code>。</p>
<p>用于等待某个线程结束。哪个线程内调用 <code>join()</code> 方法，就等待哪个线程结束，然后再去执行其他线程。</p>
<p>如在主线程中调用 <code>ti.join()</code>，则是主线程等待 <code>t1</code> 线程结束。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>();</span><br><span class="line"><span class="comment">//等待thread线程执行结束</span></span><br><span class="line">thread.join();</span><br><span class="line"><span class="comment">//最多等待1000ms,如果1000ms内线程执行完毕，则会直接执行下面的语句，不会等够1000ms</span></span><br><span class="line">thread.join(<span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<h5 id="234-interrupt"><a class="markdownIt-Anchor" href="#234-interrupt"></a> 2.3.4 <code>interrupt()</code></h5>
<p>用于打断<u>阻塞</u> (<code>sleep()</code>、<code>wait()</code>、<code>join()</code> …) 以及<u>正常运行</u>的线程。 处于<strong>阻塞状态</strong>的线程，CPU 不会给其分配时间片。</p>
<ul>
<li>如果一个线程在在运行中被打断，打断标记会被置为 <code>true</code>。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test6</span> &#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;t1开始运行&quot;</span>);</span><br><span class="line">                <span class="keyword">while</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="built_in">this</span>.isInterrupted()) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        t1.interrupt(); <span class="comment">// 打断t1的sleep</span></span><br><span class="line">        System.out.println(<span class="string">&quot;t1的打断标记：&quot;</span> + t1.isInterrupted());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">t1开始运行</span><br><span class="line">t1的打断标记：true</span><br></pre></td></tr></table></figure>
<ul>
<li>如果是打断因<code>sleep(), wait(), join()</code>方法而被阻塞的线程，会将打断标记会被清空，置为 <code>false</code></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用于查看打断标记，返回值被boolean类型</span></span><br><span class="line">t1.isInterrupted();</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test6</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="string">&quot;t1&quot;</span>) &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;t1开始sleep&quot;</span>);</span><br><span class="line">          Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">          System.out.println(<span class="string">&quot;t1结束sleep&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;t1被打断&quot;</span>);</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    t1.strat();</span><br><span class="line">    </span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    t1.interrupt(); <span class="comment">// 打断t1的sleep</span></span><br><span class="line">    System.out.println(<span class="string">&quot;t1的打断标记：&quot;</span> + t1.isInterrupted());</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t1开始sleep</span><br><span class="line">t1被打断</span><br><span class="line">t1的打断标记：false</span><br></pre></td></tr></table></figure>
<p>正常运行的线程在被打断后，<strong>不会停止</strong>，会继续执行。如果要让线程在被打断后停下来，需要<strong>使用打断标记来判断</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throw</span> InterruptedException&#123;</span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span>(Thread.currentThread().isInterrupted()) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  t1.start();</span><br><span class="line">  </span><br><span class="line">  Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">  Log.debug(<span class="string">&quot;interrupted&quot;</span>);</span><br><span class="line">  t1.interrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="interrupt-的应用两阶段终止模式"><a class="markdownIt-Anchor" href="#interrupt-的应用两阶段终止模式"></a> <code>interrupt()</code> 的应用——两阶段终止模式</h6>
<p>当我们在执行线程一时，想要终止线程二，这是就需要使用 <code>interrupt()</code> 方法来<strong>优雅</strong>的停止线程二（料理后事: <u>释放锁和临界资源等</u>）。</p>
<p>【错误思路】</p>
<ul>
<li><code>stop()</code>：该方法会强制杀死线程，该方法虽然能在进程结束后立即释放锁对象，但是这种方法会破坏 <code>run()</code> 代码块的原子性（<code>synchronized</code> 保护其原子性），造成程序的逻辑错误（运行一半被突然恶意打断）。</li>
<li><code>suspend()</code>：暂停线程（挂起）和 <code>resume()</code>恢复线程，若线程对临界区资源上锁，则永远解锁，其他线程也无法获取锁。</li>
<li><code>System.exit(int)</code>：该方法会直接<strong>停止进程</strong>。</li>
</ul>
<p>【两阶段终止模式】</p>
<pre class="mermaid">graph TD

A["while(true)"]
B{是否被打断?}
C[料理后事]
D[睡眠2s]
E(结束循环)
F[执行监控记录]
G["设置打断标记 = true"]

A --> B
B --yes--> C
B --no--> D
C --> E
D --无异常--> F
D --有异常--> G
F --> A
G --> A</pre>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  两阶段终止模式（Two Phase Termination）：在进程T1中终止进程T2</span></span><br><span class="line"><span class="comment">    在终止进程T2之前让T2释放锁和临界资源</span></span><br><span class="line"><span class="comment">    不用stop() 和 System.exit()</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TwoPhaseTermination</span> &#123;</span><br><span class="line">    <span class="comment">// 监控线程</span></span><br><span class="line">    privite Thread monitor;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 启动监控线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">start</span><span class="params">()</span> &#123;</span><br><span class="line">        monitor = <span class="keyword">new</span> <span class="title class_">Thread</span> (() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">current</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                <span class="keyword">if</span> (current.isInterrupted()) &#123;</span><br><span class="line">                    <span class="comment">// TODO 释放锁和临界资源</span></span><br><span class="line">                    System.out.println(<span class="string">&quot;释放锁和临界资源&quot;</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                    <span class="comment">//TODO 正常功能的代码块</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                    <span class="comment">// 若sleep时被打断，会捕获错误e，此时的isInterrupted标记为false，程序会继续执行。所以有以下操作</span></span><br><span class="line">                    current.interrupt(); <span class="comment">// 重新设置isInterrupted打断标记, true -&gt; false</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        monitor.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 停止监控线程</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">stop</span><span class="params">()</span> &#123;</span><br><span class="line">        monitor.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="235-主线程与守护线程"><a class="markdownIt-Anchor" href="#235-主线程与守护线程"></a> 2.3.5 主线程与守护线程</h5>
<ul>
<li>
<p>主线程: 当 JAVA 进程中有多个线程在执行时，只有当所有非守护线程都执行完毕后，JAVA进程才会结束。</p>
</li>
<li>
<p>守护线程: <strong>但当非守护线程全部执行完毕后，守护线程无论是否执行完毕，也会一同结束。</strong>(垃圾回收线程)</p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将线程设置为守护线程, 默认为false</span></span><br><span class="line">Thread.setDaemon(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<h4 id="24-线程的状态"><a class="markdownIt-Anchor" href="#24-线程的状态"></a> 2.4 线程的状态</h4>
<h5 id="241-五种状态操作系统层面"><a class="markdownIt-Anchor" href="#241-五种状态操作系统层面"></a> 2.4.1 五种状态（操作系统层面）</h5>
<img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/20200608144606.png" alt="20200608144606" style="zoom:75%;">
<ol>
<li>【初始状态】：在<strong>语言层面创建了线程对象</strong>，但未与操作系统线程关联</li>
<li>【可运行状态】：（就需状态），已与操作系统线程关联，可由 cpu 调度执行</li>
<li>【运行状态】：获得 cpu 时间片，正在执行。
<ul>
<li>当 cpu 分配的时间片用完，由【运行状态】转为【可运行状态】，导致线程的上下文切换</li>
</ul>
</li>
<li>【阻塞状态】：该状态下的线程不会占用 cpu ，会导致线程的上下文切换
<ul>
<li>等阻塞操作结束，系统唤醒阻塞状态，切换至【可运行状态】</li>
</ul>
</li>
<li>【终止状态】：表示线程已经执行完毕，线程不会再转换成其他状态</li>
</ol>
<h5 id="242-六种状态java-api-层面"><a class="markdownIt-Anchor" href="#242-六种状态java-api-层面"></a> 2.4.2 六种状态（JAVA API 层面）</h5>
<img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/20200608144621.png" alt="20200608144621" style="zoom:75%;">
<p>详见<a href="#3.9-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2">第三章 3.9【线程状态转换】</a></p>
<ol>
<li>
<p>【<code>NEW</code>】：线程被创建，还没有调用<code>strat()</code>方法</p>
</li>
<li>
<p>【<code>RUNNABLE</code>】：调用了<code>start()</code>方法后。该状态涵盖了<strong>操作系统层面</strong>的*【可运行状态】、【运行状态】和【阻塞状态】*</p>
</li>
<li>
<p>三种“Java 中的阻塞状态”：后面会在状态转换一节详述。</p>
<p>(1) 【<code>BLOCKED</code>】：<code>synchronized</code> 等待获得锁时</p>
<p>(2)【<code>WAITING</code>】：<code>join()</code></p>
<p>(3)【<code>TIMED_WAITING</code>】：<code>sleep()</code></p>
</li>
<li>
<p>【<code>TERMINATED</code>】：代码运行结束</p>
</li>
</ol>
<h4 id="25-习题"><a class="markdownIt-Anchor" href="#25-习题"></a> 2.5 习题</h4>
<h5 id="251-统筹方法烧水泡茶"><a class="markdownIt-Anchor" href="#251-统筹方法烧水泡茶"></a> 2.5.1 统筹方法（烧水泡茶）</h5>
<p>阅读华罗庚《统筹方法》，给出烧水泡茶的多线程解决方案，提示：</p>
<ul>
<li>参考图二，用两个线程（两个人协作）模拟烧水泡茶过程
<ul>
<li>文中办法乙、丙都相当于任务串行</li>
<li>而图一相当于启动了 4 个线程，有点浪费</li>
</ul>
</li>
<li>用<code>sleep(n)</code>模拟洗茶壶、洗水壶等耗费的时间</li>
</ul>
<p>附：华罗庚《统筹方法》</p>
<hr>
<p>统筹方法，是一种安排工作进程的数学方法。它的实用范围极广泛，在企业管理和基本建设中，以及关系复杂的科研项目的组织与管理中，都可以应用。</p>
<p>怎样应用呢？主要是把工序安排好。</p>
<p>比如，想泡壶茶喝。当时的情况是：开水没有；水壶要洗，茶壶、茶杯要洗;火已生了，茶叶也有了。<br>
怎么办？</p>
<ul>
<li>办法甲：洗好水壶，灌上凉水，放在火上；在等待水开的时间里，洗茶壶、洗茶杯、 拿茶叶；等水开了，泡茶喝。</li>
<li>办法乙：先做好一些准备工作，洗水壶，洗茶壶茶杯，拿茶叶；一切就绪，灌水烧水；坐待水开了，泡茶喝。</li>
<li>办法丙：洗净水壶，灌上凉水，放在火上，坐待水开；水开了之后，急急忙忙找茶叶，洗茶壶茶杯，泡茶喝。</li>
</ul>
<p>哪一种办法省时间？我们能一眼看出，第一种办法好，后两种办法都窝了工。</p>
<p>这是小事，但这是引子，可以引出生产管理等方面有用的方法来。</p>
<p>水壶不洗，不能烧开水，因而洗水壶是烧开水的前提。没开水、没茶叶、不洗茶壶茶杯，就不能泡茶，因而这些又是泡茶的前提。它们的相互关系，可以用下图来表示：</p>
<pre class="mermaid">graph LR;
A[洗水壶 1min]--> B[烧开水 15mins];
B--> R[泡茶];
C[洗茶壶 1min]--> R;
D[洗茶杯 1min]--> R;
E[拿茶叶 1min]--> R;</pre>
<p>从这个图上可以一眼看出，办法甲总共要16分钟（而办法乙、丙需要20分钟）。如果要缩短工时．提高工作效率，应当主要抓烧开水这个环节，而不是抓拿茶叶等环节。同时，洗茶壶茶杯、拿茶叶总共不过3分钟，大可利用“等水开”的时间来做。</p>
<p>是的，这好像是废话，卑之无甚高论。有但稍有变化，临事而迷的情况，常常是存任的。在近代工业的错综夏杂的工艺过程中，往往就不是像泡茶喝这么简单了。任务多了，几百几千，甚至有好几万个任务。关系多了，错综复杂，千头万绪，往往出现 “万事俱备，只欠东风” 的情况。由于一两个零件没完成，耽误了一台复杂机器的出厂时间。或往往因为抓的不是关键，连夜三班，急急忙忙，完成这一环节之后，还得等待旁的环节才能装配。</p>
<p>洗茶壶，洗茶杯，拿茶叶，或先或后，关系不大，而且同是一个人的活儿，因币可以合并成为：</p>
<pre class="mermaid">graph LR;
A[洗水壶 1min]--> B[烧开水 15mins];
B--> R[泡茶];
C[洗茶壶, 洗茶杯, 拿茶叶 3mins]--> R;</pre>
<p>看来这是“小题大做”，但在工作环节太多的时候，这样做就非常必要了。</p>
<p>这里讲的主要是时间方面的事，但在具体生产实践中，还有其他方面的许多事。这种方法里然不一定能直接解决所有问题，但是，我们利用这种方法来考虑问题，也是不无裨益的。</p>
<hr>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">pubilc <span class="keyword">static</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    Log.debug(<span class="string">&quot;洗水壶&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    Log.debug(<span class="string">&quot;烧开水&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">15000</span>);</span><br><span class="line">  &#125;, <span class="string">&quot;小明&quot;</span>);</span><br><span class="line">    </span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    Log.debug(<span class="string">&quot;洗茶壶&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    Log.debug(<span class="string">&quot;洗茶杯&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    Log.debug(<span class="string">&quot;拿茶叶&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">     t1.join(); <span class="comment">// 由 小王 来泡茶 </span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="string">&quot;小王&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  t1.start();</span><br><span class="line">  t2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">19:19:37.547	[小明]	c.TestMakeTea -	洗茶壶</span><br><span class="line">19:19:37.547	[小王]	c.TestMakeTea - 洗水壶</span><br><span class="line">19:19:38.552	[小明]	c.TestMakeTea - 洗茶杯</span><br><span class="line">19:19:38.552	[小王]	c.TestMakeTea - 烧开水</span><br><span class="line">19:19:49.553	[小明]	c.TestMakeTea - 拿茶叶</span><br><span class="line">19:19:53.553	[小明]	c.TestMakeTea -	泡茶</span><br></pre></td></tr></table></figure>
<p>解法1的缺陷：</p>
<ul>
<li>上面模拟的是小明等小王的水烧开了，小明泡茶，如果反过来要实现小王等小明的茶叶拿来了，小王泡茶呢？代码最好能适应两种情况</li>
<li>上面的两个线程其实是各执行各的，如果要模拟小王把水壶交给小明泡茶，或模拟小明把茶叶交给小王泡茶</li>
</ul>
<h4 id="26-小结"><a class="markdownIt-Anchor" href="#26-小结"></a> 2.6 小结</h4>
<p>本章的重点在于掌握</p>
<ul>
<li>线程的四种创建方式：
<ol>
<li>使用构造器 <code>new Thread()</code>，重写其中的 <code>run()</code> 方法</li>
<li>重写 <code>Runnable</code> 接口的 <code>run()</code> 方法，再将其（任务）作为参数传入 <code>new Thread()</code>。线程和任务可以分离。</li>
<li>重写 <code>Callable</code> 接口的 <code>V call()</code> 方法，再将 <code>FutureTask&lt;&gt;(new Callable)</code> 任务作为参数传入 <code>new Thread()</code>。这样不仅可以实现线程和任务的分离，还可以返回线程的结果。</li>
<li>使用线程池。</li>
</ol>
</li>
<li>线程重要api， 如<code>start, run, sleep, join, interrupt</code>等</li>
<li>线程状态：操作系统的五种，Java 层面的六种</li>
<li>应用方面
<ul>
<li>异步调用：主线程执行期间，其它线程异步执行耗时操作</li>
<li>提高效率：并行计算，缩短运算时间</li>
<li>同步等待：<code>join</code></li>
<li>统筹规划：合理使用线程，得到最优效果</li>
</ul>
</li>
<li>原理方面
<ul>
<li>线程运行流程：栈、栈帧、上下文切换、程序计数器</li>
<li>Thread 三种创建方式的源码</li>
</ul>
</li>
<li>模式方面
<ul>
<li>两阶段终止</li>
</ul>
</li>
</ul>
<h3 id="3-共享模型之-monitor"><a class="markdownIt-Anchor" href="#3-共享模型之-monitor"></a> 3 共享模型之 <code>Monitor</code></h3>
<h4 id="31-共享带来的问题"><a class="markdownIt-Anchor" href="#31-共享带来的问题"></a> 3.1 共享带来的问题</h4>
<p>Java 代码中的体现</p>
<p>两个线程对初始值为 0 的全局静态变量。一个做自增操作， 一个做自减操作，各执行5000次， 最终的结果是0吗？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">5000</span>; i++)&#123;</span><br><span class="line">      counter++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i&lt;<span class="number">5000</span>; i++)&#123;</span><br><span class="line">      counter--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line">  </span><br><span class="line">  t1.start();</span><br><span class="line">  t2.start();</span><br><span class="line">  t1.join();</span><br><span class="line">  t2.join();</span><br><span class="line">  </span><br><span class="line">  Log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>, counter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试结果大概率不为 <code>0</code></p>
<pre class="mermaid">sequenceDiagram
    participant 线程1
    participant 线程2
    participant 静态变量 i
    
    静态变量 i ->> 线程2 :getstatic i 读取0
    线程2 ->> 线程2 :iconst_1 准备常数 1
    线程2 ->> 线程2 :isub 减法, 线程内 i= -1
    线程2 -x 静态变量 i :!!!还没来得及将i的结果写入
    线程2 -->> 线程1 :上下文切换
    线程1 ->> 线程1 :iconst_1 准备常数 1
    线程1 ->> 线程1 :iadd 加法, 线程内 i= 1
    线程1 ->> 静态变量 i :putstatic i 写入 1
    线程1 -->> 线程2 :上下文切换
    线程2 ->> 静态变量 i :putstatic i 写入 -1</pre>
<p>最终结果为 <code>-1</code>.</p>
<h5 id="311-临界区-critical-section"><a class="markdownIt-Anchor" href="#311-临界区-critical-section"></a> 3.1.1 临界区 Critical Section</h5>
<ul>
<li>一个程序运行多个线程本身是没有问题的</li>
<li>问题出在多个线程访问共享资源
<ul>
<li>多个线程读共享资源其实也没有问题</li>
<li>在多个线程对共享资源读写操作时发生指令交错，就会出现问题</li>
</ul>
</li>
<li>一段代码块内如果存在对共享资源的多线程读写操作，称这段代码块为<strong>临界区</strong></li>
</ul>
<p>例如，下面代码中的临界区</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>; <span class="comment">// 临界资源</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> </span><br><span class="line"><span class="comment">// 临界区 </span></span><br><span class="line">&#123;   </span><br><span class="line">    counter++; </span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> </span><br><span class="line"><span class="comment">// 临界区 </span></span><br><span class="line">&#123; </span><br><span class="line">    counter--; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="312-竞态条件-race-condition"><a class="markdownIt-Anchor" href="#312-竞态条件-race-condition"></a> 3.1.2 竞态条件 Race Condition</h5>
<p>多个线程在<strong>临界区</strong>内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了<strong>竞态条件</strong></p>
<h4 id="32-synchronized-解决方案"><a class="markdownIt-Anchor" href="#32-synchronized-解决方案"></a> 3.2 <code>Synchronized</code> 解决方案</h4>
<h5 id="321-解决手段"><a class="markdownIt-Anchor" href="#321-解决手段"></a> 3.2.1 解决手段</h5>
<p>为了避免临界区的竞态条件发生，有多种手段可以达到目的。</p>
<ul>
<li>【阻塞式】的解决方案：<code>synchronized</code>，<code>Lock</code></li>
<li>【非阻塞式】的解决方案：原子变量</li>
</ul>
<p>本次课使用阻塞式的解决方案：<strong>synchronized</strong>，来解决上述问题，即俗称的**【对象锁】**，它采用互斥的方式让同一 时刻至多只有一个线程能持有【对象锁】，其它线程再想获取这个【对象锁】时就会阻塞住(blocked)。这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心线程上下文切换。</p>
<h5 id="322-synchronized-语法"><a class="markdownIt-Anchor" href="#322-synchronized-语法"></a> 3.2.2 Synchronized 语法</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(Object) &#123; <span class="comment">// 例如, 当线程1持有锁时, 线程2被阻塞; 等待线程1释放锁</span></span><br><span class="line">		<span class="comment">//临界区</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>举例如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>; </span><br><span class="line"><span class="comment">//创建一个公共对象，作为对象锁的对象</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;    </span><br><span class="line">	<span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;            </span><br><span class="line">        <span class="keyword">synchronized</span> (room) &#123; <span class="comment">// 上锁</span></span><br><span class="line">        counter++;            </span><br><span class="line">       	 &#125;       </span><br><span class="line"> 	   &#125;    </span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;       </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;         </span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123; <span class="comment">// 上锁</span></span><br><span class="line">            counter--;          </span><br><span class="line">            &#125;    </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    t1.start();    </span><br><span class="line">    t2.start(); </span><br><span class="line">    t1.join();   </span><br><span class="line">    t2.join();    </span><br><span class="line">    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,counter); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序流程如下图:</p>
<pre class="mermaid">sequenceDiagram
    participant 线程1
    participant 线程2
    participant 静态变量 i
    participant 🔒锁对象
    
    线程2 ->> 🔒锁对象 :尝试获取锁
    Note over 🔒锁对象,线程2 :拥有锁
    静态变量 i ->> 线程2 :getstatic i 读取0
    线程2 ->> 线程2 :iconst_1 准备常数 1
    线程2 ->> 线程2 :isub 减法, 线程内 i= 0-1 = -1
    线程2 -->> 线程1 :上下文切换
    线程1 ->> 🔒锁对象 :尝试获取锁, 但是被阻塞(BLOCKED)
    线程1 -->> 线程2 :上下文切换
    线程2 ->> 静态变量 i :putstatic i 写入 -1
    Note over 🔒锁对象,线程2 :拥有锁
    线程2 ->> 🔒锁对象 :释放锁, 并唤醒阻塞的线程
    Note over 🔒锁对象,线程1 :拥有锁
    静态变量 i ->> 线程1 :getstatic i 读取-1
    线程1 ->> 线程1 :iconst_1 准备常数 1
    线程1 ->> 线程1 :iadd 加法, 线程内 i= -1+1 = 0
    线程1 ->> 静态变量 i :putstatic i 写入 0
    Note over 🔒锁对象,线程1 :拥有锁
    线程1 ->> 🔒锁对象 :释放锁, 并唤醒阻塞的线程</pre>
<p>【思考】</p>
<p><code>synchronized</code> 实际是用<strong>对象锁</strong>保证了<strong>临界区内代码的原子性</strong>，临界区内的代码对外是不可分割的，不会被线程切换所打断。</p>
<p>将上一个代码块的例子解耦，使其资源类和任务类分开:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Room</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> <span class="variable">counter</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">increment</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">      counter++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">decrement</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">      counter--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getCounter</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> counter;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">  <span class="type">Room</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Room</span>();</span><br><span class="line">	<span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;        </span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;            </span><br><span class="line">      room.increment();</span><br><span class="line"> 	   &#125;    </span><br><span class="line">    &#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;       </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5000</span>; i++) &#123;</span><br><span class="line">          room.decrement();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;, <span class="string">&quot;t2&quot;</span>);</span><br><span class="line"> </span><br><span class="line">    t1.start();    </span><br><span class="line">    t2.start(); </span><br><span class="line">    t1.join();   </span><br><span class="line">    t2.join();    </span><br><span class="line">    log.debug(<span class="string">&quot;&#123;&#125;&quot;</span>,room.getCounter()); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="323-synchronized-在方法上"><a class="markdownIt-Anchor" href="#323-synchronized-在方法上"></a> 3.2.3 <code>Synchronized</code> 在方法上</h5>
<p>我们必须知道， <strong><code>Synchronized</code> 锁住的始终是对象</strong>. 以下两个例子看似是与方法有关, 实则依然是为对象加锁.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// synchronized 加在成员方法上</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123; <span class="comment">// 锁住 this 对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// synchronized 加在静态方法上</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价于</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Test.class) &#123; <span class="comment">// 锁住 Test 类对象</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<ul>
<li><code>sleep()</code> 方法不会释放 <code>synchronized</code> 锁。</li>
</ul>
<h4 id="33-变量的线程安全分析"><a class="markdownIt-Anchor" href="#33-变量的线程安全分析"></a> 3.3 变量的线程安全分析</h4>
<h5 id="331-成员变量和静态变量的线程安全分析"><a class="markdownIt-Anchor" href="#331-成员变量和静态变量的线程安全分析"></a> 3.3.1 成员变量和静态变量的线程安全分析</h5>
<ul>
<li>如果没有变量<u>没有在线程间共享</u>，那么变量是<u>安全</u>的；</li>
<li>如果变量在线程间共享
<ul>
<li>如果只有<u>读操作</u>，则线程<u>安全</u>；</li>
<li>如果有<u>读写操作</u>，则这段代码是临界区，需要<u>考虑线程安全</u>。</li>
</ul>
</li>
</ul>
<h5 id="332-局部变量线程安全分析"><a class="markdownIt-Anchor" href="#332-局部变量线程安全分析"></a> 3.3.2 局部变量线程安全分析</h5>
<ul>
<li>
<p><u>局部变量被初始化</u>为【基本数据类型】是<strong>安全</strong>的；</p>
</li>
<li>
<p><u>局部变量<a target="_blank" rel="noopener" href="https://dave0126.github.io/2022/03/22/JVM-1/#1-3-%E4%BA%94%E7%A7%8D%E5%BC%95%E7%94%A8">引用的对象</a></u> 【未必】是安全的；</p>
<ul>
<li>如果局部变量引用的对象<u>没有引用线程共享的对象</u>，那么是<u>线程安全</u>的；</li>
<li>如果局部变量引用的对象<u>引用了一个线程共享的对象</u>，那么要<u>考虑线程安全</u>。</li>
</ul>
</li>
<li>
<p><u>局部变量是线程安全的</u>——每个方法都在对应线程的栈中创建栈帧，不会被其他线程共享。</p>
</li>
</ul>
<img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/20200608144636.png" alt="20200608144636" style="zoom:75%;">
<ul>
<li>如果局部变量引用的对象被共享，且执行了读写操作，则<strong>线程不安全</strong></li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassUnsafe</span> &#123;</span><br><span class="line">    ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(<span class="type">int</span> loopNumber)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;loopNumber; i++) &#123;</span><br><span class="line">            method2();</span><br><span class="line">            method3();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123;</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span> &#123;</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">ClassUnsafe</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassUnsafe</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">                test.method1(<span class="number">200</span>);</span><br><span class="line">            &#125;,<span class="string">&quot;thread &quot;</span>+i).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该程序的在运行过程中有可能会报错。因为多个线程会访问同一个 <code>ArrayList&lt;String&gt; list</code> 对象。</p>
<img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/20200608144649.png" alt="20200608144649" style="zoom:60%;">
<ul>
<li>如果是局部变量，则会在<a target="_blank" rel="noopener" href="https://dave0126.github.io/2022/03/22/JVM-1/#4-%E5%A0%86">堆</a>中创建对应的对象，不会存在线程安全问题。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ClassSafe</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">(<span class="type">int</span> loopNumber)</span> &#123;</span><br><span class="line">      ArrayList&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;loopNumber; i++) &#123;</span><br><span class="line">            method2(list);</span><br><span class="line">            method3(list);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">(ArrayList&lt;String&gt; list)</span> &#123;</span><br><span class="line">        list.add(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">(ArrayList&lt;String&gt; list)</span> &#123;</span><br><span class="line">        list.remove(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/20200608144702.png" alt="20200608144702" style="zoom:60%;">
<h5 id="333-常见线程安全类"><a class="markdownIt-Anchor" href="#333-常见线程安全类"></a> 3.3.3 常见线程安全类</h5>
<ul>
<li><code>String</code></li>
<li><code>Integer</code></li>
<li><code>StringBuffer</code></li>
<li><code>Random</code></li>
<li><code>Vector</code></li>
<li><code>Hashtable</code></li>
<li><code>java.util.concurrent</code> 包下的类</li>
</ul>
<p>这里说它们是线程安全的是指，<u>多个线程调用它们同一个实例的某个方法时，是线程安全的</u>。也可以理解为</p>
<ul>
<li>它们的每个方法是原子的</li>
<li>但多个方法组合在一起就不是原子的</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Hashtable</span> <span class="variable">table</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hashtable</span>();</span><br><span class="line"><span class="comment">// thread1, thread2</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"> 	<span class="keyword">if</span> (table.get(<span class="string">&quot;key&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">  	table.put(<span class="string">&quot;key&quot;</span>,value1)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line"> 	<span class="keyword">if</span> (table.get(<span class="string">&quot;key&quot;</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">  	table.put(<span class="string">&quot;key&quot;</span>,value2)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;).start();</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<pre class="mermaid">sequenceDiagram
    participant 线程1
    participant 线程2
    participant table
    
    table ->> 线程1 :get("key") == null
    table ->> 线程2 :get("key") == null
    线程2 ->> table :put("key", value2)
    线程1 ->> table :put("key", value1)</pre>
<h5 id="334-不可变类线程安全性"><a class="markdownIt-Anchor" href="#334-不可变类线程安全性"></a> 3.3.4 不可变类线程安全性</h5>
<p><code>String</code>、<code>Integer</code> 等都是<strong>不可变类</strong>，因为<u>其内部的属性不可以改变</u>，因此它们的方法都是线程安全的</p>
<blockquote>
<p><strong>思考:</strong></p>
<p><code>String</code> 有 <code>replace()</code>，<code>substring()</code> 等方法可以改变值，那么这些方法又是如何保证线程安全的呢？</p>
<p>这是因为这些方法的返回值都<u>创建了一个新的对象</u>，而不是直接改变 <code>String</code>、<code>Integer</code> 对象本身。</p>
</blockquote>
<h5 id="335-习题"><a class="markdownIt-Anchor" href="#335-习题"></a> 3.3.5 习题</h5>
<p>找出临界区代码，加锁</p>
<ul>
<li>买票：BiliBili - 黑马程序员全面深入学习Java并发编程，JUC并发编程全套教程 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV16J411h7Rd?p=71">买票问题</a></li>
<li>转账：BiliBili - 黑马程序员全面深入学习Java并发编程，JUC并发编程全套教程 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV16J411h7Rd?p=74">转账问题</a></li>
</ul>
<h4 id="34-monitor"><a class="markdownIt-Anchor" href="#34-monitor"></a> 3.4 <code>Monitor</code></h4>
<h5 id="340-java-对象头"><a class="markdownIt-Anchor" href="#340-java-对象头"></a> 3.4.0 Java 对象头</h5>
<blockquote>
<p>注意 ⚠️</p>
<p>个人认为，对于一个对象，当我们<u>通过</u>对象头信息的 【<code>Mark Word</code>】 <u>区分</u>（关于锁的）不同【对象类型】的时候，我们是通过【最后 <code>2 bits</code> 】来区分不同的锁信息的（<code>Normal</code> 和 <code>Biased</code> 则需要最后 <code>3 bits</code>，因为其后两位都为 <code>01</code>）。</p>
</blockquote>
<p>一个 Java 对象由【对象头】和【对象体】组成。以 <code>32 bits</code> 的虚拟机为例，</p>
<ul>
<li>
<p>普通对象：</p>
<img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/image-20220902142218758.png" alt="image-20220902142218758" style="zoom:70%;">
<ul>
<li>
<p>普通对象的 Java 对象头由 <code>Mark Word</code> 和 <code>Klass World</code> 组成，一共 <code>64 bits</code>；</p>
</li>
<li>
<p><code>Klass World</code>：用来表示该对象的类型（如 <code>String</code> 等），是一个指针，用来找到类对象；</p>
</li>
<li>
<p><code>Mark Word</code> 在不同对象类型下的结构如下：</p>
</li>
</ul>
<ol>
<li><code>Normal</code> 普通类型标记：<code>hashcode(25 bits)</code> 用来区分对象的哈希码；<code>age(4 bits)</code> GC 垃圾回收时的分代年龄；<code>biased_lock(1 bit)</code> 代表是否是偏向锁；最后 <code>2 bits</code> 代表该对象的加锁状态。</li>
<li><code>Biased</code> 偏向锁标记</li>
<li><code>Ligthweight Locked</code> 轻量级锁标记（最后 <code>2 bits : 0 0</code>）：<code>ptr_to_lock_record(30 bits)</code> 指向 <code>LockRecord</code> 锁记录对象的指针；最后 <code>2 bits</code> 代表该对象的加锁状态。</li>
<li><code>Heavyweight Locked</code> 重量级锁标记：<code>ptr_to_heavyweight_monitor(30 bits)</code> 指向 <code>Monitor</code> 的指针；最后 <code>2 bits</code> 代表该对象的加锁状态。</li>
<li><code>GC</code> 垃圾回收标记：如果该对象已经被 <code>GC</code> 垃圾回收了，则将最后 <code>2 bits</code> 置为 <code>11</code>。</li>
</ol>
  <img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/image-20220902142940973.png" alt="image-20220902142940973" style="zoom:70%;">
</li>
<li>
<p>数组对象：数组对象在普通对象 <code>(64 bits)</code> 的基础上增加了 <code>array length(32 bits)</code> 数组长度。</p>
</li>
</ul>
<img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/image-20220902142343013.png" alt="image-20220902142343013" style="zoom:70%;">
<h5 id="341-monitor-原理"><a class="markdownIt-Anchor" href="#341-monitor-原理"></a> 3.4.1 <code>Monitor</code> 原理</h5>
<blockquote>
<p><em><strong>2022.09.04</strong></em> 更新：<a target="_blank" rel="noopener" href="https://dave0126.github.io/2022/09/02/%E5%85%B3%E4%BA%8EObjectMonitor%E7%9A%84%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">关于 <code>ObjectMonitor</code> 的底层源码分析</a></p>
</blockquote>
<p><code>Monitor</code> 又称为监视器或<strong>管程</strong>,，<u>是 <code>synchronized</code> 实现的底层原理</u>, 由<u>【操作系统】提供</u></p>
<p>每个 Java 对象都可以关联一个 <code>Monitor</code> 对象：如果使用 <code>synchronized</code> 关键字给对象上锁（重量级）之后，该对象与 <code>Monitor</code> 关联。其中</p>
<ul>
<li>【上锁】的字节码表示是 <code>monitorenter</code>，将该对象的对象头中的 <code>Mark Word</code> 的前 <code>30 bits</code> 设置为为指向 <code>Monitor</code> 的指针；</li>
<li>【解锁】的字节码表示是 <code>monitorexit</code>，将该 <code>Owner</code> 置为 <code>null</code>，唤醒 <code>EntryList</code> 里等待的线程。</li>
</ul>
<p><img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/20200608144917.png" alt="20200608144917"></p>
<ul>
<li>刚开始时， <code>Monitor</code> 的 <code>Owner</code> 为空</li>
<li>当线程执行到临界区代码时，如果使用了 <code>synchronized</code>，会先查询 <code>synchronized</code> 中所指定的对象（<code>obj</code>）<strong>是否关联了 <code>Monitor</code></strong>
<ul>
<li>如果<strong>没有关联</strong>，则会先去去与 <code>Monitor</code> 关联，并且将 <code>Owner</code> 设为当前线程。</li>
<li>如果已经关联，则会去查询该 <code>Monitor</code> 是否已经有了 <code>Owner</code>
<ul>
<li>如果没有，则 <code>Owner</code> 与将当前线程绑定</li>
<li>如果有，则放入 <code>EntryList</code>，进入阻塞状态（<code>blocked</code>）</li>
</ul>
</li>
</ul>
</li>
<li>当 <code>Monitor</code> 的 <code>Owner</code> 将临界区中代码执行完毕后，<code>Owner</code> 便会被清空，此时 <code>EntryList</code> 中处于<strong>阻塞</strong>状态的线程会被<strong>叫醒并竞争</strong>，此时的竞争是**【非公平的】**</li>
</ul>
<blockquote>
<p><strong>注意</strong> ⚠️：</p>
<ul>
<li>对象在使用了 <code>synchronized</code> 后与 <code>Monitor</code> 绑定时，会将对象头中的 <code>Mark Word</code> 的前 <code>30 bits</code> 设置为为指向 <code>Monitor</code> 的指针。</li>
<li>每个对象都会绑定一个【唯一】的 <code>Monitor</code>，如果 <code>synchronized</code> 中所指定的对象（<code>obj</code>）不同，则会绑定不同的 <code>Monitor</code>。</li>
</ul>
</blockquote>
<h5 id="342-轻量级锁"><a class="markdownIt-Anchor" href="#342-轻量级锁"></a> 3.4.2 轻量级锁</h5>
<blockquote>
<p>我们之前已经知道，由 <code>synchronized</code> 关键字加锁的对象底层是通过 <code>monitor</code> 这种【重量级锁】实现的。那么当我们为了保证一个对象可以被互斥地访问而采取了 <code>synchronized</code>，但是这个对象在运行中不存在不同线程间竞争的关系。JVM 为此提供了一套对于 <code>synchronized</code> 的优化机制，以减小每次使用重量级锁的系统开销。</p>
</blockquote>
<blockquote>
<p>注意 ⚠️</p>
<p>个人认为，轻量级锁并<u>不是一种【实体的锁】</u>，而是一系列通过算法调度，优化 <code>Monitor</code> 的系统开销的”策略“。为了与 <code>Monitor</code> 这种重量级锁对应，我们才称其为轻量级锁。</p>
</blockquote>
<p>【使用场景】当一个对象被多个线程所访问，但访问的时间是错开的（不存在竞争），此时就可以使用轻量级锁来优化。</p>
<p>因为重量级锁由操作系统提供，使用时系统开销较大，所以在使用 <code>synchronized</code> 时【优先】使用轻量级锁。轻量级锁对使用者是透明的，即语法依然是 【<code>synchronized</code>】， 优先使用轻量级锁，如若失败则改用其他类型。</p>
<p>（1）每次想要访问<code>Object</code> 时，都会创建<strong>锁记录</strong> <code>Lock Record</code>对象。每个线程的栈帧都会包含一个锁记录对象，内部可以存储锁定对象的 <code>Mark Word</code>（不再一开始就使用 <code>Monitor</code>）；</p>
<img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/20200608144942.png" alt="20200608144942" style="zoom:75%;">
<p>（2）让锁记录中的 <code>Object reference</code> 指向锁对象 <code>Object</code>，并尝试用 <code>cas</code>去替换 <code>Object</code> 中的 <code>Mark Word</code>，将此 <code>Mark Word</code> 放入 <code>lock record</code> 中保存；</p>
<blockquote>
<p>这里提到的 <code>cas</code> 在后面的章节会详细介绍，这里只需了解 <code>cas</code> 操作目的是<u>为了交换【对象头】的 <code>Mark Word</code> 与线程栈中【锁记录】的【地址 + 锁类型】信息</u>。该操作是<u>原子性</u>的。</p>
</blockquote>
<img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/20200608144950.png" alt="20200608144950" style="zoom:75%;">
<p>（3）如果 <code>cas</code> 替换成功，则将 <code>Object</code> 的<u>***对象头的 <code>Mark Word</code>***</u>替换为<u>锁记录的地址和状态 <code>00</code>（轻量级锁状态）</u>，表示由该线程给对象加锁</p>
<img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/20200608144957.png" alt="20200608144957" style="zoom:75%;">
<p>（4）当一个【线程】想要访问一个加锁 【<code>Object</code> 】对象时，该线程会检查对象头 <u><code>Mark Word</code> 的最后 <code>2 bits</code></u> 是不是 <u><code>01</code></u>。若是，则为【步骤（3）】中的正常加锁流程；若是  <u><code>00</code></u>，则说明<u>已经有线程持有了该 <code>Object</code> 的轻量级锁</u>， <code>cas</code> 失败。以下根据<u>线程的不同</u>，分为<u>两种情况</u>讨论：</p>
<ul>
<li>如果是【其他线程】已经持有了该 <code>Object</code> 的轻量级锁，即对象头中的【锁记录地址】不指向本线程。这时表明有竞争，进入下一小节的【<a href>锁膨胀</a>】过程</li>
<li>如果是【本线程】已经持有了该 <code>Object</code> 的轻量级锁，也即加锁 <code>Object</code> 对象头中的锁记录地址指向本线程。当再一次使用这个加锁的 <code>Object</code> 时，新创建一个为<u>地址与状态码为 <code>null</code>的【锁记录】</u>。此时我们称执行了 <code>synchronized</code> 【锁重入】，而<u>【锁记录】的个数</u>就是该线程<u>对 <code>Object</code> 加锁的次数</u>。</li>
</ul>
<img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/image-20220326175731138-8313862.png" alt="image-20220326175731138" style="zoom:75%;">
<p>（5）当退出 <code>synchronized</code> 【解锁】时，如果<u>有取值为 <code>null</code> 的锁记录</u>，表示有锁重入。这时清除这个记录，表示【重入计数 -1】</p>
<img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/20200608144957.png" alt="20200608144957" style="zoom:75%;">
<p>（6）当退出 <code>synchronized</code> 【解锁】<u>锁记录的值不为 <code>null</code></u> 时，这时使用 <code>cas</code> 将 <code>Mark Word</code> 的值恢复给对象头：</p>
<ul>
<li>成功，则解锁成功；</li>
<li>失败，说明轻量级锁进行了【锁膨胀】或者已经升级为【重量级锁】，进入重量级锁解锁流程。</li>
</ul>
<h5 id="343-锁膨胀"><a class="markdownIt-Anchor" href="#343-锁膨胀"></a> 3.4.3 锁膨胀</h5>
<blockquote>
<p>锁膨胀：轻量级锁 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover><mo><mo>⟶</mo></mo><mrow><mi mathvariant="normal">升</mi><mi mathvariant="normal">级</mi></mrow></mover></mrow><annotation encoding="application/x-tex">\stackrel{升级}{\longrightarrow}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8220000000000001em;vertical-align:-0.011em;"></span><span class="mrel"><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.811em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span><span class="mop">⟶</span></span></span><span style="top:-3.7110000000000003em;margin-left:0em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord cjk_fallback mtight">升</span><span class="mord cjk_fallback mtight">级</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.011em;"><span></span></span></span></span></span></span></span></span></span> 重量级锁的过程。</p>
</blockquote>
<p>（1）如果一个线程在给一个对象加轻量级锁时，<u><code>cas</code> 替换操作失败</u>（因为此时其他线程已经给对象加了轻量级锁，<u><code>Mark Word</code> 的最后 <code>2 bits</code></u> 是 <u><code>00</code></u>），此时该线程就会进入【锁膨胀】过程：</p>
<img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/20200608145004.png" alt="20200608145004" style="zoom:75%;">
<p>（2）此时便会给对象加上【重量级锁】（<code>Monitor</code>）：</p>
<p>将对象头的 <code>Mark Word</code> 改为 <u><code>Monitor</code> 的地址</u>，并且状态改为 <u><code>10</code></u>，进入【阻塞状态】</p>
<img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/20200608145148.png" alt="20200608145148" style="zoom:75%;">
<p>（3）当 <code>Thread-0</code> 解锁时，想使用 <code>cas</code> 将 <code>Mark Word</code> 的值恢复给对象头，而此时的对象头里存放着 <code>Monitor</code>  的地址和状态码 <code>10</code>。<code>cas</code> 失败。这时会进入重量级解锁流程，即按照 <code>Monitor</code> 地址找到 <code>Monitor</code> 对象，设置<code>Owner</code> 为 <code>null</code>，唤醒 <code>EntryList</code> 中阻塞等待的线程。</p>
<h5 id="344-自旋优化"><a class="markdownIt-Anchor" href="#344-自旋优化"></a> 3.4.4 自旋优化</h5>
<p><strong>重量级锁</strong>竞争时，还可以使用自旋来优化(在多核心 cpu 中才有意义)，如果当前线程在<strong>自旋成功</strong>（使用锁的线程退出了同步块，<strong>释放了锁</strong>，即当前线程可以直接成为新的 <code>Owner</code>），这时就可以避免线程进入阻塞状态。</p>
<h6 id="自旋成功的情况"><a class="markdownIt-Anchor" href="#自旋成功的情况"></a> 自旋成功的情况</h6>
<pre class="mermaid">sequenceDiagram
    participant t1 as 线程1(CPU 0)
    participant obj as synchronized(Object)
    participant t2 as 线程2(CPU 1)
    
    Note over obj :状态码 01 (无锁)
    t1 ->> +obj :访问同步块， 获取 Monitor
    t1 ->> obj :成功加锁
    Note over obj :重量级锁指针 ｜状态码 10 (重量级锁)
    t2 -x obj :❌ 访问同步块， 获取 Monitor
    t2 ->> t2 :自旋重试
    Note over t1 :执行临界区代码块
    t2 ->> t2 :自旋重试
    obj ->> -t1 :成功解锁
    Note over obj :状态码 01 (无锁)
    t2 ->> +obj :成功加锁
    Note over obj :重量级锁指针 ｜状态码 10 (重量级锁)
    Note over t2 :执行临界区代码块
    obj ->> -t2 : 成功解锁</pre>
<h6 id="自旋重试失败的情况"><a class="markdownIt-Anchor" href="#自旋重试失败的情况"></a> 自旋重试失败的情况</h6>
<pre class="mermaid">sequenceDiagram
    participant t1 as 线程1(CPU 0)
    participant obj as synchronized(Object)
    participant t2 as 线程2(CPU 1)
    
    Note over obj :状态码 01 (无锁)
    t1 ->> +obj :访问同步块， 获取 Monitor
    t1 ->> obj :成功加锁
    Note over obj :重量级锁指针 ｜状态码 10 (重量级锁)
    t2 -x obj :❌ 访问同步块， 获取 Monitor
    t2 ->> t2 :自旋重试
    Note over t1 :执行临界区代码块
    t2 ->> t2 :自旋重试
    t2 ->> t2 :自旋重试
    t2 ->> t2 :自旋重试
    Note over t2 :阻塞
    obj ->> -t1 :成功解锁
    Note over obj :状态码 01 (无锁)</pre>
<blockquote>
<p>由以上两个流程我们可以看到，可以设置【线程自旋重试的次数】来控制该线程是否要阻塞。在 JDK 1.6 之后版本的次数时自适应的。在<u>单 CPU 下的自旋重试没有意义</u>。</p>
</blockquote>
<h5 id="345-偏向锁"><a class="markdownIt-Anchor" href="#345-偏向锁"></a> 3.4.5 偏向锁</h5>
<blockquote>
<p>注意 ⚠️</p>
<p>个人理解，对于一个类的对象的偏向锁，<u>是对于一个【类本身】的偏向</u>，而<u>不是对于【类的对象】的偏向</u>，一个类只能有一个偏向锁。</p>
</blockquote>
<p>轻量级锁在没有竞争时，每次<u>【锁重入】</u>（该线程执行的方法中再次锁住该对象）<u>操作仍需要 <code>cas</code> 替换操作</u>，这样是会使<u>性能降低</u>的。那么我们能不能减少 <code>cas</code> 操作呢？</p>
<p>所以引入了【偏向锁】对性能进行优化：在【第一次 <code>cas</code>】时会将【线程的 <code>ID</code>】写入对象的 <code>Mark Word</code>中。此后发现这个线程 <code>ID</code> 就是自己的，就表示没有竞争，就不需要再次 <code>cas</code>；以后只要不发生竞争，这个对象就归该线程所有。</p>
<blockquote>
<p>相当于在临界资源上刻上进程的名字， 该【资源】归【此进程】所有</p>
</blockquote>
<h6 id="偏向状态"><a class="markdownIt-Anchor" href="#偏向状态"></a> 偏向状态</h6>
<p><code>Mark Word</code> 在不同对象类型下的结构如下：</p>
<img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/image-20220902142940973.png" alt="image-20220902142940973" style="zoom:70%;">
<ol>
<li><code>Normal</code> 普通类型标记（最后 <code>3 bits : 0 0 1</code>）：
<ul>
<li><code>hashcode(25 bits)</code> 用来区分对象的哈希码；</li>
<li><code>age(4 bits)</code> GC 垃圾回收时的分代年龄；</li>
<li><code>biased_lock(1 bit)</code> 代表是否是偏向锁；</li>
<li>最后 <code>2 bits</code> 代表该对象的加锁状态。</li>
</ul>
</li>
<li><code>Biased</code> 偏向锁标记（最后 <code>3 bits : 1 0 1</code>）：
<ul>
<li><code>thread(23 bits)</code> 用来存储获得偏向锁的（操作系统层面的）线程 <code>ID</code>；</li>
<li><code>epoch(2 bits)</code> 批量重偏向与批量撤销时用到；</li>
<li><code>age(4 bits)</code> GC 垃圾回收时的分代年龄；</li>
<li><code>biased_lock(1 bit)</code> 代表是否是偏向锁；</li>
<li>最后 <code>2 bits</code> 代表该对象的加锁状态。</li>
</ul>
</li>
<li><code>Ligthweight Locked</code> 轻量级锁标记（最后 <code>2 bits : 0 0</code>）：<code>ptr_to_lock_record(30 bits)</code> 指向 <code>LockRecord</code> 锁记录对象的指针；最后 <code>2 bits</code> 代表该对象的加锁状态。</li>
<li><code>Heavyweight Locked</code> 重量级锁标记（最后 <code>2 bits : 1 0</code>）：<code>ptr_to_heavyweight_monitor(30 bits)</code> 指向 <code>Monitor</code> 的指针；最后 <code>2 bits</code> 代表该对象的加锁状态。</li>
<li><code>GC</code> 垃圾回收标记（最后 <code>2 bits : 1 1</code>）：如果该对象已经被 <code>GC</code> 垃圾回收了，则将最后 <code>2 bits</code> 置为 <code>11</code>。</li>
</ol>
<blockquote>
<p>TIPS :</p>
<ul>
<li>如果开启了偏向锁（默认开启），在创建对象时，对象的 <code>Mark Word</code> 后三位应该是 <code>1 0 1</code>；</li>
<li>但是偏向锁默认是<strong>有延迟</strong>的，不会再程序一启动就生效，而是会在程序运行一段时间（几秒之后），才会对创建的对象设置为偏向状态。可以使用<code>-XX:BiasedLockingStartupDelay=0</code> 来禁用延迟；</li>
<li>如果没有开启偏向锁，对象的 <code>Mark Word</code> 后三位应该是 <code>0 0 1</code>。</li>
</ul>
</blockquote>
<h6 id="撤销偏向"><a class="markdownIt-Anchor" href="#撤销偏向"></a> 撤销偏向</h6>
<p>以下几种情况会使对象的偏向锁失效</p>
<ul>
<li>调用对象的 <code>hashCode()</code>方法时才会产生哈希码，本来用来<u>存储偏向锁的【线程 <code>ID</code>】的空间</u>就要用来<u>存【哈希码】</u>，所以偏向锁就失效了；</li>
<li>【无竞争】的多个线程使用该对象（升级为【轻量级锁】），因为违背了偏向锁【只有一个线程使用该对象】的本意；</li>
<li>调用了 <code>wait() / notify()</code> 方法（调用 <code>wait()</code> 方法会导致锁膨胀而使用【重量级锁】）</li>
</ul>
<h6 id="批量重偏向"><a class="markdownIt-Anchor" href="#批量重偏向"></a> 批量重偏向</h6>
<p>如果对象虽然被多个线程访问，但是线程间不存在竞争，这时偏向 <code>thread-1</code> 的对象仍有机会重新偏向 <code>thread-2</code>。重偏向会重置 <code>Thread ID</code>。</p>
<p>当对同一个加锁对象（而不是对象的实例）撤销重偏向超过<u>超过阈值</u>时，JVM 会觉得是不是偏向错了，此后再给对象加锁时，JVM 会将该对象重新偏向至该线程。</p>
<h6 id="批量撤销"><a class="markdownIt-Anchor" href="#批量撤销"></a> 批量撤销</h6>
<p>当撤销偏向锁的操作<u>超过阈值</u>以后，就会将<strong>整个类的对象都改为不可偏向的</strong></p>
<p>【图解】</p>
<p>![截屏2022-09-02 19.29.43](2022-03-23-JUC-Java多线程-1/image-2022-09-02 19.29.43.png)</p>
<h4 id="35-wait-notify"><a class="markdownIt-Anchor" href="#35-wait-notify"></a> 3.5 <code>Wait() / Notify()</code></h4>
<img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/20200608144917.png" alt="20200608144917" style="zoom:75%;">
<ul>
<li>
<p><code>Owner</code> 线程发现执行条件不满足，锁对象调用 <code>wait()</code>方法（<code>obj.wait()</code>），就会使当前线程进入 <code>WaitSet</code> 中，变为 <code>WAITING / TIMEWAITING</code> 状态。</p>
</li>
<li>
<p>处于 <code>BLOCKED</code> 和 <code>WAITING</code> 状态的线程都为阻塞</p>
<p>状态，CPU都不会分给他们时间片。但是有所区别：</p>
<ul>
<li>*<em><code>BLOCKED</code> 状态的线程是在</em><u>竞争锁对象</u>时，发现 <code>Monitor</code> 的 <code>Owner</code> 已经是别的线程了，此时就会进入 <code>EntryList</code> 中，并处于 <code>BLOCKED</code> 状态</li>
<li>*<em><code>WAITING</code>状态的线程是</em><u>获得了对象的锁</u>，但是自身因为某些原因需要进入阻塞状态时，锁对象调用了<code>wait()</code> 方法而进入了 <code>WaitSet</code> 中，处于 <code>WAITING</code> 状态</li>
</ul>
</li>
<li>
<p><code>BLOCKED</code> 状态的线程会在锁被释放的时候被唤醒，但是处于 <code>WAITING</code> 状态的线程只有被锁对象调用了<code>notify()</code> 或 <code>notifyAll()</code>方法，才会被唤醒。</p>
</li>
</ul>
<h5 id="351-api介绍"><a class="markdownIt-Anchor" href="#351-api介绍"></a> 3.5.1 API介绍</h5>
<ol>
<li><code>obj.wait()</code>：让进入 <code>Monitor</code> 的线程到 <code>waitSet</code> 等待</li>
<li><code>obj.wait(long timeout)</code> 让进入<code>Monitor</code> 的线程到 <code>waitSet</code> <strong>等待 <code>timeout</code>时间长度</strong>，继续执行</li>
<li><code>obj.notify()</code>：在 <code>Monitor</code> 上正在 <code>waitSet</code> 等待的线程中**【挑一个】**唤醒（虽然在 JVM 层面被描述<u>成随机唤醒</u>一个 <code>WaitSet</code> 中的线程，但是在源码实现方面，实际上仍然是唤醒第一个（先进先出））</li>
<li><code>obj.notifyAll()</code>：在<code>Monitor</code> 上正在 <code>waitSet</code> 等待的线程**【全部】**唤醒</li>
</ol>
<p>注意⚠️：他们都是线程之间进行协作的手段，都属于 <code>Monitor</code>对象的方法。<strong>必须获得此对象的锁</strong>，才能调用这几个方法。<strong>只有当对象被锁以后，才能调用 <code>wait()</code> 和 <code>notify()</code> 方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span> ();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span> (() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.wait(); <span class="comment">// 把线程t1放在lock的WaitSet中，空出Monitor的Owner</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span> (() -&gt; &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                lock.wait(); <span class="comment">// 把线程t2放在lock的WaitSet中，空出Monitor的Owner</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,<span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">    Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (lock) &#123; <span class="comment">// 主线程</span></span><br><span class="line">        lock.notify(); <span class="comment">// 随机唤醒一个</span></span><br><span class="line">        lock.notifyAll(); <span class="comment">// 唤醒所有</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="352-wait-和-sleep-的区别"><a class="markdownIt-Anchor" href="#352-wait-和-sleep-的区别"></a> 3.5.2 <code>wait()</code> 和 <code>sleep()</code> 的区别</h5>
<ul>
<li>
<p>不同点：</p>
<ol>
<li>从 API 角度：<code>sleep()</code> 是 <u>Thread 的静态方法</u>，<code>wait()</code> 是所有<u>对象（Object）的方法</u></li>
<li><code>sleep()</code> 【不用】与 <code>synchronized</code> 一起用，<code>wait()</code> 【需要】与 <code>synchronized</code> 一起用</li>
<li><code>sleep()</code> <u>不会释放锁</u>，<code>wait()</code> 在等待时<u>会释放锁</u></li>
</ol>
</li>
<li>
<p>相同点：</p>
<ol>
<li>进入的线程状态都是 <code>TIMED_WAITING</code></li>
</ol>
</li>
</ul>
<p>为了解决 <code>wait()</code> 的虚假唤醒（因为 <code>WaitSet</code> 中有多个线程，我们<u>无法精确指定唤醒哪个线程</u>，所以我们<u>使用 <code>lock.notifyAll()</code> 唤醒所有线程</u>。而因为我们唤醒了所有 <code>WaitSet</code> 中的线程，其他线程应该被重新 <code>wait()</code> 在  <code>WaitSet</code> 中，所以我们使用 <code>while</code> 重复执行 <code>wait()</code>），代码结构如下：<code>while</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">   <span class="keyword">while</span> (条件不成立) &#123;</span><br><span class="line">       lock.wait();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一个线程</span></span><br><span class="line"><span class="keyword">synchronized</span> (lock)&#123;</span><br><span class="line">    lock.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestCorrectPosture&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCorrectPostureStep4</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasCigarette</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasTakeout</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">                <span class="keyword">while</span> (!hasCigarette) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        room.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">                <span class="keyword">if</span> (hasCigarette) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没干成活...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                <span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">                log.debug(<span class="string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);</span><br><span class="line">                <span class="keyword">while</span> (!hasTakeout) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没外卖，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        room.wait();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);</span><br><span class="line">                <span class="keyword">if</span> (hasTakeout) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没干成活...&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小女&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (room) &#123;</span><br><span class="line">                hasTakeout = <span class="literal">true</span>;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖到了噢！&quot;</span>);</span><br><span class="line">                room.notifyAll();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;送外卖的&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="36-同步模式-之-保护性暂停"><a class="markdownIt-Anchor" href="#36-同步模式-之-保护性暂停"></a> 3.6 同步模式 之 保护性暂停</h4>
<p>即 Guarded Suspension，用于一个线程等待另一个线程的执行结果时。如下图。</p>
<img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/image-20220904170554996.png" alt="image-20220904170554996" style="zoom:45%;">
<p>要点：</p>
<ul>
<li>有<u>一个结果</u>想从<u>一个线程传递到另一个线程</u>，可以让他们关联同一个 【<code>GuardedObject</code>】</li>
<li>如果<u>有结果不断的从一个结果到另一个结果</u>，那么可以使用**【消息队列】**（见消费者/生产者）</li>
<li>JDK 中，<code>join()</code>的实现、<code>future</code> 的实现，采用的就是该模式</li>
<li>因为要等待另一方的结果，因此归类到同步模式</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">hello</span> <span class="operator">=</span> <span class="string">&quot;hello thread!&quot;</span>;</span><br><span class="line">		<span class="type">Guarded</span> <span class="variable">guarded</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Guarded</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// thread 1</span></span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;想要得到结果&quot;</span>);</span><br><span class="line">			<span class="keyword">synchronized</span> (guarded) &#123;</span><br><span class="line">				System.out.println(<span class="string">&quot;结果是：&quot;</span>+ guarded.getResponse());</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">&quot;得到结果&quot;</span>);</span><br><span class="line">		&#125;).start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//thread 2</span></span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;设置结果&quot;</span>);</span><br><span class="line">			<span class="keyword">synchronized</span> (guarded) &#123;</span><br><span class="line">				guarded.setResponse(hello);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Guarded</span> &#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	 * 要返回的结果</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">private</span> Object response;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//优雅地使用wait/notify</span></span><br><span class="line">	<span class="keyword">public</span> Object <span class="title function_">getResponse</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="comment">//如果返回结果为空就一直等待，避免虚假唤醒</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">			<span class="keyword">while</span>(response == <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					<span class="built_in">this</span>.wait();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> response;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setResponse</span><span class="params">(Object response)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.response = response;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">			<span class="comment">//唤醒休眠的线程</span></span><br><span class="line">			<span class="built_in">this</span>.notifyAll();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="string">&quot;Guarded&#123;&quot;</span> +</span><br><span class="line">				<span class="string">&quot;response=&quot;</span> + response +</span><br><span class="line">				<span class="string">&#x27;&#125;&#x27;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>带超时判断的暂停</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 修改上面代码块中的 getResponse() 方法</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">getResponse</span><span class="params">(<span class="type">long</span> time)</span> &#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">			<span class="comment">//获取开始时间</span></span><br><span class="line">			<span class="type">long</span> <span class="variable">currentTime</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">			<span class="comment">//用于保存已经等待了的时间</span></span><br><span class="line">			<span class="type">long</span> <span class="variable">passedTime</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">while</span>(response == <span class="literal">null</span>) &#123;</span><br><span class="line">				<span class="comment">//看经过的时间-开始时间是否超过了指定时间</span></span><br><span class="line">				<span class="type">long</span> <span class="variable">waitTime</span> <span class="operator">=</span> time -passedTime;</span><br><span class="line">				<span class="keyword">if</span>(waitTime &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">                   	<span class="comment">//等待剩余时间</span></span><br><span class="line">					<span class="built_in">this</span>.wait(waitTime);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">//获取当前时间</span></span><br><span class="line">				passedTime = System.currentTimeMillis()-currentTime		</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> response;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h5 id="361-join-的原理"><a class="markdownIt-Anchor" href="#361-join-的原理"></a> 3.6.1 <code>join()</code> 的原理</h5>
<p><code>join()</code> 的原理：使用保护性暂停模式。一个线程等待另一个线程的结束。源码如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">join</span><span class="params">(<span class="type">long</span> millis)</span></span><br><span class="line">    <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">        <span class="type">long</span> <span class="variable">now</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123; <span class="comment">// 检查 等待时间 millis 是否符合要求</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;timeout value is negative&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123; </span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123; <span class="comment">// 如果该线程存活，则 wait(0) : 一直等下去</span></span><br><span class="line">                wait(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">delay</span> <span class="operator">=</span> millis - now;</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay);</span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="362-扩展-future-的原理"><a class="markdownIt-Anchor" href="#362-扩展-future-的原理"></a> 3.6.2 扩展 - <code>Future</code> 的原理</h5>
<p>图中的 <code>Future</code> 就好比居民楼的信箱（每个信箱都有自己的编号），左边的 <code>t0</code>，<code>t2</code>，<code>t4</code> 就好比等待邮件的居民，右侧的 <code>t1</code>，<code>t3</code>，<code>t5</code> 就好比邮递员。</p>
<p>如果需要再多个类之间使用 <code>GuardedObject</code> 对象，作为参数传递不是很方便，因此设计一个用来<u>解耦的中间类</u>，这样不仅可以解耦【结果等待者】和【结果生产者】，还能够同时支持多个任务的处理。</p>
<img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/image-20220327202425832-8405470.png" alt="image-20220327202425832" style="zoom:67%;">
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GuardedObject</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">GuardedObject</span> <span class="params">(<span class="type">int</span> id)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Future</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, GuardedObject&gt; map = <span class="keyword">new</span> <span class="title class_">HashTable</span>&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="title function_">generateId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> id++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GuardedObject <span class="title function_">createGuardedObject</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">GuardedObject</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">GuardedObject</span>(generateId());</span><br><span class="line">        map.put(obj.getId(), obj);</span><br><span class="line">        <span class="keyword">return</span> obj;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Set&lt;Integer&gt; <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.keySet();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> GuardedObject <span class="title function_">getGuardedObject</span> <span class="params">(<span class="type">int</span> id)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> map.remove(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span> (() -&gt; &#123;</span><br><span class="line">            <span class="type">GuardedObject</span> <span class="variable">guardedObject</span> <span class="operator">=</span> Future.createGuardedObject();</span><br><span class="line">            guardedObject.notifyAll();</span><br><span class="line">        &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">while</span> (Future.getGuardedObject(<span class="number">1</span>) == <span class="literal">null</span>) &#123;</span><br><span class="line">                guardedObject.wait();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">GuardedObject</span> <span class="variable">guardedObject</span> <span class="operator">=</span> Future.getGuardedObject(<span class="number">1</span>);</span><br><span class="line">        &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="37-异步模式-之-生产者消费者"><a class="markdownIt-Anchor" href="#37-异步模式-之-生产者消费者"></a> 3.7 异步模式 之 生产者/消费者</h4>
<h5 id="371-要点"><a class="markdownIt-Anchor" href="#371-要点"></a> 3.7.1 要点</h5>
<ul>
<li>与前面的保护性暂停中的 <code>Guardobject</code> 不同，<u>不需要产生结果和消费结果的线程一一对应</u></li>
<li>消息队列可以用来平衡生产和消费的线程资源</li>
<li>生产者仅负责产生结果数据，不关心数据该如何处理，而消费者专心处理结果数据</li>
<li>消息队列是有容量 <code>capacity</code> 限制的，<strong><u><em>满时不会再加入数据</em></u></strong>（【生产者阻塞】），<strong><u><em>空时不会再消耗数据</em></u></strong>（【消费者阻塞】）</li>
<li>JDK 中各种阻塞队列，采用的就是这种模式</li>
</ul>
<p><img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/image-20220327204404520-8406649.png" alt="image-20220327204404520"></p>
<p>如上图所示，左边的三个线程是生产者，右边的是消费者。</p>
<h5 id="372-实现"><a class="markdownIt-Anchor" href="#372-实现"></a> 3.7.2 实现</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 线程间通信的消息队列</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MessageQueue</span> &#123;</span><br><span class="line">  <span class="comment">// 消息的队列集合，双向链表</span></span><br><span class="line">  <span class="keyword">private</span> LinkedList&lt;Message&gt;list = <span class="keyword">new</span> <span class="title class_">LinkedList</span>();</span><br><span class="line">  <span class="comment">// 队列容量</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> capacity;</span><br><span class="line">  <span class="comment">// 构造函数</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">MessageQueue</span> <span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.capacity = capacity;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Message <span class="title function_">take</span><span class="params">()</span> &#123; <span class="comment">// 取消息</span></span><br><span class="line">  	<span class="comment">// 检查队列是否为空</span></span><br><span class="line">    <span class="keyword">synchronized</span>(list)&#123;</span><br><span class="line">      <span class="keyword">while</span>(list.isEmply())&#123;</span><br><span class="line">      	<span class="keyword">try</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;消息队列为空，消费者等待\n&quot;</span>);</span><br><span class="line">          list.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    	&#125;</span><br><span class="line">      <span class="comment">// 从队列头获取消息并返回</span></span><br><span class="line">      <span class="type">Message</span> <span class="variable">message</span> <span class="operator">=</span> list.removeFrist();</span><br><span class="line">      System.out.println(<span class="string">&quot;已经消费一个消息\n&quot;</span> +message);</span><br><span class="line">      list.notifyAll(); <span class="comment">// 目的是唤醒 WaitSet 中因为消息队列已满的【生产者】线程</span></span><br><span class="line">      <span class="keyword">return</span> message;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">put</span><span class="params">(Message message)</span> &#123; <span class="comment">// 存消息</span></span><br><span class="line">    <span class="comment">// 检查队列是否已满</span></span><br><span class="line">    <span class="keyword">synchronized</span>(list)&#123;</span><br><span class="line">      <span class="keyword">while</span>(list.size() == capcity) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;消息队列已满，生产者等待\n&quot;</span>);</span><br><span class="line">          list.wait();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">          e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// 将消息加入队列尾部</span></span><br><span class="line">      list.addLast(message);</span><br><span class="line">      System.out.println(<span class="string">&quot;已经生产了一个消息：\n&quot;</span> +message);</span><br><span class="line">      list.notifyAll(); <span class="comment">// 目的是唤醒 WaitSet 中因为消息队列已空的【消费者】线程</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">class</span> <span class="title class_">Message</span> &#123; <span class="comment">// 只能创建和读取，不能修改；且字类不能覆盖(final)</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> id;</span><br><span class="line">  <span class="keyword">private</span> Object value;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Message</span> <span class="params">(<span class="type">int</span> id, Object value)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.id = id;</span><br><span class="line">    <span class="built_in">this</span>.value = value;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">getId</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.id;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> Object <span class="title function_">getValue</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.value;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Message: id:&quot;</span>+id+<span class="string">&quot;, value:&quot;</span>+value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">MessageQueue</span> <span class="variable">queue</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MessageQueue</span>(<span class="number">2</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 创建 3 个者线程</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;<span class="number">3</span>; i++) &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">id</span> <span class="operator">=</span> i;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">      queue.put(<span class="keyword">new</span> <span class="title class_">Message</span>(id, <span class="string">&quot;value&quot;</span>+id));</span><br><span class="line">    &#125;, <span class="string">&quot;生产者&quot;</span>+i).start();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 创建 1 个消费者线程</span></span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">      <span class="type">Message</span> <span class="variable">massage</span> <span class="operator">=</span> queue.take();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="string">&quot;消费者&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="38-park-unpark"><a class="markdownIt-Anchor" href="#38-park-unpark"></a> 3.8 <code>park()</code> &amp; <code>unpark()</code></h4>
<h5 id="381-基本使用"><a class="markdownIt-Anchor" href="#381-基本使用"></a> 3.8.1 基本使用</h5>
<p><strong>park/unpark都是LockSupport类中的的方法</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暂停线程运行</span></span><br><span class="line">LockSupport.park;</span><br><span class="line"></span><br><span class="line"><span class="comment">//恢复线程运行</span></span><br><span class="line">LockSupport.unpark(Thread);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">thread</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;park&quot;</span>);</span><br><span class="line">      <span class="comment">//暂停线程运行</span></span><br><span class="line">			LockSupport.park();</span><br><span class="line">			System.out.println(<span class="string">&quot;resume&quot;</span>);</span><br><span class="line">		&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line">		thread.start();</span><br><span class="line"></span><br><span class="line">		Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">		System.out.println(<span class="string">&quot;unpark&quot;</span>);</span><br><span class="line">    	<span class="comment">//恢复线程运行</span></span><br><span class="line">		LockSupport.unpark(thread);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h5 id="382-特点"><a class="markdownIt-Anchor" href="#382-特点"></a> 3.8.2 特点</h5>
<p><strong><code>park()/unpark()</code> 与 <code>wait()/notify()</code> 的区别</strong></p>
<ul>
<li><code>wait()</code>，<code>notify()</code> 和 <code>notifyAll()</code> 必须配合 <strong><code>ObjectMonitor</code></strong> 一起使用，而 <code>park()</code>，<code>unpark()</code> 是与线程相关。</li>
<li><code>park()</code> ，<code>unpark()</code> 是<u>以线程为单位</u>来**【阻塞】<strong>和</strong>【唤醒】**线程，而 notify 只能随机唤醒一个等待线程，notifyAll 是唤醒所有等待线程，就不那么【精确】</li>
<li><code>park()/unpark()</code> 可以<strong>先 <code>unpark()</code></strong>，而  <code>wait()/notify()</code>  不能先 <code>notify()</code></li>
<li><strong><code>park()</code> 不会释放锁</strong>，而 <code>wait()</code> 会释放锁</li>
</ul>
<h5 id="383-原理"><a class="markdownIt-Anchor" href="#383-原理"></a> 3.8.3 原理</h5>
<p>每个线程都有一个自己的 <code>Parker</code> 对象，并且该对象由 <code>_counter</code>、<code>_cond</code>、<code>_mutex</code> 等组成。</p>
<p>我们研究以下源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Parker</span> : <span class="keyword">public</span> os::PlatformParker &#123;</span><br><span class="line"><span class="comment">// 我们可以看到：它继承了os::PlatformParker，内置了一个 volatitle的 _counter。</span></span><br><span class="line"><span class="comment">// os::PlatformParker 的结构我们在下面介绍。</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="comment">// 表示许可</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="type">int</span> _counter ; <span class="comment">// 计数器，是park用来判断是否暂停线程的核心依据，存在读写屏障</span></span><br><span class="line">        Parker * FreeNext ;</span><br><span class="line">        JavaThread * AssociatedWith ; <span class="comment">// Current association 与当前Parker对象相关的Java线程</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">Parker</span>() : <span class="built_in">PlatformParker</span>() &#123;</span><br><span class="line">        <span class="comment">//初始化_counter</span></span><br><span class="line">        _counter       = <span class="number">0</span> ;</span><br><span class="line">        FreeNext       = <span class="literal">NULL</span> ;</span><br><span class="line">        AssociatedWith = <span class="literal">NULL</span> ;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">        ~<span class="built_in">Parker</span>() &#123; <span class="built_in">ShouldNotReachHere</span>(); &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">park</span><span class="params">(<span class="type">bool</span> isAbsolute, jlong time)</span></span>; <span class="comment">// park 方法</span></span><br><span class="line">        <span class="function"><span class="type">void</span> <span class="title">unpark</span><span class="params">()</span></span>;                          <span class="comment">// unpark 方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Lifecycle operators</span></span><br><span class="line"><span class="function"><span class="type">static</span> Parker * <span class="title">Allocate</span> <span class="params">(JavaThread * t)</span> </span>;</span><br><span class="line"><span class="function"><span class="type">static</span> <span class="type">void</span> <span class="title">Release</span> <span class="params">(Parker * e)</span> </span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="type">static</span> Parker * <span class="keyword">volatile</span> FreeList ;</span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">int</span> ListLock ;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">PlatformParker</span> : <span class="keyword">public</span> CHeapObj &#123;</span><br><span class="line">  <span class="keyword">protected</span>:</span><br><span class="line">    <span class="type">pthread_mutex_t</span> _mutex [<span class="number">1</span>] ; <span class="comment">// 互斥变量类型</span></span><br><span class="line">    <span class="type">pthread_cond_t</span>  _cond  [<span class="number">1</span>] ; <span class="comment">// 条件变量类型</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:        </span><br><span class="line">     ~<span class="built_in">PlatformParker</span>() &#123; <span class="built_in">guarantee</span> (<span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">PlatformParker</span>() &#123;</span><br><span class="line">      <span class="type">int</span> status;</span><br><span class="line">     <span class="comment">// 初始化条件变量，使用 pthread_cond_t 之前必须先执行初始化</span></span><br><span class="line">      status = <span class="built_in">pthread_cond_init</span> (_cond, <span class="literal">NULL</span>);</span><br><span class="line">      <span class="built_in">assert_status</span>(status == <span class="number">0</span>, status, <span class="string">&quot;cond_init”);</span></span><br><span class="line"><span class="string">      // 初始化互斥变量，使用 pthread_mutex_t 之前必须先执行初始化</span></span><br><span class="line"><span class="string">      status = pthread_mutex_init (_mutex, NULL);</span></span><br><span class="line"><span class="string">      assert_status(status == 0, status, &quot;</span>mutex_init<span class="string">&quot;);</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125; </span></span><br></pre></td></tr></table></figure>
<p>此时我们再观察 <code>park()</code> 方法的源码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Parker::park</span><span class="params">(<span class="type">bool</span> isAbsolute, jlong time)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (_counter &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 已经有许可了，用掉当前许可</span></span><br><span class="line">        _counter = <span class="number">0</span> ;</span><br><span class="line">        <span class="comment">// 使用内存屏障，确保 _counter赋值为0(写入操作)能够被内存屏障之后的读操作获取内存屏障事前的结果，也就是能够正确的读到 0</span></span><br><span class="line">        OrderAccess::<span class="built_in">fence</span>();</span><br><span class="line">        <span class="comment">//立即返回</span></span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread* thread = Thread::<span class="built_in">current</span>();</span><br><span class="line">    <span class="built_in">assert</span>(thread-&gt;<span class="built_in">is_Java_thread</span>(), <span class="string">&quot;Must be JavaThread&quot;</span>);</span><br><span class="line">    JavaThread *jt = (JavaThread *)thread;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Thread::<span class="built_in">is_interrupted</span>(thread, <span class="literal">false</span>)) &#123;</span><br><span class="line">        <span class="comment">// 线程执行了中断，返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (time &lt; <span class="number">0</span> || (isAbsolute &amp;&amp; time == <span class="number">0</span>) ) &#123;</span><br><span class="line">        <span class="comment">// 时间到了，或者是代表绝对时间，同时绝对时间是0（此时也是时间到了），直接返回，java中的parkUtil传的就是绝对时间，其它都不是</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (time &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 传入了时间参数，将其存入absTime，并解析成absTime-&gt;tv_sec(秒)和absTime-&gt;tv_nsec(纳秒)存储起来，存的是绝对时间</span></span><br><span class="line">        <span class="built_in">unpackTime</span>(&amp;absTime, isAbsolute, time);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进入safepoint region，更改线程为阻塞状态.</span></span><br><span class="line">    <span class="function">ThreadBlockInVM <span class="title">tbivm</span><span class="params">(jt)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (Thread::<span class="built_in">is_interrupted</span>(thread, <span class="literal">false</span>) || <span class="built_in">pthread_mutex_trylock</span>(_mutex) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果线程被中断，或者是在尝试给互斥变量加锁的过程中，加锁失败，比如被其它线程锁住了，直接返回</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里表示线程互斥变量锁成功了</span></span><br><span class="line">    <span class="type">int</span> status ;</span><br><span class="line">    <span class="keyword">if</span> (_counter &gt; <span class="number">0</span>)  &#123;</span><br><span class="line">        <span class="comment">// 有许可了，返回</span></span><br><span class="line">        _counter = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//对互斥变量解锁</span></span><br><span class="line">        status = <span class="built_in">pthread_mutex_unlock</span>(_mutex);</span><br><span class="line">        <span class="built_in">assert</span> (status == <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">        OrderAccess::<span class="built_in">fence</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> ASSERT</span></span><br><span class="line">        <span class="comment">// Don&#x27;t catch signals while blocked; let the running threads have the signals.  </span></span><br><span class="line">        <span class="comment">// (This allows a debugger to break into the running thread.)  </span></span><br><span class="line">        <span class="comment">// debug用</span></span><br><span class="line">        <span class="type">sigset_t</span> oldsigs;</span><br><span class="line">        <span class="type">sigset_t</span>* allowdebug_blocked = os::Linux::<span class="built_in">allowdebug_blocked_signals</span>();</span><br><span class="line">        <span class="built_in">pthread_sigmask</span>(SIG_BLOCK, allowdebug_blocked, &amp;oldsigs);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        </span><br><span class="line">    <span class="comment">//将java线程所拥有的操作系统线程设置成 CONDVAR_WAIT状态 ，表示在等待某个条件的发生</span></span><br><span class="line">    <span class="function">OSThreadWaitState <span class="title">osts</span><span class="params">(thread-&gt;osthread(), <span class="literal">false</span> <span class="comment">/* not Object.wait() */</span>)</span></span>;</span><br><span class="line">    <span class="comment">//将java的_suspend_equivalent参数设置为true</span></span><br><span class="line">    jt-&gt;<span class="built_in">set_suspend_equivalent</span>();</span><br><span class="line">    <span class="comment">// cleared by handle_special_suspend_equivalent_condition() or java_suspend_self()</span></span><br><span class="line">    <span class="keyword">if</span> (time == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//把调用线程放到等待条件的线程列表上，然后对互斥变量解锁，（这两是原子操作），这个时候线程进入等待，当它返回时，互斥变量再次被锁住。</span></span><br><span class="line">        <span class="comment">//成功返回0，否则返回错误编号</span></span><br><span class="line">        status = <span class="built_in">pthread_cond_wait</span> (_cond, _mutex) ;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//同pthread_cond_wait，只是多了一个超时，如果超时还没有条件出现，那么重新获取胡吃两然后返回错误码 ETIMEDOUT</span></span><br><span class="line">        status = os::Linux::<span class="built_in">safe_cond_timedwait</span> (_cond, _mutex, &amp;absTime) ;</span><br><span class="line">        <span class="keyword">if</span> (status != <span class="number">0</span> &amp;&amp; WorkAroundNPTLTimedWaitHang) &#123;</span><br><span class="line">            <span class="comment">//WorkAroundNPTLTimedWaitHang 是JVM的运行参数，默认为1</span></span><br><span class="line">            <span class="comment">//去除初始化</span></span><br><span class="line">            <span class="built_in">pthread_cond_destroy</span> (_cond) ;</span><br><span class="line">            <span class="comment">//重新初始化</span></span><br><span class="line">            <span class="built_in">pthread_cond_init</span>    (_cond, <span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">assert_status</span>(status == <span class="number">0</span> || status == EINTR ||</span><br><span class="line">        status == ETIME || status == ETIMEDOUT,</span><br><span class="line">        status, <span class="string">&quot;cond_timedwait&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">#<span class="keyword">ifdef</span> ASSERT</span></span><br><span class="line">        <span class="built_in">pthread_sigmask</span>(SIG_SETMASK, &amp;oldsigs, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">        <span class="comment">//等待结束后，许可被消耗，改为0  _counter = 0 ;</span></span><br><span class="line"><span class="comment">//释放互斥量的锁</span></span><br><span class="line">    status = <span class="built_in">pthread_mutex_unlock</span>(_mutex) ;</span><br><span class="line">    <span class="built_in">assert_status</span>(status == <span class="number">0</span>, status, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">    <span class="comment">// If externally suspended while waiting, re-suspend </span></span><br><span class="line">    <span class="keyword">if</span> (jt-&gt;<span class="built_in">handle_special_suspend_equivalent_condition</span>()) &#123;</span><br><span class="line">        jt-&gt;<span class="built_in">java_suspend_self</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//加入内存屏障指令</span></span><br><span class="line">    OrderAccess::<span class="built_in">fence</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>从 <code>park</code> 的实现可以看到</p>
<ol>
<li>无论是什么情况返回，<code>park</code>方法本身都不会告知调用方返回的原因，所以调用的时候一般都会去判断返回的场景，根据场景做不同的处理</li>
<li>线程的等待与挂起、唤醒等等就是使用的 <code>POSIX</code> 的线程 API</li>
<li><code>park</code> 的许可通过变量 <code>_count</code> 实现，当被消耗时，<code>_count</code> 为 0，只要拥有许可，就会立即返回</li>
</ol>
</blockquote>
<p><code>unpark()</code> 的源码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Parker::unpark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="type">int</span> s, status ;</span><br><span class="line"> <span class="comment">//给互斥量加锁，如果互斥量已经上锁，则阻塞到互斥量被解锁</span></span><br><span class="line"><span class="comment">//park进入wait时，_mutex会被释放</span></span><br><span class="line">  status = <span class="built_in">pthread_mutex_lock</span>(_mutex);</span><br><span class="line">  <span class="built_in">assert</span> (status == <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ; </span><br><span class="line">  <span class="comment">//存储旧的_counter</span></span><br><span class="line">  s = _counter; </span><br><span class="line"><span class="comment">//许可改为1，每次调用都设置成发放许可</span></span><br><span class="line">  _counter = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">if</span> (s &lt; <span class="number">1</span>) &#123;</span><br><span class="line">     <span class="comment">//之前没有许可</span></span><br><span class="line">     <span class="keyword">if</span> (WorkAroundNPTLTimedWaitHang) &#123;</span><br><span class="line">      <span class="comment">//默认执行 ,释放信号，表明条件已经满足，将唤醒等待的线程</span></span><br><span class="line">        status = <span class="built_in">pthread_cond_signal</span> (_cond) ;</span><br><span class="line">        <span class="built_in">assert</span> (status == <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        status = <span class="built_in">pthread_mutex_unlock</span>(_mutex);</span><br><span class="line">        <span class="built_in">assert</span> (status == <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        status = <span class="built_in">pthread_mutex_unlock</span>(_mutex);</span><br><span class="line">        <span class="built_in">assert</span> (status == <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">        status = <span class="built_in">pthread_cond_signal</span> (_cond) ;</span><br><span class="line">        <span class="built_in">assert</span> (status == <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">//一直有许可，释放掉自己加的锁,有许可park本身就返回了</span></span><br><span class="line">    <span class="built_in">pthread_mutex_unlock</span>(_mutex);</span><br><span class="line">    <span class="built_in">assert</span> (status == <span class="number">0</span>, <span class="string">&quot;invariant&quot;</span>) ;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码可知 <code>unpark</code> 本身就是发放许可 <code>_count</code>，并通知等待的线程，已经可以结束等待了。</p>
<h5 id="384-park-unpark-总结"><a class="markdownIt-Anchor" href="#384-park-unpark-总结"></a> 3.8.4 <code>park / unpark</code> 总结</h5>
<ul>
<li>
<p>先调用 <code>park</code> 再调用 <code>unpark</code> 时</p>
<ol>
<li>先调用 <code>park</code>
<ul>
<li>线程运行时，会将Park对象中 <code>_counter</code>的值设为 0；</li>
<li>调用 <code>park</code> 时，会先查看 <code>_counter</code>的值是否为 0，如果为 0，则将线程放入阻塞队列 <code>_cond</code> 中</li>
<li>放入阻塞队列中后，会<strong>再次</strong>将<code>_counter</code>设置为 0</li>
</ul>
</li>
</ol>
<img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/20200608145250.png" alt="20200608145250" style="zoom:70%;">
<ol start="2">
<li>然后调用 <code>unpark</code>
<ul>
<li>调用 <code>unpark</code> 方法后，会将<code>_counter</code>的值设置为 1</li>
<li>去唤醒阻塞队列<code>_cond</code>中的线程</li>
<li>线程继续运行并将<code>_counter</code>的值设为 0</li>
</ul>
</li>
</ol>
<img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/20200608145303.png" alt="20200608145303" style="zoom:60%;">
</li>
<li>
<p>先调用 <code>unpark</code>，再调用 <code>park</code></p>
<ol>
<li>
<p>调用 <code>unpark</code></p>
<ul>
<li>会将<code>_counter</code>设置为 1（运行时 0）</li>
</ul>
</li>
<li>
<p>调用 <code>park</code> 方法</p>
<ul>
<li>查看<code>_counter</code>是否为 0</li>
<li>因为 <code>unpark</code> 已经把<code>_counter</code>设置为 1，所以此时将<code>_counter</code>设置为 0，但<strong>不放入</strong>阻塞队列 <code>_cond</code> 中</li>
</ul>
</li>
</ol>
</li>
</ul>
<img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/20200608145313.png" alt="20200608145313" style="zoom:60%;">
<h4 id="39-线程状态转换"><a class="markdownIt-Anchor" href="#39-线程状态转换"></a> 3.9 线程状态转换</h4>
<img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/20200608144621-8409900.png" alt="20200608144621" style="zoom:75%;">
<h5 id="情况一tstart-new-runnable"><a class="markdownIt-Anchor" href="#情况一tstart-new-runnable"></a> 情况一：<code>t.start() : NEW --&gt; RUNNABLE</code></h5>
<ul>
<li>当调用了 <code>Thread t.start()</code> 方法时，Java 中的 <code>Thread</code> 对象就和操作系统的线程关联起来了。</li>
<li>由 <code>NEW</code> –&gt; <code>RUNNABLE</code>。</li>
</ul>
<h5 id="情况二waitnotify-runnable-waiting"><a class="markdownIt-Anchor" href="#情况二waitnotify-runnable-waiting"></a> 情况二：<code>wait/notify : RUNNABLE &lt;--&gt; WAITING</code></h5>
<ul>
<li>当调用了 <code>t</code> 线程用 <code>synchronized(obj)</code> 获取了对象锁后
<ul>
<li>调用 <code>obj.wait()</code> 方法时， <code>t</code> 线程从 <code>RUNNABLE</code> –&gt; <code>WAITING</code></li>
<li>调用 <code>obj.notify()</code> ， <code>obj.notifyAll()</code> ，<u><code>t.interrupt()</code></u> 时
<ul>
<li>竞争 <code>Monitor</code> 锁【成功】，<code>t</code> 线程从 <code>WAITING</code> –&gt; <code>RUNNABLE</code></li>
<li>竞争 <code>Monitor</code> 锁【失败】，<code>t</code> 线程从 <code>WAITING</code> –&gt; <code>BLOCKED</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="情况三tjoin-runnable-waiting"><a class="markdownIt-Anchor" href="#情况三tjoin-runnable-waiting"></a> 情况三：<code>t.join() : RUNNABLE &lt;--&gt; WAITING</code></h5>
<ul>
<li>
<p>当前线程</p>
<p>调用 <code>t.join()</code> 方法时，当前线程从 <code>RUNNABLE</code> –&gt; <code>WAITING</code></p>
<ul>
<li>注意是<u>当前线程</u>在 <code>t</code> 线程对象的监视器上等待</li>
</ul>
</li>
<li>
<p><code>t</code> 线程<u>运行结束</u>，或调用了<strong>当前线程</strong>的 <u><code>interrupt()</code></u> 时，当前线程从 <code>WAITING</code> –&gt; <code>RUNNABLE</code></p>
</li>
</ul>
<h5 id="情况四parkunpark-runnable-waiting"><a class="markdownIt-Anchor" href="#情况四parkunpark-runnable-waiting"></a> 情况四：<code>park/unpark : RUNNABLE &lt;--&gt; WAITING</code></h5>
<ul>
<li>当前线程调用 <code>LockSupport.park()</code> 方法会让当前线程从 <code>RUNNABLE</code> –&gt; <code>WAITING</code></li>
<li>调用 <code>LockSupport.unpark(目标线程)</code> 或调用了线程 的 <code>interrupt()</code> ，会让目标线程从 <code>WAITING</code> –&gt; <code>RUNNABLE</code></li>
</ul>
<h5 id="情况五-waitnotify-long-n-runnable-timed_waiting"><a class="markdownIt-Anchor" href="#情况五-waitnotify-long-n-runnable-timed_waiting"></a> 情况五： <code>wait/notify (long n) : RUNNABLE &lt;--&gt; TIMED_WAITING</code></h5>
<p><code>t</code> 线程用 <code>synchronized(obj)</code> 获取了对象锁后</p>
<ul>
<li>调用 <code>obj.wait(long n)</code> 方法时，t 线程从 <code>RUNNABLE</code> –&gt; <code>TIMED_WAITING</code></li>
<li>t 线程等待时间超过了 n 毫秒，或调用 <code>obj.notify()</code>， <code>obj.notifyAll()</code> ，<code>t.interrupt()</code> 时
<ul>
<li>竞争锁成功，<code>t</code> 线程从 <code>TIMED_WAITING</code> –&gt; <code>RUNNABLE</code></li>
<li>竞争锁失败，<code>t</code> 线程从 <code>TIMED_WAITING</code> –&gt; <code>BLOCKED</code></li>
</ul>
</li>
</ul>
<h5 id="情况六tjoinlong-n-runnable-timed_waiting"><a class="markdownIt-Anchor" href="#情况六tjoinlong-n-runnable-timed_waiting"></a> 情况六：<code>t.join(long n) : RUNNABLE &lt;--&gt; TIMED_WAITING</code></h5>
<ul>
<li>当前线程调用 <code>t.join(long n)</code> 方法时，当前线程从 <code>RUNNABLE</code> –&gt; <code>TIMED_WAITING</code>
<ul>
<li>注意是当前线程在t 线程对象的监视器上等待</li>
</ul>
</li>
<li>当前线程等待时间超过了 n 毫秒，或t 线程运行结束，或调用了当前线程的 <code>interrupt()</code> 时，当前线程从 <code>TIMED_WAITING</code> –&gt; <code>RUNNABLE</code></li>
</ul>
<h5 id="情况七threadsleeplong-n-runnable-timed_waiting"><a class="markdownIt-Anchor" href="#情况七threadsleeplong-n-runnable-timed_waiting"></a> 情况七：<code>Thread.sleep(long n) : RUNNABLE &lt;--&gt; TIMED_WAITING</code></h5>
<ul>
<li>当前线程调用 <code>Thread.sleep(long n)</code>，当前线程从 <code>RUNNABLE</code> –&gt; <code>TIMED_WAITING</code></li>
<li>当前线程等待时间超过了 n 毫秒，当前线程从 <code>TIMED_WAITING</code> –&gt; <code>RUNNABLE</code></li>
</ul>
<h5 id="情况八parknanosunpark-long-n-runnable-timed_waiting"><a class="markdownIt-Anchor" href="#情况八parknanosunpark-long-n-runnable-timed_waiting"></a> 情况八：<code>parkNanos/unpark (long n) : RUNNABLE &lt;--&gt; TIMED_WAITING</code></h5>
<ul>
<li>当前线程调用 <code>LockSupport.parkNanos(long nanos)</code> 或 <code>LockSupport.parkUntil(long millis)</code> 时，当前线 程从 <code>RUNNABLE</code> –&gt; <code>TIMED_WAITING</code></li>
<li>调用 <code>LockSupport.unpark(目标线程)</code> 或调用了线程 的 <code>interrupt()</code> ，或是等待超时，会让目标线程从 <code>TIMED_WAITING</code> –&gt; <code>RUNNABLE</code></li>
</ul>
<h5 id="情况九阻塞在entrylist-runnable-blocked"><a class="markdownIt-Anchor" href="#情况九阻塞在entrylist-runnable-blocked"></a> 情况九：<code>阻塞在EntryList : RUNNABLE &lt;--&gt; BLOCKED</code></h5>
<ul>
<li><code>t</code> 线程用 <code>synchronized(obj)</code> 获取了对象锁时如果<strong>竞争失败</strong>，从 <code>RUNNABLE</code> –&gt; <code>BLOCKED</code></li>
<li>持 <code>obj</code> 锁线程的同步代码块执行完毕，会唤醒该对象上所有 <code>BLOCKED</code> 的线程重新竞争，如果其中<code>t</code> 线程竞争成功，从 <code>BLOCKED</code> –&gt; <code>RUNNABLE</code> ，其它<strong>失败</strong>的线程仍然 <code>BLOCKED</code></li>
</ul>
<h5 id="情况十-执行完毕-runnable-terminated"><a class="markdownIt-Anchor" href="#情况十-执行完毕-runnable-terminated"></a> 情况十： <code>执行完毕 : RUNNABLE --&gt; TERMINATED</code></h5>
<p>当前线<u>程所有代码运行完毕</u>，进入 <code>TERMINATED</code></p>
<h4 id="310-多把锁"><a class="markdownIt-Anchor" href="#310-多把锁"></a> 3.10 多把锁</h4>
<p><strong>将锁的粒度细分</strong></p>
<p>例如一套房子中有多个房间，书房和卧室的功能毫不相干。所以我们可以把锁分别加在卧室和书房上。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BigRoom</span> &#123;</span><br><span class="line">    <span class="comment">//额外创建对象来作为锁</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">studyRoom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">bedRoom</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="311-线程的活跃性"><a class="markdownIt-Anchor" href="#311-线程的活跃性"></a> 3.11 线程的活跃性</h4>
<h5 id="3111-死锁"><a class="markdownIt-Anchor" href="#3111-死锁"></a> 3.11.1 死锁</h5>
<blockquote>
<p>定义：</p>
<p>在并发环境下，各进程因竞争资源而造成的一种<u>互相等待对方手里的资源</u>，导致各进程都阻塞，都无法向前推进的现象，就是死锁。</p>
</blockquote>
<p>有这样的情况：一个线程需要<strong>同时获取多把锁</strong>，这时就容易发生死锁</p>
<p>如：</p>
<ul>
<li><code>t1线程</code> 获得 <code>A对象锁</code>，接下来想获取 <code>B对象的锁</code></li>
<li><code>t2线程</code> 获得 <code>B对象锁</code>，接下来想获取 <code>A对象的锁</code></li>
</ul>
<p>每个人都占有一个资源，同时又在等待另一个人手里的资源。发生“死锁”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="keyword">final</span> <span class="type">Object</span> <span class="variable">A</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">		<span class="keyword">final</span> <span class="type">Object</span> <span class="variable">B</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">					System.out.println(<span class="string">&quot;TODO&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line"></span><br><span class="line">		<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (B) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">synchronized</span> (A) &#123;</span><br><span class="line">          System.out.println(<span class="string">&quot;TODO&quot;</span>);</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;).start();</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h6 id="发生死锁的必要条件"><a class="markdownIt-Anchor" href="#发生死锁的必要条件"></a> 发生死锁的必要条件</h6>
<ol>
<li>
<p><u>互斥条件</u>：只有对必须互斥使用的资源的争抢才会产生死锁。</p>
</li>
<li>
<p><u>不可剥夺条件</u>：进程所获得的资源在未使用完之前，不能<strong>由其他进程强行夺走</strong></p>
</li>
<li>
<p><u>请求和保持条件</u>：进程已经<strong>保持了至少一个资源</strong>，但<strong>又提出了新的资源请求</strong>，而该资源又被其他进程占有，此时请求进程被阻塞，但又<strong>对自己已有的资源保持不放</strong></p>
</li>
<li>
<p><u>循环等待条件</u>：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。死锁  <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mo>→</mo></mrow><annotation encoding="application/x-tex">\to</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">→</span></span></span></span> 一定有循环等待； 循环等待【不一定】发生死锁</p>
</li>
</ol>
<p><strong>【预防死锁】：</strong> 破坏<strong>死锁产生的必要条件</strong>，即可预防死锁。</p>
<h6 id="避免死锁的方法"><a class="markdownIt-Anchor" href="#避免死锁的方法"></a> 避免死锁的方法</h6>
<p>在线程使用锁对象时**，顺序加锁**即可避免死锁。线程1按顺序获得A，B对象的锁：</p>
<pre class="mermaid">sequenceDiagram
    participant t1 as 线程1
    participant t2 as 线程2
    participant obj1 as 对象1
    participant obj2 as 对象2
    
    t1 -->> obj1 : 尝试获取锁
    Note over t1,obj1 :拥有锁
    
    t2 --x obj1 : 尝试获取锁（失败）
    t2 -->> obj1 : 阻塞
    
    t1 -->> obj2 : 尝试获取锁
    Note over t1,obj2 :拥有锁</pre>
<h5 id="3112-活锁"><a class="markdownIt-Anchor" href="#3112-活锁"></a> 3.11.2 活锁</h5>
<p>活锁出现在两个线程<strong>互相改变对方的结束条件</strong>后谁也无法结束。</p>
<h6 id="避免活锁的方法"><a class="markdownIt-Anchor" href="#避免活锁的方法"></a> 避免活锁的方法</h6>
<p>在线程执行时，中途给予<strong>不同的间隔时间</strong>即可。</p>
<h6 id="死锁与活锁的区别"><a class="markdownIt-Anchor" href="#死锁与活锁的区别"></a> 死锁与活锁的区别</h6>
<ul>
<li>死锁是因为线程互相持有对象想要的锁，并且都不释放，最后到时<strong>线程阻塞</strong>，<strong>停止运行</strong>的现象。</li>
<li>活锁是因为线程间修改了对方的结束条件，而导致代码<strong>一直在运行</strong>，却一直<strong>运行不完</strong>的现象。</li>
</ul>
<h5 id="3113-饥饿"><a class="markdownIt-Anchor" href="#3113-饥饿"></a> 3.11.3 饥饿</h5>
<p>某些线程因为优先级太低，导致一直无法获得资源的现象。</p>
<p>为了避免死锁而使用顺序加锁时，可能会出现饥饿现象</p>
<h5 id="3114-死锁-饥饿和死循环的异同点"><a class="markdownIt-Anchor" href="#3114-死锁-饥饿和死循环的异同点"></a> 3.11.4 死锁、饥饿和死循环的异同点</h5>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">共同点</th>
<th style="text-align:center">区别</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">死锁</td>
<td style="text-align:center">都是进程无法顺利向前推进的现象</td>
<td style="text-align:center">死锁一定是“循环等待对方手里的资源”导致的，因此如果有死锁现象，那<strong>至少有两个或两个以上的进程同时发生死锁</strong>。另外，发生死锁的进程一定处于阻塞态</td>
</tr>
<tr>
<td style="text-align:center">饥饿</td>
<td style="text-align:center"><strong>可能只有一个进程发生饥饿</strong>。发生饥饿的进程可能是阻塞态（如长期得不到需要的IO设备），也可能是就绪态（长期得不到处理机）</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">死循环</td>
<td style="text-align:center">可能只有一个进程发生死循环。死循环可以是运行态，只不过无法继续推进。死锁和饥饿是由于操作系统分配资源的策略不合理导致的，而死循环是由代码逻辑错误导致的。<strong>死锁和饥饿是管理者(操作系统)的问题，死循环是被管理者的问题。</strong></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h5 id="3115-预防死锁-静态策略"><a class="markdownIt-Anchor" href="#3115-预防死锁-静态策略"></a> 3.11.5 预防死锁 - 静态策略</h5>
<h6 id="31151-资源分配图graphe-dallocation"><a class="markdownIt-Anchor" href="#31151-资源分配图graphe-dallocation"></a> 3.11.5.1 资源分配图（Graphe d’allocation）</h6>
<ul>
<li>两种结点
<ul>
<li>进程结点：对应一个进程</li>
<li>资源结点：对应一类资源，一类资源可能有多个。（一般用矩形代表资源结点，矩形中的小圆圈代表该类资源的数量）</li>
</ul>
</li>
<li>两种边：
<ul>
<li>进程结点 -&gt; 资源结点：<strong>请求边</strong>，表示进程<strong>想申请几个资源</strong>（一条边代表一个）</li>
<li>资源结点 -&gt; 进程结点：<strong>分配边</strong>，表示<strong>已经为进程分配了几个资源</strong></li>
</ul>
</li>
</ul>
<pre class="mermaid">graph LR
  A(P1) --> B
  B[R2:2] --> C
  C(P2) --> D
  D[R1:3] --> C
  D --> A
  D --> A</pre>
<p>如果系统中剩余的可用资源数足够满足进程的需求，那么这个进程暂时是不会阻塞的，可以顺利地执行下去。</p>
<pre class="mermaid">graph LR;
  A(P1) 
  B[R2:2] --> C
  C(P2) --> D
  D[R1:3] --> C</pre>
<p>如果这个进程执行结束了把资源归还系统，就可能使某些正在等待资源的进程被激活，并顺利地执行下去。<br>
相应的，这些被激活的进程执行完了之后又会归还一些资源，这样可能又会激活另外一些阻塞的进程….</p>
<pre class="mermaid">graph TB;
  A(P1) 
  B[R2:2]
  C(P2)
  D[R1:3]</pre>
<p>如果按上述过程分析，最终<strong>能消除所有边</strong>，就称这个图是<strong>可完全简化的</strong>。此时一定<strong>没有发生死锁</strong>（相当于能找到一个安全序列）</p>
<p>另一个例子：</p>
<pre class="mermaid">graph LR;
  A(P1)
  B[R2:2]
  C(P2)
  D[R1:3]
  
  E(P3)
  E --> B
  A --> B
  A --> B
  B --> C
  C --> D
  D --> C
  D --> A
  D --> A</pre>
<p>如果最终<strong>不能消除所有边</strong>，那么此时就是<strong>发生了死锁</strong>。 <strong>最终没有被消除的边所连的进程就发生了死锁</strong>。</p>
<h6 id="31152-死锁的解除"><a class="markdownIt-Anchor" href="#31152-死锁的解除"></a> 3.11.5.2 死锁的解除</h6>
<p>用死锁检测算法化简资源分配图后，还连着边的那此进程就是死锁进程。 解除死锁的主要方法有：</p>
<ol>
<li>资源剥夺法。挂起（暂时放到外存上）某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但是应防止被挂起的进程长时间得不到资源而饥饿。</li>
<li>撤销进程法（或称终止进程法）。强制撤销部分、甚至全部死锁进程，并剥夺这些进程的资源，这种方式的优点是实现简单，但所付出的代价可能会很大。因为有些进程可能已经运行了很长时间，己经接近结束了，旦被终止可谓功亏一篑，以后还得从头再来。</li>
<li>进程回退法。让一个或多个死锁进程回退到足以避免死锁的地步。这就要求系统耍记录进程的历史信息，设置还原点</li>
</ol>
<h5 id="3116-避免死锁-动态策略"><a class="markdownIt-Anchor" href="#3116-避免死锁-动态策略"></a> 3.11.6 避免死锁 - 动态策略</h5>
<h6 id="31161-安全序列"><a class="markdownIt-Anchor" href="#31161-安全序列"></a> 3.11.6.1 安全序列</h6>
<p>所谓<strong>安全序列</strong>，就是值如果系统按照这种序列分配资源，则每个进程都能顺利完成。只要能找出一个安全序列，系统就是<strong>安全状态</strong>。当然，<strong>安全序列可能有多个</strong>。<br>
如果分配了资源之后，系统中找不出任何一个安全序列，系统就进入了<strong>不安全状态</strong>。这就意味着之后<strong>可能</strong>所有进程都无法顺利的进行下去。当然，如果有进程提前归还了一些资源，那系统也<strong>有可能重新回到安全状态</strong>，不过我们在分配资源之前总是要考虑到最坏的情况。</p>
<p>因此可以<strong>在资源分配之前前预判这次分配是否会导致系统进入不安全状态</strong>，一次决定是否答应资源分配的请求。这也是“<strong>银行家算法</strong>”的核心思想。</p>
<h6 id="31162-银行家算法"><a class="markdownIt-Anchor" href="#31162-银行家算法"></a> 3.11.6.2 银行家算法</h6>
<p>假设系统中有 <code>n</code> 个进程，<code>m</code> 种资源每个进程在运行前先声明对各种资源的最大需求数，则可用一个 <code>n*m</code>的矩阵（可用二维数组实现） 表示所有进程对各种资源的最大需求数。不妨称为<strong>最大需求矩阵</strong> <code>Max</code>， <code>Max[i,j] = K</code> 表示进程 <code>P_i</code> 最多需要 K 个资源 <code>R_j</code>。同理，系统可以用一个 <code>n*m</code> 的<strong>分配矩阵 Allocation</strong> 表示对所有进程的资源分配情况。<code>Max - Allocation = Need</code> 矩阵，表示各进程最多还需要多少各类资源。<br>
另外，还要用一个长度为 <code>m</code> 的一维数组 <code>Available(...)</code> 表示当前系统中<strong>还有多少可用资源</strong><br>
某进程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 向系统申请资源，可用1个长度为<code>m</code>的一维数组 <code>Request(...)</code>， 表示<strong>本次申请的各种资源量</strong>。</p>
<table>
<thead>
<tr>
<th>进程</th>
<th>最大需求(Max 矩阵)</th>
<th>已分配(Allocation 矩阵)</th>
<th>最多还需要(Need 矩阵)</th>
</tr>
</thead>
<tbody>
<tr>
<td>P0</td>
<td>(7,5,3)</td>
<td>(0,1,0)</td>
<td>(7,4,3)</td>
</tr>
<tr>
<td>P1</td>
<td>(3,2,2)</td>
<td>(2,0,0)</td>
<td>(1,2,2)</td>
</tr>
<tr>
<td>P2</td>
<td>(9,0,2)</td>
<td>(3,0,2)</td>
<td>(6,0,0)</td>
</tr>
<tr>
<td>P3</td>
<td>(2,2,2)</td>
<td>(2,1,1)</td>
<td>(0,1,1)</td>
</tr>
<tr>
<td>P4</td>
<td>(4,3,3)</td>
<td>(0,0,2)</td>
<td>(4,3,1)</td>
</tr>
</tbody>
</table>
<p>可用<strong>银行家算法</strong>预判本次分配是否会导致系统进入不安全状态：</p>
<ol>
<li>如果 <code>Request_i[j] &lt; Need[i,j] (0 &lt;= j &lt; m)</code> 便转向 ②：否则认为出错</li>
<li>如果 <code>Request_i[j] &lt; Available[i,j] (0 &lt;= j &lt; m)</code>，便转向 ③：否则表示尚无足够资源，p必须等待</li>
<li>系统试探着把资源分配给进程 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>P</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">P_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:-0.13889em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，并修改相应的数据（并非真的分配，修改数值只是为了做预判)：
<ul>
<li><code>Available = Available - Request_j;</code></li>
<li><code>Allocation[i,j] = Allocation[i,j] + Request_i[j];</code></li>
<li><code>Need[i,j] = Need[i,j] - Request_i[j]</code></li>
</ul>
</li>
<li>操作系统执行<strong>安全性算法</strong>，检查此次资源分配后，系统是<strong>否处于安全状态</strong>。若安全，才正式分配;否则，恢复相应数据，让进程阻塞等待。</li>
</ol>
<p>【银行家算法步骤】</p>
<ol>
<li>检查此次申请是否超过了之前声明的最大需求数</li>
<li>检查此时系统剩余的可用资源是否还能满足这次请求</li>
<li>试探着分配，更改各数据结构</li>
<li>用安全性算法检查此次分配是否会导致系统进入不安全状态</li>
</ol>
<p>安全性算法步骤： 检查当前的剩余可用资源是否能满足某个进程的最大需求，如果可以，就把该进程加入安全序列，并把该讲程持有的资源全部回收。 不断重复上述过程，看最终是否能让所有进程都加入安全序列。</p>
<h4 id="312-reentrantlock-可重入锁"><a class="markdownIt-Anchor" href="#312-reentrantlock-可重入锁"></a> 3.12 ReentrantLock (可重入锁)</h4>
<blockquote>
<p>源码分析：<a target="_blank" rel="noopener" href="https://dave0126.github.io/2022/09/05/Java%E4%B8%AD%E7%9A%84%E9%94%81%EF%BC%9AReentrantLock/">Java中的锁：ReentrantLock</a></p>
</blockquote>
<p><strong>和 <code>synchronized</code> 相比具有的的特点</strong></p>
<ul>
<li>可被别的线程中断（例如 A，B 两个线程中，A 线程拥有锁，B 线程中断 A 线程后，锁就被释放了）</li>
<li>可以设置超时时间（给定时间内如果争抢不到锁，就放弃争抢）</li>
<li>可以设置为公平锁 （先到先得）</li>
<li>支持多个条件变量（相当于具有<strong>多个</strong> <code>WaitSet</code>）</li>
</ul>
<h5 id="3121-基本语法"><a class="markdownIt-Anchor" href="#3121-基本语法"></a> 3.12.1 基本语法</h5>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取 ReentrantLock 对象</span></span><br><span class="line"><span class="keyword">private</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">// 加锁。思考为什么lock()要在try代码块的外面？</span></span><br><span class="line"><span class="comment">// 因为如果在try块内，线程在lock()的时候出现异常，会执行finally代码块中的unlock()方法，</span></span><br><span class="line"><span class="comment">// 但是此时并没有成功lock()，程序会出错。</span></span><br><span class="line">lock.lock();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">// 需要执行的代码</span></span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">	<span class="comment">// 释放锁</span></span><br><span class="line">	lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3122-可重入"><a class="markdownIt-Anchor" href="#3122-可重入"></a> 3.12.2 可重入</h5>
<ul>
<li>可重入是指同一个线程如果首次获得了这把锁，那么因为它是这把锁的拥有者，因此有权利再次获取这把锁</li>
<li>如果是不可重入锁，那么第二次获得锁时，自己也会被锁挡住</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123; </span><br><span class="line">    method1();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123; </span><br><span class="line">    lock.lock(); <span class="comment">// 锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;execute method1&quot;</span>); </span><br><span class="line">        method2(); <span class="comment">// 调用method2</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">finally</span> &#123; </span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method2</span><span class="params">()</span> &#123; </span><br><span class="line">    lock.lock(); <span class="comment">// 锁的重入</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;execute method2&quot;</span>); </span><br><span class="line">        method3(); <span class="comment">// 调用method3</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; </span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method3</span><span class="params">()</span> &#123; </span><br><span class="line">    lock.lock(); <span class="comment">// 锁的重入</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;execute method3&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; </span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">17:59:11.862 [main] c.TestReentrant - execute method1</span><br><span class="line">17:59:11.865 [main] c.TestReentrant - execute method2</span><br><span class="line">17:59:11.865 [main] c.TestReentrant - execute method3</span><br></pre></td></tr></table></figure>
<h5 id="3123-可打断"><a class="markdownIt-Anchor" href="#3123-可打断"></a> 3.12.3 可打断</h5>
<p>可打断的意义：<u>被动避免死等</u>。</p>
<p>如果某个线程 <u><code>ReentrentLock lock.lockInterruptibly()</code></u> 处于阻塞状态（等待获得锁），可以调用其 <code>interrupt()</code> 方法让其停止阻塞，放弃获得锁。</p>
<p><strong>简而言之</strong>就是：处于阻塞状态的线程，被打断了就不用阻塞了，直接返回</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); </span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;启动...&quot;</span>); </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有竞争，那么此方法就会获得lock对象锁</span></span><br><span class="line">        <span class="comment">// 如果有竞争就进入阻塞队列，可以被其他进程用 interrupt 方法打断</span></span><br><span class="line">        lock.lockInterruptibly(); <span class="comment">// 可中断锁</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">        e.printStackTrace(); </span><br><span class="line">        log.debug(<span class="string">&quot;等锁的过程中被打断&quot;</span>); </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123; <span class="comment">// 思考这里为什么要用两个try代码块？可以写在一起吗？</span></span><br><span class="line">        log.debug(<span class="string">&quot;获得了锁&quot;</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock(); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">lock.lock(); </span><br><span class="line">log.debug(<span class="string">&quot;获得了锁&quot;</span>); </span><br><span class="line">t1.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    t1.interrupt(); <span class="comment">// 执行中断</span></span><br><span class="line">    log.debug(<span class="string">&quot;执行打断&quot;</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">finally</span> &#123; </span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">18:02:40.520 [main] c.TestInterrupt - 获得了锁 </span><br><span class="line">18:02:40.524 [t1] c.TestInterrupt - 启动... </span><br><span class="line">18:02:41.530 [main] c.TestInterrupt - 执行打断</span><br><span class="line">java.lang.InterruptedException</span><br><span class="line">    at java.util.concurrent.locks.AbstractQueuedSynchronizer.doAcquireInterruptibly(AbstractQueuedSynchr onizer.java:898)</span><br><span class="line">    at java.util.concurrent.locks.AbstractQueuedSynchronizer.acquireInterruptibly(AbstractQueuedSynchron izer.java:1222)</span><br><span class="line">    at java.util.concurrent.locks.ReentrantLock.lockInterruptibly(ReentrantLock.java:335) at cn.itcast.n4.reentrant.TestInterrupt.lambda$main$0(TestInterrupt.java:17)</span><br><span class="line">    at java.lang.Thread.run(Thread.java:748)</span><br><span class="line">18:02:41.532 [t1] c.TestInterrupt - 等锁的过程中被打断</span><br></pre></td></tr></table></figure>
<p>注意如果是不可中断模式，那么即使被 <code>interrupt()</code> 也不会让等待中断</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;启动...&quot;</span>);</span><br><span class="line">    lock.lock(); <span class="comment">// 普通锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获得了锁&quot;</span>); </span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">lock.lock(); </span><br><span class="line">log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">t1.start();</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    t1.interrupt(); <span class="comment">// 执行中断</span></span><br><span class="line">    log.debug(<span class="string">&quot;执行打断&quot;</span>);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">finally</span> &#123; </span><br><span class="line">    log.debug(<span class="string">&quot;释放了锁&quot;</span>); </span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">18:06:56.261 [main] c.TestInterrupt - 获得了锁</span><br><span class="line">18:06:56.265 [t1] c.TestInterrupt - 启动...</span><br><span class="line">18:06:57.266 [main] c.TestInterrupt - 执行打断 // 这时 t1 并没有被真正打断, 而是仍继续等待锁</span><br><span class="line">18:06:58.267 [main] c.TestInterrupt - 释放了锁</span><br><span class="line">18:06:58.267 [t1] c.TestInterrupt - 获得了锁</span><br></pre></td></tr></table></figure>
<h5 id="3124-锁超时"><a class="markdownIt-Anchor" href="#3124-锁超时"></a> 3.12.4 锁超时</h5>
<p>锁超时的意义：<u>主动避免死等</u></p>
<p>使用 <code>lock.tryLock()</code> 方法会返回获取锁是否成功。如果成功则返回 <code>true</code>，反之则返回 <code>false</code>。</p>
<p>并且 <code>tryLock()</code> 方法可以指定<u>等待时间</u>，参数为：<code>tryLock(long timeout, TimeUnit unit)</code>，其中 <code>timeout</code> 为最长等待时间，<code>TimeUnit</code> 为时间单位</p>
<p><strong>简而言之</strong>就是：获取失败了、获取超时了或者被打断了，不再阻塞，直接返回。</p>
<p>例：不设置等待时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(); </span><br><span class="line"></span><br><span class="line"><span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    log.debug(<span class="string">&quot;启动...&quot;</span>); </span><br><span class="line">    <span class="keyword">if</span> (!lock.tryLock()) &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获取立刻失败，返回&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> &#123; </span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="string">&quot;t1&quot;</span>);</span><br><span class="line"></span><br><span class="line">lock.lock();</span><br><span class="line">log.debug(<span class="string">&quot;获得了锁&quot;</span>);</span><br><span class="line">t1.start(); </span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    sleep(<span class="number">2</span>); </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line">    lock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">18:15:02.918 [main] c.TestTimeout - 获得了锁</span><br><span class="line">18:15:02.921 [t1] c.TestTimeout - 启动...</span><br><span class="line">18:15:02.921 [t1] c.TestTimeout - 获取立刻失败，返回</span><br></pre></td></tr></table></figure>
<p>例：设置等待时间</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">		<span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt; &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				<span class="comment">//判断获取锁是否成功，最多等待1秒</span></span><br><span class="line">				<span class="keyword">if</span>(!lock.tryLock(<span class="number">1</span>, TimeUnit.SECONDS)) &#123;</span><br><span class="line">					System.out.println(<span class="string">&quot;获取失败&quot;</span>);</span><br><span class="line">					<span class="comment">//获取失败，不再向下执行，直接返回</span></span><br><span class="line">					<span class="keyword">return</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">				<span class="comment">//被打断，不再向下执行，直接返回</span></span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">&quot;得到了锁&quot;</span>);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// TODO : 临界区代码</span></span><br><span class="line">      &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">      &#125;</span><br><span class="line">		&#125;);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">		lock.lock();</span><br><span class="line">		<span class="keyword">try</span>&#123;</span><br><span class="line">			t1.start();</span><br><span class="line">			<span class="comment">//打断等待</span></span><br><span class="line">			t1.interrupt();</span><br><span class="line">			Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			lock.unlock();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3125-公平锁"><a class="markdownIt-Anchor" href="#3125-公平锁"></a> 3.12.5 公平锁</h5>
<p>在线程获取锁失败，进入阻塞队列时，<strong>先进入</strong>的会在锁被释放后<strong>先获得</strong>锁。这样的获取方式就是<strong>公平</strong>的。但会降低并发度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认是不公平锁，需要在创建时指定为公平锁</span></span><br><span class="line"><span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>(<span class="type">boolean</span> fair);</span><br></pre></td></tr></table></figure>
<h5 id="3126-条件变量"><a class="markdownIt-Anchor" href="#3126-条件变量"></a> 3.12.6 条件变量</h5>
<p>synchronized 中也有条件变量，就是我们讲原理时那个 waitSet 休息室，当条件不满足时进入waitSet 等待</p>
<p>ReentrantLock 的条件变量比 synchronized 强大之处在于，它是支持<strong>多个</strong>条件变量的，这就好比</p>
<ul>
<li>synchronized 是那些不满足条件的线程都在一间休息室等消息</li>
<li>而 ReentrantLock 支持多间休息室，有专门等烟的休息室、专门等早餐的休息室、唤醒时也是按休息室来唤醒</li>
</ul>
<p>使用要点：</p>
<ul>
<li><code>await()</code> 前需要<strong>获得锁</strong></li>
<li><code>await()</code> 执行后，会释放锁，进入 conditionObject 等待</li>
<li><code>await</code> 的线程被唤醒（或打断、或超时）取重新竞争 lock 锁</li>
<li>竞争 lock 锁成功后，从 <code>await</code> 后继续执行</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="comment">// 创建新的条件变量（休息室）</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">condition1</span> <span class="operator">=</span> lock.newCondition();</span><br><span class="line"><span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">condition2</span> <span class="operator">=</span> lock.newCondition(); </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> &#123;</span><br><span class="line">    lock.lock();</span><br><span class="line"></span><br><span class="line">    condition1.await(); <span class="comment">// 进入“休息室”等待</span></span><br><span class="line"></span><br><span class="line">    condition1.signal(); <span class="comment">// 从“休息室”唤醒</span></span><br><span class="line"></span><br><span class="line">    condition1.signalAll();<span class="comment">// 从“休息室”唤醒所有</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Slf4j(topic = &quot;c.TestCorrectPosture&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TestCorrectPostureStep4</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">room</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasCigarette</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="type">boolean</span> <span class="variable">hasTakeout</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line">  	<span class="keyword">static</span> <span class="type">ReentrantLock</span> <span class="variable">ROOM</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line">  	<span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">waitCigaretteSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Condition</span>();</span><br><span class="line">  	<span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">waitTakeOutSet</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Condition</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            ROOM.lock();</span><br><span class="line">          	<span class="keyword">try</span>&#123;</span><br><span class="line">                log.debug(<span class="string">&quot;有烟没？[&#123;&#125;]&quot;</span>, hasCigarette);</span><br><span class="line">                <span class="keyword">while</span> (!hasCigarette) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没烟，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        waitCigaretteSet.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              ROOM.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小南&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            ROOM.lock();</span><br><span class="line">          	<span class="keyword">try</span> &#123;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖送到没？[&#123;&#125;]&quot;</span>, hasTakeout);</span><br><span class="line">                <span class="keyword">while</span> (!hasTakeout) &#123;</span><br><span class="line">                    log.debug(<span class="string">&quot;没外卖，先歇会！&quot;</span>);</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        waitTakeOutSet.await();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                log.debug(<span class="string">&quot;可以开始干活了&quot;</span>);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              ROOM.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;小女&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            ROOM.lock();</span><br><span class="line">          	<span class="keyword">try</span> &#123;</span><br><span class="line">                hasTakeout = <span class="literal">true</span>;</span><br><span class="line">                log.debug(<span class="string">&quot;外卖到了噢！&quot;</span>);</span><br><span class="line">                waitTakeOutSet.signal();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              ROOM.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;送外卖的&quot;</span>).start();</span><br><span class="line">      </span><br><span class="line">      Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            ROOM.lock();</span><br><span class="line">          	<span class="keyword">try</span> &#123;</span><br><span class="line">                hasTakeout = <span class="literal">true</span>;</span><br><span class="line">                log.debug(<span class="string">&quot;烟到了噢！&quot;</span>);</span><br><span class="line">                waitCigaretteSet.signal();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">              ROOM.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="string">&quot;送烟的&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">15:34:20.249 c.Test24	[小女] - 外卖送到没？ [false]</span><br><span class="line">15:34:20.260 c.Test24	[小女] - 没外卖，先歇会！</span><br><span class="line">15:34:20.303 c.Test24	[小南] - 有烟没？[false]</span><br><span class="line">15:34:20.303 c.Test24	[小南] - 没烟，先歇会！</span><br><span class="line">15:34:21.238 c.Test24	[小女] - 可以开始干活了</span><br><span class="line">15:34:22.241 c.Test24	[小南] - 可以开始干活了</span><br></pre></td></tr></table></figure>
<h4 id="313-同步模式-之-顺序控制"><a class="markdownIt-Anchor" href="#313-同步模式-之-顺序控制"></a> 3.13 同步模式 之 顺序控制</h4>
<h5 id="3131-固定运行顺序"><a class="markdownIt-Anchor" href="#3131-固定运行顺序"></a> 3.13.1 固定运行顺序</h5>
<p>比如先打印“2”，再打印“1”</p>
<h6 id="wait-notify-方法"><a class="markdownIt-Anchor" href="#wait-notify-方法"></a> <code>wait / notify 方法</code></h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Object</span> <span class="variable">LOCK</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line"><span class="comment">//判断先执行的内容是否执行完毕</span></span><br><span class="line"><span class="keyword">static</span> <span class="type">Boolean</span> <span class="variable">t2Runned</span> <span class="operator">=</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  </span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">			<span class="keyword">while</span> (!t2Runned) &#123; <span class="comment">// 判断 2 是否打印过</span></span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					LOCK.wait();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">			System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">new</span> <span class="title class_">Thread</span>(()-&gt;&#123;</span><br><span class="line">		<span class="keyword">synchronized</span> (LOCK) &#123;</span><br><span class="line">			System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">			t2Runned = <span class="literal">true</span>;</span><br><span class="line">			LOCK.notify(); <span class="comment">//执行完毕，唤醒所有等待线程</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="park-unpark方法"><a class="markdownIt-Anchor" href="#park-unpark方法"></a> <code>park / unpark方法</code></h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span> &#123;</span><br><span class="line">  </span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span> (() -&gt; &#123;</span><br><span class="line">    LockSupport.park();</span><br><span class="line">    System.out.println(<span class="string">&quot;1&quot;</span>);</span><br><span class="line">  &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">  </span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span> (() -&gt; &#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;2&quot;</span>);</span><br><span class="line">    LockSupport.unpark(t1);</span><br><span class="line">  &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="3132-交替输出"><a class="markdownIt-Anchor" href="#3132-交替输出"></a> 3.13.2 交替输出</h5>
<p>线程 1 输出“a“ 5 次，线程 2 输出 ”b“ 5 次，线程 3 输出 ”c“ 5 次。现在要求输出 abcabcabcabcabc 怎么实现？</p>
<h6 id="wait-notify-方法-2"><a class="markdownIt-Anchor" href="#wait-notify-方法-2"></a> <code>wait / notify 方法</code></h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* </span></span><br><span class="line"><span class="comment">	输出内容			等待标记			下一个标记</span></span><br><span class="line"><span class="comment">	a			1			2</span></span><br><span class="line"><span class="comment">	b			2			3</span></span><br><span class="line"><span class="comment">	c			3			1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WaitSymbol</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> flag; <span class="comment">// 等待标记</span></span><br><span class="line">  <span class="keyword">private</span> <span class="type">int</span> loopNum; <span class="comment">// 循环次数</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">WaitSymbol</span> <span class="params">(<span class="type">int</span> flag, <span class="type">int</span> loopNum)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.flag = flag;</span><br><span class="line">    <span class="built_in">this</span>.loopNum = loopNum;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str, <span class="type">int</span> waitFlag, <span class="type">int</span> nextFlag)</span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;loopNum; i++) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span>(<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span>(flag != waitFlag) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.wait();</span><br><span class="line">          &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.print(str);</span><br><span class="line">        flag = nextFlag;</span><br><span class="line">        <span class="built_in">this</span>.notifyAll();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">WaitSymbol</span> <span class="variable">ws</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WaitSymbol</span>(<span class="number">1</span>,<span class="number">5</span>);</span><br><span class="line">  </span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span> (() -&gt; &#123;</span><br><span class="line">    ws.print(<span class="string">&quot;a&quot;</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">  &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line">  </span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span> (() -&gt; &#123;</span><br><span class="line">    ws.print(<span class="string">&quot;b&quot;</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">  &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line">  </span><br><span class="line">  <span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span> (() -&gt; &#123;</span><br><span class="line">    ws.print(<span class="string">&quot;c&quot;</span>, <span class="number">3</span>, <span class="number">1</span>);</span><br><span class="line">  &#125;, <span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abcabcabcabcabc</span><br></pre></td></tr></table></figure>
<h6 id="reentrantlock-方法"><a class="markdownIt-Anchor" href="#reentrantlock-方法"></a> <code>ReentrantLock 方法</code></h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">AwaitSignal</span> <span class="keyword">extends</span> <span class="title class_">ReentrantLock</span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="type">int</span> <span class="variable">loopNum</span> <span class="operator">=</span> <span class="number">5</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">AwaitSignal</span> <span class="params">(<span class="type">int</span> loopNum)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loopNum = loopNum;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 参数1：打印内容		参数2：进入哪一间休息室		参数3：下一间休息室</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str, Condition current, Condition next)</span> &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;loopNumber; i++) &#123;</span><br><span class="line">			lock();</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				current.await();</span><br><span class="line">				System.out.print(str);</span><br><span class="line">				next.signal();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">				unlock();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="type">AwaitSignal</span> <span class="variable">awaitSignal</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AwaitSignal</span>();</span><br><span class="line"><span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">conditionA</span> <span class="operator">=</span> awaitSignal.newCondition();</span><br><span class="line"><span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">conditionB</span> <span class="operator">=</span> awaitSignal.newCondition();</span><br><span class="line"><span class="keyword">static</span> <span class="type">Condition</span> <span class="variable">conditionC</span> <span class="operator">=</span> awaitSignal.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    </span><br><span class="line">	<span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">		awaitSignal.print(<span class="string">&quot;a&quot;</span>, conditionA, conditionB);</span><br><span class="line">	&#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">	<span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">		awaitSignal.print(<span class="string">&quot;b&quot;</span>, conditionB, conditionC);</span><br><span class="line">	&#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">	<span class="type">Thread</span> <span class="variable">t3</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">		awaitSignal.print(<span class="string">&quot;c&quot;</span>, conditionC, conditionA);</span><br><span class="line">	&#125;, <span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">	awaitSignal.lock();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">    System.out.print(<span class="string">&quot;开始...&quot;</span>);</span><br><span class="line">		conditionA.signal(); <span class="comment">// 唤醒一个等待的线程</span></span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		awaitSignal.unlock();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abcabcabcabcabc</span><br></pre></td></tr></table></figure>
<h6 id="park-unpark-方法"><a class="markdownIt-Anchor" href="#park-unpark-方法"></a> <code>park / unpark 方法</code></h6>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ParkUnpark</span> &#123;</span><br><span class="line">  <span class="keyword">private</span> loopNum;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">ParkUnpark</span><span class="params">(<span class="type">int</span> loopNum)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.loopNum = loopNum;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">(String str, thread next)</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;loopNum; i++) &#123;</span><br><span class="line">      LockSupport.park();</span><br><span class="line">      System.out.print(str);</span><br><span class="line">      LockSupport.unpark(next);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Thread t1;</span><br><span class="line"><span class="keyword">static</span> Thread t2;</span><br><span class="line"><span class="keyword">static</span> Thread t3;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">  <span class="type">ParkUnpark</span> <span class="variable">pu</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ParkUnpark</span>(<span class="number">5</span>);</span><br><span class="line">  t1 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    pu.print(<span class="string">&quot;a&quot;</span>, t2);</span><br><span class="line">  &#125;, <span class="string">&quot;t1&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">	t2 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    pu.print(<span class="string">&quot;b&quot;</span>, t3);</span><br><span class="line">  &#125;, <span class="string">&quot;t2&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">	t3 = <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">    pu.run(<span class="string">&quot;c&quot;</span>, t1);</span><br><span class="line">  &#125;, <span class="string">&quot;t3&quot;</span>).start();</span><br><span class="line">  </span><br><span class="line">  LockSupport.unpark(t1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">abcabcabcabcabc</span><br></pre></td></tr></table></figure>
<h4 id="314-经典问题哲学家就餐问题"><a class="markdownIt-Anchor" href="#314-经典问题哲学家就餐问题"></a> 3.14 经典问题：哲学家就餐问题</h4>
<img src="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/image-20220327221126928.png" alt="image-20220327221126928" style="zoom:50%;">
<p>圆桌上坐着5名哲学家，每两个哲学家之问的桌上摆一根筷子，桌子的中间是一碗米饭。哲学们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时才试图拿起左、右两根筷子（一根一根地拿起）。如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐。当进餐完毕后，放下筷子继续思考。</p>
<ol>
<li>关系分析。系统中有5个哲学家进程，5位哲学家<strong>与左右邻居对其中间筷子的访问</strong>是<strong>互斥关系</strong></li>
<li>整理思路。这个问题中只有互斥关系，但与之前遇到的问题不同的事，每个哲学家进程需要同时持有两个临界资源才能开始吃饭。如何<strong>避免临界资源分配不当造成的死锁现象</strong>，是哲学家问题的精髓。</li>
<li>信号量设置。定义互斥信号量数组<code>chopstick [5] = &#123;1,1,1,1,1&#125;</code>用于实现对5个筷子的互斥访问。并对哲学家按<code>0~4</code>编号，哲学家<code>i</code>左边的筷子编号为<code>i</code>，右边的筷子编号为<code>(i+1) % 5</code>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Semaphore chopstick[<span class="number">5</span>] = <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">Semaphore</span> <span class="variable">mutex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line">Philosoph_i () &#123;    <span class="comment">// i号哲学家进程</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        chopstick[i].down();            <span class="comment">// 拿起左边筷子</span></span><br><span class="line">        chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>].down();      <span class="comment">// 拿起右边筷子</span></span><br><span class="line">        吃饭；</span><br><span class="line">        chopstick[i].up();              <span class="comment">// 放下左边筷子</span></span><br><span class="line">        chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>].up();        <span class="comment">// 放下右边筷子</span></span><br><span class="line">        思考；</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    这种情况下，所有哲学家都会拿起左边的筷子，会造成死锁</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**注意：**这种情况下，所有哲学家都会拿起左边的筷子，会造成 <strong>死锁</strong>。这种解决方案不合理。</p>
<p><strong>如何防止死锁的发生呢？</strong></p>
<ol>
<li>可以对哲学家进程施加一些限制条件，比如最多允许<strong>四个哲学家同时进餐</strong>。这样可以<strong>保证至少有一个哲学家是可以拿到左右两只筷子</strong>的</li>
<li>要求<strong>奇数号哲学家先拿左边的筷子，然后再拿右边的筷子</strong>，而<strong>偶数号哲学家刚好相反</strong>。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一支后再等待另一只的情况。</li>
<li>当且仅当一个哲学家<strong>左右两只筷子都可用时才允许他挂起筷子</strong>。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Semaphore chopstick[<span class="number">5</span>] = <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>);</span><br><span class="line"><span class="type">Semaphore</span> <span class="variable">mutex</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Semaphore</span>(<span class="number">1</span>); <span class="comment">// 互斥地取筷子</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    实现方法3.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">Philosoph_i () &#123;    <span class="comment">// i号哲学家进程</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        mutex.down();                   <span class="comment">// 拿两个筷子的锁</span></span><br><span class="line">        chopstick[i].down();            <span class="comment">// 拿起左边筷子</span></span><br><span class="line">        chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>].down();      <span class="comment">// 拿起右边筷子</span></span><br><span class="line">        mutex.up();</span><br><span class="line">        吃饭；</span><br><span class="line">        chopstick[i].up();              <span class="comment">// 放下左边筷子</span></span><br><span class="line">        chopstick[(i+<span class="number">1</span>)%<span class="number">5</span>].up();        <span class="comment">// 放下右边筷子</span></span><br><span class="line">        思考；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>总结：</strong></p>
<ul>
<li>这些<strong>进程之间只存在互斥关系</strong>，但是与之前接触到的互斥关系不同的是，每个进程都需要同时持有两个临界资源，因此就有“死锁”问题的隐患。</li>
<li>如果在考试中遇到了一个进程需要同时持有<strong>多个临界资源的情况</strong>，应该<strong>参考哲学家问题的思想</strong>，分析题中给出的进程之间<strong>是否会发生循环等待，是否会发生死锁</strong>。</li>
<li>可以参考哲学家就餐问题解决死锁的三种思路</li>
</ul>
<h3 id="4-共享模型之-内存"><a class="markdownIt-Anchor" href="#4-共享模型之-内存"></a> 4 共享模型之 内存</h3>
<p>上一章讲解的 Monitor 主要关注的是访问共享变量时，保证临界区代码的原子性。这一章我们将进一步学习共享变量在多线程间的【可见性】问题与多条指令执行时的【有序性】问题。</p>
<p>本章节单独作为一篇：<a target="_blank" rel="noopener" href="https://dave0126.github.io/2022/08/26/JMM-Java-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/">Java 内存模型 - JMM</a>，点击跳转。</p>
<h3 id="5-共享模型之-无锁"><a class="markdownIt-Anchor" href="#5-共享模型之-无锁"></a> 5 共享模型之 无锁</h3>
<p>在本章中我们会研究一种相对于 <code>Monitor</code>（悲观锁）来实现线程安全的模式（乐观锁/无锁）。</p>
<p>本章节单独作为一篇：<a target="_blank" rel="noopener" href="https://dave0126.github.io/2022/09/15/Java%E4%B8%AD%E7%9A%84%E9%94%81%EF%BC%9A%E4%B9%90%E8%A7%82%E9%94%81/">Java中的锁：乐观锁</a>，点击跳转。</p>
<h3 id="6-并发工具"><a class="markdownIt-Anchor" href="#6-并发工具"></a> 6 并发工具</h3>
<p>在本章中我们会研究一些 Java 提供的并发工具，主要分为以下三个部分：</p>
<ol>
<li><a target="_blank" rel="noopener" href="https://dave0126.github.io/2022/09/16/Java%E4%B8%AD%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%88%86%E6%9E%90/">线程池使用及分析</a></li>
<li><code>java.util.concurrent</code> 并发工具包的使用及源码分析</li>
<li>第三方并发工具</li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://lostnfound.top">Guohao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lostnfound.top/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/">https://lostnfound.top/2022/03/23/JUC-Java多线程-1/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lostnfound.top" target="_blank">Lost N Found</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java/">Java</a><a class="post-meta__tags" href="/tags/JUC/">JUC</a></div><div class="post_share"><div class="social-share" data-image="/linear-gradient(45deg,%20#8EC3B0,%20#9ED5C5,%20#F8C4B4,%20#FF8787)" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Guohao</div><div class="author-info__description">L’existence précède l‘essence</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">25</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">4</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Dave0126" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:dave980126@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%BA%BF%E7%A8%8B%E4%B8%8E%E8%BF%9B%E7%A8%8B"><span class="toc-text"> 1 线程与进程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-%E8%BF%9B%E7%A8%8B"><span class="toc-text"> 1.1 进程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-%E7%BA%BF%E7%A8%8B"><span class="toc-text"> 1.2 线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-%E4%B8%A4%E8%80%85%E5%AF%B9%E6%AF%94"><span class="toc-text"> 1.3 两者对比</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#131-%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%87%E6%8D%A2"><span class="toc-text"> 1.3.1 进程和线程的切换</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-text"> 上下文切换</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2%E5%92%8C%E7%BA%BF%E7%A8%8B%E5%88%87%E6%8D%A2%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB"><span class="toc-text"> 进程切换和线程切换的主要区别</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88tlb%E8%83%BD%E5%8A%A0%E5%BF%AB%E8%AE%BF%E9%97%AE%E9%80%9F%E5%BA%A6"><span class="toc-text"> 为什么TLB能加快访问速度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91"><span class="toc-text"> 1.4 并行与并发</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#15-%E5%BA%94%E7%94%A8"><span class="toc-text"> 1.5 应用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#151-%E5%BA%94%E7%94%A8%E4%B9%8B%E5%BC%82%E6%AD%A5%E8%B0%83%E7%94%A8%E6%A1%88%E4%BE%8B1"><span class="toc-text"> 1.5.1 应用之异步调用（案例1）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E8%AE%BE%E8%AE%A1"><span class="toc-text"> 1) 设计</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E7%BB%93%E8%AE%BA"><span class="toc-text"> 2) 结论</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#152-%E5%BA%94%E7%94%A8%E4%B9%8B%E6%8F%90%E9%AB%98%E6%95%88%E7%8E%87%E6%A1%88%E4%BE%8B1"><span class="toc-text"> 1.5.2 应用之提高效率（案例1）</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%93%E8%AE%BA"><span class="toc-text"> 结论</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-java-%E7%BA%BF%E7%A8%8B"><span class="toc-text"> 2 Java 线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#21-%E5%88%9B%E5%BB%BA%E5%92%8C%E8%BF%90%E8%A1%8C%E7%BA%BF%E7%A8%8B"><span class="toc-text"> 2.1 创建和运行线程</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%80%E7%9B%B4%E6%8E%A5%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8%E5%88%9B%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BA%BF%E7%A8%8B"><span class="toc-text"> 方法一：直接使用构造器创建一个线程</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E4%BD%BF%E7%94%A8-runnable-%E9%85%8D%E5%90%88-thread%E6%8E%A8%E8%8D%90"><span class="toc-text"> 方法二：使用 Runnable 配合 Thread（推荐）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%BA%8C%E7%9A%84%E7%AE%80%E5%8C%96%E4%BD%BF%E7%94%A8lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E7%AE%80%E5%8C%96%E6%93%8D%E4%BD%9C"><span class="toc-text"> 方法二的简化：使用lambda表达式简化操作</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#thread-%E4%B8%8E-runnable-%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-text"> Thread 与 Runnable 的关系</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%96%B9%E6%B3%95%E4%B8%89%E4%BD%BF%E7%94%A8-futuretask-%E4%B8%8E-thread-%E7%BB%93%E5%90%88"><span class="toc-text"> 方法三：使用 FutureTask 与 Thread 结合</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#22-%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C"><span class="toc-text"> 2.2 原理之线程运行</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#221-%E6%A0%88%E4%B8%8E%E6%A0%88%E5%B8%A7"><span class="toc-text"> 2.2.1 栈与栈帧</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#jvm-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-text"> JVM 工作流程：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#222-%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E5%88%87%E6%8D%A2"><span class="toc-text"> 2.2.2 线程上下文切换</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#23-%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95"><span class="toc-text"> 2.3 常见方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#231-start-vs-run"><span class="toc-text"> 2.3.1 start() vs run()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#232-sleep-vs-yield"><span class="toc-text"> 2.3.2 sleep() vs yield()</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#sleep-%E4%BD%BF%E7%BA%BF%E7%A8%8B%E9%98%BB%E5%A1%9E"><span class="toc-text"> sleep() 使线程阻塞</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#yield-%E8%AE%A9%E5%87%BA%E5%BD%93%E5%89%8D%E7%BA%BF%E7%A8%8B"><span class="toc-text"> yield() 让出当前线程</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-text"> 线程优先级</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#233-join"><span class="toc-text"> 2.3.3 join()</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#234-interrupt"><span class="toc-text"> 2.3.4 interrupt()</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#interrupt-%E7%9A%84%E5%BA%94%E7%94%A8%E4%B8%A4%E9%98%B6%E6%AE%B5%E7%BB%88%E6%AD%A2%E6%A8%A1%E5%BC%8F"><span class="toc-text"> interrupt() 的应用——两阶段终止模式</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#235-%E4%B8%BB%E7%BA%BF%E7%A8%8B%E4%B8%8E%E5%AE%88%E6%8A%A4%E7%BA%BF%E7%A8%8B"><span class="toc-text"> 2.3.5 主线程与守护线程</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#24-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81"><span class="toc-text"> 2.4 线程的状态</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#241-%E4%BA%94%E7%A7%8D%E7%8A%B6%E6%80%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B1%82%E9%9D%A2"><span class="toc-text"> 2.4.1 五种状态（操作系统层面）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#242-%E5%85%AD%E7%A7%8D%E7%8A%B6%E6%80%81java-api-%E5%B1%82%E9%9D%A2"><span class="toc-text"> 2.4.2 六种状态（JAVA API 层面）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#25-%E4%B9%A0%E9%A2%98"><span class="toc-text"> 2.5 习题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#251-%E7%BB%9F%E7%AD%B9%E6%96%B9%E6%B3%95%E7%83%A7%E6%B0%B4%E6%B3%A1%E8%8C%B6"><span class="toc-text"> 2.5.1 统筹方法（烧水泡茶）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#26-%E5%B0%8F%E7%BB%93"><span class="toc-text"> 2.6 小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B-monitor"><span class="toc-text"> 3 共享模型之 Monitor</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#31-%E5%85%B1%E4%BA%AB%E5%B8%A6%E6%9D%A5%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text"> 3.1 共享带来的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#311-%E4%B8%B4%E7%95%8C%E5%8C%BA-critical-section"><span class="toc-text"> 3.1.1 临界区 Critical Section</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#312-%E7%AB%9E%E6%80%81%E6%9D%A1%E4%BB%B6-race-condition"><span class="toc-text"> 3.1.2 竞态条件 Race Condition</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#32-synchronized-%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-text"> 3.2 Synchronized 解决方案</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#321-%E8%A7%A3%E5%86%B3%E6%89%8B%E6%AE%B5"><span class="toc-text"> 3.2.1 解决手段</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#322-synchronized-%E8%AF%AD%E6%B3%95"><span class="toc-text"> 3.2.2 Synchronized 语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#323-synchronized-%E5%9C%A8%E6%96%B9%E6%B3%95%E4%B8%8A"><span class="toc-text"> 3.2.3 Synchronized 在方法上</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#33-%E5%8F%98%E9%87%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90"><span class="toc-text"> 3.3 变量的线程安全分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#331-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90"><span class="toc-text"> 3.3.1 成员变量和静态变量的线程安全分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#332-%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E5%88%86%E6%9E%90"><span class="toc-text"> 3.3.2 局部变量线程安全分析</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#333-%E5%B8%B8%E8%A7%81%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%B1%BB"><span class="toc-text"> 3.3.3 常见线程安全类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#334-%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%B1%BB%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7"><span class="toc-text"> 3.3.4 不可变类线程安全性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#335-%E4%B9%A0%E9%A2%98"><span class="toc-text"> 3.3.5 习题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#34-monitor"><span class="toc-text"> 3.4 Monitor</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#340-java-%E5%AF%B9%E8%B1%A1%E5%A4%B4"><span class="toc-text"> 3.4.0 Java 对象头</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#341-monitor-%E5%8E%9F%E7%90%86"><span class="toc-text"> 3.4.1 Monitor 原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#342-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-text"> 3.4.2 轻量级锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#343-%E9%94%81%E8%86%A8%E8%83%80"><span class="toc-text"> 3.4.3 锁膨胀</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#344-%E8%87%AA%E6%97%8B%E4%BC%98%E5%8C%96"><span class="toc-text"> 3.4.4 自旋优化</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E6%88%90%E5%8A%9F%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-text"> 自旋成功的情况</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E8%87%AA%E6%97%8B%E9%87%8D%E8%AF%95%E5%A4%B1%E8%B4%A5%E7%9A%84%E6%83%85%E5%86%B5"><span class="toc-text"> 自旋重试失败的情况</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#345-%E5%81%8F%E5%90%91%E9%94%81"><span class="toc-text"> 3.4.5 偏向锁</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%81%8F%E5%90%91%E7%8A%B6%E6%80%81"><span class="toc-text"> 偏向状态</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%92%A4%E9%94%80%E5%81%8F%E5%90%91"><span class="toc-text"> 撤销偏向</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E9%87%8D%E5%81%8F%E5%90%91"><span class="toc-text"> 批量重偏向</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%89%B9%E9%87%8F%E6%92%A4%E9%94%80"><span class="toc-text"> 批量撤销</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#35-wait-notify"><span class="toc-text"> 3.5 Wait() &#x2F; Notify()</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#351-api%E4%BB%8B%E7%BB%8D"><span class="toc-text"> 3.5.1 API介绍</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#352-wait-%E5%92%8C-sleep-%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text"> 3.5.2 wait() 和 sleep() 的区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#36-%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F-%E4%B9%8B-%E4%BF%9D%E6%8A%A4%E6%80%A7%E6%9A%82%E5%81%9C"><span class="toc-text"> 3.6 同步模式 之 保护性暂停</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#361-join-%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text"> 3.6.1 join() 的原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#362-%E6%89%A9%E5%B1%95-future-%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-text"> 3.6.2 扩展 - Future 的原理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#37-%E5%BC%82%E6%AD%A5%E6%A8%A1%E5%BC%8F-%E4%B9%8B-%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85"><span class="toc-text"> 3.7 异步模式 之 生产者&#x2F;消费者</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#371-%E8%A6%81%E7%82%B9"><span class="toc-text"> 3.7.1 要点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#372-%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 3.7.2 实现</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#38-park-unpark"><span class="toc-text"> 3.8 park() &amp; unpark()</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#381-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="toc-text"> 3.8.1 基本使用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#382-%E7%89%B9%E7%82%B9"><span class="toc-text"> 3.8.2 特点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#383-%E5%8E%9F%E7%90%86"><span class="toc-text"> 3.8.3 原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#384-park-unpark-%E6%80%BB%E7%BB%93"><span class="toc-text"> 3.8.4 park &#x2F; unpark 总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#39-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2"><span class="toc-text"> 3.9 线程状态转换</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%83%85%E5%86%B5%E4%B8%80tstart-new-runnable"><span class="toc-text"> 情况一：t.start() : NEW --&gt; RUNNABLE</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%83%85%E5%86%B5%E4%BA%8Cwaitnotify-runnable-waiting"><span class="toc-text"> 情况二：wait&#x2F;notify : RUNNABLE &lt;--&gt; WAITING</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%83%85%E5%86%B5%E4%B8%89tjoin-runnable-waiting"><span class="toc-text"> 情况三：t.join() : RUNNABLE &lt;--&gt; WAITING</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%83%85%E5%86%B5%E5%9B%9Bparkunpark-runnable-waiting"><span class="toc-text"> 情况四：park&#x2F;unpark : RUNNABLE &lt;--&gt; WAITING</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%83%85%E5%86%B5%E4%BA%94-waitnotify-long-n-runnable-timed_waiting"><span class="toc-text"> 情况五： wait&#x2F;notify (long n) : RUNNABLE &lt;--&gt; TIMED_WAITING</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%83%85%E5%86%B5%E5%85%ADtjoinlong-n-runnable-timed_waiting"><span class="toc-text"> 情况六：t.join(long n) : RUNNABLE &lt;--&gt; TIMED_WAITING</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%83%85%E5%86%B5%E4%B8%83threadsleeplong-n-runnable-timed_waiting"><span class="toc-text"> 情况七：Thread.sleep(long n) : RUNNABLE &lt;--&gt; TIMED_WAITING</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%83%85%E5%86%B5%E5%85%ABparknanosunpark-long-n-runnable-timed_waiting"><span class="toc-text"> 情况八：parkNanos&#x2F;unpark (long n) : RUNNABLE &lt;--&gt; TIMED_WAITING</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%83%85%E5%86%B5%E4%B9%9D%E9%98%BB%E5%A1%9E%E5%9C%A8entrylist-runnable-blocked"><span class="toc-text"> 情况九：阻塞在EntryList : RUNNABLE &lt;--&gt; BLOCKED</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%83%85%E5%86%B5%E5%8D%81-%E6%89%A7%E8%A1%8C%E5%AE%8C%E6%AF%95-runnable-terminated"><span class="toc-text"> 情况十： 执行完毕 : RUNNABLE --&gt; TERMINATED</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#310-%E5%A4%9A%E6%8A%8A%E9%94%81"><span class="toc-text"> 3.10 多把锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#311-%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%B4%BB%E8%B7%83%E6%80%A7"><span class="toc-text"> 3.11 线程的活跃性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3111-%E6%AD%BB%E9%94%81"><span class="toc-text"> 3.11.1 死锁</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E5%8F%91%E7%94%9F%E6%AD%BB%E9%94%81%E7%9A%84%E5%BF%85%E8%A6%81%E6%9D%A1%E4%BB%B6"><span class="toc-text"> 发生死锁的必要条件</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text"> 避免死锁的方法</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3112-%E6%B4%BB%E9%94%81"><span class="toc-text"> 3.11.2 活锁</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E9%81%BF%E5%85%8D%E6%B4%BB%E9%94%81%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-text"> 避免活锁的方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%AD%BB%E9%94%81%E4%B8%8E%E6%B4%BB%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-text"> 死锁与活锁的区别</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3113-%E9%A5%A5%E9%A5%BF"><span class="toc-text"> 3.11.3 饥饿</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3114-%E6%AD%BB%E9%94%81-%E9%A5%A5%E9%A5%BF%E5%92%8C%E6%AD%BB%E5%BE%AA%E7%8E%AF%E7%9A%84%E5%BC%82%E5%90%8C%E7%82%B9"><span class="toc-text"> 3.11.4 死锁、饥饿和死循环的异同点</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3115-%E9%A2%84%E9%98%B2%E6%AD%BB%E9%94%81-%E9%9D%99%E6%80%81%E7%AD%96%E7%95%A5"><span class="toc-text"> 3.11.5 预防死锁 - 静态策略</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#31151-%E8%B5%84%E6%BA%90%E5%88%86%E9%85%8D%E5%9B%BEgraphe-dallocation"><span class="toc-text"> 3.11.5.1 资源分配图（Graphe d’allocation）</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#31152-%E6%AD%BB%E9%94%81%E7%9A%84%E8%A7%A3%E9%99%A4"><span class="toc-text"> 3.11.5.2 死锁的解除</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3116-%E9%81%BF%E5%85%8D%E6%AD%BB%E9%94%81-%E5%8A%A8%E6%80%81%E7%AD%96%E7%95%A5"><span class="toc-text"> 3.11.6 避免死锁 - 动态策略</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#31161-%E5%AE%89%E5%85%A8%E5%BA%8F%E5%88%97"><span class="toc-text"> 3.11.6.1 安全序列</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#31162-%E9%93%B6%E8%A1%8C%E5%AE%B6%E7%AE%97%E6%B3%95"><span class="toc-text"> 3.11.6.2 银行家算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#312-reentrantlock-%E5%8F%AF%E9%87%8D%E5%85%A5%E9%94%81"><span class="toc-text"> 3.12 ReentrantLock (可重入锁)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3121-%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text"> 3.12.1 基本语法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3122-%E5%8F%AF%E9%87%8D%E5%85%A5"><span class="toc-text"> 3.12.2 可重入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3123-%E5%8F%AF%E6%89%93%E6%96%AD"><span class="toc-text"> 3.12.3 可打断</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3124-%E9%94%81%E8%B6%85%E6%97%B6"><span class="toc-text"> 3.12.4 锁超时</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3125-%E5%85%AC%E5%B9%B3%E9%94%81"><span class="toc-text"> 3.12.5 公平锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3126-%E6%9D%A1%E4%BB%B6%E5%8F%98%E9%87%8F"><span class="toc-text"> 3.12.6 条件变量</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#313-%E5%90%8C%E6%AD%A5%E6%A8%A1%E5%BC%8F-%E4%B9%8B-%E9%A1%BA%E5%BA%8F%E6%8E%A7%E5%88%B6"><span class="toc-text"> 3.13 同步模式 之 顺序控制</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#3131-%E5%9B%BA%E5%AE%9A%E8%BF%90%E8%A1%8C%E9%A1%BA%E5%BA%8F"><span class="toc-text"> 3.13.1 固定运行顺序</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#wait-notify-%E6%96%B9%E6%B3%95"><span class="toc-text"> wait &#x2F; notify 方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#park-unpark%E6%96%B9%E6%B3%95"><span class="toc-text"> park &#x2F; unpark方法</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3132-%E4%BA%A4%E6%9B%BF%E8%BE%93%E5%87%BA"><span class="toc-text"> 3.13.2 交替输出</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#wait-notify-%E6%96%B9%E6%B3%95-2"><span class="toc-text"> wait &#x2F; notify 方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#reentrantlock-%E6%96%B9%E6%B3%95"><span class="toc-text"> ReentrantLock 方法</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#park-unpark-%E6%96%B9%E6%B3%95"><span class="toc-text"> park &#x2F; unpark 方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#314-%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98%E5%93%B2%E5%AD%A6%E5%AE%B6%E5%B0%B1%E9%A4%90%E9%97%AE%E9%A2%98"><span class="toc-text"> 3.14 经典问题：哲学家就餐问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B-%E5%86%85%E5%AD%98"><span class="toc-text"> 4 共享模型之 内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%85%B1%E4%BA%AB%E6%A8%A1%E5%9E%8B%E4%B9%8B-%E6%97%A0%E9%94%81"><span class="toc-text"> 5 共享模型之 无锁</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E5%B9%B6%E5%8F%91%E5%B7%A5%E5%85%B7"><span class="toc-text"> 6 并发工具</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background: #8EC3B0"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2022 By Guohao</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: 'ea138c6f176d57705144',
      clientSecret: 'c999d74b366c68c80bc3b704c716a8ff8d67af6d',
      repo: 'Dave0126.github.io',
      owner: 'Dave0126',
      admin: ['Dave0126'],
      id: '65a08bd37fb3507f207b3f52a6a43f67',
      updateCountCallback: commentCount
    },))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !true) {
  if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div></div></body></html>