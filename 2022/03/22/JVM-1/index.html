<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dave0126.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="JVM 基础学习视频课程: BiliBili - 黑马程序员JVM完整教程  第一章：JVM 结构 第二章：JVM 内存结构 第三章：JVM 垃圾回收 第四章：">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 虚拟机 - JVM">
<meta property="og:url" content="https://dave0126.github.io/2022/03/22/JVM-1/index.html">
<meta property="og:site_name" content="Lost N Found">
<meta property="og:description" content="JVM 基础学习视频课程: BiliBili - 黑马程序员JVM完整教程  第一章：JVM 结构 第二章：JVM 内存结构 第三章：JVM 垃圾回收 第四章：">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/image-20220719142025243.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/image-20220719142921758.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/image-20220719144541816.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/IMG_6B2CE85A4DCA-1.jpeg">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/IMG_9A689689FB20-1.jpeg">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/IMG_42907AA7BAF6-1.jpeg">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/image-20220816162626624.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/image-20220816163058539.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/20200608150750%20(1).png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/20200608150800.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/20200608150813.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/20200608150827.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/20200608150842.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/20200608150856.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/20200608150907.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/20200608150919.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/20200608150931.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/20200608150939.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/20200608150946.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/20200608150955.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/20200608151002.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/20200608151010.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/20200608151018.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/IMG_FB5339E468EB-1.jpeg">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/image-20220818231033690.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/image-20220818231641184.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/image-20220818235606862.png">
<meta property="article:published_time" content="2022-03-22T20:52:44.000Z">
<meta property="article:modified_time" content="2022-08-18T22:00:42.318Z">
<meta property="article:author" content="Guohao">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://dave0126.github.io/2022/03/22/JVM-1/image-20220719142025243.png">

<link rel="canonical" href="https://dave0126.github.io/2022/03/22/JVM-1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java 虚拟机 - JVM | Lost N Found</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Lost N Found" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Lost N Found</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/Dave0126" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dave0126.github.io/2022/03/22/JVM-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Guohao">
      <meta itemprop="description" content="间歇性踌躇满志, 持续性划水摸鱼">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lost N Found">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java 虚拟机 - JVM
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-22 21:52:44" itemprop="dateCreated datePublished" datetime="2022-03-22T21:52:44+01:00">2022-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-19 00:00:42" itemprop="dateModified" datetime="2022-08-19T00:00:42+02:00">2022-08-19</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>28k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>25 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="JVM-基础学习"><a href="#JVM-基础学习" class="headerlink" title="JVM 基础学习"></a>JVM 基础学习</h1><p>视频课程: <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1yE411Z7AP">BiliBili - 黑马程序员JVM完整教程</a></p>
<ul>
<li><a href="#一、JVM-结构">第一章：JVM 结构</a></li>
<li><a href="#二、JVM-内存结构">第二章：JVM 内存结构</a></li>
<li><a href="#三、JVM-垃圾回收">第三章：JVM 垃圾回收</a></li>
<li><a href>第四章：</a></li>
</ul>
<span id="more"></span>
<h2 id="什么是-JVM？"><a href="#什么是-JVM？" class="headerlink" title="什么是 JVM？"></a>什么是 JVM？</h2><p><code>JVM (Java Virtual Machine)</code> 是 Java 程序的运行环境(Java 二进制字节码的运行环境)</p>
<p><strong>好处:</strong></p>
<ul>
<li>可以提供一个跨平台的一致的运行环境, 达到平台无关性；</li>
<li>提供内存管理, 垃圾回收功能；</li>
</ul>
<p><code>JRE = JVM + 基础类库</code></p>
<p><code>JDK = JVM + 基础类库 + 编译工具</code></p>
<p><img src="/2022/03/22/JVM-1/image-20220719142025243.png" alt="image-20220719142025243" style="zoom:40%;"></p>
<h2 id="一、JVM-结构"><a href="#一、JVM-结构" class="headerlink" title="一、JVM 结构"></a>一、JVM 结构</h2><p><img src="/2022/03/22/JVM-1/image-20220719142921758.png" alt="image-20220719142921758"></p>
<p>总体分为三大部分：</p>
<ul>
<li><code>ClassLoader</code> 类加载器：<code>Java</code> 代码编译成二进制后，会经过类加载器，这样才能加载到 <code>JVM</code> 中运行。</li>
<li><code>JVM</code> 内存结构</li>
<li>执行引擎</li>
</ul>
<h2 id="二、JVM-内存结构"><a href="#二、JVM-内存结构" class="headerlink" title="二、JVM 内存结构"></a>二、JVM 内存结构</h2><ol>
<li>程序计数器 (Program Counter Register)</li>
<li>虚拟机栈 (JVM Stacks)</li>
<li>本地方法栈 (Native Method Stacks)</li>
<li>堆 (Heap)</li>
<li>方法区 (Method Area)</li>
</ol>
<h3 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1. 程序计数器"></a>1. 程序计数器</h3><p>Java中 <code>JVM</code> 指令的实行流程</p>
<p><img src="/2022/03/22/JVM-1/image-20220719144541816.png" alt="image-20220719144541816" style="zoom:50%;"></p>
<p>作用: 在指令的执行中, 记住<strong>下一条 <code>JVM</code> 指令的执行地址</strong>. 在物理上可使用<strong>寄存器</strong>实现.</p>
<p>特点:</p>
<ul>
<li>线程私有。在多线程下, 线程间切换时需要保存当前环境, 需要用到程序计数器记住下一条 <code>JVM</code> 指令的执行地址</li>
<li>不存在内存溢出。</li>
</ul>
<h3 id="2-虚拟机栈"><a href="#2-虚拟机栈" class="headerlink" title="2. 虚拟机栈"></a>2. 虚拟机栈</h3><h4 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h4><p>回忆数据结构中“<strong>栈</strong>”的结构: 先进后出</p>
<p>虚拟机栈是<strong><u>线程</u>运行需要的内存空间</strong>，<strong>一个栈由多个栈帧组成</strong>。一个栈帧对应一次方法的调用，<strong>栈帧(Frame)</strong>即<strong>每个方法调用时需要的内存(参数、局部变量、返回地址等)</strong>。</p>
<ul>
<li>每个线程只能有一个<strong><u>活动栈帧</u></strong>，对应着<strong><u>当前正在执行的那个方法</u></strong>，栈顶的栈帧。</li>
</ul>
<blockquote>
<p>注意⚠️：可以在 IDEA 中用 “debug” 模式下的“Debugger”视图中看到栈和栈帧.</p>
</blockquote>
<p><strong>思考:</strong></p>
<ul>
<li>在函数的调用中, <ol>
<li>先把主调函数入栈，调用被调函数，紧接着被调函数入栈，活动栈帧为被调函数；</li>
<li>等被调函数返回返回值时，被调函数出栈，活动栈帧为主调函数。</li>
</ol>
</li>
<li><u>垃圾回收不涉及栈内存</u>, 因为每次执行后栈内存都会被清空(出栈)</li>
<li><p>栈内存越大, 线程数越小 (默认 1024KB)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xss 1m or 1024k or 1048576</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-2-栈内存溢出"><a href="#2-2-栈内存溢出" class="headerlink" title="2.2 栈内存溢出"></a>2.2 栈内存溢出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.StackOverflowError</span><br></pre></td></tr></table></figure>
<ol>
<li><p>栈帧过多导致内存溢出</p>
<ul>
<li><p>想象一下，在不断的调用方法时，一直入栈没有出栈，直到某一次调用时无法分配新的栈帧内存。</p>
<p>e.g. 无递归终止条件的<strong>递归调用</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackOverflowTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> count;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      method1();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable a) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      System.out.print(count);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    count++;</span><br><span class="line">    method1();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>栈帧过大导致内存溢出，栈帧 &gt; 栈内存</li>
</ol>
<h4 id="2-3-线程运行诊断"><a href="#2-3-线程运行诊断" class="headerlink" title="2.3 线程运行诊断"></a>2.3 线程运行诊断</h4><p>如何查看某个进程中 CPU 的占用情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps H -eo pid,tid,%cpu | grep 进程id</span><br></pre></td></tr></table></figure>
<p><code>JDK</code> 自带一个工具 <code>JStack</code> 命令, 用于定位 CPU占用过多的 Java线程(TID). 根据线程 id(TID) 找到有问题的线程,即可能有问题的代码行数. 也可以发现<strong>有死锁的进程</strong>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack 进程id(PID)</span><br></pre></td></tr></table></figure>
<h3 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3. 本地方法栈"></a>3. 本地方法栈</h3><p>本地方法是由于 Java 语言限制, 不能直接和操作系统底层“打交道”，所以需要 <code>c/c++</code> 语言编写的方法直接与底层操作系统“打交道”， 而java代码可以使用本地方法调用来调用这些方法。</p>
<p>本地方法使用的内存就是本地方法栈.</p>
<ul>
<li>例如 <code>hashCode()</code>, <code>wait()</code>, <code>notify()</code>, <code>notifyAll()</code> 等</li>
<li>由 <code>native</code> 修饰</li>
</ul>
<h3 id="4-堆"><a href="#4-堆" class="headerlink" title="4. 堆"></a>4. 堆</h3><p>线程共享的区域，都要考虑线程安全问题</p>
<h4 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h4><ul>
<li>通过 <code>new</code> 关键字 $\to$ 创建一个堆，都会使用堆的内存</li>
</ul>
<p>特点:</p>
<ul>
<li><strong><u>线程共享</u></strong>，堆中对象都要考虑线程安全问题</li>
<li><strong><u>有垃圾回收机制</u></strong>，当对象不再被引用时，其占用的内存会被回收</li>
</ul>
<h4 id="4-2-堆内存溢出"><a href="#4-2-堆内存溢出" class="headerlink" title="4.2 堆内存溢出"></a>4.2 堆内存溢出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 创建堆</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            list.add(a);</span><br><span class="line">            a = a + a; <span class="comment">// Hello, HelloHello, HelloHelloHelloHello, ....</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-3-堆内存诊断"><a href="#4-3-堆内存诊断" class="headerlink" title="4.3 堆内存诊断"></a>4.3 堆内存诊断</h4><p><code>Java</code> 常用工具:</p>
<ol>
<li><code>jps</code> 工具<ul>
<li>查看当前系统中有哪些java进程</li>
</ul>
</li>
<li><code>jmap</code> 工具 <ul>
<li>查看某一时刻下,堆内存的占用情况</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ jps</span><br><span class="line">$ jmap -heap 进程id(PID)</span><br></pre></td></tr></table></figure>
<ol>
<li><code>jconsole</code> 工具<ul>
<li>图形界面的, 多功能的检查工具, 可以连续监测</li>
</ul>
</li>
<li><code>jvisualvm</code> 工具 (需要自行下载)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;1....&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">    <span class="type">byte</span>[] array = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>];  <span class="comment">// 堆中内存占用新增10MB</span></span><br><span class="line">    System.out.println(<span class="string">&quot;2....&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">    array = <span class="literal">null</span>;</span><br><span class="line">    System.gc();                                <span class="comment">// 垃圾回收</span></span><br><span class="line">    System.out.println(<span class="string">&quot;3....&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5. 方法区"></a>5. 方法区</h3><h4 id="5-1-定义"><a href="#5-1-定义" class="headerlink" title="5.1 定义"></a>5.1 定义</h4><p>方法区是 <code>JVM</code> 中<strong>所有线程共享</strong>的区域.</p>
<p>存储了与<strong>类</strong>结构相关的信息: </p>
<ul>
<li>成员变量 (field)</li>
<li>方法的数据 (method data)</li>
<li>方法的代码 (code of method)</li>
<li>构造器的代码 (code of constructor)</li>
<li>运行时常量池 (run-time constant pool)</li>
</ul>
<p>方法区在 <code>JVM</code> <strong><u>启动时</u></strong>创建，逻辑上是<u><strong>堆</strong></u>的一部分。</p>
<h4 id="5-2-组成"><a href="#5-2-组成" class="headerlink" title="5.2 组成"></a>5.2 组成</h4><p>JDK 1.6 与 JDK 1.8。</p>
<ul>
<li>JDK 1.6 中，方法区这种概念的实现方式（永久代）属于 <code>JVM</code> 的内存结构；</li>
<li>JDK 1.8 中，方法区这种概念的实现方式（元空间）从 <code>JVM</code> 的内存结构中提取出来，属于操作系统内存结构的一部分</li>
</ul>
<p><img src="/2022/03/22/JVM-1/IMG_6B2CE85A4DCA-1.jpeg" alt="methodArea"></p>
<h4 id="5-3-方法区的内存溢出"><a href="#5-3-方法区的内存溢出" class="headerlink" title="5.3 方法区的内存溢出"></a>5.3 方法区的内存溢出</h4><ul>
<li>永久代内存溢出（JDK 1.8以前）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR INFO: java.lang.OutOfMemoryError: PermGen space</span><br><span class="line">-XX:MaxPermSize=8m</span><br></pre></td></tr></table></figure>
<ul>
<li>元空间内存溢出（JDK 1.8以后）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR INFO: java.lang.OutOfMemoryError: Metaspace</span><br><span class="line">-XX:MaxMetaspaceSize=8m</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123; <span class="comment">// 类加载器: 可以用来加载类的二进制字节码, 动态加载</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">Demo</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++, j++) &#123;</span><br><span class="line">        <span class="type">ClassWriter</span> <span class="variable">cw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(<span class="number">0</span>); <span class="comment">// ClassWriter作用是生成类的二进制字节码</span></span><br><span class="line">        cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, <span class="string">&quot;Class&quot;</span> + i, <span class="literal">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="literal">null</span>); </span><br><span class="line">        <span class="comment">// 版本号, public, 类名:1~10000, 包名:null, 父类: 继承自&quot;java/lang/Object&quot;, 接口名:null</span></span><br><span class="line">        <span class="comment">//返回 byte[]</span></span><br><span class="line">        <span class="type">byte</span>[] code = cw.toByteArray();</span><br><span class="line">        <span class="comment">// 只执行类的加载, 而不链接</span></span><br><span class="line">        test.defineClass(<span class="string">&quot;Class&quot;</span> + i, code, <span class="number">0</span>, code.length); <span class="comment">// class 对象</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      System.out.println(j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有可能的溢出场景：实际生产中，动态产生并加载类时容易产生这种内存溢出</p>
<ol>
<li><code>Spring</code> 框架中的 <code>cglib</code> 字节码技术，<code>AOP</code> 的核心 - 生成动态代理类</li>
<li><code>Mybatis</code> 框架中的 <code>cglib</code> 字节码技术</li>
</ol>
<h4 id="5-4-运行时常量池"><a href="#5-4-运行时常量池" class="headerlink" title="5.4 运行时常量池"></a>5.4 运行时常量池</h4><p>编译后的<strong>二进制字节码</strong>包含: <u>类基本信息</u>、<u>常量池</u>、<u>类方法定义</u>、<u>虚拟机指令</u></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -v &lt;xxx.class&gt; // -v 显示反编译后的详细信息</span><br></pre></td></tr></table></figure>
<p>例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反编译后的详细信息: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">Classfile /test.class											// 类基本信息</span><br><span class="line">  Last modified 2022年3月6日; size 413 bytes</span><br><span class="line">  SHA-256 checksum 7ab757ee2d78f0e76a52ba8b03b43fee2fe9d7994d74bc7d133b2e309ceed8f3</span><br><span class="line">  Compiled from &quot;test.java&quot;</span><br><span class="line">public class test</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 59</span><br><span class="line">  flags: (0x0021) ACC_PUBLIC, ACC_SUPER		// 访问修饰符</span><br><span class="line">  this_class: #21                         // test</span><br><span class="line">  super_class: #2                         // 父类:java/lang/Object</span><br><span class="line">  interfaces: 0, fields: 0, methods: 2, attributes: 1</span><br><span class="line">  </span><br><span class="line">Constant pool:														// 常量池</span><br><span class="line">   #1 = Methodref          #2.#3          // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Class              #4             // java/lang/Object</span><br><span class="line">   #3 = NameAndType        #5:#6          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #4 = Utf8               java/lang/Object</span><br><span class="line">   #5 = Utf8               &lt;init&gt;</span><br><span class="line">   #6 = Utf8               ()V</span><br><span class="line">   #7 = Fieldref           #8.#9          // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #8 = Class              #10            // java/lang/System</span><br><span class="line">   #9 = NameAndType        #11:#12        // out:Ljava/io/PrintStream;</span><br><span class="line">  #10 = Utf8               java/lang/System</span><br><span class="line">  #11 = Utf8               out</span><br><span class="line">  #12 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #13 = String             #14            // Hello World</span><br><span class="line">  #14 = Utf8               Hello World</span><br><span class="line">  #15 = Methodref          #16.#17        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">  #16 = Class              #18            // java/io/PrintStream</span><br><span class="line">  #17 = NameAndType        #19:#20        // println:(Ljava/lang/String;)V</span><br><span class="line">  #18 = Utf8               java/io/PrintStream</span><br><span class="line">  #19 = Utf8               println</span><br><span class="line">  #20 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">  #21 = Class              #22            // test</span><br><span class="line">  #22 = Utf8               test</span><br><span class="line">  #23 = Utf8               Code</span><br><span class="line">  #24 = Utf8               LineNumberTable</span><br><span class="line">  #25 = Utf8               main</span><br><span class="line">  #26 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #27 = Utf8               SourceFile</span><br><span class="line">  #28 = Utf8               test.java</span><br><span class="line">  </span><br><span class="line">&#123;																// 方法定义的区域</span><br><span class="line">  public test();								// 当程序没有构造方法时, 编译器会默认生成一个无参的构造方法</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (0x0001) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1		// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 1: 0</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);	// main方法</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: (0x0009) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">      // 虚拟机指令				#n: 对应着常量池中的变量</span><br><span class="line">         0: getstatic     #7		// Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #13		// String Hello World 加载引用地址</span><br><span class="line">         5: invokevirtual #15		// Method java/io/PrintStream.println:(Ljava/lang/String)V</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">        line 4: 8</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;test.java&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>常量池</strong>就是<u>一张常量查找表</u>，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量(如字符串、整型、bool类型等)等信息；</li>
<li>运行时常量池，就是当该类被加载时，它的常量池信息会放入运行常量池，地址会替换为真正的内存地址。</li>
</ul>
<h4 id="5-5-StringTable串池"><a href="#5-5-StringTable串池" class="headerlink" title="5.5 StringTable串池"></a>5.5 <em>StringTable</em>串池</h4><p>特征：</p>
<ul>
<li><p>常量池中的信息，都会被加载到运行时常量池中。这时 <code>&quot;a&quot;, &quot;b&quot;, &quot;ab&quot;</code> 都是常量池中的符号，<strong>还不是 字符串对象</strong></p>
</li>
<li><p>常量池中的字符串仅是符号，只有<strong>在被第一次引用到时才会转化为对象</strong> <code>ldc</code></p>
</li>
<li><p>StringTable在内存结构上是哈希表，不能扩容</p>
</li>
<li><p>利用串池的机制，来避免重复创建字符串对象</p>
</li>
<li><p>字符串<strong>变量</strong>拼接的原理是<strong>StringBuilder</strong></p>
</li>
<li><p>字符串<strong>常量</strong>拼接的原理是<strong>编译器优化</strong></p>
</li>
<li><p>可以使用 <strong><code>intern()</code> 方法</strong>，主动将串池中还没有的字符串对象放入串池中</p>
<ul>
<li>JDK 1.8 中，尝试将串池中还没有的字符串对象放入串池时，如果串池中有该对象则不会放入；若没有，则放入串池，且将串池中的对象返回</li>
<li>JDK 1.6 中，尝试将串池中还没有的字符串对象放入串池时，如果串池中有该对象则不会放入；若没有，则会先将该对象复制一份，然后放入串池，最后将串池中的对象返回</li>
</ul>
<p><strong>注意</strong>：无论是串池还是堆里面的字符串，都是对象</p>
</li>
</ul>
<h5 id="5-5-1-串池"><a href="#5-5-1-串池" class="headerlink" title="5.5.1 串池"></a>5.5.1 串池</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableStudy</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>; </span><br><span class="line">		<span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">ab</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常量池中的信息:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0: ldc           #2                  	// String a</span><br><span class="line">2: astore_1														// 把 a符号 变成 “a”字符串对象</span><br><span class="line">3: ldc           #3                 	// String b</span><br><span class="line">5: astore_2														// 把 b符号 变成 “b”字符串对象</span><br><span class="line">6: ldc           #4                  	// String ab</span><br><span class="line">8: astore_3														// 把 ab符号 变成 “ab”字符串对象</span><br><span class="line">9: return</span><br></pre></td></tr></table></figure>
<ol>
<li><p>当执行到 <code>ldc #2</code> 时，会把符号 a 变为 “a” 字符串对象，<strong>并放入串池中</strong>（hashtable结构 不可扩容）</p>
</li>
<li><p>当执行到 <code>ldc #3</code> 时，会把符号 b 变为 “b” 字符串对象，并放入串池中</p>
</li>
<li><p>当执行到 <code>ldc #4</code> 时，会把符号 ab 变为 “ab” 字符串对象，并放入串池中</p>
</li>
<li><p>最终 <code>StringTable [&quot;a&quot;, &quot;b&quot;, &quot;ab&quot;]</code></p>
<p><strong>注意</strong>：字符串对象的创建都是<strong>懒惰的</strong>，只有当运行到那一行字符串且在串池中不存在的时候（如 ldc #2）时，该字符串才会被创建并放入串池中。</p>
</li>
</ol>
<h5 id="5-5-2-串池：拼接变量字符串对象创建字符串"><a href="#5-5-2-串池：拼接变量字符串对象创建字符串" class="headerlink" title="5.5.2 串池：拼接变量字符串对象创建字符串"></a>5.5.2 串池：拼接变量字符串对象创建字符串</h5><p>使用拼接<strong>字符串变量对象</strong>创建字符串的过程: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableStudy</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">ab</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">ab2</span> <span class="operator">=</span> a+b;		<span class="comment">// new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toSrting()</span></span><br><span class="line">    										<span class="comment">// 相当于创建了一个新的 String对象</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(ab == ab2); <span class="comment">// 结果为false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反编译后的结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">    stack=2, locals=5, args_size=1</span><br><span class="line">       0: ldc           #2                  // String a</span><br><span class="line">       2: astore_1</span><br><span class="line">       3: ldc           #3                  // String b</span><br><span class="line">       5: astore_2</span><br><span class="line">       6: ldc           #4                  // String ab</span><br><span class="line">       8: astore_3</span><br><span class="line">       9: new           #5                  // class java/lang/StringBuilder</span><br><span class="line">      12: dup</span><br><span class="line">      13: invokespecial #6                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">      16: aload_1</span><br><span class="line">      17: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      20: aload_2</span><br><span class="line">      21: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      24: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">      27: astore        4</span><br><span class="line">      29: return</span><br></pre></td></tr></table></figure>
<p>通过拼接的方式来创建字符串的<strong>过程</strong>是：<code>new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString()</code>，地址应该在<strong>堆</strong>中</p>
<p>最后的toString方法的返回值是一个<strong>新的字符串</strong>，但字符串的<strong>值</strong>和拼接的字符串一致，但是两个不同的字符串，<strong>一个存在于串池之中，一个存在于堆内存之中</strong></p>
<h5 id="5-5-3-串池：拼接常量字符串对象的方法创建字符串"><a href="#5-5-3-串池：拼接常量字符串对象的方法创建字符串" class="headerlink" title="5.5.3 串池：拼接常量字符串对象的方法创建字符串"></a>5.5.3 串池：<strong>拼接常量字符串对象</strong>的方法创建字符串</h5><p>使用<strong>拼接字符串常量对象</strong>的方法创建字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableStudy</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">ab</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ab2</span> <span class="operator">=</span> a+b;</span><br><span class="line">		<span class="type">String</span> <span class="variable">ab3</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>; <span class="comment">// 使用拼接字符串的方法创建字符串，由于编译期间的优化</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(ab == ab3); <span class="comment">// 结果为true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反编译后的结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">  stack=2, locals=6, args_size=1</span><br><span class="line">     0: ldc           #2                  // String a</span><br><span class="line">     2: astore_1</span><br><span class="line">     3: ldc           #3                  // String b</span><br><span class="line">     5: astore_2</span><br><span class="line">     6: ldc           #4                  // String ab</span><br><span class="line">     8: astore_3</span><br><span class="line">     9: new           #5                  // class java/lang/StringBuilder</span><br><span class="line">    12: dup</span><br><span class="line">    13: invokespecial #6                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">    16: aload_1</span><br><span class="line">    17: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">    20: aload_2</span><br><span class="line">    21: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">    24: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">    27: astore        4										// ab3初始化时直接从串池中获取字符串</span><br><span class="line">    29: ldc           #4                  // String ab</span><br><span class="line">    31: astore        5</span><br><span class="line">    33: return</span><br></pre></td></tr></table></figure>
<ul>
<li><p>当虚拟机执行到<strong>第0、3、5行</strong>时，会将“a” “b“ ”ab“放入串池。当执行到<strong>29行</strong>时我们可以看到，虚拟机不会先找“a” 再找“b”然后再将它们拼接起来，而是之间找到拼接后的“ab”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringTable[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;ab&quot;</span>]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>⚠️ 需要注意的是：</p>
<ul>
<li>使用<strong>拼接字符串<u>常量</u></strong> 的方法来创建新的字符串时，因为<strong>内容是<u>常量</u>，<code>javac</code> 在编译期会进行优化，结果已在编译期确定为 <code>ab</code></strong>，而创建 <code>ab</code> 的时候已经在串池中放入了 <code>&quot;ab&quot;</code>，所以 <code>ab3</code> 直接从串池中获取值，所以进行的操作和 <code>ab = &quot;ab&quot;</code> 一致。</li>
<li>使用<strong>拼接字符串<u>变量</u></strong> 的方法来创建新的字符串时，因为<strong>内容是<u>变量</u></strong>，只能<strong>在运行期确定它的值，所以需要使用StringBuilder来创建</strong></li>
</ul>
</blockquote>
<h5 id="5-5-4-串池：intern-方法-JDK1-8"><a href="#5-5-4-串池：intern-方法-JDK1-8" class="headerlink" title="5.5.4 串池：intern() 方法(JDK1.8)"></a>5.5.4 串池：<code>intern()</code> 方法(JDK1.8)</h5><p>调用字符串对象的 <code>intern()</code> 方法，会将该字符串对象尝试放入到串池中</p>
<ul>
<li>如果串池中没有该字符串对象，则放入成功</li>
<li>如果有该字符串对象，则放入失败</li>
<li>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</li>
</ul>
<h6 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h6><p>JDK 1.8 环境下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableInternMethod1</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    	<span class="comment">// &quot;a&quot;&quot;b&quot; 被放入串池中，str 则存在于堆中</span></span><br><span class="line">    	<span class="comment">// StringTable[&quot;a&quot;, &quot;b&quot;]</span></span><br><span class="line">    	<span class="comment">// new String(&quot;a&quot;) 和 new String(&quot;b&quot;) 两个字符串对象</span></span><br><span class="line">    	<span class="comment">// 字符串对象 str = new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toSrting()</span></span><br><span class="line">    </span><br><span class="line">		<span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> str.intern();</span><br><span class="line">    	<span class="comment">// 调用str的intern()方法，这时串池中没有&quot;ab&quot;，则会将该字符串对象放入到串池中，此时堆内存与串池中的&quot;ab&quot;是同一个对象</span></span><br><span class="line">    </span><br><span class="line">		<span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    	<span class="comment">// 给str3赋值，因为此时串池中已有&quot;ab&quot;，则直接将串池中的内容返回</span></span><br><span class="line">    </span><br><span class="line">		<span class="comment">// 因为堆内存与串池中的&quot;ab&quot;是同一个对象，所以以下两条语句打印的都为true</span></span><br><span class="line">		System.out.println(str2 == str);</span><br><span class="line">		System.out.println(str3 == str);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h6><p>JDK 1.8 与 JDK 1.6</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SringTableInternMethod2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">/* 此处创建字符串对象&quot;ab&quot;，因为串池中还没有&quot;ab&quot;，所以将其放入串池中 */</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="comment">/* &quot;a&quot; &quot;b&quot; 被放入串池中，str则存在于堆内存之中 */</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="comment">/* 此时因为在创建str3时，&quot;ab&quot;已存在与串池中，所以放入失败，但是会返回串池中的&quot;ab&quot; */</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> str.intern();</span><br><span class="line">    </span><br><span class="line">		System.out.println(str == str2); <span class="comment">//false</span></span><br><span class="line">		System.out.println(str == str3); <span class="comment">//false</span></span><br><span class="line">		System.out.println(str2 == str3); <span class="comment">//true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h6><p>JDK 1.6环境下，与<a href="#例1">例1</a>进行比较。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableInternMethod3</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    	<span class="comment">// &quot;a&quot;&quot;b&quot; 被放入串池中，str 则存在于堆中</span></span><br><span class="line">    	<span class="comment">// StringTable[&quot;a&quot;, &quot;b&quot;]</span></span><br><span class="line">    	<span class="comment">// new String(&quot;a&quot;) 和 new String(&quot;b&quot;) 两个字符串对象</span></span><br><span class="line">    	<span class="comment">// 字符串对象 str = new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toSrting()</span></span><br><span class="line">    </span><br><span class="line">		<span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> str.intern();</span><br><span class="line">    	<span class="comment">// 调用str的intern()方法，这时串池中没有&quot;ab&quot;，则会将该字符串对象放入到串池中，此时堆内存与串池中的&quot;ab&quot;是同一个对象</span></span><br><span class="line">    	<span class="comment">// 将 str 复制一份，将复制后的对象放入串池</span></span><br><span class="line">    	<span class="comment">// 此时 str2 与串池中的对象相同；str 则不同，是其的复制</span></span><br><span class="line">    </span><br><span class="line">		<span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    	<span class="comment">// 给str3赋值，因为此时串池中已有&quot;ab&quot;，则直接将串池中的内容返回，即 str3 = str2</span></span><br><span class="line">    </span><br><span class="line">		System.out.println(str3 == str2);	<span class="comment">// true</span></span><br><span class="line">		System.out.println(str3 == str); 	<span class="comment">// false</span></span><br><span class="line">    <span class="comment">// JDK1.8 环境下都为true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="5-5-5-串池的位置"><a href="#5-5-5-串池的位置" class="headerlink" title="5.5.5 串池的位置"></a>5.5.5 串池的位置</h5><p>在 JDK 1.6 中：</p>
<p><img src="/2022/03/22/JVM-1/IMG_9A689689FB20-1.jpeg" alt="1.6" style="zoom: 60%;"></p>
<p>我们可以看到，由于串池逻辑上处于方法区中，而方法区是由永久代实现的，在垃圾回收时需要 <code>FullGC</code> 才能清理永久代，这样就会造成串池迟迟得不到清理，从而导致内存溢出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JDK1.6 环境下：</span><br><span class="line">-XX:MaxPermSize=10m</span><br><span class="line">-Xmx10m -XX:-UseGCOverheadLimit</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableJDK1_6Demo</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;~&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000000</span>; j++) &#123;</span><br><span class="line">        list.add(String.valueOf(j).intern());</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR INFO:</span><br><span class="line">java.lang.OutOfMemoryError: PermGen space</span><br></pre></td></tr></table></figure>
<p>为了解决以上问题，在 JDK 1.8 中改进了串池的位置。</p>
<p>在 JDK 1.8 中：</p>
<p><img src="/2022/03/22/JVM-1/IMG_42907AA7BAF6-1.jpeg" alt="StringTable1.8"></p>
<p>串池位于堆中，在垃圾回收时需要 <code>MinorGC</code> 进行垃圾回收，从而减轻内存占用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JDK1.6 环境下：</span><br><span class="line">-Xmx10m -XX:-UseGCOverheadLimit</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableJDK1_8Demo</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;~&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000000</span>; j++) &#123;</span><br><span class="line">        list.add(String.valueOf(j).intern());</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR INFO:</span><br><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure>
<h5 id="5-5-6-串池的垃圾回收"><a href="#5-5-6-串池的垃圾回收" class="headerlink" title="5.5.6 串池的垃圾回收"></a>5.5.6 串池的垃圾回收</h5><p><code>StringTable</code> 在内存紧张时，会发生<a href="#三、JVM-垃圾回收">垃圾回收</a>。</p>
<h5 id="5-5-7-串池的性能调优"><a href="#5-5-7-串池的性能调优" class="headerlink" title="5.5.7 串池的性能调优"></a>5.5.7 串池的性能调优</h5><ul>
<li><p>因为 <code>StringTable</code> 是用 <code>HashTable</code> 实现的，所以我们可以<strong>适当增加 <code>HashTable</code> 的桶的个数</strong>，来减少字符串放入串池所需要的时间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:StringTableSize=xxxx</span><br></pre></td></tr></table></figure>
</li>
<li><p>考虑是否需要将字符串对象入池，可以通过 <strong><code>intern()</code> 方法减少重复入池</strong></p>
</li>
</ul>
<h3 id="6-直接内存"><a href="#6-直接内存" class="headerlink" title="6. 直接内存"></a>6. 直接内存</h3><h4 id="6-1-定义"><a href="#6-1-定义" class="headerlink" title="6.1 定义"></a>6.1 定义</h4><p>直接内存不属于 <code>JVM</code> 内存结构，而是<strong>操作系统的内存</strong>。</p>
<ul>
<li>属于操作系统，常见于 NIO 操作时，<strong>用于数据缓冲区</strong></li>
<li>分配回收成本较高，但读写性能高</li>
<li>不受 <code>JVM</code> 内存回收管理</li>
</ul>
<h4 id="6-2-基本使用"><a href="#6-2-基本使用" class="headerlink" title="6.2 基本使用"></a>6.2 基本使用</h4><p><img src="/2022/03/22/JVM-1/image-20220816162626624.png" alt="image-20220816162626624"></p>
<p>使用了 <code>DirectBuffer</code> 后，</p>
<p>【直接内存】是操作系统和 <code>Java</code> 代码<strong>都可以访问的一块区域</strong>，无需将代码从系统内存复制到 <code>Java</code> 堆内存，从而提高了效率</p>
<p><img src="/2022/03/22/JVM-1/image-20220816163058539.png" alt="image-20220816163058539"></p>
<h4 id="6-3-分配和回收原理"><a href="#6-3-分配和回收原理" class="headerlink" title="6.3 分配和回收原理"></a>6.3 分配和回收原理</h4><ul>
<li>使用了 <code>Unsafe</code> 类来完成直接内存的分配回收，而且回收需要主动调用<strong>unsafe.freeMemory()</strong>方法</li>
<li><code>ByteBuffer</code> 的实现内部使用了 <code>Cleaner</code>（<a href="#1-3-五种引用">虚引用</a>）来检测 <code>ByteBuffer</code>。一旦 <code>ByteBuffer</code> 被垃圾回收，那么会由 <code>ReferenceHandler</code> 来调用 Cleaner 的 <code>clean()</code> 方法调用 <code>freeMemory</code> 来释放内存</li>
</ul>
<p>直接内存的回收不是通过JVM的垃圾回收来释放的，而是通过<strong>unsafe.freeMemory()</strong>来手动释放</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过ByteBuffer申请1M的直接内存</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(_1M);</span><br></pre></td></tr></table></figure>
<p>申请直接内存，但JVM并不能回收直接内存中的内容，它是如何实现回收的呢？</p>
<h5 id="allocateDirect-的实现底层源码分析"><a href="#allocateDirect-的实现底层源码分析" class="headerlink" title="allocateDirect() 的实现底层源码分析"></a>allocateDirect() 的实现底层源码分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title function_">allocateDirect</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectByteBuffer</span>(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DirectByteBuffer</code> 类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">DirectByteBuffer(<span class="type">int</span> cap) &#123;   <span class="comment">// package-private</span></span><br><span class="line">   </span><br><span class="line">    <span class="built_in">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">pa</span> <span class="operator">=</span> VM.isDirectMemoryPageAligned();</span><br><span class="line">    <span class="type">int</span> <span class="variable">ps</span> <span class="operator">=</span> Bits.pageSize();</span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> Math.max(<span class="number">1L</span>, (<span class="type">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        base = unsafe.allocateMemory(size); <span class="comment">//申请内存</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.setMemory(base, size, (<span class="type">byte</span>) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// Round up to page boundary</span></span><br><span class="line">        address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    cleaner = Cleaner.create(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">Deallocator</span>(base, size, cap)); <span class="comment">//通过虚引用，来实现直接内存的释放，this为虚引用的实际对象</span></span><br><span class="line">    att = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里调用了一个Cleaner的 <code>create()</code> 方法，且后台线程还会对虚引用的对象监测，如果虚引用的实际对象（这里是 <code>DirectByteBuffer</code>）被回收以后，就会调用Cleaner的 <code>clean()</code> 方法，来清除直接内存中占用的内存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clean</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (remove(<span class="built_in">this</span>)) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="built_in">this</span>.thunk.run(); <span class="comment">//调用run方法</span></span><br><span class="line">           &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable var2) &#123;</span><br><span class="line">               AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">                   <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                       <span class="keyword">if</span> (System.err != <span class="literal">null</span>) &#123;</span><br><span class="line">                           (<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Cleaner terminated abnormally&quot;</span>, var2)).printStackTrace();</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       System.exit(<span class="number">1</span>);</span><br><span class="line">                       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>
<p>对应对象的 <code>run()</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (address == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Paranoia</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.freeMemory(address); <span class="comment">// 释放直接内存中占用的内存</span></span><br><span class="line">    address = <span class="number">0</span>;</span><br><span class="line">    Bits.unreserveMemory(size, capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、JVM-垃圾回收"><a href="#三、JVM-垃圾回收" class="headerlink" title="三、JVM 垃圾回收"></a>三、JVM 垃圾回收</h2><h3 id="0-主要内容大纲"><a href="#0-主要内容大纲" class="headerlink" title="0 主要内容大纲"></a>0 主要内容大纲</h3><p>【概述】</p>
<p>之前我们讲解了 JVM 的内存结构，其中我们了解到<a href="#4-堆">堆</a>存在着垃圾回收机制。这一章我们将重点介绍这一部分内容。</p>
<ol>
<li><a href="#1-如何判断对象可以被回收">如何判断对象可以回收</a></li>
<li><a href="#2-垃圾回收算法">垃圾回收算法</a></li>
<li><a href="#3-分代垃圾回收机制">分代垃圾回收</a></li>
<li><a href>垃圾回收器</a></li>
<li><a href>垃圾回收调优</a></li>
</ol>
<h3 id="1-如何判断对象可以被回收"><a href="#1-如何判断对象可以被回收" class="headerlink" title="1 如何判断对象可以被回收"></a>1 如何判断对象可以被回收</h3><h4 id="1-1-引用计数法"><a href="#1-1-引用计数法" class="headerlink" title="1.1 引用计数法"></a>1.1 引用计数法</h4><ul>
<li>只要一个对象被其他变量所引用，那我们就让这个对象的计数 $+1$，如果被引用两次，该计数就为2。</li>
<li>如果某个变量不再引用这个对象，该对象的引用计数 $-1$。</li>
<li>当计数为 0 时，表示没有变量引用这个对象了，则可作为垃圾回收掉。</li>
</ul>
<p><img src="/2022/03/22/JVM-1/20200608150750 (1).png" alt="20200608150750 (1)" style="zoom:60%;"></p>
<blockquote>
<p>弊端：在例如上图的循环引用时，两个对象的计数都为 1，导致两个对象都无法被释放</p>
</blockquote>
<h4 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2 可达性分析算法"></a>1.2 可达性分析算法</h4><p>首先先要确定【根对象】。那么什么是根对象呢？就是那些<u>肯定不能被当成垃圾回收的对象</u>。</p>
<p>在垃圾回收之前，我们先扫描堆内存中的所有对象，检查对象<u>是否被根对象直接或者间接的引用</u>。若是，则不能被回收；反之则可以被回收。</p>
<ul>
<li>JVM中的垃圾回收器通过<strong>可达性分析</strong>来探索所有存活的对象</li>
<li>扫描堆中的对象，看能否沿着 <code>GC Root</code> 对象（根对象）为起点的引用链找到该对象，如果<strong>找不到，则表示可以回收</strong></li>
</ul>
<blockquote>
<p>可以作为 <code>GC Root</code>的对象：</p>
<ul>
<li>虚拟机栈（栈帧中的局部变量表）中引用的对象；</li>
<li>方法区中类静态属性引用的对象；</li>
<li>方法区中常量引用的对象；</li>
<li>本地方法栈中JNI（即一般说的 Native方法）引用的对象</li>
</ul>
</blockquote>
<h4 id="1-3-五种引用"><a href="#1-3-五种引用" class="headerlink" title="1.3 五种引用"></a>1.3 五种引用</h4><p><img src="/2022/03/22/JVM-1/20200608150800.png" alt="20200608150800"></p>
<p>【总结】引用应用垃圾回收 GC 的时机：</p>
<ol>
<li>强引用：只有 GC Root <strong>都不引用</strong>该对象时，才会回收<strong>强引用</strong>对象</li>
<li>软引用：<ul>
<li><strong>仅有</strong>软引用引用该对象时，在垃圾回收之后，内存仍不足时会再次触发垃圾回收，回收软引用对象</li>
<li>可以配合引用队列来释放软引用自身</li>
</ul>
</li>
<li>弱引用：<ul>
<li><strong>只有</strong><u>弱引用</u>引用该对象时，在垃圾回收时，<strong>无论内存是否充足</strong>，都会回收弱引用所引用的对象。</li>
<li>可以配合引用队列来释放弱引用自身</li>
</ul>
</li>
<li>虚引用：<ul>
<li>必须配合<strong>引用队列</strong>使用，主要配合 <code>ByteBuffer</code> 使用。</li>
<li>被引用对象回收时，会讲虚引用入队列，由 <code>Reference Handler</code> 线程调用虚引用的相关方法释放内存。</li>
</ul>
</li>
<li>终结器引用：<ul>
<li>无需手动编码，但其内部配合引用队列使用。</li>
<li>在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由 <code>Finalizer</code> 线程通过终结器引用找到被引用对象并调用它的 <code>finalize()</code> 方法，第二次 GC 时才能回收被引用对象</li>
</ul>
</li>
</ol>
<h5 id="1-3-1-强引用"><a href="#1-3-1-强引用" class="headerlink" title="1.3.1 强引用"></a>1.3.1 强引用</h5><p>如上图，实线箭头表示强引用。日常使用中的引用都属于强引用。例如，<code>new</code> 一个对象，使用 <code>&quot;=&quot;</code> 将该对象赋值给一个变量，那么这个变量就强引用该对象。</p>
<blockquote>
<p><strong>垃圾回收的条件：</strong></p>
<p>只有 GC Root <strong>都不引用</strong>该对象时，才会回收<strong>强引用</strong>对象</p>
</blockquote>
<ul>
<li>如上图 B、C 对象都不引用 A1 对象时，A1 对象才会被回收</li>
</ul>
<p>案例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoStrongReference</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_4M</span> <span class="operator">=</span> <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 强引用</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_4M]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure>
<h5 id="1-3-2-软引用-Soft-Reference"><a href="#1-3-2-软引用-Soft-Reference" class="headerlink" title="1.3.2 软引用 (Soft Reference)"></a>1.3.2 软引用 (Soft Reference)</h5><p>使用场景：当内存空间有限时，一些不重要的资源可以用软引用。</p>
<p>只要 A2、A3 两个对象没有被直接的强引用所引用，当垃圾回收发生时，都有可以被回收。</p>
<blockquote>
<p><strong>垃圾回收的条件：</strong></p>
<p>当 GC Root 指向软引用对象（垃圾回收）时，在<strong>内存不足时</strong>，会<strong>回收软引用所引用的对象</strong>。（先回收一次，如果内存还不够，回收软引用所引用的对象）</p>
</blockquote>
<ul>
<li>如上图如果 B 对象不再引用 A2 对象且内存不足时，软引用所引用的 A2 对象就会被回收</li>
</ul>
<p>案例 1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 软引用演示</span></span><br><span class="line"><span class="comment"> * -Xmx20m -XX:+PrintGCDetails -verbose:gc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoSoftReference1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_4M</span> <span class="operator">=</span> <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span></span><br><span class="line">        List&lt;SoftReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 强引用</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">            SoftReference&lt;<span class="type">byte</span>[]&gt; ref= <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[_4M]); <span class="comment">// 软引用</span></span><br><span class="line">            <span class="comment">// List list --强引用--&gt; SoftReference ref --软引用--&gt; byte[_4M]</span></span><br><span class="line">            System.out.println(ref.get());</span><br><span class="line">            list.add(ref);</span><br><span class="line">            System.out.println(list.size());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;循环结束：&quot;</span> + list.size());</span><br><span class="line">        <span class="keyword">for</span> (SoftReference&lt;<span class="type">byte</span>[]&gt; ref : list) &#123;</span><br><span class="line">            System.out.println(ref.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[B@75b84c92</span><br><span class="line">1</span><br><span class="line">[B@6bc7c054</span><br><span class="line">2</span><br><span class="line">[B@232204a1</span><br><span class="line">3</span><br><span class="line">[B@4aa298b7</span><br><span class="line">4</span><br><span class="line">[B@7d4991ad</span><br><span class="line">5</span><br><span class="line">循环结束：5</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">[B@7d4991ad	// 只有最后一个数组被保留，上面的都被垃圾回收了</span><br></pre></td></tr></table></figure>
<p>如果在垃圾回收时发现内存不足，在回收软引用所指向的对象时，<strong>软引用本身不会被清理</strong></p>
<p>如果想要<strong>清理软引用</strong>，需要使<strong>用引用队列</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoSoftReference2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_4M</span> <span class="operator">=</span> <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用引用队列，用于移除引用为空的软引用对象</span></span><br><span class="line">        ReferenceQueue&lt;<span class="type">byte</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;(); <span class="comment">// 引用队列</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span></span><br><span class="line">        List&lt;SoftReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 强引用</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 关联了引用队列，当软引用所关联的 byte[]被回收时，软引用自自己会加入到 queue 中去</span></span><br><span class="line">            SoftReference&lt;<span class="type">byte</span>[]&gt; ref= <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[_4M], queue); <span class="comment">// 软引用</span></span><br><span class="line">            <span class="comment">// List list --强引用--&gt; SoftReference ref --软引用--&gt; byte[_4M]</span></span><br><span class="line"></span><br><span class="line">            System.out.println(ref.get());</span><br><span class="line">            list.add(ref);</span><br><span class="line">            System.out.println(list.size());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历引用队列，如果有元素，则取出</span></span><br><span class="line">        Reference&lt;? <span class="keyword">extends</span> <span class="title class_">byte</span>[]&gt; poll = queue.poll(); <span class="comment">// poll(), 取出最先放入队列的元素，返回类型Reference</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(poll != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 引用队列不为空，则从集合中移除该元素</span></span><br><span class="line">            list.remove(poll);</span><br><span class="line">            <span class="comment">// 移动到引用队列中的下一个元素</span></span><br><span class="line">            poll = queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;========================&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (SoftReference&lt;<span class="type">byte</span>[]&gt; ref : list) &#123;</span><br><span class="line">            System.out.println(ref.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[B@75b84c92</span><br><span class="line">1</span><br><span class="line">[B@6bc7c054</span><br><span class="line">2</span><br><span class="line">[B@232204a1</span><br><span class="line">3</span><br><span class="line">[B@4aa298b7</span><br><span class="line">4</span><br><span class="line">[B@7d4991ad</span><br><span class="line">5</span><br><span class="line">========================</span><br><span class="line">[B@7d4991ad</span><br></pre></td></tr></table></figure>
<p><strong>大概思路为：</strong>查看引用队列中有无软引用，如果有，则将该软引用从存放它的集合中移除（这里为一个list集合）</p>
<h5 id="1-3-3-弱引用-Weak-Referrnce"><a href="#1-3-3-弱引用-Weak-Referrnce" class="headerlink" title="1.3.3 弱引用 (Weak Referrnce)"></a>1.3.3 弱引用 (Weak Referrnce)</h5><blockquote>
<p><strong>垃圾回收的条件：</strong></p>
<p>当<strong>只有</strong><u>弱引用</u>引用该对象时，在垃圾回收时，<strong>无论内存是否充足</strong>，都会回收弱引用所引用的对象。</p>
</blockquote>
<ul>
<li>如上图如果B对象不再引用A3对象，则A3对象会被回收</li>
</ul>
<p><strong>弱引用的使用和软引用类似</strong>，只是将 <strong>SoftReference 换为了 WeakReference</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoWeakReference1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_4M</span> <span class="operator">=</span> <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">        List&lt;WeakReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 强引用</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">            WeakReference&lt;<span class="type">byte</span>[]&gt; ref= <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[_4M]); <span class="comment">// 软引用</span></span><br><span class="line">            <span class="comment">// List list --强引用--&gt; WeakReference ref --弱引用--&gt; byte[_4M]</span></span><br><span class="line">            list.add(ref);</span><br><span class="line">            <span class="keyword">for</span> (WeakReference&lt;<span class="type">byte</span>[]&gt; weakReference : list) &#123;</span><br><span class="line">                System.out.print(weakReference.get() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;循环结束：&quot;</span> + list.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[B@75b84c92	</span><br><span class="line">[B@75b84c92	[B@6bc7c054	</span><br><span class="line">[B@75b84c92	[B@6bc7c054	[B@232204a1	</span><br><span class="line">[B@75b84c92	[B@6bc7c054	[B@232204a1	[B@4aa298b7	</span><br><span class="line">null	[B@6bc7c054	[B@232204a1	[B@4aa298b7	[B@7d4991ad	</span><br><span class="line">null	[B@6bc7c054	[B@232204a1	[B@4aa298b7	null	[B@28d93b30	</span><br><span class="line">循环结束：6</span><br></pre></td></tr></table></figure>
<h5 id="1-3-4-虚引用-Phantom-Reference"><a href="#1-3-4-虚引用-Phantom-Reference" class="headerlink" title="1.3.4 虚引用 (Phantom Reference)"></a>1.3.4 虚引用 (Phantom Reference)</h5><p>必须配合<strong>引用队列</strong>一同使用。当虚（终结器）引用被创建时，会<u>关联一个引用队列</u>。</p>
<blockquote>
<ul>
<li>当虚引用对象所引用的对象被回收以后，虚引用对象就会被放入引用队列中，调用虚引用的方法</li>
<li>虚引用的一个体现是<strong>释放直接内存所分配的内存</strong>，当引用的对象 <code>ByteBuffer</code> 被垃圾回收以后，虚引用对象 <code>Cleaner</code> 就会被放入引用队列中，然后调用 <code>Cleaner</code> 的 <code>clean()</code> 方法来释放直接内存</li>
</ul>
</blockquote>
<ul>
<li>如上图，B 对象不再引用 <code>ByteBuffer</code> 对象，<code>ByteBuffer</code> 就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象 <code>Cleaner</code> 放入引用队列中，然后调用它的 <code>clean()</code> 方法来释放直接内存</li>
</ul>
<h5 id="1-3-5-终结器引用-Finalize-Reference"><a href="#1-3-5-终结器引用-Finalize-Reference" class="headerlink" title="1.3.5 终结器引用 (Finalize Reference)"></a>1.3.5 终结器引用 (Finalize Reference)</h5><p>所有的对象都继承自 <code>Object</code> 类，<code>Object</code> 类有一个 <code>finalize()</code> 方法。</p>
<blockquote>
<p>当某个对象不再被其他的对象所引用时，会先将终结器引用对象放入引用队列中（处理这个引用队列的<em>FinalizeHandler 线程</em> 优先级很低），然后根据终结器引用对象找到它所引用的对象，然后调用该对象的 <code>finalize()</code> 方法。调用以后，该对象就可以被垃圾回收了。</p>
</blockquote>
<ul>
<li>如上图，B对象不再引用A4对象。这是终结器对象就会被放入引用队列中，引用队列会根据它，找到它所引用的对象。然后调用被引用对象的finalize()方法。调用以后，该对象就可以被垃圾回收了</li>
</ul>
<h3 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2 垃圾回收算法"></a>2 垃圾回收算法</h3><h4 id="2-1-标记-清除-算法-Mark-Sweep"><a href="#2-1-标记-清除-算法-Mark-Sweep" class="headerlink" title="2.1 标记 - 清除 算法 (Mark - Sweep)"></a>2.1 标记 - 清除 算法 (Mark - Sweep)</h4><p><img src="/2022/03/22/JVM-1/20200608150813.png" alt="20200608150813" style="zoom:50%;"></p>
<p><strong>定义</strong>：标记清除算法顾名思义，是指在虚拟机执行垃圾回收的过程中，先<u>采用标记算法确定可回收对象</u>（图中为没有GC Root引用的块），然后<u>垃圾收集器根据标识清除相应的内容</u>，给堆内存腾出相应的空间。</p>
<ul>
<li>这里的腾出内存空间并不是将内存空间的字节清零，而是记录下这段内存的起始结束地址，下次分配内存的时候，会直接<strong>覆盖</strong>这段内存。同理于操作系统中的内存管理</li>
</ul>
<blockquote>
<p><strong>优点</strong>：垃圾回收速度快</p>
<p><strong>缺点</strong>：<strong>容易产生大量的内存碎片</strong>，可能无法满足大对象的内存分配，一旦导致无法分配对象，那就会导致 <code>JVM</code> 启动 GC，一旦启动 GC，我们的应用程序就会暂停，这就导致应用的响应速度变慢。同理于操作系统中的内存碎片。</p>
</blockquote>
<h4 id="2-2-标记-整理-算法-Mark-Compact"><a href="#2-2-标记-整理-算法-Mark-Compact" class="headerlink" title="2.2 标记 - 整理 算法 (Mark - Compact)"></a>2.2 标记 - 整理 算法 (Mark - Compact)</h4><p><img src="/2022/03/22/JVM-1/20200608150827.png" alt="20200608150827"></p>
<p><strong>标记-整理</strong> 会将不被 GC Root 引用的对象回收，清理其占用的内存空间。然后整理剩余的对象（将其地址向前移动，使内存更为紧凑，连续空间更多）.</p>
<blockquote>
<p>优点：可以<strong>有效避免因内存碎片而导致的问题</strong></p>
<p>缺点：但是因为整体需要消耗一定的时间，所以<strong>效率较低</strong></p>
</blockquote>
<h4 id="2-3-复制-算法-Copy"><a href="#2-3-复制-算法-Copy" class="headerlink" title="2.3 复制 算法 (Copy)"></a>2.3 复制 算法 (Copy)</h4><p>将内存分为等大小的两个区域，<code>FROM</code> 和 <code>TO</code>（其中 <code>TO</code> 中是空闲的）。</p>
<p>先将被 GC Root 引用的对象从 <code>FROM</code> 复制到 <code>TO</code> 中，再回收不被 GC Root 引用的对象。然后交换 <code>FROM</code> 和<code>TO</code>。</p>
<ol>
<li>如下图，先采用标记算法确定可回收对象（图中为没有 GC Root 引用的块）</li>
</ol>
<p><img src="/2022/03/22/JVM-1/20200608150842.png" alt="20200608150842" style="zoom:75%;"></p>
<ol>
<li>将 <code>FROM</code> 区域中存活的对象复制到 <code>TO</code> 区域</li>
</ol>
<p><img src="/2022/03/22/JVM-1/20200608150856.png" alt="20200608150856" style="zoom:75%;"></p>
<ol>
<li>此时由于 <code>FROM</code> 区域中全是垃圾，全部清空</li>
</ol>
<p><img src="/2022/03/22/JVM-1/20200608150907.png" alt="20200608150907" style="zoom:75%;"></p>
<ol>
<li>交换 <code>FROM</code> 区域 和 <code>TO</code> 区域 的位置</li>
</ol>
<p><img src="/2022/03/22/JVM-1/20200608150919.png" alt="20200608150919" style="zoom:75%;"></p>
<blockquote>
<p>优点：可以避免内存碎片的问题</p>
<p>缺点：但是会<strong>占用双倍的内存空间</strong>。</p>
</blockquote>
<h4 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4 总结"></a>2.4 总结</h4><ol>
<li>标记 - 清除 算法 (Mark - Sweep)<ul>
<li><strong>优点</strong>：垃圾回收速度快</li>
<li><strong>缺点</strong>：<strong>容易产生大量的内存碎片</strong></li>
</ul>
</li>
<li>标记 - 整理 算法 (Mark - Compact)<ul>
<li>优点：可以<strong>有效避免因内存碎片而导致的问题</strong></li>
<li>缺点：但是因为整体需要消耗一定的时间，所以<strong>效率较低</strong></li>
</ul>
</li>
<li>复制 算法 (Copy)<ul>
<li>优点：可以避免内存碎片的问题</li>
<li>缺点：但是会<strong>占用双倍的内存空间</strong>。</li>
</ul>
</li>
</ol>
<h3 id="3-分代垃圾回收机制"><a href="#3-分代垃圾回收机制" class="headerlink" title="3 分代垃圾回收机制"></a>3 分代垃圾回收机制</h3><p><img src="/2022/03/22/JVM-1/20200608150931.png" alt="20200608150931"></p>
<p>如上图，我们将堆内存划分成两个部分，一个是左边的 <em>YoungGeneration</em> 新生代 (新生代又分为【伊甸园 Eden】、【幸存区 FROM】和【幸存区 TO】三个部分)，另一个是老年代 <em>OldGeneration</em>。</p>
<p>Java 中，<u>长时间使用的对象放在老年代中</u>，<u>用完就可以丢弃的对象放在新生代中</u>。这样就可以根据对象的存活时间的不同特点进行不用的回收策略。<u>老年代中的垃圾回收很久发生一次</u>，而<u>新生代中回收更频繁</u>。</p>
<h4 id="3-1-分代回收流程"><a href="#3-1-分代回收流程" class="headerlink" title="3.1 分代回收流程"></a>3.1 分代回收流程</h4><blockquote>
<p>简要流程：</p>
<ol>
<li>对象首先分配在伊甸园区域；</li>
<li>新生代空间不足时，触发 Minor GC，伊甸园和 FROM 存活的对象使用 copy 复制到 TO 中，存活的对象年龄加 1，并且交换 FROM 和 TO；</li>
<li>当幸存区中的对象的<strong>寿命超过阈值</strong>（最大为15，4bit），就会<strong>晋升到老年代</strong>中；</li>
<li>如果新生代中的内存空间不足时，先触发 Minor GC；垃圾回收后发现新生代中的内存空间仍然不足，且老年代中的内存空间也不足，再触发 <strong>Full GC</strong> (整体清理)；</li>
<li>内存分配失败，触发 <code>java.lang.OutOfMemoryError</code>。</li>
</ol>
</blockquote>
<p>【流程图解】</p>
<p>1、新创建的对象都被放在了<strong>新生代的伊甸园</strong>中，伊甸园逐渐就会被占满。</p>
<p><img src="/2022/03/22/JVM-1/20200608150939.png" alt="20200608150939"></p>
<p><img src="/2022/03/22/JVM-1/20200608150946.png" alt="20200608150946"></p>
<p>2、当伊甸园中的内存不足时，就会进行一次垃圾回收，这时<u>新生代的垃圾回收叫做 <strong>Minor GC</strong></u></p>
<p>​    (1) Minor GC 触发后，采用“可达性分析算法”，沿着以 GC Root 对象（根对象）为起点的引用链，采用“标记算法”确定可回收对象；</p>
<p>​    (2) 标记完成后，采用“复制算法”将<strong><u>伊甸园</u>和<u>幸存区 FROM</u></strong> 存活的对象<strong>先</strong>复制到<strong><u>幸存区 TO</u></strong> 中， 并让其<strong>寿命$+1$</strong>；</p>
<p><img src="/2022/03/22/JVM-1/20200608150955.png" alt="20200608150955"></p>
<p>​    (3) 根据复制算法，我们将交换<u>幸存区 FROM</u> 和<u>幸存区 TO</u> 的位置</p>
<p><img src="/2022/03/22/JVM-1/20200608151002.png" alt="20200608151002"></p>
<p>3、再次创建对象，若新生代的伊甸园又满了，则会<strong>再次触发 Minor GC</strong>（会触发 <strong>“Stop the world”</strong>， 暂停其他用户线程，只让垃圾回收线程工作）；</p>
<p>这时不仅会回收伊甸园中的垃圾，<strong>还会回收幸存区中的垃圾</strong>，再将活跃对象复制到<u>幸存区 TO</u> 中；</p>
<p>回收以后会交换两个幸存区，并让幸存区中的对象<strong>寿命加1</strong></p>
<p><img src="/2022/03/22/JVM-1/20200608151010.png" alt="20200608151010"></p>
<p>4、如此反复。如果幸存区中的对象的<strong>寿命超过某个阈值</strong>（最大为15，4bit），就会<strong>晋升到老年代</strong>中</p>
<p><img src="/2022/03/22/JVM-1/20200608151018.png" alt="20200608151018"></p>
<p>5、如果新生代中的内存空间不足时，先触发 Minor GC；垃圾回收后发现新生代中的内存空间仍然不足，且老年代中的内存空间也不足，再触发 <strong>Full GC</strong> (整体清理)，也会触发“Stop the world”，时间更长，以扫描<strong>新生代和老年代中</strong>所有不再使用的对象并回收</p>
<p>6、如果老年代的内存也不够，内存分配失败，触发 <code>java.lang.OutOfMemoryError</code>。</p>
<p><img src="/2022/03/22/JVM-1/IMG_FB5339E468EB-1.jpeg" alt="IMG_FB5339E468EB-1"></p>
<h4 id="3-2-相关虚拟机参数"><a href="#3-2-相关虚拟机参数" class="headerlink" title="3.2 相关虚拟机参数"></a>3.2 相关虚拟机参数</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">含义</th>
<th style="text-align:left">参数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">堆初始大小</td>
<td style="text-align:left"><code>-Xms</code></td>
</tr>
<tr>
<td style="text-align:left">堆最大大小</td>
<td style="text-align:left"><code>-Xmx</code> 或 <code>-XX:MaxHeapSize=size</code></td>
</tr>
<tr>
<td style="text-align:left">新生代大小</td>
<td style="text-align:left"><code>-Xmn</code> 或 <code>-XX:NewSize=size + XX:MaxNewSize=size</code></td>
</tr>
<tr>
<td style="text-align:left">幸存区比例（动态）</td>
<td style="text-align:left"><code>-XX:InitialSurvivorRatio=ratio</code> 和 <code>-XX:+UseAdaptiveSizePolicy</code></td>
</tr>
<tr>
<td style="text-align:left">幸存区比例</td>
<td style="text-align:left"><code>-XX:SurvivorRatio=ratio</code></td>
</tr>
<tr>
<td style="text-align:left">晋升阈值</td>
<td style="text-align:left"><code>-XX:MaxTenuringThreshold=threshold</code></td>
</tr>
<tr>
<td style="text-align:left">晋升详情</td>
<td style="text-align:left"><code>-XX:+PrintTenuringDistribution</code></td>
</tr>
<tr>
<td style="text-align:left">GC 详情</td>
<td style="text-align:left"><code>-XX:+PrintGCDetails -verbose:gc</code></td>
</tr>
<tr>
<td style="text-align:left">在 FullGC 前执行 MinorGC</td>
<td style="text-align:left"><code>-XX:+ScavengeBeforeFullGC</code></td>
</tr>
</tbody>
</table>
</div>
<h4 id="3-3-GC分析"><a href="#3-3-GC分析" class="headerlink" title="3.3  GC分析"></a>3.3  GC分析</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 1505K [0x00000007be800000, 0x00000007bf200000, 0x00000007bf200000)</span><br><span class="line">  eden space 8192K,  18% used [0x00000007be800000, 0x00000007be9786f8, 0x00000007bf000000)</span><br><span class="line">  from space 1024K,   0% used [0x00000007bf000000, 0x00000007bf000000, 0x00000007bf100000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000007bf100000, 0x00000007bf100000, 0x00000007bf200000)</span><br><span class="line"> tenured generation   total 14336K, used 0K [0x00000007bf200000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line">   the space 14336K,   0% used [0x00000007bf200000, 0x00000007bf200000, 0x00000007bf200200, 0x00000007c0000000)</span><br><span class="line"> Metaspace       used 3132K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 341K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<p>垃圾回收信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: 1333K-&gt;331K(9216K), 0.0003968 secs] 1333K-&gt;331K(23552K), 0.0004083 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br></pre></td></tr></table></figure>
<ul>
<li><code>GC</code> 表示是新生代的 <code>MinorGC</code>；<code>FullGC</code> 表示是老年代的垃圾回收</li>
<li><code>DefNew</code> 表示垃圾回收发生在新生代，<code>xxx -&gt; xxx</code> 表示回收之前的占用和回收之后的占用</li>
</ul>
<p>案例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_512K</span> <span class="operator">=</span> <span class="number">512</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1M</span> <span class="operator">=</span>  <span class="number">1</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_5M</span> <span class="operator">=</span>  <span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_6M</span> <span class="operator">=</span>  <span class="number">6</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_7M</span> <span class="operator">=</span>  <span class="number">7</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_7M]);</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_512K]);</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_512K]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: 1508K-&gt;366K(9216K), 0.0006691 secs] 1508K-&gt;366K(23552K), 0.0006841 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [DefNew: 8210K-&gt;876K(9216K), 0.0012508 secs] 8210K-&gt;8044K(23552K), 0.0012588 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 1716K [0x00000007be800000, 0x00000007bf200000, 0x00000007bf200000)</span><br><span class="line">  eden space 8192K,  10% used [0x00000007be800000, 0x00000007be8d1eb8, 0x00000007bf000000)</span><br><span class="line">  from space 1024K,  85% used [0x00000007bf000000, 0x00000007bf0db1e8, 0x00000007bf100000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000007bf100000, 0x00000007bf100000, 0x00000007bf200000)</span><br><span class="line"> tenured generation   total 14336K, used 7168K [0x00000007bf200000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line">   the space 14336K,  50% used [0x00000007bf200000, 0x00000007bf900010, 0x00000007bf900200, 0x00000007c0000000)</span><br><span class="line"> Metaspace       used 3199K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 352K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<h5 id="3-3-1-大对象处理策略"><a href="#3-3-1-大对象处理策略" class="headerlink" title="3.3.1 大对象处理策略"></a>3.3.1 大对象处理策略</h5><p>当遇到一个<strong>较大的对象</strong>时，就算新生代的<strong>伊甸园</strong>为空，也<strong>无法容纳该对象</strong>时，会将该对象<strong>直接晋升为老年代</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_8M</span> <span class="operator">=</span>  <span class="number">8</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_8M]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 1497K [0x00000007be800000, 0x00000007bf200000, 0x00000007bf200000)</span><br><span class="line">  eden space 8192K,  18% used [0x00000007be800000, 0x00000007be9766e8, 0x00000007bf000000)</span><br><span class="line">  from space 1024K,   0% used [0x00000007bf000000, 0x00000007bf000000, 0x00000007bf100000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000007bf100000, 0x00000007bf100000, 0x00000007bf200000)</span><br><span class="line"> tenured generation   total 14336K, used 8192K [0x00000007bf200000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line">   the space 14336K,  57% used [0x00000007bf200000, 0x00000007bfa00010, 0x00000007bfa00200, 0x00000007c0000000)</span><br><span class="line"> Metaspace       used 3106K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 333K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<h5 id="3-3-2-线程内存溢出"><a href="#3-3-2-线程内存溢出" class="headerlink" title="3.3.2 线程内存溢出"></a>3.3.2 线程内存溢出</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_8M</span> <span class="operator">=</span>  <span class="number">8</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            ArrayList&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_8M]);</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_8M]);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;sleep...&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sleep...</span><br><span class="line">[GC (Allocation Failure) [DefNew: 3683K-&gt;572K(9216K), 0.0010077 secs][Tenured: 8192K-&gt;8762K(14336K), 0.0015132 secs] 11875K-&gt;8762K(23552K), [Metaspace: 4106K-&gt;4106K(1056768K)], 0.0025433 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (Allocation Failure) [Tenured: 8762K-&gt;8707K(14336K), 0.0012168 secs] 8762K-&gt;8707K(23552K), [Metaspace: 4106K-&gt;4106K(1056768K)], 0.0012369 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">Exception in thread &quot;Thread-0&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at GC_Analyse.Demo.lambda$main$0(Demo.java:17)</span><br><span class="line">	at GC_Analyse.Demo$$Lambda$1/455659002.run(Unknown Source)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:750)</span><br><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 383K [0x00000007be800000, 0x00000007bf200000, 0x00000007bf200000)</span><br><span class="line">  eden space 8192K,   4% used [0x00000007be800000, 0x00000007be85fc28, 0x00000007bf000000)</span><br><span class="line">  from space 1024K,   0% used [0x00000007bf100000, 0x00000007bf100000, 0x00000007bf200000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000007bf000000, 0x00000007bf000000, 0x00000007bf100000)</span><br><span class="line"> tenured generation   total 14336K, used 8707K [0x00000007bf200000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line">   the space 14336K,  60% used [0x00000007bf200000, 0x00000007bfa80c48, 0x00000007bfa80e00, 0x00000007c0000000)</span><br><span class="line"> Metaspace       used 4133K, capacity 4676K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 461K, capacity 496K, committed 512K, reserved 1048576K</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>某个线程的内存溢出了而抛异常 (<code>java.lang.OutOfMemoryError</code>)，不会让其他的线程结束运行，原因如下：</p>
<ul>
<li>当一个线程<strong>抛出OOM异常后</strong>，<strong>它所占据的内存资源会全部被释放掉</strong>，从而不会影响其他线程的运行，<strong>其他进程依然正常</strong></li>
</ul>
<h3 id="4-垃圾回收器"><a href="#4-垃圾回收器" class="headerlink" title="4 垃圾回收器"></a>4 垃圾回收器</h3><h4 id="4-0-概述"><a href="#4-0-概述" class="headerlink" title="4.0 概述"></a>4.0 概述</h4><ol>
<li>串行垃圾回收器<ul>
<li>实质是一个单线程的垃圾回收器</li>
<li>使用场景：堆内存较小，适合个人电脑</li>
</ul>
</li>
<li>吞吐量优先垃圾回收器<ul>
<li>多线程</li>
<li>使用场景：堆内存较大，多核 CPU 支持</li>
<li>在单位时间内，STW 的时间最短。例如，在一小时内，垃圾回收了 2 次，总时长是 0.2 + 0.1 秒</li>
</ul>
</li>
<li>响应时间优先垃圾回收器<ul>
<li>多线程</li>
<li>使用场景：堆内存较大，多核 CPU 支持</li>
<li>垃圾清理（STW）的单次时间尽可能最短</li>
</ul>
</li>
</ol>
<h4 id="4-1-串行垃圾回收器"><a href="#4-1-串行垃圾回收器" class="headerlink" title="4.1 串行垃圾回收器"></a>4.1 串行垃圾回收器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseSerialGC=Serial+SerialOld // 新生代copy算法，老年代 标记整理</span><br></pre></td></tr></table></figure>
<p><img src="/2022/03/22/JVM-1/image-20220818231033690.png" alt="image-20220818231033690" style="zoom:50%;"></p>
<h4 id="4-2-吞吐量优先垃圾回收器"><a href="#4-2-吞吐量优先垃圾回收器" class="headerlink" title="4.2 吞吐量优先垃圾回收器"></a>4.2 吞吐量优先垃圾回收器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC -XX:+UseParallelOldGC</span><br><span class="line">-XX:ParallelGCThreads=n // 设置垃圾回收线程数</span><br><span class="line">-XX:+UseAdaptiveSizePolicy // 自适应调整</span><br><span class="line">-XX:GCTimeRatio=ratio // 调整垃圾回收时间与总时间的占比: 1/(1+ratio)</span><br><span class="line">-XX:MaxGCPauseMillis=ms // 最大暂停时间(毫秒)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/03/22/JVM-1/image-20220818231641184.png" alt="image-20220818231641184" style="zoom:50%;"></p>
<h4 id="4-3-响应时间优先垃圾回收器"><a href="#4-3-响应时间优先垃圾回收器" class="headerlink" title="4.3 响应时间优先垃圾回收器"></a>4.3 响应时间优先垃圾回收器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseConcMarkSweepGC ~ -XX:+UseParNewGC ~ SerialOld</span><br><span class="line">-XX:ParallelGCThreads=n ~ -XX:ConcGCThreads=threads</span><br><span class="line">-XX:CMSInitiatingOccupancyFraction=percent</span><br><span class="line">-XX:+CMSScavengeBeforeRemark</span><br></pre></td></tr></table></figure>
<p><img src="/2022/03/22/JVM-1/image-20220818235606862.png" alt="image-20220818235606862" style="zoom:50%;"></p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Guohao
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://dave0126.github.io/2022/03/22/JVM-1/" title="Java 虚拟机 - JVM">https://dave0126.github.io/2022/03/22/JVM-1/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
              <a href="/tags/JVM/" rel="tag"># JVM</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/" rel="prev" title="图论 复习笔记">
      <i class="fa fa-chevron-left"></i> 图论 复习笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/" rel="next" title="Java 并发多线程编程 (JUC) (一)">
      Java 并发多线程编程 (JUC) (一) <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0"><span class="nav-text">JVM 基础学习</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-JVM%EF%BC%9F"><span class="nav-text">什么是 JVM？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81JVM-%E7%BB%93%E6%9E%84"><span class="nav-text">一、JVM 结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="nav-text">二、JVM 内存结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-text">1. 程序计数器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="nav-text">2. 虚拟机栈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-%E5%AE%9A%E4%B9%89"><span class="nav-text">2.1 定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-%E6%A0%88%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="nav-text">2.2 栈内存溢出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%AF%8A%E6%96%AD"><span class="nav-text">2.3 线程运行诊断</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="nav-text">3. 本地方法栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%A0%86"><span class="nav-text">4. 堆</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-%E5%AE%9A%E4%B9%89"><span class="nav-text">4.1 定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-%E5%A0%86%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="nav-text">4.2 堆内存溢出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-%E5%A0%86%E5%86%85%E5%AD%98%E8%AF%8A%E6%96%AD"><span class="nav-text">4.3 堆内存诊断</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="nav-text">5. 方法区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-%E5%AE%9A%E4%B9%89"><span class="nav-text">5.1 定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-%E7%BB%84%E6%88%90"><span class="nav-text">5.2 组成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="nav-text">5.3 方法区的内存溢出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-text">5.4 运行时常量池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-StringTable%E4%B8%B2%E6%B1%A0"><span class="nav-text">5.5 StringTable串池</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-5-1-%E4%B8%B2%E6%B1%A0"><span class="nav-text">5.5.1 串池</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-5-2-%E4%B8%B2%E6%B1%A0%EF%BC%9A%E6%8B%BC%E6%8E%A5%E5%8F%98%E9%87%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">5.5.2 串池：拼接变量字符串对象创建字符串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-5-3-%E4%B8%B2%E6%B1%A0%EF%BC%9A%E6%8B%BC%E6%8E%A5%E5%B8%B8%E9%87%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">5.5.3 串池：拼接常量字符串对象的方法创建字符串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-5-4-%E4%B8%B2%E6%B1%A0%EF%BC%9Aintern-%E6%96%B9%E6%B3%95-JDK1-8"><span class="nav-text">5.5.4 串池：intern() 方法(JDK1.8)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BE%8B1"><span class="nav-text">例1</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BE%8B2"><span class="nav-text">例2</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BE%8B3"><span class="nav-text">例3</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-5-5-%E4%B8%B2%E6%B1%A0%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="nav-text">5.5.5 串池的位置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-5-6-%E4%B8%B2%E6%B1%A0%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-text">5.5.6 串池的垃圾回收</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-5-7-%E4%B8%B2%E6%B1%A0%E7%9A%84%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98"><span class="nav-text">5.5.7 串池的性能调优</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="nav-text">6. 直接内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-%E5%AE%9A%E4%B9%89"><span class="nav-text">6.1 定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-text">6.2 基本使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6%E5%8E%9F%E7%90%86"><span class="nav-text">6.3 分配和回收原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#allocateDirect-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-text">allocateDirect() 的实现底层源码分析</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-text">三、JVM 垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#0-%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9%E5%A4%A7%E7%BA%B2"><span class="nav-text">0 主要内容大纲</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9B%9E%E6%94%B6"><span class="nav-text">1 如何判断对象可以被回收</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="nav-text">1.1 引用计数法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="nav-text">1.2 可达性分析算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-%E4%BA%94%E7%A7%8D%E5%BC%95%E7%94%A8"><span class="nav-text">1.3 五种引用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-1-%E5%BC%BA%E5%BC%95%E7%94%A8"><span class="nav-text">1.3.1 强引用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-2-%E8%BD%AF%E5%BC%95%E7%94%A8-Soft-Reference"><span class="nav-text">1.3.2 软引用 (Soft Reference)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-3-%E5%BC%B1%E5%BC%95%E7%94%A8-Weak-Referrnce"><span class="nav-text">1.3.3 弱引用 (Weak Referrnce)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-4-%E8%99%9A%E5%BC%95%E7%94%A8-Phantom-Reference"><span class="nav-text">1.3.4 虚引用 (Phantom Reference)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-5-%E7%BB%88%E7%BB%93%E5%99%A8%E5%BC%95%E7%94%A8-Finalize-Reference"><span class="nav-text">1.3.5 终结器引用 (Finalize Reference)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="nav-text">2 垃圾回收算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4-%E7%AE%97%E6%B3%95-Mark-Sweep"><span class="nav-text">2.1 标记 - 清除 算法 (Mark - Sweep)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86-%E7%AE%97%E6%B3%95-Mark-Compact"><span class="nav-text">2.2 标记 - 整理 算法 (Mark - Compact)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-%E5%A4%8D%E5%88%B6-%E7%AE%97%E6%B3%95-Copy"><span class="nav-text">2.3 复制 算法 (Copy)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-%E6%80%BB%E7%BB%93"><span class="nav-text">2.4 总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="nav-text">3 分代垃圾回收机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6%E6%B5%81%E7%A8%8B"><span class="nav-text">3.1 分代回收流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-%E7%9B%B8%E5%85%B3%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%82%E6%95%B0"><span class="nav-text">3.2 相关虚拟机参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-GC%E5%88%86%E6%9E%90"><span class="nav-text">3.3  GC分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-1-%E5%A4%A7%E5%AF%B9%E8%B1%A1%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="nav-text">3.3.1 大对象处理策略</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-2-%E7%BA%BF%E7%A8%8B%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="nav-text">3.3.2 线程内存溢出</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-text">4 垃圾回收器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-0-%E6%A6%82%E8%BF%B0"><span class="nav-text">4.0 概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-%E4%B8%B2%E8%A1%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-text">4.1 串行垃圾回收器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-text">4.2 吞吐量优先垃圾回收器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-text">4.3 响应时间优先垃圾回收器</span></a></li></ol></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Guohao</p>
  <div class="site-description" itemprop="description">间歇性踌躇满志, 持续性划水摸鱼</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Guohao</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">271k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">4:06</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>



        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  













<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : '[object Object]',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
