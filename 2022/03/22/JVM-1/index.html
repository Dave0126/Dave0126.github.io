<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dave0126.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="JVM 基础学习 第一章：JVM 结构 第二章：JVM 内存结构 第三章：JVM 垃圾回收 第四章：类加载与字节码技术  【参考资料】  视频课程：BiliBili - 黑马程序员 JVM 完整教程 The Java® Virtual Machine Specification - Java SE 8 Edition 官方文档">
<meta property="og:type" content="article">
<meta property="og:title" content="Java 虚拟机 - JVM">
<meta property="og:url" content="https://dave0126.github.io/2022/03/22/JVM-1/index.html">
<meta property="og:site_name" content="Lost N Found">
<meta property="og:description" content="JVM 基础学习 第一章：JVM 结构 第二章：JVM 内存结构 第三章：JVM 垃圾回收 第四章：类加载与字节码技术  【参考资料】  视频课程：BiliBili - 黑马程序员 JVM 完整教程 The Java® Virtual Machine Specification - Java SE 8 Edition 官方文档">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/image-20220719142025243.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/image-20220719142921758.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/image-20220719144541816.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/IMG_6B2CE85A4DCA-1.jpeg">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/IMG_9A689689FB20-1.jpeg">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/IMG_42907AA7BAF6-1.jpeg">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/image-20220816162626624.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/image-20220816163058539.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/20200608150750%20(1).png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/20200608150800.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/20200608150813.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/20200608150827.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/20200608150842.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/20200608150856.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/20200608150907.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/20200608150919.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/20200608150931.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/20200608150939.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/20200608150946.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/20200608150955.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/20200608151002.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/20200608151010.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/20200608151018.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/IMG_FB5339E468EB-1.jpeg">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/image-20220818231033690.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/image-20220818231641184.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/image-20220818235606862.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/image-20220819112113472.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/image-20220819113509917.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/image-20220819114148727.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/image-20220819114932406.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/image-20220819120000627.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/image-20220819122114517.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/image-20220819161019323.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/1-1001259.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/2.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/3.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/4.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/5.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/6.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/7.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/8.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/9.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/10.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/11.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/12.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/13.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/14.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/15.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/16.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/17.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/18.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/19.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/20.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/21.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/image-20220823212538798.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/22/JVM-1/image-20220824100940813.png">
<meta property="article:published_time" content="2022-03-22T20:52:44.000Z">
<meta property="article:modified_time" content="2022-08-26T17:31:41.593Z">
<meta property="article:author" content="Guohao">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="JVM">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://dave0126.github.io/2022/03/22/JVM-1/image-20220719142025243.png">

<link rel="canonical" href="https://dave0126.github.io/2022/03/22/JVM-1/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Java 虚拟机 - JVM | Lost N Found</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Lost N Found" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Lost N Found</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/Dave0126" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dave0126.github.io/2022/03/22/JVM-1/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Guohao">
      <meta itemprop="description" content="间歇性踌躇满志, 持续性划水摸鱼">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lost N Found">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Java 虚拟机 - JVM
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-22 21:52:44" itemprop="dateCreated datePublished" datetime="2022-03-22T21:52:44+01:00">2022-03-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-08-26 19:31:41" itemprop="dateModified" datetime="2022-08-26T19:31:41+02:00">2022-08-26</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index"><span itemprop="name">Java</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>66k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:01</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="JVM-基础学习"><a href="#JVM-基础学习" class="headerlink" title="JVM 基础学习"></a>JVM 基础学习</h1><ul>
<li><a href="#一、JVM-结构">第一章：JVM 结构</a></li>
<li><a href="#二、JVM-内存结构">第二章：JVM 内存结构</a></li>
<li><a href="#三、JVM-垃圾回收">第三章：JVM 垃圾回收</a></li>
<li><a href="#四、类加载与字节码技术">第四章：类加载与字节码技术</a></li>
</ul>
<p>【参考资料】</p>
<ol>
<li>视频课程：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1yE411Z7AP">BiliBili - 黑马程序员 JVM 完整教程</a></li>
<li><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/index.html">The Java® Virtual Machine Specification - Java SE 8 Edition 官方文档</a></li>
</ol>
<span id="more"></span>
<h2 id="什么是-JVM？"><a href="#什么是-JVM？" class="headerlink" title="什么是 JVM？"></a>什么是 JVM？</h2><p><code>JVM (Java Virtual Machine)</code> 是 Java 程序的运行环境(Java 二进制字节码的运行环境)</p>
<p><strong>好处:</strong></p>
<ul>
<li>可以提供一个跨平台的一致的运行环境, 达到平台无关性；</li>
<li>提供内存管理, 垃圾回收功能；</li>
</ul>
<p><code>JRE = JVM + 基础类库</code></p>
<p><code>JDK = JVM + 基础类库 + 编译工具</code></p>
<p><img src="/2022/03/22/JVM-1/image-20220719142025243.png" alt="image-20220719142025243" style="zoom:40%;"></p>
<h2 id="一、JVM-结构"><a href="#一、JVM-结构" class="headerlink" title="一、JVM 结构"></a>一、JVM 结构</h2><p><img src="/2022/03/22/JVM-1/image-20220719142921758.png" alt="image-20220719142921758"></p>
<p>总体分为三大部分：</p>
<ul>
<li><code>ClassLoader</code> 类加载器：<code>Java</code> 代码编译成二进制后，会经过类加载器，这样才能加载到 <code>JVM</code> 中运行。</li>
<li><code>JVM</code> 内存结构</li>
<li>执行引擎</li>
</ul>
<h2 id="二、JVM-内存结构"><a href="#二、JVM-内存结构" class="headerlink" title="二、JVM 内存结构"></a>二、JVM 内存结构</h2><ol>
<li>程序计数器 (Program Counter Register)</li>
<li>虚拟机栈 (JVM Stacks)</li>
<li>本地方法栈 (Native Method Stacks)</li>
<li>堆 (Heap)</li>
<li>方法区 (Method Area)</li>
</ol>
<h3 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1. 程序计数器"></a>1. 程序计数器</h3><p>Java中 <code>JVM</code> 指令的实行流程</p>
<p><img src="/2022/03/22/JVM-1/image-20220719144541816.png" alt="image-20220719144541816" style="zoom:50%;"></p>
<p>作用: 在指令的执行中, 记住<strong>下一条 <code>JVM</code> 指令的执行地址</strong>. 在物理上可使用<strong>寄存器</strong>实现.</p>
<p>特点:</p>
<ul>
<li>线程私有。在多线程下, 线程间切换时需要保存当前环境, 需要用到程序计数器记住下一条 <code>JVM</code> 指令的执行地址</li>
<li>不存在内存溢出。</li>
</ul>
<h3 id="2-虚拟机栈"><a href="#2-虚拟机栈" class="headerlink" title="2. 虚拟机栈"></a>2. 虚拟机栈</h3><h4 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h4><p>回忆数据结构中“<strong>栈</strong>”的结构: 先进后出</p>
<p>虚拟机栈是<strong><u>线程</u>运行需要的内存空间</strong>，<strong>一个栈由多个栈帧组成</strong>。一个栈帧对应一次方法的调用，<strong>栈帧(Frame)</strong>即<strong>每个方法调用时需要的内存(参数、局部变量、返回地址等)</strong>。</p>
<ul>
<li>每个线程只能有一个<strong><u>活动栈帧</u></strong>，对应着<strong><u>当前正在执行的那个方法</u></strong>，栈顶的栈帧。</li>
</ul>
<blockquote>
<p>注意⚠️：可以在 IDEA 中用 “debug” 模式下的“Debugger”视图中看到栈和栈帧.</p>
</blockquote>
<p><strong>思考:</strong></p>
<ul>
<li>在函数的调用中, <ol>
<li>先把主调函数入栈，调用被调函数，紧接着被调函数入栈，活动栈帧为被调函数；</li>
<li>等被调函数返回返回值时，被调函数出栈，活动栈帧为主调函数。</li>
</ol>
</li>
<li><u>垃圾回收不涉及栈内存</u>, 因为每次执行后栈内存都会被清空(出栈)</li>
<li><p>栈内存越大, 线程数越小 (默认 1024KB)</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xss 1m or 1024k or 1048576</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="2-2-栈内存溢出"><a href="#2-2-栈内存溢出" class="headerlink" title="2.2 栈内存溢出"></a>2.2 栈内存溢出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.StackOverflowError</span><br></pre></td></tr></table></figure>
<ol>
<li><p>栈帧过多导致内存溢出</p>
<ul>
<li><p>想象一下，在不断的调用方法时，一直入栈没有出栈，直到某一次调用时无法分配新的栈帧内存。</p>
<p>e.g. 无递归终止条件的<strong>递归调用</strong></p>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StackOverflowTest</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> count;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      method1();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable a) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">      System.out.print(count);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">method1</span><span class="params">()</span> &#123;</span><br><span class="line">    count++;</span><br><span class="line">    method1();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>栈帧过大导致内存溢出，栈帧 &gt; 栈内存</li>
</ol>
<h4 id="2-3-线程运行诊断"><a href="#2-3-线程运行诊断" class="headerlink" title="2.3 线程运行诊断"></a>2.3 线程运行诊断</h4><p>如何查看某个进程中 CPU 的占用情况</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ps H -eo pid,tid,%cpu | grep 进程id</span><br></pre></td></tr></table></figure>
<p><code>JDK</code> 自带一个工具 <code>JStack</code> 命令, 用于定位 CPU占用过多的 Java线程(TID). 根据线程 id(TID) 找到有问题的线程,即可能有问题的代码行数. 也可以发现<strong>有死锁的进程</strong>.</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack 进程id(PID)</span><br></pre></td></tr></table></figure>
<h3 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3. 本地方法栈"></a>3. 本地方法栈</h3><p>本地方法是由于 Java 语言限制, 不能直接和操作系统底层“打交道”，所以需要 <code>c/c++</code> 语言编写的方法直接与底层操作系统“打交道”， 而java代码可以使用本地方法调用来调用这些方法。</p>
<p>本地方法使用的内存就是本地方法栈.</p>
<ul>
<li>例如 <code>hashCode()</code>, <code>wait()</code>, <code>notify()</code>, <code>notifyAll()</code> 等</li>
<li>由 <code>native</code> 修饰</li>
</ul>
<h3 id="4-堆"><a href="#4-堆" class="headerlink" title="4. 堆"></a>4. 堆</h3><p>线程共享的区域，都要考虑线程安全问题</p>
<h4 id="4-1-定义"><a href="#4-1-定义" class="headerlink" title="4.1 定义"></a>4.1 定义</h4><ul>
<li>通过 <code>new</code> 关键字 $\to$ 创建一个堆，都会使用堆的内存</li>
</ul>
<p>特点:</p>
<ul>
<li><strong><u>线程共享</u></strong>，堆中对象都要考虑线程安全问题</li>
<li><strong><u>有垃圾回收机制</u></strong>，当对象不再被引用时，其占用的内存会被回收</li>
</ul>
<h4 id="4-2-堆内存溢出"><a href="#4-2-堆内存溢出" class="headerlink" title="4.2 堆内存溢出"></a>4.2 堆内存溢出</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 创建堆</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            list.add(a);</span><br><span class="line">            a = a + a; <span class="comment">// Hello, HelloHello, HelloHelloHelloHello, ....</span></span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="4-3-堆内存诊断"><a href="#4-3-堆内存诊断" class="headerlink" title="4.3 堆内存诊断"></a>4.3 堆内存诊断</h4><p><code>Java</code> 常用工具:</p>
<ol>
<li><code>jps</code> 工具<ul>
<li>查看当前系统中有哪些java进程</li>
</ul>
</li>
<li><code>jmap</code> 工具 <ul>
<li>查看某一时刻下,堆内存的占用情况</li>
</ul>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ jps</span><br><span class="line">$ jmap -heap 进程id(PID)</span><br></pre></td></tr></table></figure>
<ol>
<li><code>jconsole</code> 工具<ul>
<li>图形界面的, 多功能的检查工具, 可以连续监测</li>
</ul>
</li>
<li><code>jvisualvm</code> 工具 (需要自行下载)</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;1....&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">    <span class="type">byte</span>[] array = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span> * <span class="number">1024</span> * <span class="number">10</span>];  <span class="comment">// 堆中内存占用新增10MB</span></span><br><span class="line">    System.out.println(<span class="string">&quot;2....&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">    array = <span class="literal">null</span>;</span><br><span class="line">    System.gc();                                <span class="comment">// 垃圾回收</span></span><br><span class="line">    System.out.println(<span class="string">&quot;3....&quot;</span>);</span><br><span class="line">    Thread.sleep(<span class="number">30000</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5. 方法区"></a>5. 方法区</h3><h4 id="5-1-定义"><a href="#5-1-定义" class="headerlink" title="5.1 定义"></a>5.1 定义</h4><p>方法区是 <code>JVM</code> 中<strong>所有线程共享</strong>的区域.</p>
<p>存储了与<strong>类</strong>结构相关的信息: </p>
<ul>
<li>成员变量 (field)</li>
<li>方法的数据 (method data)</li>
<li>方法的代码 (code of method)</li>
<li>构造器的代码 (code of constructor)</li>
<li>运行时常量池 (run-time constant pool)</li>
</ul>
<p>方法区在 <code>JVM</code> <strong><u>启动时</u></strong>创建，逻辑上是<u><strong>堆</strong></u>的一部分。</p>
<h4 id="5-2-组成"><a href="#5-2-组成" class="headerlink" title="5.2 组成"></a>5.2 组成</h4><p>JDK 1.6 与 JDK 1.8。</p>
<ul>
<li>JDK 1.6 中，方法区这种概念的实现方式（永久代）属于 <code>JVM</code> 的内存结构；</li>
<li>JDK 1.8 中，方法区这种概念的实现方式（元空间）从 <code>JVM</code> 的内存结构中提取出来，属于操作系统内存结构的一部分</li>
</ul>
<p><img src="/2022/03/22/JVM-1/IMG_6B2CE85A4DCA-1.jpeg" alt="methodArea"></p>
<h4 id="5-3-方法区的内存溢出"><a href="#5-3-方法区的内存溢出" class="headerlink" title="5.3 方法区的内存溢出"></a>5.3 方法区的内存溢出</h4><ul>
<li>永久代内存溢出（JDK 1.8以前）</li>
</ul>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR INFO: java.lang.OutOfMemoryError: PermGen space</span><br><span class="line">-XX:MaxPermSize=8m</span><br></pre></td></tr></table></figure>
<ul>
<li>元空间内存溢出（JDK 1.8以后）</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR INFO: java.lang.OutOfMemoryError: Metaspace</span><br><span class="line">-XX:MaxMetaspaceSize=8m</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> <span class="keyword">extends</span> <span class="title class_">ClassLoader</span> &#123; <span class="comment">// 类加载器: 可以用来加载类的二进制字节码, 动态加载</span></span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span> <span class="params">(String[] args)</span>&#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="type">Demo</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Demo</span>();</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++, j++) &#123;</span><br><span class="line">        <span class="type">ClassWriter</span> <span class="variable">cw</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassWriter</span>(<span class="number">0</span>); <span class="comment">// ClassWriter作用是生成类的二进制字节码</span></span><br><span class="line">        cw.visit(Opcodes.V1_8, Opcodes.ACC_PUBLIC, <span class="string">&quot;Class&quot;</span> + i, <span class="literal">null</span>, <span class="string">&quot;java/lang/Object&quot;</span>, <span class="literal">null</span>); </span><br><span class="line">        <span class="comment">// 版本号, public, 类名:1~10000, 包名:null, 父类: 继承自&quot;java/lang/Object&quot;, 接口名:null</span></span><br><span class="line">        <span class="comment">//返回 byte[]</span></span><br><span class="line">        <span class="type">byte</span>[] code = cw.toByteArray();</span><br><span class="line">        <span class="comment">// 只执行类的加载, 而不链接</span></span><br><span class="line">        test.defineClass(<span class="string">&quot;Class&quot;</span> + i, code, <span class="number">0</span>, code.length); <span class="comment">// class 对象</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      System.out.println(j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有可能的溢出场景：实际生产中，动态产生并加载类时容易产生这种内存溢出</p>
<ol>
<li><code>Spring</code> 框架中的 <code>cglib</code> 字节码技术，<code>AOP</code> 的核心 - 生成动态代理类</li>
<li><code>Mybatis</code> 框架中的 <code>cglib</code> 字节码技术</li>
</ol>
<h4 id="5-4-运行时常量池"><a href="#5-4-运行时常量池" class="headerlink" title="5.4 运行时常量池"></a>5.4 运行时常量池</h4><p>编译后的<strong>二进制字节码</strong>包含: <u>类基本信息</u>、<u>常量池</u>、<u>类方法定义</u>、<u>虚拟机指令</u></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -v &lt;xxx.class&gt; // -v 显示反编译后的详细信息</span><br></pre></td></tr></table></figure>
<p>例如:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">test</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">&quot;Hello World&quot;</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反编译后的详细信息: </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line">Classfile /test.class											// 类基本信息</span><br><span class="line">  Last modified 2022年3月6日; size 413 bytes</span><br><span class="line">  SHA-256 checksum 7ab757ee2d78f0e76a52ba8b03b43fee2fe9d7994d74bc7d133b2e309ceed8f3</span><br><span class="line">  Compiled from &quot;test.java&quot;</span><br><span class="line">public class test</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 59</span><br><span class="line">  flags: (0x0021) ACC_PUBLIC, ACC_SUPER		// 访问修饰符</span><br><span class="line">  this_class: #21                         // test</span><br><span class="line">  super_class: #2                         // 父类:java/lang/Object</span><br><span class="line">  interfaces: 0, fields: 0, methods: 2, attributes: 1</span><br><span class="line">  </span><br><span class="line">Constant pool:														// 常量池</span><br><span class="line">   #1 = Methodref          #2.#3          // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Class              #4             // java/lang/Object</span><br><span class="line">   #3 = NameAndType        #5:#6          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #4 = Utf8               java/lang/Object</span><br><span class="line">   #5 = Utf8               &lt;init&gt;</span><br><span class="line">   #6 = Utf8               ()V</span><br><span class="line">   #7 = Fieldref           #8.#9          // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #8 = Class              #10            // java/lang/System</span><br><span class="line">   #9 = NameAndType        #11:#12        // out:Ljava/io/PrintStream;</span><br><span class="line">  #10 = Utf8               java/lang/System</span><br><span class="line">  #11 = Utf8               out</span><br><span class="line">  #12 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #13 = String             #14            // Hello World</span><br><span class="line">  #14 = Utf8               Hello World</span><br><span class="line">  #15 = Methodref          #16.#17        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">  #16 = Class              #18            // java/io/PrintStream</span><br><span class="line">  #17 = NameAndType        #19:#20        // println:(Ljava/lang/String;)V</span><br><span class="line">  #18 = Utf8               java/io/PrintStream</span><br><span class="line">  #19 = Utf8               println</span><br><span class="line">  #20 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">  #21 = Class              #22            // test</span><br><span class="line">  #22 = Utf8               test</span><br><span class="line">  #23 = Utf8               Code</span><br><span class="line">  #24 = Utf8               LineNumberTable</span><br><span class="line">  #25 = Utf8               main</span><br><span class="line">  #26 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #27 = Utf8               SourceFile</span><br><span class="line">  #28 = Utf8               test.java</span><br><span class="line">  </span><br><span class="line">&#123;																// 方法定义的区域</span><br><span class="line">  public test();								// 当程序没有构造方法时, 编译器会默认生成一个无参的构造方法</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (0x0001) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1		// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 1: 0</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);	// main方法</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: (0x0009) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1</span><br><span class="line">      // 虚拟机指令				#n: 对应着常量池中的变量</span><br><span class="line">         0: getstatic     #7		// Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">         3: ldc           #13		// String Hello World 加载引用地址</span><br><span class="line">         5: invokevirtual #15		// Method java/io/PrintStream.println:(Ljava/lang/String)V</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">        line 4: 8</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;test.java&quot;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>常量池</strong>就是<u>一张常量查找表</u>，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量(如字符串、整型、bool类型等)等信息；</li>
<li>运行时常量池，就是当该类被加载时，它的常量池信息会放入运行常量池，地址会替换为真正的内存地址。</li>
</ul>
<h4 id="5-5-StringTable串池"><a href="#5-5-StringTable串池" class="headerlink" title="5.5 StringTable串池"></a>5.5 <em>StringTable</em>串池</h4><p>特征：</p>
<ul>
<li><p>常量池中的信息，都会被加载到运行时常量池中。这时 <code>&quot;a&quot;, &quot;b&quot;, &quot;ab&quot;</code> 都是常量池中的符号，<strong>还不是 字符串对象</strong></p>
</li>
<li><p>常量池中的字符串仅是符号，只有<strong>在被第一次引用到时才会转化为对象</strong> <code>ldc</code></p>
</li>
<li><p>StringTable在内存结构上是哈希表，不能扩容</p>
</li>
<li><p>利用串池的机制，来避免重复创建字符串对象</p>
</li>
<li><p>字符串<strong>变量</strong>拼接的原理是<strong>StringBuilder</strong></p>
</li>
<li><p>字符串<strong>常量</strong>拼接的原理是<strong>编译器优化</strong></p>
</li>
<li><p>可以使用 <strong><code>intern()</code> 方法</strong>，主动将串池中还没有的字符串对象放入串池中</p>
<ul>
<li>JDK 1.8 中，尝试将串池中还没有的字符串对象放入串池时，如果串池中有该对象则不会放入；若没有，则放入串池，且将串池中的对象返回</li>
<li>JDK 1.6 中，尝试将串池中还没有的字符串对象放入串池时，如果串池中有该对象则不会放入；若没有，则会先将该对象复制一份，然后放入串池，最后将串池中的对象返回</li>
</ul>
<p><strong>注意</strong>：无论是串池还是堆里面的字符串，都是对象</p>
</li>
</ul>
<h5 id="5-5-1-串池"><a href="#5-5-1-串池" class="headerlink" title="5.5.1 串池"></a>5.5.1 串池</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableStudy</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>; </span><br><span class="line">		<span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">ab</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常量池中的信息:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">0: ldc           #2                  	// String a</span><br><span class="line">2: astore_1														// 把 a符号 变成 “a”字符串对象</span><br><span class="line">3: ldc           #3                 	// String b</span><br><span class="line">5: astore_2														// 把 b符号 变成 “b”字符串对象</span><br><span class="line">6: ldc           #4                  	// String ab</span><br><span class="line">8: astore_3														// 把 ab符号 变成 “ab”字符串对象</span><br><span class="line">9: return</span><br></pre></td></tr></table></figure>
<ol>
<li><p>当执行到 <code>ldc #2</code> 时，会把符号 a 变为 “a” 字符串对象，<strong>并放入串池中</strong>（hashtable结构 不可扩容）</p>
</li>
<li><p>当执行到 <code>ldc #3</code> 时，会把符号 b 变为 “b” 字符串对象，并放入串池中</p>
</li>
<li><p>当执行到 <code>ldc #4</code> 时，会把符号 ab 变为 “ab” 字符串对象，并放入串池中</p>
</li>
<li><p>最终 <code>StringTable [&quot;a&quot;, &quot;b&quot;, &quot;ab&quot;]</code></p>
<p><strong>注意</strong>：字符串对象的创建都是<strong>懒惰的</strong>，只有当运行到那一行字符串且在串池中不存在的时候（如 ldc #2）时，该字符串才会被创建并放入串池中。</p>
</li>
</ol>
<h5 id="5-5-2-串池：拼接变量字符串对象创建字符串"><a href="#5-5-2-串池：拼接变量字符串对象创建字符串" class="headerlink" title="5.5.2 串池：拼接变量字符串对象创建字符串"></a>5.5.2 串池：拼接变量字符串对象创建字符串</h5><p>使用拼接<strong>字符串变量对象</strong>创建字符串的过程: </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableStudy</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">ab</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">ab2</span> <span class="operator">=</span> a+b;		<span class="comment">// new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toSrting()</span></span><br><span class="line">    										<span class="comment">// 相当于创建了一个新的 String对象</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(ab == ab2); <span class="comment">// 结果为false</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反编译后的结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">    stack=2, locals=5, args_size=1</span><br><span class="line">       0: ldc           #2                  // String a</span><br><span class="line">       2: astore_1</span><br><span class="line">       3: ldc           #3                  // String b</span><br><span class="line">       5: astore_2</span><br><span class="line">       6: ldc           #4                  // String ab</span><br><span class="line">       8: astore_3</span><br><span class="line">       9: new           #5                  // class java/lang/StringBuilder</span><br><span class="line">      12: dup</span><br><span class="line">      13: invokespecial #6                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">      16: aload_1</span><br><span class="line">      17: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      20: aload_2</span><br><span class="line">      21: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">      24: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">      27: astore        4</span><br><span class="line">      29: return</span><br></pre></td></tr></table></figure>
<p>通过拼接的方式来创建字符串的<strong>过程</strong>是：<code>new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toString()</code>，地址应该在<strong>堆</strong>中</p>
<p>最后的toString方法的返回值是一个<strong>新的字符串</strong>，但字符串的<strong>值</strong>和拼接的字符串一致，但是两个不同的字符串，<strong>一个存在于串池之中，一个存在于堆内存之中</strong></p>
<h5 id="5-5-3-串池：拼接常量字符串对象的方法创建字符串"><a href="#5-5-3-串池：拼接常量字符串对象的方法创建字符串" class="headerlink" title="5.5.3 串池：拼接常量字符串对象的方法创建字符串"></a>5.5.3 串池：<strong>拼接常量字符串对象</strong>的方法创建字符串</h5><p>使用<strong>拼接字符串常量对象</strong>的方法创建字符串</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableStudy</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;b&quot;</span>;</span><br><span class="line">		<span class="type">String</span> <span class="variable">ab</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    <span class="type">String</span> <span class="variable">ab2</span> <span class="operator">=</span> a+b;</span><br><span class="line">		<span class="type">String</span> <span class="variable">ab3</span> <span class="operator">=</span> <span class="string">&quot;a&quot;</span> + <span class="string">&quot;b&quot;</span>; <span class="comment">// 使用拼接字符串的方法创建字符串，由于编译期间的优化</span></span><br><span class="line">    </span><br><span class="line">    System.out.println(ab == ab3); <span class="comment">// 结果为true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反编译后的结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">  stack=2, locals=6, args_size=1</span><br><span class="line">     0: ldc           #2                  // String a</span><br><span class="line">     2: astore_1</span><br><span class="line">     3: ldc           #3                  // String b</span><br><span class="line">     5: astore_2</span><br><span class="line">     6: ldc           #4                  // String ab</span><br><span class="line">     8: astore_3</span><br><span class="line">     9: new           #5                  // class java/lang/StringBuilder</span><br><span class="line">    12: dup</span><br><span class="line">    13: invokespecial #6                  // Method java/lang/StringBuilder.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">    16: aload_1</span><br><span class="line">    17: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">    20: aload_2</span><br><span class="line">    21: invokevirtual #7                  // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span><br><span class="line">    24: invokevirtual #8                  // Method java/lang/StringBuilder.toString:()Ljava/lang/String;</span><br><span class="line">    27: astore        4										// ab3初始化时直接从串池中获取字符串</span><br><span class="line">    29: ldc           #4                  // String ab</span><br><span class="line">    31: astore        5</span><br><span class="line">    33: return</span><br></pre></td></tr></table></figure>
<ul>
<li><p>当虚拟机执行到<strong>第0、3、5行</strong>时，会将“a” “b“ ”ab“放入串池。当执行到<strong>29行</strong>时我们可以看到，虚拟机不会先找“a” 再找“b”然后再将它们拼接起来，而是之间找到拼接后的“ab”。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringTable[<span class="string">&quot;a&quot;</span>, <span class="string">&quot;b&quot;</span>, <span class="string">&quot;ab&quot;</span>]</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>⚠️ 需要注意的是：</p>
<ul>
<li>使用<strong>拼接字符串<u>常量</u></strong> 的方法来创建新的字符串时，因为<strong>内容是<u>常量</u>，<code>javac</code> 在编译期会进行优化，结果已在编译期确定为 <code>ab</code></strong>，而创建 <code>ab</code> 的时候已经在串池中放入了 <code>&quot;ab&quot;</code>，所以 <code>ab3</code> 直接从串池中获取值，所以进行的操作和 <code>ab = &quot;ab&quot;</code> 一致。</li>
<li>使用<strong>拼接字符串<u>变量</u></strong> 的方法来创建新的字符串时，因为<strong>内容是<u>变量</u></strong>，只能<strong>在运行期确定它的值，所以需要使用StringBuilder来创建</strong></li>
</ul>
</blockquote>
<h5 id="5-5-4-串池：intern-方法-JDK1-8"><a href="#5-5-4-串池：intern-方法-JDK1-8" class="headerlink" title="5.5.4 串池：intern() 方法(JDK1.8)"></a>5.5.4 串池：<code>intern()</code> 方法(JDK1.8)</h5><p>调用字符串对象的 <code>intern()</code> 方法，会将该字符串对象尝试放入到串池中</p>
<ul>
<li>如果串池中没有该字符串对象，则放入成功</li>
<li>如果有该字符串对象，则放入失败</li>
<li>无论放入是否成功，都会返回<strong>串池中</strong>的字符串对象</li>
</ul>
<h6 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h6><p>JDK 1.8 环境下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableInternMethod1</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    	<span class="comment">// &quot;a&quot;&quot;b&quot; 被放入串池中，str 则存在于堆中</span></span><br><span class="line">    	<span class="comment">// StringTable[&quot;a&quot;, &quot;b&quot;]</span></span><br><span class="line">    	<span class="comment">// new String(&quot;a&quot;) 和 new String(&quot;b&quot;) 两个字符串对象</span></span><br><span class="line">    	<span class="comment">// 字符串对象 str = new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toSrting()</span></span><br><span class="line">    </span><br><span class="line">		<span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> str.intern();</span><br><span class="line">    	<span class="comment">// 调用str的intern()方法，这时串池中没有&quot;ab&quot;，则会将该字符串对象放入到串池中，此时堆内存与串池中的&quot;ab&quot;是同一个对象</span></span><br><span class="line">    </span><br><span class="line">		<span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    	<span class="comment">// 给str3赋值，因为此时串池中已有&quot;ab&quot;，则直接将串池中的内容返回</span></span><br><span class="line">    </span><br><span class="line">		<span class="comment">// 因为堆内存与串池中的&quot;ab&quot;是同一个对象，所以以下两条语句打印的都为true</span></span><br><span class="line">		System.out.println(str2 == str);</span><br><span class="line">		System.out.println(str3 == str);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h6><p>JDK 1.8 与 JDK 1.6</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SringTableInternMethod2</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"><span class="comment">/* 此处创建字符串对象&quot;ab&quot;，因为串池中还没有&quot;ab&quot;，所以将其放入串池中 */</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line"><span class="comment">/* &quot;a&quot; &quot;b&quot; 被放入串池中，str则存在于堆内存之中 */</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line"><span class="comment">/* 此时因为在创建str3时，&quot;ab&quot;已存在与串池中，所以放入失败，但是会返回串池中的&quot;ab&quot; */</span></span><br><span class="line">		<span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> str.intern();</span><br><span class="line">    </span><br><span class="line">		System.out.println(str == str2); <span class="comment">//false</span></span><br><span class="line">		System.out.println(str == str3); <span class="comment">//false</span></span><br><span class="line">		System.out.println(str2 == str3); <span class="comment">//true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h6><p>JDK 1.6环境下，与<a href="#例1">例1</a>进行比较。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableInternMethod3</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">		<span class="type">String</span> <span class="variable">str</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;a&quot;</span>) + <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">    	<span class="comment">// &quot;a&quot;&quot;b&quot; 被放入串池中，str 则存在于堆中</span></span><br><span class="line">    	<span class="comment">// StringTable[&quot;a&quot;, &quot;b&quot;]</span></span><br><span class="line">    	<span class="comment">// new String(&quot;a&quot;) 和 new String(&quot;b&quot;) 两个字符串对象</span></span><br><span class="line">    	<span class="comment">// 字符串对象 str = new StringBuilder().append(&quot;a&quot;).append(&quot;b&quot;).toSrting()</span></span><br><span class="line">    </span><br><span class="line">		<span class="type">String</span> <span class="variable">str2</span> <span class="operator">=</span> str.intern();</span><br><span class="line">    	<span class="comment">// 调用str的intern()方法，这时串池中没有&quot;ab&quot;，则会将该字符串对象放入到串池中，此时堆内存与串池中的&quot;ab&quot;是同一个对象</span></span><br><span class="line">    	<span class="comment">// 将 str 复制一份，将复制后的对象放入串池</span></span><br><span class="line">    	<span class="comment">// 此时 str2 与串池中的对象相同；str 则不同，是其的复制</span></span><br><span class="line">    </span><br><span class="line">		<span class="type">String</span> <span class="variable">str3</span> <span class="operator">=</span> <span class="string">&quot;ab&quot;</span>;</span><br><span class="line">    	<span class="comment">// 给str3赋值，因为此时串池中已有&quot;ab&quot;，则直接将串池中的内容返回，即 str3 = str2</span></span><br><span class="line">    </span><br><span class="line">		System.out.println(str3 == str2);	<span class="comment">// true</span></span><br><span class="line">		System.out.println(str3 == str); 	<span class="comment">// false</span></span><br><span class="line">    <span class="comment">// JDK1.8 环境下都为true</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="5-5-5-串池的位置"><a href="#5-5-5-串池的位置" class="headerlink" title="5.5.5 串池的位置"></a>5.5.5 串池的位置</h5><p>在 JDK 1.6 中：</p>
<p><img src="/2022/03/22/JVM-1/IMG_9A689689FB20-1.jpeg" alt="1.6" style="zoom: 60%;"></p>
<p>我们可以看到，由于串池逻辑上处于方法区中，而方法区是由永久代实现的，在垃圾回收时需要 <code>FullGC</code> 才能清理永久代，这样就会造成串池迟迟得不到清理，从而导致内存溢出。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">JDK1.6 环境下：</span><br><span class="line">-XX:MaxPermSize=10m</span><br><span class="line">-Xmx10m -XX:-UseGCOverheadLimit</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableJDK1_6Demo</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;~&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000000</span>; j++) &#123;</span><br><span class="line">        list.add(String.valueOf(j).intern());</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR INFO:</span><br><span class="line">java.lang.OutOfMemoryError: PermGen space</span><br></pre></td></tr></table></figure>
<p>为了解决以上问题，在 JDK 1.8 中改进了串池的位置。</p>
<p>在 JDK 1.8 中：</p>
<p><img src="/2022/03/22/JVM-1/IMG_42907AA7BAF6-1.jpeg" alt="StringTable1.8"></p>
<p>串池位于堆中，在垃圾回收时需要 <code>MinorGC</code> 进行垃圾回收，从而减轻内存占用。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">JDK1.6 环境下：</span><br><span class="line">-Xmx10m -XX:-UseGCOverheadLimit</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">StringTableJDK1_8Demo</span>&#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">    List&lt;String&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;~&gt;();</span><br><span class="line">    <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; <span class="number">1000000</span>; j++) &#123;</span><br><span class="line">        list.add(String.valueOf(j).intern());</span><br><span class="line">        i++;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      System.out.println(i);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR INFO:</span><br><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure>
<h5 id="5-5-6-串池的垃圾回收"><a href="#5-5-6-串池的垃圾回收" class="headerlink" title="5.5.6 串池的垃圾回收"></a>5.5.6 串池的垃圾回收</h5><p><code>StringTable</code> 在内存紧张时，会发生<a href="#三、JVM-垃圾回收">垃圾回收</a>。</p>
<h5 id="5-5-7-串池的性能调优"><a href="#5-5-7-串池的性能调优" class="headerlink" title="5.5.7 串池的性能调优"></a>5.5.7 串池的性能调优</h5><ul>
<li><p>因为 <code>StringTable</code> 是用 <code>HashTable</code> 实现的，所以我们可以<strong>适当增加 <code>HashTable</code> 的桶的个数</strong>，来减少字符串放入串池所需要的时间</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:StringTableSize=xxxx</span><br></pre></td></tr></table></figure>
</li>
<li><p>考虑是否需要将字符串对象入池，可以通过 <strong><code>intern()</code> 方法减少重复入池</strong></p>
</li>
</ul>
<h3 id="6-直接内存"><a href="#6-直接内存" class="headerlink" title="6. 直接内存"></a>6. 直接内存</h3><h4 id="6-1-定义"><a href="#6-1-定义" class="headerlink" title="6.1 定义"></a>6.1 定义</h4><p>直接内存不属于 <code>JVM</code> 内存结构，而是<strong>操作系统的内存</strong>。</p>
<ul>
<li>属于操作系统，常见于 NIO 操作时，<strong>用于数据缓冲区</strong></li>
<li>分配回收成本较高，但读写性能高</li>
<li>不受 <code>JVM</code> 内存回收管理</li>
</ul>
<h4 id="6-2-基本使用"><a href="#6-2-基本使用" class="headerlink" title="6.2 基本使用"></a>6.2 基本使用</h4><p><img src="/2022/03/22/JVM-1/image-20220816162626624.png" alt="image-20220816162626624"></p>
<p>使用了 <code>DirectBuffer</code> 后，</p>
<p>【直接内存】是操作系统和 <code>Java</code> 代码<strong>都可以访问的一块区域</strong>，无需将代码从系统内存复制到 <code>Java</code> 堆内存，从而提高了效率</p>
<p><img src="/2022/03/22/JVM-1/image-20220816163058539.png" alt="image-20220816163058539"></p>
<h4 id="6-3-分配和回收原理"><a href="#6-3-分配和回收原理" class="headerlink" title="6.3 分配和回收原理"></a>6.3 分配和回收原理</h4><ul>
<li>使用了 <code>Unsafe</code> 类来完成直接内存的分配回收，而且回收需要主动调用<strong>unsafe.freeMemory()</strong>方法</li>
<li><code>ByteBuffer</code> 的实现内部使用了 <code>Cleaner</code>（<a href="#1-3-五种引用">虚引用</a>）来检测 <code>ByteBuffer</code>。一旦 <code>ByteBuffer</code> 被垃圾回收，那么会由 <code>ReferenceHandler</code> 来调用 Cleaner 的 <code>clean()</code> 方法调用 <code>freeMemory</code> 来释放内存</li>
</ul>
<p>直接内存的回收不是通过JVM的垃圾回收来释放的，而是通过<strong>unsafe.freeMemory()</strong>来手动释放</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过ByteBuffer申请1M的直接内存</span></span><br><span class="line"><span class="type">ByteBuffer</span> <span class="variable">byteBuffer</span> <span class="operator">=</span> ByteBuffer.allocateDirect(_1M);</span><br></pre></td></tr></table></figure>
<p>申请直接内存，但JVM并不能回收直接内存中的内容，它是如何实现回收的呢？</p>
<h5 id="allocateDirect-的实现底层源码分析"><a href="#allocateDirect-的实现底层源码分析" class="headerlink" title="allocateDirect() 的实现底层源码分析"></a>allocateDirect() 的实现底层源码分析</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ByteBuffer <span class="title function_">allocateDirect</span><span class="params">(<span class="type">int</span> capacity)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DirectByteBuffer</span>(capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>DirectByteBuffer</code> 类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">DirectByteBuffer(<span class="type">int</span> cap) &#123;   <span class="comment">// package-private</span></span><br><span class="line">   </span><br><span class="line">    <span class="built_in">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line">    <span class="type">boolean</span> <span class="variable">pa</span> <span class="operator">=</span> VM.isDirectMemoryPageAligned();</span><br><span class="line">    <span class="type">int</span> <span class="variable">ps</span> <span class="operator">=</span> Bits.pageSize();</span><br><span class="line">    <span class="type">long</span> <span class="variable">size</span> <span class="operator">=</span> Math.max(<span class="number">1L</span>, (<span class="type">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">    Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">    <span class="type">long</span> <span class="variable">base</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        base = unsafe.allocateMemory(size); <span class="comment">//申请内存</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">        Bits.unreserveMemory(size, cap);</span><br><span class="line">        <span class="keyword">throw</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.setMemory(base, size, (<span class="type">byte</span>) <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="comment">// Round up to page boundary</span></span><br><span class="line">        address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        address = base;</span><br><span class="line">    &#125;</span><br><span class="line">    cleaner = Cleaner.create(<span class="built_in">this</span>, <span class="keyword">new</span> <span class="title class_">Deallocator</span>(base, size, cap)); <span class="comment">//通过虚引用，来实现直接内存的释放，this为虚引用的实际对象</span></span><br><span class="line">    att = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里调用了一个Cleaner的 <code>create()</code> 方法，且后台线程还会对虚引用的对象监测，如果虚引用的实际对象（这里是 <code>DirectByteBuffer</code>）被回收以后，就会调用Cleaner的 <code>clean()</code> 方法，来清除直接内存中占用的内存</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">clean</span><span class="params">()</span> &#123;</span><br><span class="line">       <span class="keyword">if</span> (remove(<span class="built_in">this</span>)) &#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="built_in">this</span>.thunk.run(); <span class="comment">//调用run方法</span></span><br><span class="line">           &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable var2) &#123;</span><br><span class="line">               AccessController.doPrivileged(<span class="keyword">new</span> <span class="title class_">PrivilegedAction</span>&lt;Void&gt;() &#123;</span><br><span class="line">                   <span class="keyword">public</span> Void <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                       <span class="keyword">if</span> (System.err != <span class="literal">null</span>) &#123;</span><br><span class="line">                           (<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;Cleaner terminated abnormally&quot;</span>, var2)).printStackTrace();</span><br><span class="line">                       &#125;</span><br><span class="line"></span><br><span class="line">                       System.exit(<span class="number">1</span>);</span><br><span class="line">                       <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>
<p>对应对象的 <code>run()</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (address == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Paranoia</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    unsafe.freeMemory(address); <span class="comment">// 释放直接内存中占用的内存</span></span><br><span class="line">    address = <span class="number">0</span>;</span><br><span class="line">    Bits.unreserveMemory(size, capacity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="三、JVM-垃圾回收"><a href="#三、JVM-垃圾回收" class="headerlink" title="三、JVM 垃圾回收"></a>三、JVM 垃圾回收</h2><h3 id="0-主要内容大纲"><a href="#0-主要内容大纲" class="headerlink" title="0 主要内容大纲"></a>0 主要内容大纲</h3><p>【概述】</p>
<p>之前我们讲解了 JVM 的内存结构，其中我们了解到<a href="#4-堆">堆</a>存在着垃圾回收机制。这一章我们将重点介绍这一部分内容。</p>
<ol>
<li><a href="#1-如何判断对象可以被回收">如何判断对象可以回收</a></li>
<li><a href="#2-垃圾回收算法">垃圾回收算法</a></li>
<li><a href="#3-分代垃圾回收机制">分代垃圾回收</a></li>
<li><a href>垃圾回收器</a></li>
<li><a href>垃圾回收调优</a></li>
</ol>
<h3 id="1-如何判断对象可以被回收"><a href="#1-如何判断对象可以被回收" class="headerlink" title="1 如何判断对象可以被回收"></a>1 如何判断对象可以被回收</h3><h4 id="1-1-引用计数法"><a href="#1-1-引用计数法" class="headerlink" title="1.1 引用计数法"></a>1.1 引用计数法</h4><ul>
<li>只要一个对象被其他变量所引用，那我们就让这个对象的计数 $+1$，如果被引用两次，该计数就为2。</li>
<li>如果某个变量不再引用这个对象，该对象的引用计数 $-1$。</li>
<li>当计数为 0 时，表示没有变量引用这个对象了，则可作为垃圾回收掉。</li>
</ul>
<p><img src="/2022/03/22/JVM-1/20200608150750 (1).png" alt="20200608150750 (1)" style="zoom:60%;"></p>
<blockquote>
<p>弊端：在例如上图的循环引用时，两个对象的计数都为 1，导致两个对象都无法被释放</p>
</blockquote>
<h4 id="1-2-可达性分析算法"><a href="#1-2-可达性分析算法" class="headerlink" title="1.2 可达性分析算法"></a>1.2 可达性分析算法</h4><p>首先先要确定【根对象】。那么什么是根对象呢？就是那些<u>肯定不能被当成垃圾回收的对象</u>。</p>
<p>在垃圾回收之前，我们先扫描堆内存中的所有对象，检查对象<u>是否被根对象直接或者间接的引用</u>。若是，则不能被回收；反之则可以被回收。</p>
<ul>
<li>JVM中的垃圾回收器通过<strong>可达性分析</strong>来探索所有存活的对象</li>
<li>扫描堆中的对象，看能否沿着 <code>GC Root</code> 对象（根对象）为起点的引用链找到该对象，如果<strong>找不到，则表示可以回收</strong></li>
</ul>
<blockquote>
<p>可以作为 <code>GC Root</code>的对象：</p>
<ul>
<li>虚拟机栈（栈帧中的局部变量表）中引用的对象；</li>
<li>方法区中类静态属性引用的对象；</li>
<li>方法区中常量引用的对象；</li>
<li>本地方法栈中JNI（即一般说的 Native方法）引用的对象</li>
</ul>
</blockquote>
<h4 id="1-3-五种引用"><a href="#1-3-五种引用" class="headerlink" title="1.3 五种引用"></a>1.3 五种引用</h4><p><img src="/2022/03/22/JVM-1/20200608150800.png" alt="20200608150800"></p>
<p>【总结】引用应用垃圾回收 GC 的时机：</p>
<ol>
<li>强引用：只有 GC Root <strong>都不引用</strong>该对象时，才会回收<strong>强引用</strong>对象</li>
<li>软引用：<ul>
<li><strong>仅有</strong>软引用引用该对象时，在垃圾回收之后，内存仍不足时会再次触发垃圾回收，回收软引用对象</li>
<li>可以配合引用队列来释放软引用自身</li>
</ul>
</li>
<li>弱引用：<ul>
<li><strong>只有</strong><u>弱引用</u>引用该对象时，在垃圾回收时，<strong>无论内存是否充足</strong>，都会回收弱引用所引用的对象。</li>
<li>可以配合引用队列来释放弱引用自身</li>
</ul>
</li>
<li>虚引用：<ul>
<li>必须配合<strong>引用队列</strong>使用，主要配合 <code>ByteBuffer</code> 使用。</li>
<li>被引用对象回收时，会讲虚引用入队列，由 <code>Reference Handler</code> 线程调用虚引用的相关方法释放内存。</li>
</ul>
</li>
<li>终结器引用：<ul>
<li>无需手动编码，但其内部配合引用队列使用。</li>
<li>在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由 <code>Finalizer</code> 线程通过终结器引用找到被引用对象并调用它的 <code>finalize()</code> 方法，第二次 GC 时才能回收被引用对象</li>
</ul>
</li>
</ol>
<h5 id="1-3-1-强引用"><a href="#1-3-1-强引用" class="headerlink" title="1.3.1 强引用"></a>1.3.1 强引用</h5><p>如上图，实线箭头表示强引用。日常使用中的引用都属于强引用。例如，<code>new</code> 一个对象，使用 <code>&quot;=&quot;</code> 将该对象赋值给一个变量，那么这个变量就强引用该对象。</p>
<blockquote>
<p><strong>垃圾回收的条件：</strong></p>
<p>只有 GC Root <strong>都不引用</strong>该对象时，才会回收<strong>强引用</strong>对象</p>
</blockquote>
<ul>
<li>如上图 B、C 对象都不引用 A1 对象时，A1 对象才会被回收</li>
</ul>
<p>案例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoStrongReference</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_4M</span> <span class="operator">=</span> <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line"></span><br><span class="line">        List&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 强引用</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_4M]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError: Java heap space</span><br></pre></td></tr></table></figure>
<h5 id="1-3-2-软引用-Soft-Reference"><a href="#1-3-2-软引用-Soft-Reference" class="headerlink" title="1.3.2 软引用 (Soft Reference)"></a>1.3.2 软引用 (Soft Reference)</h5><p>使用场景：当内存空间有限时，一些不重要的资源可以用软引用。</p>
<p>只要 A2、A3 两个对象没有被直接的强引用所引用，当垃圾回收发生时，都有可以被回收。</p>
<blockquote>
<p><strong>垃圾回收的条件：</strong></p>
<p>当 GC Root 指向软引用对象（垃圾回收）时，在<strong>内存不足时</strong>，会<strong>回收软引用所引用的对象</strong>。（先回收一次，如果内存还不够，回收软引用所引用的对象）</p>
</blockquote>
<ul>
<li>如上图如果 B 对象不再引用 A2 对象且内存不足时，软引用所引用的 A2 对象就会被回收</li>
</ul>
<p>案例 1</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 软引用演示</span></span><br><span class="line"><span class="comment"> * -Xmx20m -XX:+PrintGCDetails -verbose:gc</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoSoftReference1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_4M</span> <span class="operator">=</span> <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span></span><br><span class="line">        List&lt;SoftReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 强引用</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">            SoftReference&lt;<span class="type">byte</span>[]&gt; ref= <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[_4M]); <span class="comment">// 软引用</span></span><br><span class="line">            <span class="comment">// List list --强引用--&gt; SoftReference ref --软引用--&gt; byte[_4M]</span></span><br><span class="line">            System.out.println(ref.get());</span><br><span class="line">            list.add(ref);</span><br><span class="line">            System.out.println(list.size());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;循环结束：&quot;</span> + list.size());</span><br><span class="line">        <span class="keyword">for</span> (SoftReference&lt;<span class="type">byte</span>[]&gt; ref : list) &#123;</span><br><span class="line">            System.out.println(ref.get());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[B@75b84c92</span><br><span class="line">1</span><br><span class="line">[B@6bc7c054</span><br><span class="line">2</span><br><span class="line">[B@232204a1</span><br><span class="line">3</span><br><span class="line">[B@4aa298b7</span><br><span class="line">4</span><br><span class="line">[B@7d4991ad</span><br><span class="line">5</span><br><span class="line">循环结束：5</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">null</span><br><span class="line">[B@7d4991ad	// 只有最后一个数组被保留，上面的都被垃圾回收了</span><br></pre></td></tr></table></figure>
<p>如果在垃圾回收时发现内存不足，在回收软引用所指向的对象时，<strong>软引用本身不会被清理</strong></p>
<p>如果想要<strong>清理软引用</strong>，需要使<strong>用引用队列</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoSoftReference2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_4M</span> <span class="operator">=</span> <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用引用队列，用于移除引用为空的软引用对象</span></span><br><span class="line">        ReferenceQueue&lt;<span class="type">byte</span>[]&gt; queue = <span class="keyword">new</span> <span class="title class_">ReferenceQueue</span>&lt;&gt;(); <span class="comment">// 引用队列</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用软引用对象 list和SoftReference是强引用，而SoftReference和byte数组则是软引用</span></span><br><span class="line">        List&lt;SoftReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 强引用</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 关联了引用队列，当软引用所关联的 byte[]被回收时，软引用自自己会加入到 queue 中去</span></span><br><span class="line">            SoftReference&lt;<span class="type">byte</span>[]&gt; ref= <span class="keyword">new</span> <span class="title class_">SoftReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[_4M], queue); <span class="comment">// 软引用</span></span><br><span class="line">            <span class="comment">// List list --强引用--&gt; SoftReference ref --软引用--&gt; byte[_4M]</span></span><br><span class="line"></span><br><span class="line">            System.out.println(ref.get());</span><br><span class="line">            list.add(ref);</span><br><span class="line">            System.out.println(list.size());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//遍历引用队列，如果有元素，则取出</span></span><br><span class="line">        Reference&lt;? <span class="keyword">extends</span> <span class="title class_">byte</span>[]&gt; poll = queue.poll(); <span class="comment">// poll(), 取出最先放入队列的元素，返回类型Reference</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(poll != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 引用队列不为空，则从集合中移除该元素</span></span><br><span class="line">            list.remove(poll);</span><br><span class="line">            <span class="comment">// 移动到引用队列中的下一个元素</span></span><br><span class="line">            poll = queue.poll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;========================&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (SoftReference&lt;<span class="type">byte</span>[]&gt; ref : list) &#123;</span><br><span class="line">            System.out.println(ref.get());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[B@75b84c92</span><br><span class="line">1</span><br><span class="line">[B@6bc7c054</span><br><span class="line">2</span><br><span class="line">[B@232204a1</span><br><span class="line">3</span><br><span class="line">[B@4aa298b7</span><br><span class="line">4</span><br><span class="line">[B@7d4991ad</span><br><span class="line">5</span><br><span class="line">========================</span><br><span class="line">[B@7d4991ad</span><br></pre></td></tr></table></figure>
<p><strong>大概思路为：</strong>查看引用队列中有无软引用，如果有，则将该软引用从存放它的集合中移除（这里为一个list集合）</p>
<h5 id="1-3-3-弱引用-Weak-Referrnce"><a href="#1-3-3-弱引用-Weak-Referrnce" class="headerlink" title="1.3.3 弱引用 (Weak Referrnce)"></a>1.3.3 弱引用 (Weak Referrnce)</h5><blockquote>
<p><strong>垃圾回收的条件：</strong></p>
<p>当<strong>只有</strong><u>弱引用</u>引用该对象时，在垃圾回收时，<strong>无论内存是否充足</strong>，都会回收弱引用所引用的对象。</p>
</blockquote>
<ul>
<li>如上图如果B对象不再引用A3对象，则A3对象会被回收</li>
</ul>
<p><strong>弱引用的使用和软引用类似</strong>，只是将 <strong>SoftReference 换为了 WeakReference</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoWeakReference1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_4M</span> <span class="operator">=</span> <span class="number">4</span>*<span class="number">1024</span>*<span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">        List&lt;WeakReference&lt;<span class="type">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;(); <span class="comment">// 强引用</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">            WeakReference&lt;<span class="type">byte</span>[]&gt; ref= <span class="keyword">new</span> <span class="title class_">WeakReference</span>&lt;&gt;(<span class="keyword">new</span> <span class="title class_">byte</span>[_4M]); <span class="comment">// 软引用</span></span><br><span class="line">            <span class="comment">// List list --强引用--&gt; WeakReference ref --弱引用--&gt; byte[_4M]</span></span><br><span class="line">            list.add(ref);</span><br><span class="line">            <span class="keyword">for</span> (WeakReference&lt;<span class="type">byte</span>[]&gt; weakReference : list) &#123;</span><br><span class="line">                System.out.print(weakReference.get() + <span class="string">&quot;\t&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;循环结束：&quot;</span> + list.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[B@75b84c92	</span><br><span class="line">[B@75b84c92	[B@6bc7c054	</span><br><span class="line">[B@75b84c92	[B@6bc7c054	[B@232204a1	</span><br><span class="line">[B@75b84c92	[B@6bc7c054	[B@232204a1	[B@4aa298b7	</span><br><span class="line">null	[B@6bc7c054	[B@232204a1	[B@4aa298b7	[B@7d4991ad	</span><br><span class="line">null	[B@6bc7c054	[B@232204a1	[B@4aa298b7	null	[B@28d93b30	</span><br><span class="line">循环结束：6</span><br></pre></td></tr></table></figure>
<h5 id="1-3-4-虚引用-Phantom-Reference"><a href="#1-3-4-虚引用-Phantom-Reference" class="headerlink" title="1.3.4 虚引用 (Phantom Reference)"></a>1.3.4 虚引用 (Phantom Reference)</h5><p>必须配合<strong>引用队列</strong>一同使用。当虚（终结器）引用被创建时，会<u>关联一个引用队列</u>。</p>
<blockquote>
<ul>
<li>当虚引用对象所引用的对象被回收以后，虚引用对象就会被放入引用队列中，调用虚引用的方法</li>
<li>虚引用的一个体现是<strong>释放直接内存所分配的内存</strong>，当引用的对象 <code>ByteBuffer</code> 被垃圾回收以后，虚引用对象 <code>Cleaner</code> 就会被放入引用队列中，然后调用 <code>Cleaner</code> 的 <code>clean()</code> 方法来释放直接内存</li>
</ul>
</blockquote>
<ul>
<li>如上图，B 对象不再引用 <code>ByteBuffer</code> 对象，<code>ByteBuffer</code> 就会被回收。但是直接内存中的内存还未被回收。这时需要将虚引用对象 <code>Cleaner</code> 放入引用队列中，然后调用它的 <code>clean()</code> 方法来释放直接内存</li>
</ul>
<h5 id="1-3-5-终结器引用-Finalize-Reference"><a href="#1-3-5-终结器引用-Finalize-Reference" class="headerlink" title="1.3.5 终结器引用 (Finalize Reference)"></a>1.3.5 终结器引用 (Finalize Reference)</h5><p>所有的对象都继承自 <code>Object</code> 类，<code>Object</code> 类有一个 <code>finalize()</code> 方法。</p>
<blockquote>
<p>当某个对象不再被其他的对象所引用时，会先将终结器引用对象放入引用队列中（处理这个引用队列的<em>FinalizeHandler 线程</em> 优先级很低），然后根据终结器引用对象找到它所引用的对象，然后调用该对象的 <code>finalize()</code> 方法。调用以后，该对象就可以被垃圾回收了。</p>
</blockquote>
<ul>
<li>如上图，B对象不再引用A4对象。这是终结器对象就会被放入引用队列中，引用队列会根据它，找到它所引用的对象。然后调用被引用对象的finalize()方法。调用以后，该对象就可以被垃圾回收了</li>
</ul>
<h3 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2 垃圾回收算法"></a>2 垃圾回收算法</h3><h4 id="2-1-标记-清除-算法-Mark-Sweep"><a href="#2-1-标记-清除-算法-Mark-Sweep" class="headerlink" title="2.1 标记 - 清除 算法 (Mark - Sweep)"></a>2.1 标记 - 清除 算法 (Mark - Sweep)</h4><p><img src="/2022/03/22/JVM-1/20200608150813.png" alt="20200608150813" style="zoom:50%;"></p>
<p><strong>定义</strong>：标记清除算法顾名思义，是指在虚拟机执行垃圾回收的过程中，先<u>采用标记算法确定可回收对象</u>（图中为没有GC Root引用的块），然后<u>垃圾收集器根据标识清除相应的内容</u>，给堆内存腾出相应的空间。</p>
<ul>
<li>这里的腾出内存空间并不是将内存空间的字节清零，而是记录下这段内存的起始结束地址，下次分配内存的时候，会直接<strong>覆盖</strong>这段内存。同理于操作系统中的内存管理</li>
</ul>
<blockquote>
<p><strong>优点</strong>：垃圾回收速度快</p>
<p><strong>缺点</strong>：<strong>容易产生大量的内存碎片</strong>，可能无法满足大对象的内存分配，一旦导致无法分配对象，那就会导致 <code>JVM</code> 启动 GC，一旦启动 GC，我们的应用程序就会暂停，这就导致应用的响应速度变慢。同理于操作系统中的内存碎片。</p>
</blockquote>
<h4 id="2-2-标记-整理-算法-Mark-Compact"><a href="#2-2-标记-整理-算法-Mark-Compact" class="headerlink" title="2.2 标记 - 整理 算法 (Mark - Compact)"></a>2.2 标记 - 整理 算法 (Mark - Compact)</h4><p><img src="/2022/03/22/JVM-1/20200608150827.png" alt="20200608150827"></p>
<p><strong>标记-整理</strong> 会将不被 GC Root 引用的对象回收，清理其占用的内存空间。然后整理剩余的对象（将其地址向前移动，使内存更为紧凑，连续空间更多）.</p>
<blockquote>
<p>优点：可以<strong>有效避免因内存碎片而导致的问题</strong></p>
<p>缺点：但是因为整体需要消耗一定的时间，所以<strong>效率较低</strong></p>
</blockquote>
<h4 id="2-3-复制-算法-Copy"><a href="#2-3-复制-算法-Copy" class="headerlink" title="2.3 复制 算法 (Copy)"></a>2.3 复制 算法 (Copy)</h4><p>将内存分为等大小的两个区域，<code>FROM</code> 和 <code>TO</code>（其中 <code>TO</code> 中是空闲的）。</p>
<p>先将被 GC Root 引用的对象从 <code>FROM</code> 复制到 <code>TO</code> 中，再回收不被 GC Root 引用的对象。然后交换 <code>FROM</code> 和<code>TO</code>。</p>
<ol>
<li>如下图，先采用标记算法确定可回收对象（图中为没有 GC Root 引用的块）</li>
</ol>
<p><img src="/2022/03/22/JVM-1/20200608150842.png" alt="20200608150842" style="zoom:75%;"></p>
<ol>
<li>将 <code>FROM</code> 区域中存活的对象复制到 <code>TO</code> 区域</li>
</ol>
<p><img src="/2022/03/22/JVM-1/20200608150856.png" alt="20200608150856" style="zoom:75%;"></p>
<ol>
<li>此时由于 <code>FROM</code> 区域中全是垃圾，全部清空</li>
</ol>
<p><img src="/2022/03/22/JVM-1/20200608150907.png" alt="20200608150907" style="zoom:75%;"></p>
<ol>
<li>交换 <code>FROM</code> 区域 和 <code>TO</code> 区域 的位置</li>
</ol>
<p><img src="/2022/03/22/JVM-1/20200608150919.png" alt="20200608150919" style="zoom:75%;"></p>
<blockquote>
<p>优点：可以避免内存碎片的问题</p>
<p>缺点：但是会<strong>占用双倍的内存空间</strong>。</p>
</blockquote>
<h4 id="2-4-总结"><a href="#2-4-总结" class="headerlink" title="2.4 总结"></a>2.4 总结</h4><ol>
<li>标记 - 清除 算法 (Mark - Sweep)<ul>
<li><strong>优点</strong>：垃圾回收速度快</li>
<li><strong>缺点</strong>：<strong>容易产生大量的内存碎片</strong></li>
</ul>
</li>
<li>标记 - 整理 算法 (Mark - Compact)<ul>
<li>优点：可以<strong>有效避免因内存碎片而导致的问题</strong></li>
<li>缺点：但是因为整体需要消耗一定的时间，所以<strong>效率较低</strong></li>
</ul>
</li>
<li>复制 算法 (Copy)<ul>
<li>优点：可以避免内存碎片的问题</li>
<li>缺点：但是会<strong>占用双倍的内存空间</strong>。</li>
</ul>
</li>
</ol>
<h3 id="3-分代垃圾回收机制"><a href="#3-分代垃圾回收机制" class="headerlink" title="3 分代垃圾回收机制"></a>3 分代垃圾回收机制</h3><p><img src="/2022/03/22/JVM-1/20200608150931.png" alt="20200608150931"></p>
<p>如上图，我们将堆内存划分成两个部分，一个是左边的 <em>YoungGeneration</em> 新生代 (新生代又分为【伊甸园 Eden】、【幸存区 FROM】和【幸存区 TO】三个部分)，另一个是老年代 <em>OldGeneration</em>。</p>
<p>Java 中，<u>长时间使用的对象放在老年代中</u>，<u>用完就可以丢弃的对象放在新生代中</u>。这样就可以根据对象的存活时间的不同特点进行不用的回收策略。<u>老年代中的垃圾回收很久发生一次</u>，而<u>新生代中回收更频繁</u>。</p>
<h4 id="3-1-分代回收流程"><a href="#3-1-分代回收流程" class="headerlink" title="3.1 分代回收流程"></a>3.1 分代回收流程</h4><blockquote>
<p>简要流程：</p>
<ol>
<li>对象首先分配在伊甸园区域；</li>
<li>新生代空间不足时，触发 Minor GC，伊甸园和 FROM 存活的对象使用 copy 复制到 TO 中，存活的对象年龄加 1，并且交换 FROM 和 TO；</li>
<li>当幸存区中的对象的<strong>寿命超过阈值</strong>（最大为15，4bit），就会<strong>晋升到老年代</strong>中；</li>
<li>如果新生代中的内存空间不足时，先触发 Minor GC；垃圾回收后发现新生代中的内存空间仍然不足，且老年代中的内存空间也不足，再触发 <strong>Full GC</strong> (整体清理)；</li>
<li>内存分配失败，触发 <code>java.lang.OutOfMemoryError</code>。</li>
</ol>
</blockquote>
<p>【流程图解】</p>
<p>1、新创建的对象都被放在了<strong>新生代的伊甸园</strong>中，伊甸园逐渐就会被占满。</p>
<p><img src="/2022/03/22/JVM-1/20200608150939.png" alt="20200608150939"></p>
<p><img src="/2022/03/22/JVM-1/20200608150946.png" alt="20200608150946"></p>
<p>2、当伊甸园中的内存不足时，就会进行一次垃圾回收，这时<u>新生代的垃圾回收叫做 <strong>Minor GC</strong></u></p>
<p>​    (1) Minor GC 触发后，采用“可达性分析算法”，沿着以 GC Root 对象（根对象）为起点的引用链，采用“标记算法”确定可回收对象；</p>
<p>​    (2) 标记完成后，采用“复制算法”将<strong><u>伊甸园</u>和<u>幸存区 FROM</u></strong> 存活的对象<strong>先</strong>复制到<strong><u>幸存区 TO</u></strong> 中， 并让其<strong>寿命$+1$</strong>；</p>
<p><img src="/2022/03/22/JVM-1/20200608150955.png" alt="20200608150955"></p>
<p>​    (3) 根据复制算法，我们将交换<u>幸存区 FROM</u> 和<u>幸存区 TO</u> 的位置</p>
<p><img src="/2022/03/22/JVM-1/20200608151002.png" alt="20200608151002"></p>
<p>3、再次创建对象，若新生代的伊甸园又满了，则会<strong>再次触发 Minor GC</strong>（会触发 <strong>“Stop the world”</strong>， 暂停其他用户线程，只让垃圾回收线程工作）；</p>
<p>这时不仅会回收伊甸园中的垃圾，<strong>还会回收幸存区中的垃圾</strong>，再将活跃对象复制到<u>幸存区 TO</u> 中；</p>
<p>回收以后会交换两个幸存区，并让幸存区中的对象<strong>寿命加1</strong></p>
<p><img src="/2022/03/22/JVM-1/20200608151010.png" alt="20200608151010"></p>
<p>4、如此反复。如果幸存区中的对象的<strong>寿命超过某个阈值</strong>（最大为15，4bit），就会<strong>晋升到老年代</strong>中</p>
<p><img src="/2022/03/22/JVM-1/20200608151018.png" alt="20200608151018"></p>
<p>5、如果新生代中的内存空间不足时，先触发 Minor GC；垃圾回收后发现新生代中的内存空间仍然不足，且老年代中的内存空间也不足，再触发 <strong>Full GC</strong> (整体清理)，也会触发“Stop the world”，时间更长，以扫描<strong>新生代和老年代中</strong>所有不再使用的对象并回收</p>
<p>6、如果老年代的内存也不够，内存分配失败，触发 <code>java.lang.OutOfMemoryError</code>。</p>
<p><img src="/2022/03/22/JVM-1/IMG_FB5339E468EB-1.jpeg" alt="IMG_FB5339E468EB-1"></p>
<h4 id="3-2-相关虚拟机参数"><a href="#3-2-相关虚拟机参数" class="headerlink" title="3.2 相关虚拟机参数"></a>3.2 相关虚拟机参数</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">含义</th>
<th style="text-align:left">参数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">堆初始大小</td>
<td style="text-align:left"><code>-Xms</code></td>
</tr>
<tr>
<td style="text-align:left">堆最大大小</td>
<td style="text-align:left"><code>-Xmx</code> 或 <code>-XX:MaxHeapSize=size</code></td>
</tr>
<tr>
<td style="text-align:left">新生代大小</td>
<td style="text-align:left"><code>-Xmn</code> 或 <code>-XX:NewSize=size + XX:MaxNewSize=size</code></td>
</tr>
<tr>
<td style="text-align:left">幸存区比例（动态）</td>
<td style="text-align:left"><code>-XX:InitialSurvivorRatio=ratio</code> 和 <code>-XX:+UseAdaptiveSizePolicy</code></td>
</tr>
<tr>
<td style="text-align:left">幸存区比例</td>
<td style="text-align:left"><code>-XX:SurvivorRatio=ratio</code></td>
</tr>
<tr>
<td style="text-align:left">晋升阈值</td>
<td style="text-align:left"><code>-XX:MaxTenuringThreshold=threshold</code></td>
</tr>
<tr>
<td style="text-align:left">晋升详情</td>
<td style="text-align:left"><code>-XX:+PrintTenuringDistribution</code></td>
</tr>
<tr>
<td style="text-align:left">GC 详情</td>
<td style="text-align:left"><code>-XX:+PrintGCDetails -verbose:gc</code></td>
</tr>
<tr>
<td style="text-align:left">在 FullGC 前执行 MinorGC</td>
<td style="text-align:left"><code>-XX:+ScavengeBeforeFullGC</code></td>
</tr>
</tbody>
</table>
</div>
<h4 id="3-3-GC分析"><a href="#3-3-GC分析" class="headerlink" title="3.3  GC分析"></a>3.3  GC分析</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-Xms20M -Xmx20M -Xmn10M -XX:+UseSerialGC -XX:+PrintGCDetails -verbose:gc</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 1505K [0x00000007be800000, 0x00000007bf200000, 0x00000007bf200000)</span><br><span class="line">  eden space 8192K,  18% used [0x00000007be800000, 0x00000007be9786f8, 0x00000007bf000000)</span><br><span class="line">  from space 1024K,   0% used [0x00000007bf000000, 0x00000007bf000000, 0x00000007bf100000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000007bf100000, 0x00000007bf100000, 0x00000007bf200000)</span><br><span class="line"> tenured generation   total 14336K, used 0K [0x00000007bf200000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line">   the space 14336K,   0% used [0x00000007bf200000, 0x00000007bf200000, 0x00000007bf200200, 0x00000007c0000000)</span><br><span class="line"> Metaspace       used 3132K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 341K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<p>垃圾回收信息：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: 1333K-&gt;331K(9216K), 0.0003968 secs] 1333K-&gt;331K(23552K), 0.0004083 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br></pre></td></tr></table></figure>
<ul>
<li><code>GC</code> 表示是新生代的 <code>MinorGC</code>；<code>FullGC</code> 表示是老年代的垃圾回收</li>
<li><code>DefNew</code> 表示垃圾回收发生在新生代，<code>xxx -&gt; xxx</code> 表示回收之前的占用和回收之后的占用</li>
</ul>
<p>案例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_512K</span> <span class="operator">=</span> <span class="number">512</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_1M</span> <span class="operator">=</span>  <span class="number">1</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_5M</span> <span class="operator">=</span>  <span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_6M</span> <span class="operator">=</span>  <span class="number">6</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_7M</span> <span class="operator">=</span>  <span class="number">7</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_7M]);</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_512K]);</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_512K]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[GC (Allocation Failure) [DefNew: 1508K-&gt;366K(9216K), 0.0006691 secs] 1508K-&gt;366K(23552K), 0.0006841 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[GC (Allocation Failure) [DefNew: 8210K-&gt;876K(9216K), 0.0012508 secs] 8210K-&gt;8044K(23552K), 0.0012588 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 1716K [0x00000007be800000, 0x00000007bf200000, 0x00000007bf200000)</span><br><span class="line">  eden space 8192K,  10% used [0x00000007be800000, 0x00000007be8d1eb8, 0x00000007bf000000)</span><br><span class="line">  from space 1024K,  85% used [0x00000007bf000000, 0x00000007bf0db1e8, 0x00000007bf100000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000007bf100000, 0x00000007bf100000, 0x00000007bf200000)</span><br><span class="line"> tenured generation   total 14336K, used 7168K [0x00000007bf200000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line">   the space 14336K,  50% used [0x00000007bf200000, 0x00000007bf900010, 0x00000007bf900200, 0x00000007c0000000)</span><br><span class="line"> Metaspace       used 3199K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 352K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<h5 id="3-3-1-大对象处理策略"><a href="#3-3-1-大对象处理策略" class="headerlink" title="3.3.1 大对象处理策略"></a>3.3.1 大对象处理策略</h5><p>当遇到一个<strong>较大的对象</strong>时，就算新生代的<strong>伊甸园</strong>为空，也<strong>无法容纳该对象</strong>时，会将该对象<strong>直接晋升为老年代</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_8M</span> <span class="operator">=</span>  <span class="number">8</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ArrayList&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_8M]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 1497K [0x00000007be800000, 0x00000007bf200000, 0x00000007bf200000)</span><br><span class="line">  eden space 8192K,  18% used [0x00000007be800000, 0x00000007be9766e8, 0x00000007bf000000)</span><br><span class="line">  from space 1024K,   0% used [0x00000007bf000000, 0x00000007bf000000, 0x00000007bf100000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000007bf100000, 0x00000007bf100000, 0x00000007bf200000)</span><br><span class="line"> tenured generation   total 14336K, used 8192K [0x00000007bf200000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line">   the space 14336K,  57% used [0x00000007bf200000, 0x00000007bfa00010, 0x00000007bfa00200, 0x00000007c0000000)</span><br><span class="line"> Metaspace       used 3106K, capacity 4496K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 333K, capacity 388K, committed 512K, reserved 1048576K</span><br></pre></td></tr></table></figure>
<h5 id="3-3-2-线程内存溢出"><a href="#3-3-2-线程内存溢出" class="headerlink" title="3.3.2 线程内存溢出"></a>3.3.2 线程内存溢出</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">_8M</span> <span class="operator">=</span>  <span class="number">8</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">Thread</span>(() -&gt; &#123;</span><br><span class="line">            ArrayList&lt;<span class="type">byte</span>[]&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_8M]);</span><br><span class="line">            list.add(<span class="keyword">new</span> <span class="title class_">byte</span>[_8M]);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;sleep...&quot;</span>);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">sleep...</span><br><span class="line">[GC (Allocation Failure) [DefNew: 3683K-&gt;572K(9216K), 0.0010077 secs][Tenured: 8192K-&gt;8762K(14336K), 0.0015132 secs] 11875K-&gt;8762K(23552K), [Metaspace: 4106K-&gt;4106K(1056768K)], 0.0025433 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">[Full GC (Allocation Failure) [Tenured: 8762K-&gt;8707K(14336K), 0.0012168 secs] 8762K-&gt;8707K(23552K), [Metaspace: 4106K-&gt;4106K(1056768K)], 0.0012369 secs] [Times: user=0.00 sys=0.00, real=0.00 secs] </span><br><span class="line">Exception in thread &quot;Thread-0&quot; java.lang.OutOfMemoryError: Java heap space</span><br><span class="line">	at GC_Analyse.Demo.lambda$main$0(Demo.java:17)</span><br><span class="line">	at GC_Analyse.Demo$$Lambda$1/455659002.run(Unknown Source)</span><br><span class="line">	at java.lang.Thread.run(Thread.java:750)</span><br><span class="line">Heap</span><br><span class="line"> def new generation   total 9216K, used 383K [0x00000007be800000, 0x00000007bf200000, 0x00000007bf200000)</span><br><span class="line">  eden space 8192K,   4% used [0x00000007be800000, 0x00000007be85fc28, 0x00000007bf000000)</span><br><span class="line">  from space 1024K,   0% used [0x00000007bf100000, 0x00000007bf100000, 0x00000007bf200000)</span><br><span class="line">  to   space 1024K,   0% used [0x00000007bf000000, 0x00000007bf000000, 0x00000007bf100000)</span><br><span class="line"> tenured generation   total 14336K, used 8707K [0x00000007bf200000, 0x00000007c0000000, 0x00000007c0000000)</span><br><span class="line">   the space 14336K,  60% used [0x00000007bf200000, 0x00000007bfa80c48, 0x00000007bfa80e00, 0x00000007c0000000)</span><br><span class="line"> Metaspace       used 4133K, capacity 4676K, committed 4864K, reserved 1056768K</span><br><span class="line">  class space    used 461K, capacity 496K, committed 512K, reserved 1048576K</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>某个线程的内存溢出了而抛异常 (<code>java.lang.OutOfMemoryError</code>)，不会让其他的线程结束运行，原因如下：</p>
<ul>
<li>当一个线程<strong>抛出 <code>OutOfMemoryError</code> 异常后</strong>，<strong>它所占据的内存资源会全部被释放掉</strong>，从而不会影响其他线程的运行，<strong>其他进程依然正常</strong></li>
</ul>
<h3 id="4-垃圾回收器"><a href="#4-垃圾回收器" class="headerlink" title="4 垃圾回收器"></a>4 垃圾回收器</h3><h4 id="4-0-概述"><a href="#4-0-概述" class="headerlink" title="4.0 概述"></a>4.0 概述</h4><ol>
<li>串行垃圾回收器<ul>
<li>实质是一个单线程的垃圾回收器</li>
<li>使用场景：堆内存较小，适合个人电脑</li>
</ul>
</li>
<li>吞吐量优先垃圾回收器<ul>
<li>多线程</li>
<li>使用场景：堆内存较大，多核 CPU 支持</li>
<li>在单位时间内，STW 的时间最短。例如，在一小时内，垃圾回收了 2 次，总时长是 0.2 + 0.1 秒</li>
</ul>
</li>
<li>响应时间优先垃圾回收器<ul>
<li>多线程</li>
<li>使用场景：堆内存较大，多核 CPU 支持</li>
<li>垃圾清理（STW）的单次时间尽可能最短</li>
</ul>
</li>
</ol>
<h4 id="4-1-串行垃圾回收器"><a href="#4-1-串行垃圾回收器" class="headerlink" title="4.1 串行垃圾回收器"></a>4.1 串行垃圾回收器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseSerialGC=Serial+SerialOld // 新生代copy算法，老年代 标记整理</span><br></pre></td></tr></table></figure>
<p><img src="/2022/03/22/JVM-1/image-20220818231033690.png" alt="image-20220818231033690" style="zoom:50%;"></p>
<h4 id="4-2-吞吐量优先垃圾回收器"><a href="#4-2-吞吐量优先垃圾回收器" class="headerlink" title="4.2 吞吐量优先垃圾回收器"></a>4.2 吞吐量优先垃圾回收器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseParallelGC -XX:+UseParallelOldGC</span><br><span class="line">-XX:ParallelGCThreads=n // 设置垃圾回收线程数</span><br><span class="line">-XX:+UseAdaptiveSizePolicy // 自适应调整</span><br><span class="line">-XX:GCTimeRatio=ratio // 调整垃圾回收时间与总时间的占比: 1/(1+ratio)</span><br><span class="line">-XX:MaxGCPauseMillis=ms // 最大暂停时间(毫秒)</span><br></pre></td></tr></table></figure>
<p><img src="/2022/03/22/JVM-1/image-20220818231641184.png" alt="image-20220818231641184" style="zoom:50%;"></p>
<h4 id="4-3-响应时间优先垃圾回收器"><a href="#4-3-响应时间优先垃圾回收器" class="headerlink" title="4.3 响应时间优先垃圾回收器"></a>4.3 响应时间优先垃圾回收器</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseConcMarkSweepGC ~ -XX:+UseParNewGC ~ SerialOld</span><br><span class="line">-XX:ParallelGCThreads=n ~ -XX:ConcGCThreads=threads</span><br><span class="line">-XX:CMSInitiatingOccupancyFraction=percent</span><br><span class="line">-XX:+CMSScavengeBeforeRemark</span><br></pre></td></tr></table></figure>
<p><img src="/2022/03/22/JVM-1/image-20220818235606862.png" alt="image-20220818235606862" style="zoom:50%;"></p>
<h4 id="4-4-G1-Garbage-First-垃圾回收器"><a href="#4-4-G1-Garbage-First-垃圾回收器" class="headerlink" title="4.4 G1 (Garbage First) 垃圾回收器"></a>4.4 G1 (Garbage First) 垃圾回收器</h4><p>JDK 1.9 之后代替 <code>CMS</code> 回收器，成为默认的垃圾回收器。</p>
<p>【适用场景】</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UseG1GC</span><br></pre></td></tr></table></figure>
<ul>
<li><p>同时注重吞吐量 (Throughput) 和低延迟 (Low latency)，默认的暂停目标是 200 ms</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:MaxGCPauseMillis=time</span><br></pre></td></tr></table></figure>
</li>
<li><p>超大堆内存，会将堆划分为多个大小相等的 <code>Region</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:G1HeapRegionSize=size // size = 2^n</span><br></pre></td></tr></table></figure>
</li>
<li><p>整体上是<u>标记整理</u>算法，两个区域之间是<u>复制</u></p>
</li>
</ul>
<h5 id="4-4-1-G1-垃圾回收阶段"><a href="#4-4-1-G1-垃圾回收阶段" class="headerlink" title="4.4.1 G1 垃圾回收阶段"></a>4.4.1 G1 垃圾回收阶段</h5><p><img src="/2022/03/22/JVM-1/image-20220819112113472.png" alt="image-20220819112113472" style="zoom:50%;"></p>
<h5 id="4-4-2-Young-Collection"><a href="#4-4-2-Young-Collection" class="headerlink" title="4.4.2 Young Collection"></a>4.4.2 Young Collection</h5><p>首先，G1 垃圾回收器会将堆内存 (Heap) 分成若干个大小相等的区域 (Region)，也就是说，<u>Region 是 G1 操作时的单位</u>。</p>
<p><img src="/2022/03/22/JVM-1/image-20220819113509917.png" alt="image-20220819113509917" style="zoom: 45%;"></p>
<p>当一个为<strong><em><u>伊甸园 E</u></em></strong> 的 Region 被占满时，使用<u>拷贝</u>算法将非垃圾对象放入<strong><em><u>幸存区 S</u></em></strong>，如下图</p>
<p><img src="/2022/03/22/JVM-1/image-20220819114148727.png" alt="image-20220819114148727" style="zoom:45%;"></p>
<p>继续运行一段时间，当：</p>
<ul>
<li><strong><em><u>幸存区 S</u></em></strong> 中的对象年龄到达可以晋升<strong><em><u>老年代 O</u></em></strong> 的阈值时；</li>
<li>或<strong><em><u>幸存区 S</u></em></strong> 的空间不足时</li>
</ul>
<p><img src="/2022/03/22/JVM-1/image-20220819114932406.png" alt="image-20220819114932406" style="zoom:45%;"></p>
<h5 id="4-4-3-Young-Collection-Concurrent-Mark"><a href="#4-4-3-Young-Collection-Concurrent-Mark" class="headerlink" title="4.4.3 Young Collection + Concurrent Mark"></a>4.4.3 Young Collection + Concurrent Mark</h5><ul>
<li><p>在 <code>Young GC</code> 时会进行 <code>GC Root</code> 的<strong><em><u>初始标记</u></em></strong></p>
</li>
<li><p>老年代占用堆空间比例达到阈值时，进行<strong><em><u>并发标记</u></em></strong> （不会 STW），由下面的 <code>JVM</code> 参数决定</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:InitiatingHeapOccupancyPercent=percent （默认45%）</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/2022/03/22/JVM-1/image-20220819120000627.png" alt="image-20220819120000627" style="zoom:45%;"></p>
<h5 id="4-4-4-Mixed-Collection"><a href="#4-4-4-Mixed-Collection" class="headerlink" title="4.4.4 Mixed Collection"></a>4.4.4 Mixed Collection</h5><p>会对<strong><em><u>伊甸园 E</u></em></strong>、<strong><em><u>幸存区 S</u></em></strong>、<strong><em><u>老年代 O</u></em></strong> 进行全面垃圾回收：</p>
<ul>
<li><p><strong><em><u>最终标记 (重新标记 Remark)</u></em></strong> 会 STW</p>
</li>
<li><p><strong><em><u>拷贝存活 (Evacuation)</u></em></strong> 会 STW</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX: MaxGCPauseMillis=ms</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><img src="/2022/03/22/JVM-1/image-20220819122114517.png" alt="image-20220819122114517" style="zoom:45%;"></p>
<p>如上图所示，对于<strong><em><u>伊甸园 E</u></em></strong> 和<strong><em><u>幸存区 S</u></em></strong> 的垃圾回收与之前一样：</p>
<ul>
<li><strong><em><u>伊甸园 E</u></em></strong> 被占满时，使用<u>拷贝</u>算法将非垃圾对象放入<strong><em><u>幸存区 S</u></em></strong>；</li>
<li><strong><em><u>幸存区 S</u></em></strong> 中的对象年龄到达可以晋升<strong><em><u>老年代 O</u></em></strong> 的阈值时，将其放入<strong><em><u>老年代 O</u></em></strong> ；</li>
<li><strong><em><u>幸存区 S</u></em></strong> 的空间不足时，复制存活的对象到<strong><em><u>另一个幸存区 S</u></em></strong> 中。</li>
</ul>
<p>对于<strong><em><u>老年代 O</u></em></strong>，我是使用一系列的算法，在最大暂停时间 <code>MaxGCPauseMillis</code> 内，来筛选“有价值”的存活对象，复制到<strong><em><u>另一个老年代 O</u></em></strong> 中。</p>
<p>那么，什么是“有价值”的存活对象呢？</p>
<p>个人理解是在空间不足的<strong><em><u>老年代 O</u></em></strong> 中，挑选出那些<u>可以在最大暂停时间 <code>MaxGCPauseMillis</code> 内完成复制的存活对象后</u>，并且该<strong><em><u>老年代 O</u></em></strong> 可以最大程度上的被回收，从而尽可能多的释放空间。我们将那些存活对象复制到<strong><em><u>另一个老年代 O</u></em></strong> 中。从 Region 的角度考虑，就是优先回收垃圾最多的 Region。</p>
<h5 id="4-4-5-Full-GC"><a href="#4-4-5-Full-GC" class="headerlink" title="4.4.5 Full GC"></a>4.4.5 Full GC</h5><ul>
<li>串行垃圾回收器<ul>
<li>新生代内存不足时发生的垃圾收集：Minor GC</li>
<li>老年代内存不足时发生的垃圾收集：Full GC</li>
</ul>
</li>
<li>并行垃圾回收器<ul>
<li>新生代内存不足时发生的垃圾收集：Minor GC</li>
<li>老年代内存不足时发生的垃圾收集：Full GC</li>
</ul>
</li>
<li>并发垃圾回收器 CMS<ul>
<li>新生代内存不足时发生的垃圾收集：Minor GC</li>
<li>老年代内存不足时发生的垃圾收集：触发并发垃圾回收</li>
</ul>
</li>
<li>G1 垃圾回收器<ul>
<li>新生代内存不足时发生的垃圾收集：Minor GC</li>
<li>老年代内存不足时发生的垃圾收集：老年代占用堆空间比例达到阈值时，进行<strong><em><u>并发标记</u></em></strong> （不会 STW），并进入到 Mixed Collection 阶段。当产生垃圾的速度大于垃圾收集的速度，触发 Full GC。</li>
</ul>
</li>
</ul>
<h5 id="4-4-6-Young-Collection-的跨代引用问题"><a href="#4-4-6-Young-Collection-的跨代引用问题" class="headerlink" title="4.4.6 Young Collection 的跨代引用问题"></a>4.4.6 Young Collection 的跨代引用问题</h5><p>持续更新中。。。</p>
<h2 id="四、类加载与字节码技术"><a href="#四、类加载与字节码技术" class="headerlink" title="四、类加载与字节码技术"></a>四、类加载与字节码技术</h2><h3 id="0-主要内容大纲-1"><a href="#0-主要内容大纲-1" class="headerlink" title="0 主要内容大纲"></a>0 主要内容大纲</h3><blockquote>
<p>提示：本章节可与 <a target="_blank" rel="noopener" href="https://github.com/Dave0126/S8_2A_SN_ENSEEIHT/tree/master/UE - Sémantique et Traduction des Langages/Sémantique et Traduction des Langages">“ Sémantique et Traduction des Langages “</a> 结合理解</p>
</blockquote>
<ol>
<li><a href="#1-类文件结构">类文件结构</a></li>
<li><a href="#2-字节码指令">字节码指令</a></li>
<li><a href="#3-编译期处理">编译期处理</a></li>
<li><a href>类加载阶段</a></li>
<li><a href>类加载器</a></li>
<li><a href>运行期优化</a></li>
</ol>
<p><img src="/2022/03/22/JVM-1/image-20220819161019323.png" alt="image-20220819161019323" style="zoom:50%;"></p>
<h3 id="1-类文件结构"><a href="#1-类文件结构" class="headerlink" title="1 类文件结构"></a>1 类文件结构</h3><p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html">参考文献：Oracle JDK 1.8 官方文档</a></p>
<p>我们以 <code>HelloWorld.java</code> 文件为例</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ClassFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoHelloWorld</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello World!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -parameters -d src/main/java/ClassFile/DemoHelloWorld.java</span><br></pre></td></tr></table></figure>
<p>编译后的 <code>DemoHelloWorld.class</code> 是这样的：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">od -t xC ClassFile/DemoHelloWorld.class </span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">// 标号		内容</span><br><span class="line">0000000    ca  fe  ba  be  00  00  00  3b  00  1f  0a  00  02  00  03  07</span><br><span class="line">0000020    00  04  0c  00  05  00  06  01  00  10  6a  61  76  61  2f  6c</span><br><span class="line">0000040    61  6e  67  2f  4f  62  6a  65  63  74  01  00  06  3c  69  6e</span><br><span class="line">0000060    69  74  3e  01  00  03  28  29  56  09  00  08  00  09  07  00</span><br><span class="line">0000100    0a  0c  00  0b  00  0c  01  00  10  6a  61  76  61  2f  6c  61</span><br><span class="line">0000120    6e  67  2f  53  79  73  74  65  6d  01  00  03  6f  75  74  01</span><br><span class="line">0000140    00  15  4c  6a  61  76  61  2f  69  6f  2f  50  72  69  6e  74</span><br><span class="line">0000160    53  74  72  65  61  6d  3b  08  00  0e  01  00  0c  48  65  6c</span><br><span class="line">0000200    6c  6f  20  57  6f  72  6c  64  21  0a  00  10  00  11  07  00</span><br><span class="line">0000220    12  0c  00  13  00  14  01  00  13  6a  61  76  61  2f  69  6f</span><br><span class="line">0000240    2f  50  72  69  6e  74  53  74  72  65  61  6d  01  00  07  70</span><br><span class="line">0000260    72  69  6e  74  6c  6e  01  00  15  28  4c  6a  61  76  61  2f</span><br><span class="line">0000300    6c  61  6e  67  2f  53  74  72  69  6e  67  3b  29  56  07  00</span><br><span class="line">0000320    16  01  00  18  43  6c  61  73  73  46  69  6c  65  2f  44  65</span><br><span class="line">0000340    6d  6f  48  65  6c  6c  6f  57  6f  72  6c  64  01  00  04  43</span><br><span class="line">0000360    6f  64  65  01  00  0f  4c  69  6e  65  4e  75  6d  62  65  72</span><br><span class="line">0000400    54  61  62  6c  65  01  00  04  6d  61  69  6e  01  00  16  28</span><br><span class="line">0000420    5b  4c  6a  61  76  61  2f  6c  61  6e  67  2f  53  74  72  69</span><br><span class="line">0000440    6e  67  3b  29  56  01  00  10  4d  65  74  68  6f  64  50  61</span><br><span class="line">0000460    72  61  6d  65  74  65  72  73  01  00  04  61  72  67  73  01</span><br><span class="line">0000500    00  0a  53  6f  75  72  63  65  46  69  6c  65  01  00  13  44</span><br><span class="line">0000520    65  6d  6f  48  65  6c  6c  6f  57  6f  72  6c  64  2e  6a  61</span><br><span class="line">0000540    76  61  00  21  00  15  00  02  00  00  00  00  00  02  00  01</span><br><span class="line">0000560    00  05  00  06  00  01  00  17  00  00  00  1d  00  01  00  01</span><br><span class="line">0000600    00  00  00  05  2a  b7  00  01  b1  00  00  00  01  00  18  00</span><br><span class="line">0000620    00  00  06  00  01  00  00  00  03  00  09  00  19  00  1a  00</span><br><span class="line">0000640    02  00  17  00  00  00  25  00  02  00  01  00  00  00  09  b2</span><br><span class="line">0000660    00  07  12  0d  b6  00  0f  b1  00  00  00  01  00  18  00  00</span><br><span class="line">0000700    00  0a  00  02  00  00  00  05  00  08  00  06  00  1b  00  00</span><br><span class="line">0000720    00  05  01  00  1c  00  00  00  01  00  1d  00  00  00  02  00</span><br><span class="line">0000740    1e                                                            </span><br><span class="line">0000741</span><br></pre></td></tr></table></figure>
<p>根据 JVM 规范，类文件的结构如下</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ClassFile &#123;</span><br><span class="line">  u4				magic;</span><br><span class="line">  u2				minor_version;</span><br><span class="line">  u2				major_version;</span><br><span class="line">  u2				constant_pool_count;</span><br><span class="line">  cp_info			constant_pool[constant_pool_count - <span class="number">1</span>];</span><br><span class="line">  u2				access_flags;</span><br><span class="line">  u2				this_class;</span><br><span class="line">  u2				super_class;</span><br><span class="line">  u2				interfaces_count;</span><br><span class="line">  u2				interfaces[interfaces_count];</span><br><span class="line">  u2				fields_count;</span><br><span class="line">  field_info			field[fields_count];</span><br><span class="line">  u2				methods_count;</span><br><span class="line">  method_info			methods[methods_count];</span><br><span class="line">  u2				attributes_count;</span><br><span class="line">  attribute_info		attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>示意图如下：</p>
<p><img src="/2022/03/22/JVM-1/1-1001259.png" alt="1" style="zoom:67%;"></p>
<h4 id="1-1-魔数-Magic"><a href="#1-1-魔数-Magic" class="headerlink" title="1.1 魔数 Magic"></a>1.1 魔数 Magic</h4><ul>
<li><code>前四个字节 (0~3)</code>，表示该文件是否是 <code>.class</code> 类型的文件</li>
</ul>
<blockquote>
<p>0000000    <font color="red">ca fe ba be</font>  00  00  00  3b  00  1f  0a  00  02  00  03  07</p>
</blockquote>
<h4 id="1-2-版本-Version"><a href="#1-2-版本-Version" class="headerlink" title="1.2 版本 Version"></a>1.2 版本 Version</h4><ul>
<li><code>4~7 个字节</code>，表示类的版本 (<code>minor_version + major_version</code>)。 <code>00 3b</code> 表示 JDK 15。</li>
</ul>
<blockquote>
<p>0000000    ca  fe  ba  be  <font color="red">00  00  00  3b</font>  00  1f  0a  00  02  00  03  07</p>
</blockquote>
<h4 id="1-3-常量池-Constant-Pool"><a href="#1-3-常量池-Constant-Pool" class="headerlink" title="1.3 常量池 Constant Pool"></a>1.3 常量池 Constant Pool</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">Constant Type (Bytes)</th>
<th style="text-align:center">Value (hex)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>CONSTANT_Class(1B): 引用索引(2B)</code></td>
<td style="text-align:center"><code>07</code></td>
</tr>
<tr>
<td style="text-align:left"><code>CONSTANT_Filedref(1B): CONSTANT_Class(2B) + CONSTANT_NameAndType(2B)</code></td>
<td style="text-align:center"><code>09</code></td>
</tr>
<tr>
<td style="text-align:left"><code>CONSTANT_Methodref(1B): CONSTANT_Class(2B) + CONSTANT_NameAndType(2B)</code></td>
<td style="text-align:center"><code>0a</code></td>
</tr>
<tr>
<td style="text-align:left"><code>CONSTANT_InterfaceMethodref(1B): CONSTANT_Class(2B) + CONSTANT_NameAndType(2B)</code></td>
<td style="text-align:center"><code>0b</code></td>
</tr>
<tr>
<td style="text-align:left"><code>CONSTANT_String(1B): CONSTANT_Utf8(2B)</code></td>
<td style="text-align:center"><code>08</code></td>
</tr>
<tr>
<td style="text-align:left"><code>CONSTANT_Integer(1B): value(4B)</code></td>
<td style="text-align:center"><code>03</code></td>
</tr>
<tr>
<td style="text-align:left"><code>CONSTANT_Float(1B): value(4B)</code></td>
<td style="text-align:center"><code>04</code></td>
</tr>
<tr>
<td style="text-align:left"><code>CONSTANT_Long(1B): value(8B)</code></td>
<td style="text-align:center"><code>05</code></td>
</tr>
<tr>
<td style="text-align:left"><code>CONSTANT_Double(1B): value(8B)</code></td>
<td style="text-align:center"><code>06</code></td>
</tr>
<tr>
<td style="text-align:left"><code>CONSTANT_NameAndType(1B): Name_引用索引(2B) + Type_引用索引(2B)</code></td>
<td style="text-align:center"><code>0c</code></td>
</tr>
<tr>
<td style="text-align:left"><code>CONSTANT_Utf8(1B): 长度(2B) + 数据(nB)</code></td>
<td style="text-align:center"><code>01</code></td>
</tr>
<tr>
<td style="text-align:left"><code>CONSTANT_MethodHandle(1B)</code></td>
<td style="text-align:center"><code>0f</code></td>
</tr>
<tr>
<td style="text-align:left"><code>CONSTANT_MethodType(1B)</code></td>
<td style="text-align:center"><code>10</code></td>
</tr>
<tr>
<td style="text-align:left"><code>CONSTANT_InvokeDynamic(1B)</code></td>
<td style="text-align:center"><code>12</code></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>8~9 字节</code>，表示常量池的长度。<code>00 1f</code> 表示常量池的长度是 31，有 #1～#30 项。注意 #0 项不计入，也没有值</li>
</ul>
<blockquote>
<p>0000000    ca  fe  ba  be  00  00  00  3b  <font color="red">00  1f</font>  0a  00  02  00  03  07</p>
</blockquote>
<ul>
<li><p>（第 #1 项）<code>10~14 字节</code>中，<code>10 字节</code>表示常量的类型（见上表），<code>0a</code> 表示一个 Methodref 信息；</p>
<p><code>11~12 字节</code>和 <code>13~14 字节</code>，<code>00 02</code> 和 <code>00 03</code> 表示它引用了常量池中 #2 和 #3 项来获得这个方法的【<strong><em><u>所属类</u></em></strong>】和【<strong><em><u>方法名</u></em></strong>】</p>
</li>
</ul>
<blockquote>
<p>0000000|    ca  fe  ba  be  00  00  00  3b  00  1f  <font color="red">0a   00  02   00   03</font>  07</p>
</blockquote>
<ul>
<li><p>（第 #2 项）<code>15~17 字节</code>中，<code>15 字节</code>表示常量的类型（见上表），<code>07</code> 表示一个 Class 信息；</p>
<p><code>16~17 字节</code>，<code>00 04</code> 表示它 表示它引用了常量池中 #4 项。</p>
</li>
</ul>
<blockquote>
<p>0000000|    ca  fe  ba  be  00  00  00  3b  00  1f  0a  00  02  00  03  <font color="red">07</font></p>
<p>0000020|    <font color="red">00   04</font>  0c  00 05  00  06  01  00  10  6a  61  76  61  2f  6c</p>
</blockquote>
<ul>
<li><p>（第 #3 项）<code>18~22 字节</code>中，<code>18 字节</code>表示常量的类型（见上表），<code>0c</code> 表示一个 “名称 + 类型” 信息；</p>
<p><code>19~20 字节</code>和 <code>21~22 字节</code>，<code>00 05</code> 和 <code>00 06</code> 表示它 表示它引用了常量池中 #5 项和第 #6 项。</p>
</li>
</ul>
<blockquote>
<p>0000020|    00  04  <font color="red">0c   00  05  00   06</font>  01  00  10  6a  61  76  61  2f  6c</p>
</blockquote>
<ul>
<li>（第 #4 项）<code>23~41 字节</code>中，<code>23 字节：01</code> 表示一个 utf8 串，后两位 <code>00 10</code> 表示这个串的长度是 16。所以后面紧跟的 16 个字节就是这个串的内容：<code>6a 61 76 61 2f 6c 61 6e 67 2f 4f 62 6a 65 63 74</code>，转义后是：<code>java/lang/Object</code></li>
</ul>
<blockquote>
<p>0000020|    00  04  0c  00  05  00  06  <font color="red">01   00  10  6a   61  76   61   2f  6c</font><br>0000040|    <font color="red">61   6e   67   2f  4f   62  6a   65   63   74</font>  01  00  06  3c  69  6e</p>
</blockquote>
<ul>
<li>（第 #5 项）<code>42~50 字节</code>中，<code>42 字节：01</code> 表示一个 utf8 串，后两位 <code>00 06</code> 表示这个串的长度是 6。所以后面紧跟的 6 个字节就是这个串的内容：<code>3c 69 6e 69 74 3e</code>，转义后是：<code>&lt;init&gt;</code></li>
</ul>
<blockquote>
<p>0000040|    61  6e  67  2f  4f  62  6a  65  63  74  <font color="red">01  00  06   3c   69   6e</font><br>0000060|   <font color="red">69   74   3e</font>  01  00  03  28  29  56  09  00  08  00  09  07  00</p>
</blockquote>
<ul>
<li>（第 #6 项）<code>51~56 字节</code>中，<code>51 字节：01</code> 表示一个 utf8 串，后两位 <code>00 03</code>表示这个串的长度是 3。所以后面紧跟的 3 个字节就是这个串的内容：<code>28 29 56</code>，转义后是：<code>()V</code>，表示<u>无参、无返回值</u></li>
</ul>
<blockquote>
<p>0000060|    69  74  3e  <font color="red">01   00  03   28   29  56</font>  09  00  08  00  09  07  00</p>
</blockquote>
<ul>
<li>（第 #7 项）<code>57~61 字节</code>中，<code>57 字节：09</code> 表示一个 Filedref 信息，后四位 <code>00 08</code> 和 <code>00 09</code> 表示它引用了常量池中 #8 和 #9 项来获得这个成员变量的【<strong><em><u>所属类</u></em></strong>】和【<strong><em><u>成员变量名</u></em></strong>】</li>
</ul>
<blockquote>
<p>0000060|    69  74  3e  01  00  03  28  29  56  <font color="red">09   00  08  00  09</font>  07  00</p>
</blockquote>
<p>以此类推……</p>
<h4 id="1-4-访问标识与继承信息"><a href="#1-4-访问标识与继承信息" class="headerlink" title="1.4 访问标识与继承信息"></a>1.4 访问标识与继承信息</h4><p>常量池 Constant Pool 结束之后，紧接着的<strong><em><u>两个字节</u></em></strong>代表访问标志，这个标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是接口还是类；是否被定义为 <code>public</code> 类型；是否定义为 <code>abstract</code> 类型；如果是类的话，是否被声明为 <code>final</code> 等。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Flag Name</th>
<th>Value (hex)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ACC_PUBLIC</code></td>
<td><code>00 01</code></td>
<td>是否为 <code>public</code> 类型</td>
</tr>
<tr>
<td><code>ACC_FINAL</code></td>
<td><code>00 10</code></td>
<td>是否被声明为 <code>final</code>，只有类可以设置</td>
</tr>
<tr>
<td><code>ACC_SUPER</code></td>
<td><code>00 20</code></td>
<td>是否允许使用 <em>invokespecial</em> 字节码指令的新语义</td>
</tr>
<tr>
<td><code>ACC_INTERFACE</code></td>
<td><code>02 00</code></td>
<td>标志这是一个接口</td>
</tr>
<tr>
<td><code>ACC_ABSTRACT</code></td>
<td><code>04 00</code></td>
<td>是否为 <code>abstract</code> 类型，对于接口或者抽象类来说，次标志值为真，其他类型为假</td>
</tr>
<tr>
<td><code>ACC_SYNTHETIC</code></td>
<td><code>10 00</code></td>
<td>标志这个类并非由用户代码产生</td>
</tr>
<tr>
<td><code>ACC_ANNOTATION</code></td>
<td><code>20 00</code></td>
<td>标志这是一个注解</td>
</tr>
<tr>
<td><code>ACC_ENUM</code></td>
<td><code>40 00</code></td>
<td>标志这是一个枚举</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>00 21</code> 可以推断是由 <code>ACC_PUBLIC</code> 和 <code>ACC_SUPER</code> 通过 <code>OR</code> 组合而成。</li>
</ul>
<blockquote>
<p>0000540|        76  61  <font color="red">00  21</font>  00  15  00  02  00  00  00  00  00  02  00  01</p>
</blockquote>
<ul>
<li><code>00 15</code> 表示根据常量池中的<u>第 #15 项</u>找到<strong><em><u>本类的全限定名</u></em></strong></li>
</ul>
<blockquote>
<p>0000540|        76  61  00  21   <font color="red">00   15</font>  00  02  00  00  00  00  00  02  00  01</p>
</blockquote>
<ul>
<li><code>00 02</code> 表示根据常量池中的<u>第 #2 项</u>找到<strong><em><u>父类的全限定名</u></em></strong></li>
</ul>
<blockquote>
<p>0000540|        76  61  00  21  00  15  <font color="red">00  02</font>  00  00  00  00  00  02  00  01</p>
</blockquote>
<ul>
<li><code>00 00</code> 表示本类中接口的数量，为 0</li>
</ul>
<blockquote>
<p>0000540|        76  61  00  21  00  15  00  02  <font color="red">00  00</font>  00  00  00  02  00  01</p>
</blockquote>
<h4 id="1-5-成员变量-Field"><a href="#1-5-成员变量-Field" class="headerlink" title="1.5 成员变量 Field"></a>1.5 成员变量 Field</h4><p>字段表（field info）用于描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。</p>
<p><code>field info</code> 的结构:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">field_info &#123;</span><br><span class="line">	u2			access_flags;</span><br><span class="line">	u2			name_index;</span><br><span class="line">	u2			descriptor_index;</span><br><span class="line">	u2			attributes_count;</span><br><span class="line">	attribute_info		attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>access_flags</code>: 字段的作用域（<code>public, private, protected</code> 修饰符），是实例变量还是类变量（<code>static</code> 修饰符）,可否被序列化（<code>transient</code> 修饰符）,可变性（<code>final</code>）,可见性（<code>volatile</code> 修饰符，是否强制从主内存读写）。</li>
<li><code>name_index</code>: 对常量池的引用，表示的字段的名称；</li>
<li><code>descriptor_index</code>: 对常量池的引用，表示字段和方法的描述符；</li>
<li><code>attributes_count</code>: 一个字段还会拥有一些额外的属性，<code>attributes_count</code> 存放属性的个数；</li>
<li><code>attributes[attributes_count]</code>: 存放具体属性具体内容。</li>
</ul>
<p>紧接接口信息后的<strong><em><u>两个字节</u></em></strong>为 <code>00 00</code> 表示成员变量的数量，为 0。</p>
<blockquote>
<p>0000540|        76  61  00  21  00  15  00  02. 00  00  <font color="red">00  00</font>  00  02  00  01</p>
</blockquote>
<p>在 <code>.class</code> 文件中，成员变量的类型由更简洁的字符表示，其与源代码 <code>.java</code>中的类型对应表如下：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Field Type(<code>.class</code>)</th>
<th>Field Type(<code>.java</code>)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>B</code></td>
<td><code>byte</code></td>
<td><code>byte</code> 类型</td>
</tr>
<tr>
<td><code>C</code></td>
<td><code>char</code></td>
<td><code>char</code> 类型</td>
</tr>
<tr>
<td><code>D</code></td>
<td><code>double</code></td>
<td><code>double</code> 类型</td>
</tr>
<tr>
<td><code>F</code></td>
<td><code>float</code></td>
<td><code>float</code> 类型</td>
</tr>
<tr>
<td><code>I</code></td>
<td><code>int</code></td>
<td><code>int</code> 类型</td>
</tr>
<tr>
<td><code>J</code></td>
<td><code>long</code></td>
<td><code>long</code> 类型</td>
</tr>
<tr>
<td><code>L</code> <em>ClassName</em></td>
<td><code>reference</code></td>
<td>类 <em>ClassName</em> 的引用类型</td>
</tr>
<tr>
<td><code>S</code></td>
<td><code>short</code></td>
<td><code>short</code> 类型</td>
</tr>
<tr>
<td><code>Z</code></td>
<td><code>boolean</code></td>
<td><code>boolean</code> 类型</td>
</tr>
<tr>
<td><code>[</code></td>
<td><code>reference</code></td>
<td>一维数组类型</td>
</tr>
</tbody>
</table>
</div>
<h4 id="1-6-方法-Method"><a href="#1-6-方法-Method" class="headerlink" title="1.6 方法 Method"></a>1.6 方法 Method</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2             methods_count;</span><br><span class="line">method_info    methods[methods_count];</span><br></pre></td></tr></table></figure>
<p><code>methods_count</code> 表示方法的数量，而 <code>method_info</code> 表示的方法表。</p>
<p><code>.class</code> 文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式。方法表的结构如同字段表一样，依次包括了访问标志、名称索引、描述符索引、属性表集合几项。</p>
<p><code>method_info</code> (方法表的) 结构：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">method_info &#123;</span><br><span class="line">	u2			access_flags;</span><br><span class="line">	u2			name_index;</span><br><span class="line">	u2			descriptor_index;</span><br><span class="line">	u2			attributes_count;</span><br><span class="line">	attribute_info		attributes[attributes_count];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法表的 <code>access_flags</code> 取值：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th><code>access_flags</code></th>
<th>Value (hex)</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>ACC_PUBLIC</code></td>
<td><code>00 01</code></td>
<td>是否为 <code>public</code> 类型</td>
</tr>
<tr>
<td><code>ACC_PRIVATE</code></td>
<td><code>00 02</code></td>
<td>是否为 <code>private</code> 类型</td>
</tr>
<tr>
<td><code>ACC_PROTECTED</code></td>
<td><code>00 04</code></td>
<td>是否为 <code>protected</code> 类型</td>
</tr>
<tr>
<td><code>ACC_STATIC</code></td>
<td><code>00 08</code></td>
<td>是否为 <code>static</code> 类型</td>
</tr>
<tr>
<td><code>ACC_FINAL</code></td>
<td><code>00 10</code></td>
<td>是否被声明为 <code>final</code>，只有类可以设置</td>
</tr>
<tr>
<td><code>ACC_VOLATILE</code></td>
<td><code>00 40</code></td>
<td>是否为 <code>volatile</code> 类型，不可和 <code>ACC_FIANL</code> 一起使用</td>
</tr>
<tr>
<td><code>ACC_TRANSIENT</code></td>
<td><code>00 80</code></td>
<td>在序列化中被忽略的字段</td>
</tr>
<tr>
<td><code>ACC_SYNTHETIC</code></td>
<td><code>10 00</code></td>
<td>标志这个类并非由用户代码产生</td>
</tr>
<tr>
<td><code>ACC_ENUM</code></td>
<td><code>40 00</code></td>
<td>标志这是一个枚举</td>
</tr>
</tbody>
</table>
</div>
<h4 id="1-7-属性-Attribute"><a href="#1-7-属性-Attribute" class="headerlink" title="1.7 属性 Attribute"></a>1.7 属性 Attribute</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">u2			attributes_count;<span class="comment">//此类的属性表中的属性数</span></span><br><span class="line">attribute_info		attributes[attributes_count];<span class="comment">//属性表集合</span></span><br></pre></td></tr></table></figure>
<p>在 <code>.class</code> 文件，字段表，方法表中都可以携带自己的属性表集合，以用于描述某些场景专有的信息。与 <code>.class</code> 文件中其它的数据项目要求的顺序、长度和内容不同，属性表集合的限制稍微宽松一些，不再要求各个属性表具有严格的顺序，并且只要不与已有的属性名重复，任何人实现的编译器都可以向属性表中写 入自己定义的属性信息，Java 虚拟机运行时会忽略掉它不认识的属性。</p>
<h3 id="2-字节码指令"><a href="#2-字节码指令" class="headerlink" title="2 字节码指令"></a>2 字节码指令</h3><h4 id="2-1-入门"><a href="#2-1-入门" class="headerlink" title="2.1 入门"></a>2.1 入门</h4><p>接着上一节，研究一下两组字节码指令，一个是</p>
<p><code>public ClassFile.DemoHelloWorld();</code> 构造方法的字节码指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2a b7 00 01 b1</span><br></pre></td></tr></table></figure>
<ol>
<li><code>2a</code> $\Rightarrow$ <code>aload_0</code> 加载 <code>slot 0</code> 的局部变量，即 <code>this</code>，做为下面的 <code>imvokespecial</code> 构造方法调用的参数</li>
<li><code>b7</code> $\Rightarrow$ <code>invokespecial</code> 预备调用构造方法，哪个方法呢？</li>
<li><code>0001</code> $\Rightarrow$ 引用常量池中第 #1 项，即 <code>Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</code></li>
<li><code>b1</code> $\Rightarrow$ 表示 <code>return</code></li>
</ol>
<p>另一个是主方法的字节码指令 <code>public static void main(java.lang.String[]);</code> </p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b2 00 02 12 03 b6 00 04 b1</span><br></pre></td></tr></table></figure>
<ol>
<li><code>b2</code> $\Rightarrow$ <code>getstatic</code> 用来加载静态变量，哪个静态变量呢？</li>
<li><code>00 02</code> $\Rightarrow$ 引用常量池中 #2 项，即 <code>Field javallang System.out:Ljava/io/Printstream;</code></li>
<li><code>12</code>  $\Rightarrow$ <code>ldc</code> 加载参数，哪个参数呢？</li>
<li><code>03</code> $\Rightarrow$ 引用常量池中 #3 项，即 <code>String hello world!</code></li>
<li><code>b6</code> $\Rightarrow$ <code>invokevirtual</code> 预备调用成员方法，哪个方法呢？</li>
<li><code>00 04</code> $\Rightarrow$ 引用常量池中 #4 项，即<code>Method java/io/Printstream.println:(Ljava/lang/String;)V</code></li>
<li><code>b1</code> $\Rightarrow$ 表示 <code>return</code></li>
</ol>
<h4 id="2-2-javap-工具"><a href="#2-2-javap-工具" class="headerlink" title="2.2 javap 工具"></a>2.2 <code>javap</code> 工具</h4><p>由以上步骤我们可以深刻体会到，手动分析 <code>.class</code> 文件太繁琐了。我们可以使用 Oracle 提供的 <code>javap</code> 工具来反编译 <code>.class</code> 文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javap -v file_name.class</span><br></pre></td></tr></table></figure>
<p><code>javap</code> 反编译后的 <code>DemoHelloWorld.class</code> 输出信息为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">Classfile /Users/JavaVM/target/classes/ClassFile/DemoHelloWorld.class</span><br><span class="line">  Last modified 2022年8月19日; size 481 bytes</span><br><span class="line">  SHA-256 checksum d5b3da891b099837a6618847d9ccee77453fb9a3cafca7bdcda19487f6020290</span><br><span class="line">  Compiled from &quot;DemoHelloWorld.java&quot;</span><br><span class="line">public class ClassFile.DemoHelloWorld</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 59</span><br><span class="line">  flags: (0x0021) ACC_PUBLIC, ACC_SUPER</span><br><span class="line">  this_class: #21                         // ClassFile/DemoHelloWorld</span><br><span class="line">  super_class: #2                         // java/lang/Object</span><br><span class="line">  interfaces: 0, fields: 0, methods: 2, attributes: 1</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #2.#3          // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Class              #4             // java/lang/Object</span><br><span class="line">   #3 = NameAndType        #5:#6          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #4 = Utf8               java/lang/Object</span><br><span class="line">   #5 = Utf8               &lt;init&gt;</span><br><span class="line">   #6 = Utf8               ()V</span><br><span class="line">   #7 = Fieldref           #8.#9          // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #8 = Class              #10            // java/lang/System</span><br><span class="line">   #9 = NameAndType        #11:#12        // out:Ljava/io/PrintStream;</span><br><span class="line">  #10 = Utf8               java/lang/System</span><br><span class="line">  #11 = Utf8               out</span><br><span class="line">  #12 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #13 = String             #14            // Hello World!</span><br><span class="line">  #14 = Utf8               Hello World!</span><br><span class="line">  #15 = Methodref          #16.#17        // java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">  #16 = Class              #18            // java/io/PrintStream</span><br><span class="line">  #17 = NameAndType        #19:#20        // println:(Ljava/lang/String;)V</span><br><span class="line">  #18 = Utf8               java/io/PrintStream</span><br><span class="line">  #19 = Utf8               println</span><br><span class="line">  #20 = Utf8               (Ljava/lang/String;)V</span><br><span class="line">  #21 = Class              #22            // ClassFile/DemoHelloWorld</span><br><span class="line">  #22 = Utf8               ClassFile/DemoHelloWorld</span><br><span class="line">  #23 = Utf8               Code</span><br><span class="line">  #24 = Utf8               LineNumberTable</span><br><span class="line">  #25 = Utf8               main</span><br><span class="line">  #26 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #27 = Utf8               MethodParameters</span><br><span class="line">  #28 = Utf8               args</span><br><span class="line">  #29 = Utf8               SourceFile</span><br><span class="line">  #30 = Utf8               DemoHelloWorld.java</span><br><span class="line">&#123;</span><br><span class="line">  public ClassFile.DemoHelloWorld();	// 构造方法</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (0x0001) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1		// 操作的栈的最大深度、本地变量的个数、参数的个数</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]); // 主方法</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: (0x0009) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=1, args_size=1		// 操作的栈的最大深度、本地变量的个数、参数的个数</span><br><span class="line">         0: getstatic     #7                  // Field java/lang/System.out:Ljava/io/PrintStream;	</span><br><span class="line">         3: ldc           #13                 // String Hello World!</span><br><span class="line">         5: invokevirtual #15                 // Method java/io/PrintStream.println:(Ljava/lang/String;)V</span><br><span class="line">         8: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 5: 0</span><br><span class="line">        line 6: 8</span><br><span class="line">    MethodParameters:</span><br><span class="line">      Name                           Flags</span><br><span class="line">      args</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;DemoHelloWorld.java&quot;</span><br></pre></td></tr></table></figure>
<h4 id="2-3-图解方法执行流程"><a href="#2-3-图解方法执行流程" class="headerlink" title="2.3 图解方法执行流程"></a>2.3 图解方法执行流程</h4><h5 id="2-3-1-原始-Java-代码"><a href="#2-3-1-原始-Java-代码" class="headerlink" title="2.3.1 原始 Java 代码"></a>2.3.1 原始 Java 代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ClassFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> Short.MAX_VALUE + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> a + b;</span><br><span class="line">        System.out.println(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-3-2-编译后的字节码文件"><a href="#2-3-2-编译后的字节码文件" class="headerlink" title="2.3.2 编译后的字节码文件"></a>2.3.2 编译后的字节码文件</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line">Classfile /Users/JavaVM/target/classes/ClassFile/Demo2.class</span><br><span class="line">  Last modified 2022年8月20日; size 597 bytes</span><br><span class="line">  SHA-256 checksum 564a035722627c2a2e6345f6fe7c7ae07e64c76a49d6666827fdcff254d7b5d9</span><br><span class="line">  Compiled from &quot;Demo2.java&quot;</span><br><span class="line">public class ClassFile.Demo2</span><br><span class="line">  minor version: 0</span><br><span class="line">  major version: 52</span><br><span class="line">  flags: (0x0021) ACC_PUBLIC, ACC_SUPER</span><br><span class="line">  this_class: #6                          // ClassFile/Demo2</span><br><span class="line">  super_class: #7                         // java/lang/Object</span><br><span class="line">  interfaces: 0, fields: 0, methods: 2, attributes: 1</span><br><span class="line">Constant pool:</span><br><span class="line">   #1 = Methodref          #7.#25         // java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   #2 = Class              #26            // java/lang/Short</span><br><span class="line">   #3 = Integer            32768</span><br><span class="line">   #4 = Fieldref           #27.#28        // java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">   #5 = Methodref          #29.#30        // java/io/PrintStream.println:(I)V</span><br><span class="line">   #6 = Class              #31            // ClassFile/Demo2</span><br><span class="line">   #7 = Class              #32            // java/lang/Object</span><br><span class="line">   #8 = Utf8               &lt;init&gt;</span><br><span class="line">   #9 = Utf8               ()V</span><br><span class="line">  #10 = Utf8               Code</span><br><span class="line">  #11 = Utf8               LineNumberTable</span><br><span class="line">  #12 = Utf8               LocalVariableTable</span><br><span class="line">  #13 = Utf8               this</span><br><span class="line">  #14 = Utf8               LClassFile/Demo2;</span><br><span class="line">  #15 = Utf8               main</span><br><span class="line">  #16 = Utf8               ([Ljava/lang/String;)V</span><br><span class="line">  #17 = Utf8               args</span><br><span class="line">  #18 = Utf8               [Ljava/lang/String;</span><br><span class="line">  #19 = Utf8               a</span><br><span class="line">  #20 = Utf8               I</span><br><span class="line">  #21 = Utf8               b</span><br><span class="line">  #22 = Utf8               c</span><br><span class="line">  #23 = Utf8               SourceFile</span><br><span class="line">  #24 = Utf8               Demo2.java</span><br><span class="line">  #25 = NameAndType        #8:#9          // &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  #26 = Utf8               java/lang/Short</span><br><span class="line">  #27 = Class              #33            // java/lang/System</span><br><span class="line">  #28 = NameAndType        #34:#35        // out:Ljava/io/PrintStream;</span><br><span class="line">  #29 = Class              #36            // java/io/PrintStream</span><br><span class="line">  #30 = NameAndType        #37:#38        // println:(I)V</span><br><span class="line">  #31 = Utf8               ClassFile/Demo2</span><br><span class="line">  #32 = Utf8               java/lang/Object</span><br><span class="line">  #33 = Utf8               java/lang/System</span><br><span class="line">  #34 = Utf8               out</span><br><span class="line">  #35 = Utf8               Ljava/io/PrintStream;</span><br><span class="line">  #36 = Utf8               java/io/PrintStream</span><br><span class="line">  #37 = Utf8               println</span><br><span class="line">  #38 = Utf8               (I)V</span><br><span class="line">&#123;</span><br><span class="line">  public ClassFile.Demo2();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: (0x0001) ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=1, locals=1, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: invokespecial #1                  // Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">         4: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 3: 0</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0       5     0  this   LClassFile/Demo2;</span><br><span class="line"></span><br><span class="line">  public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: (0x0009) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=4, args_size=1</span><br><span class="line">         0: bipush        10</span><br><span class="line">         2: istore_1</span><br><span class="line">         3: ldc           #3                  // int 32768</span><br><span class="line">         5: istore_2</span><br><span class="line">         6: iload_1</span><br><span class="line">         7: iload_2</span><br><span class="line">         8: iadd</span><br><span class="line">         9: istore_3</span><br><span class="line">        10: getstatic     #4                  // Field java/lang/System.out:Ljava/io/PrintStream;</span><br><span class="line">        13: iload_3</span><br><span class="line">        14: invokevirtual #5                  // Method java/io/PrintStream.println:(I)V</span><br><span class="line">        17: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 5: 0</span><br><span class="line">        line 6: 3</span><br><span class="line">        line 7: 6</span><br><span class="line">        line 8: 10</span><br><span class="line">        line 9: 17</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            0      18     0  args   [Ljava/lang/String;</span><br><span class="line">            3      15     1     a   I</span><br><span class="line">            6      12     2     b   I</span><br><span class="line">           10       8     3     c   I</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;Demo2.java&quot;</span><br></pre></td></tr></table></figure>
<h5 id="2-3-3-常量池载入-“运行时常量池”"><a href="#2-3-3-常量池载入-“运行时常量池”" class="headerlink" title="2.3.3 常量池载入 “运行时常量池”"></a>2.3.3 常量池载入 “运行时常量池”</h5><p><img src="/2022/03/22/JVM-1/2.png" alt="2"></p>
<h5 id="2-3-4-方法字节码载入方法区"><a href="#2-3-4-方法字节码载入方法区" class="headerlink" title="2.3.4 方法字节码载入方法区"></a>2.3.4 方法字节码载入方法区</h5><p><img src="/2022/03/22/JVM-1/3.png" alt="3"></p>
<h5 id="2-3-5-主线程开始运行，分配栈帧内存"><a href="#2-3-5-主线程开始运行，分配栈帧内存" class="headerlink" title="2.3.5 主线程开始运行，分配栈帧内存"></a>2.3.5 主线程开始运行，分配栈帧内存</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack=<span class="number">2</span>, locals=<span class="number">4</span> <span class="comment">// 操作的栈的最大深度=2、本地变量的个数=4</span></span><br></pre></td></tr></table></figure>
<p><img src="/2022/03/22/JVM-1/4.png" alt="4"></p>
<h6 id="bipush-10"><a href="#bipush-10" class="headerlink" title="bipush 10"></a><code>bipush 10</code></h6><p>将一个 byte 压入操作数栈（其长度会补齐4个字节），类似的指令还有</p>
<ul>
<li><code>sipush</code> 将一个 <code>short</code> 压入操作数栈（其长度会补齐4个字节）</li>
<li><code>ldc</code> 将一个 <code>int</code> 压入操作数栈</li>
<li><code>lde2_w</code> 将一个 <code>long</code> 压入操作数栈（分两次压入，因为 <code>long</code> 是 8 个字节）</li>
<li>这里小的数字（4 个字节）都是和字节码指令存在一起，超过 <code>short</code> 范围的数字存入了常量池</li>
</ul>
<p><img src="/2022/03/22/JVM-1/5.png" alt="5"></p>
<h6 id="istore-1"><a href="#istore-1" class="headerlink" title="istore 1"></a><code>istore 1</code></h6><p>将操作数栈栈顶的元素弹出，存入本地变量表的 slot 1</p>
<p><img src="/2022/03/22/JVM-1/6.png" alt="6"></p>
<p><img src="/2022/03/22/JVM-1/7.png" alt="7"></p>
<h6 id="ldc-3"><a href="#ldc-3" class="headerlink" title="ldc #3"></a><code>ldc #3</code></h6><ul>
<li>从常量池加载 #3 数据到操作数栈</li>
<li>注意：<code>Short.MAX_ VAIUE</code> 是 <code>32767</code>，所以 <code>32768 = Short. MAX_ VAIUE ＋ 1</code>实际是在编译期间计算</li>
</ul>
<p><img src="/2022/03/22/JVM-1/8.png" alt="8"></p>
<h6 id="istore-2"><a href="#istore-2" class="headerlink" title="istore 2"></a><code>istore 2</code></h6><p><img src="/2022/03/22/JVM-1/9.png" alt="9"></p>
<p><img src="/2022/03/22/JVM-1/10.png" alt="10"></p>
<h6 id="iload-1"><a href="#iload-1" class="headerlink" title="iload 1"></a><code>iload 1</code></h6><p><img src="/2022/03/22/JVM-1/11.png" alt="11"></p>
<h6 id="iload-2"><a href="#iload-2" class="headerlink" title="iload 2"></a><code>iload 2</code></h6><p><img src="/2022/03/22/JVM-1/12.png" alt="12"></p>
<h6 id="iadd"><a href="#iadd" class="headerlink" title="iadd"></a><code>iadd</code></h6><p><img src="/2022/03/22/JVM-1/13.png" alt="13"></p>
<p><img src="/2022/03/22/JVM-1/14.png" alt="14"></p>
<h6 id="istore-3"><a href="#istore-3" class="headerlink" title="istore 3"></a><code>istore 3</code></h6><p><img src="/2022/03/22/JVM-1/15.png" alt="15"></p>
<p><img src="/2022/03/22/JVM-1/16.png" alt="16"></p>
<h6 id="getstatic-4"><a href="#getstatic-4" class="headerlink" title="getstatic #4"></a><code>getstatic #4</code></h6><p><img src="/2022/03/22/JVM-1/17.png" alt="17"></p>
<p><img src="/2022/03/22/JVM-1/18.png" alt="18"></p>
<h6 id="iload-3"><a href="#iload-3" class="headerlink" title="iload 3"></a><code>iload 3</code></h6><p><img src="/2022/03/22/JVM-1/19.png" alt="19"></p>
<h6 id="invokevirtual-5"><a href="#invokevirtual-5" class="headerlink" title="invokevirtual #5"></a><code>invokevirtual #5</code></h6><ul>
<li>找到常量池 #5 项</li>
<li>定位到方法区 <code>java/io/PrintStream.println:(I)V</code>方法</li>
<li>生成新的栈帧（分配 <code>locals</code>、<code>stack</code>等）</li>
<li>传递参数，执行新栈帧中的字节码</li>
</ul>
<p><img src="/2022/03/22/JVM-1/20.png" alt="20"></p>
<ul>
<li>执行操作，弹出栈帧</li>
<li>清除 <code>main</code> 栈帧中操作数栈内容</li>
</ul>
<p><img src="/2022/03/22/JVM-1/21.png" alt="21"></p>
<h6 id="return"><a href="#return" class="headerlink" title="return"></a><code>return</code></h6><ul>
<li>完成 <code>main</code> 方法调用，弹出 <code>main</code> 栈帧</li>
<li>程序结束</li>
</ul>
<h4 id="2-4-从字节码角度分析-i-与-i"><a href="#2-4-从字节码角度分析-i-与-i" class="headerlink" title="2.4 从字节码角度分析 i++ 与 ++i"></a>2.4 从字节码角度分析 <code>i++</code> 与 <code>++i</code></h4><blockquote>
<ul>
<li><code>i++</code> $\Rightarrow$ 先执行 <code>iload</code>，再执行 <code>iinc</code></li>
<li><code>++i</code> $\Rightarrow$ 先执行 <code>iinc</code>，再执行 <code>iload</code></li>
<li><code>iinc 1 -1</code> 自增运算操作再本地变量表中进行操作，而非操作数栈。意为<u>在 slot 1 的本地变量自增 <code>-1</code></u></li>
</ul>
</blockquote>
<h4 id="2-5-条件判断指令"><a href="#2-5-条件判断指令" class="headerlink" title="2.5 条件判断指令"></a>2.5 条件判断指令</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">指令 (hex)</th>
<th>助记符</th>
<th>含义</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left"><code>99</code></td>
<td><code>ifeq</code></td>
<td>判断是否 $=0$</td>
</tr>
<tr>
<td style="text-align:left"><code>9a</code></td>
<td><code>ifne</code></td>
<td>判断是否 $\ne 0$</td>
</tr>
<tr>
<td style="text-align:left"><code>9b</code></td>
<td><code>iflt</code></td>
<td>判断是否 $&lt; 0$</td>
</tr>
<tr>
<td style="text-align:left"><code>9c</code></td>
<td><code>ifge</code></td>
<td>判断是否 $ \ge 0$</td>
</tr>
<tr>
<td style="text-align:left"><code>9d</code></td>
<td><code>ifgt</code></td>
<td>判断是否 $&gt;0$</td>
</tr>
<tr>
<td style="text-align:left"><code>9e</code></td>
<td><code>ifle</code></td>
<td>判断是否 $\le 0$</td>
</tr>
<tr>
<td style="text-align:left"><code>9f</code></td>
<td><code>if_icmpeq</code></td>
<td>判断两个 <code>int</code> 是否 $=$</td>
</tr>
<tr>
<td style="text-align:left"><code>a0</code></td>
<td><code>if_icmpne</code></td>
<td>判断两个 <code>int</code> 是否 $\ne$</td>
</tr>
<tr>
<td style="text-align:left"><code>a1</code></td>
<td><code>if_icmplt</code></td>
<td>判断两个 <code>int</code> 是否 $&lt;$</td>
</tr>
<tr>
<td style="text-align:left"><code>a2</code></td>
<td><code>if_icmpge</code></td>
<td>判断两个 <code>int</code> 是否 $\ge$</td>
</tr>
<tr>
<td style="text-align:left"><code>a3</code></td>
<td><code>if_icmpgt</code></td>
<td>判断两个 <code>int</code> 是否 $&gt;$</td>
</tr>
<tr>
<td style="text-align:left"><code>a4</code></td>
<td><code>if_icmple</code></td>
<td>判断两个 <code>int</code> 是否 $\le$</td>
</tr>
<tr>
<td style="text-align:left"><code>a5</code></td>
<td><code>if_acmpeq</code></td>
<td>判断两个 <code>引用</code> 是否 $=$</td>
</tr>
<tr>
<td style="text-align:left"><code>a6</code></td>
<td><code>if_acmpne</code></td>
<td>判断两个 <code>引用</code> 是否 $\ne$</td>
</tr>
<tr>
<td style="text-align:left"><code>c6</code></td>
<td><code>ifnull</code></td>
<td>判断是否为 <code>null</code></td>
</tr>
<tr>
<td style="text-align:left"><code>c7</code></td>
<td><code>ifnonnull</code></td>
<td>判断是否为 <code>非null</code></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li><code>byte, short, char</code> 都会按照 <code>int</code> 来比较，因为操作数栈都是 4 个字节</li>
<li>条件判断指令后，使用 <code>goto</code> 语句来跳转到指定位置</li>
</ul>
<h4 id="2-6-构造方法"><a href="#2-6-构造方法" class="headerlink" title="2.6 构造方法"></a>2.6 构造方法</h4><h5 id="2-6-1-lt-clinit-gt-V"><a href="#2-6-1-lt-clinit-gt-V" class="headerlink" title="2.6.1 &lt;clinit&gt;()V"></a>2.6.1 <code>&lt;clinit&gt;()V</code></h5><p><code>&lt;clinit&gt;()V</code> 是<strong><em><u>类构造器方法</u></em></strong>，也就是在 JVM 进行”类加载 - 链接 - 初始化”中的初始化阶段，JVM 会调用 <code>&lt;clinit&gt;()V</code> 方法。<code>&lt;clinit&gt;()V</code> 是<strong><em><u>类构造器</u></em></strong>对<u>静态变量，静态代码块进行初始化</u>。</p>
<p>从字节码角度分析如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Demo</span> &#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    i = <span class="number">20</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> &#123;</span><br><span class="line">    i = <span class="number">30</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器会按照<strong><em><u>从上至下</u></em></strong>的顺序，收集所有的 <code>static</code> 静态代码块的静态成员赋值的代码，合并成一个特殊的方法 <code>&lt;clinit&gt;()V</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> 0: bipush        10</span><br><span class="line"> 2: putstatic     #3                  // Field i:I</span><br><span class="line"> 5: bipush        20</span><br><span class="line"> 7: putstatic     #3                  // Field i:I</span><br><span class="line">10: bipush        30</span><br><span class="line">12: putstatic     #3                  // Field i:I</span><br><span class="line">15: return</span><br></pre></td></tr></table></figure>
<h5 id="2-6-2-lt-init-gt-V"><a href="#2-6-2-lt-init-gt-V" class="headerlink" title="2.6.2 &lt;init&gt;()V"></a>2.6.2 <code>&lt;init&gt;()V</code></h5><p><code>&lt;init&gt;()V</code> 是<strong><em><u>对象构造器方法</u></em></strong>，也就是说在程序执行 <code>new</code> 一个对象，调用该对象类的构造器方法时才会执行 <code>&lt;init&gt;()V</code> 方法。<code>&lt;init&gt;()V</code> 是<strong><em><u>实例构造器</u></em></strong>，对<u>非静态变量解析初始化</u>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ClassFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoStatic</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> <span class="variable">a</span> <span class="operator">=</span> <span class="string">&quot;s1&quot;</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        b = <span class="number">20</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">b</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        a = <span class="string">&quot;s2&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DemoStatic</span><span class="params">(String a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.a = a;</span><br><span class="line">        <span class="built_in">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DemoStatic</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoStatic</span>(<span class="string">&quot;s3&quot;</span>,<span class="number">30</span>);</span><br><span class="line">        System.out.println(demo.a + <span class="string">&quot;\t&quot;</span> + demo.b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译器会按照<strong><em><u>从上至下</u></em></strong>的顺序，收集所有的 <code>&#123;&#125;</code> 初始化代码块的静态成员赋值的代码，合并成一个特殊的方法 <code>&lt;init&gt;()V</code>，但原始<strong><em><u>构造方法</u></em></strong>内的代码总是在最后。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span>: aload_0</span><br><span class="line"> <span class="number">1</span>: invokespecial #<span class="number">1</span>                  <span class="comment">// Method java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line"> <span class="number">4</span>: aload_0</span><br><span class="line"> <span class="number">5</span>: ldc           #<span class="number">2</span>                  <span class="comment">// String &quot;s1&quot;</span></span><br><span class="line"> <span class="number">7</span>: putfield      #<span class="number">3</span>                  <span class="comment">// Field a:Ljava/lang/String;</span></span><br><span class="line"><span class="number">10</span>: aload_0</span><br><span class="line"><span class="number">11</span>: bipush        <span class="number">20</span></span><br><span class="line"><span class="number">13</span>: putfield      #<span class="number">4</span>                  <span class="comment">// Field b:I</span></span><br><span class="line"><span class="number">16</span>: aload_0</span><br><span class="line"><span class="number">17</span>: bipush        <span class="number">10</span></span><br><span class="line"><span class="number">19</span>: putfield      #<span class="number">4</span>                  <span class="comment">// Field b:I</span></span><br><span class="line"><span class="number">22</span>: aload_0</span><br><span class="line"><span class="number">23</span>: ldc           #<span class="number">5</span>                  <span class="comment">// String &quot;s2&quot;</span></span><br><span class="line"><span class="number">25</span>: putfield      #<span class="number">3</span>                  <span class="comment">// Field a:Ljava/lang/String;</span></span><br><span class="line"><span class="number">28</span>: aload_0</span><br><span class="line"><span class="number">29</span>: aload_1</span><br><span class="line"><span class="number">30</span>: putfield      #<span class="number">3</span>                  <span class="comment">// Field a:Ljava/lang/String;</span></span><br><span class="line"><span class="number">33</span>: aload_0</span><br><span class="line"><span class="number">34</span>: iload_2</span><br><span class="line"><span class="number">35</span>: putfield      #<span class="number">4</span>                  <span class="comment">// Field b:I</span></span><br><span class="line"><span class="number">38</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<h4 id="2-7-方法的调用"><a href="#2-7-方法的调用" class="headerlink" title="2.7 方法的调用"></a>2.7 方法的调用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ClassFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoCallMethod</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">test1</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title function_">test2</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test3</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test4</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">DemoCallMethod</span> <span class="variable">demo</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DemoCallMethod</span>();</span><br><span class="line">        demo.test1();</span><br><span class="line">        demo.test2();</span><br><span class="line">        demo.test3();</span><br><span class="line">        demo.test4();</span><br><span class="line">        DemoCallMethod.test4();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字节码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">         <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>                  <span class="comment">// class ClassFile/DemoCallMethod</span></span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">-        <span class="number">4</span>: invokespecial #<span class="number">3</span>                  <span class="comment">// Method &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">7</span>: astore_1</span><br><span class="line">         <span class="number">8</span>: aload_1</span><br><span class="line">-        <span class="number">9</span>: invokespecial #<span class="number">4</span>                  <span class="comment">// Method test1:()V</span></span><br><span class="line">        <span class="number">12</span>: aload_1</span><br><span class="line">-       <span class="number">13</span>: invokespecial #<span class="number">5</span>                  <span class="comment">// Method test2:()V</span></span><br><span class="line">        <span class="number">16</span>: aload_1</span><br><span class="line">+       <span class="number">17</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method test3:()V</span></span><br><span class="line">        <span class="number">20</span>: aload_1</span><br><span class="line">        <span class="number">21</span>: pop</span><br><span class="line">&amp;       <span class="number">22</span>: invokestatic  #<span class="number">7</span>                  <span class="comment">// Method test4:()V</span></span><br><span class="line">        <span class="number">25</span>: invokestatic  #<span class="number">7</span>                  <span class="comment">// Method test4:()V</span></span><br><span class="line">        <span class="number">28</span>: <span class="keyword">return</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在以上例子中，出现了三种不同的方法调用：</p>
<ul>
<li><code>invokespecial</code>：构造方法、私有方法 <code>private</code>、<code>final</code> 修饰的方法</li>
<li><code>invokevirtual</code>：公共方法 <code>public</code></li>
<li><code>invokestatic</code>：静态方法 <code>static</code></li>
</ul>
<p>在 JVM 中，<code>invokespecial</code> 和 <code>invokestatic</code> 属于<strong><em><u>静态方法绑定</u></em></strong>，在字节码文件生成时就已知该方法属于哪个类；但 <code>public</code> 方法有可能出现方法重写的情况，编译期间无法确定该方法属于哪个类（子类或父类），所以使用 <code>invokevirtual</code> <strong><em><u>动态方法绑定</u></em></strong>，需要在运行时确定。</p>
<blockquote>
<p>细节说明：</p>
<ul>
<li><code>new</code> 关键字调用构造方法时，先在<u>堆空间分配对象所需的内存</u>，分配成功后，再<u>将对象引用放入操作数栈</u>。</li>
<li><code>dup</code> 复制栈顶元素</li>
</ul>
</blockquote>
<h4 id="2-8-多态的原理"><a href="#2-8-多态的原理" class="headerlink" title="2.8 多态的原理"></a>2.8 多态的原理</h4><p>在上一小节中，我们提到 <code>invokevirtual</code> <strong><em><u>动态方法绑定</u></em></strong>，在此节中，我们将了解 Java 中多态的原理。</p>
<p><a target="_blank" rel="noopener" href="https://b23.tv/bRZKMKb">视频讲解：BiliBili - 黑马程序员 JVM - P119 多态原理</a></p>
<p>当执行 <code>invokevirtual</code> 指令时，</p>
<ol>
<li>先通过栈帧中的对象引用找到对象</li>
<li>分析对象头，找到对象的实际 <code>Class</code></li>
<li><code>Class</code> 结构中有 <code>vtable</code>，它在类加载的链接阶段就已经根据方法的重写规则生成好了</li>
<li>查表得到方法的具体地址</li>
<li>执行方法的字节码</li>
</ol>
<h4 id="2-9-处理异常"><a href="#2-9-处理异常" class="headerlink" title="2.9 处理异常"></a>2.9 处理异常</h4><h5 id="2-9-1-单-try-catch-代码块"><a href="#2-9-1-单-try-catch-代码块" class="headerlink" title="2.9.1 单 try-catch 代码块"></a>2.9.1 单 <code>try-catch</code> 代码块</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ClassFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i = <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            i = <span class="number">20</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字节码（重要的部分）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: (<span class="number">0x0009</span>) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: iconst_0</span><br><span class="line">         <span class="number">1</span>: istore_1		<span class="comment">// i = 0</span></span><br><span class="line">         <span class="number">2</span>: bipush        <span class="number">10</span></span><br><span class="line">         <span class="number">4</span>: istore_1		<span class="comment">// i = 10</span></span><br><span class="line">         <span class="number">5</span>: goto          <span class="number">12</span>	<span class="comment">// 没有异常，跳转 12</span></span><br><span class="line">         <span class="number">8</span>: astore_2		<span class="comment">// Execption e</span></span><br><span class="line">         <span class="number">9</span>: bipush        <span class="number">20</span></span><br><span class="line">        <span class="number">11</span>: istore_1</span><br><span class="line">        <span class="number">12</span>: <span class="keyword">return</span></span><br><span class="line">*     Exception table:	<span class="comment">// 异常表，若[from, to)范围内出现异常且匹配type类型，跳转到target</span></span><br><span class="line">         from    to  target type</span><br><span class="line">             <span class="number">2</span>     <span class="number">5</span>     <span class="number">8</span>   Class java/lang/Exception</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">9</span>       <span class="number">3</span>     <span class="number">2</span>     e   Ljava/lang/Exception;</span><br><span class="line">            <span class="number">0</span>      <span class="number">13</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">2</span>      <span class="number">11</span>     <span class="number">1</span>     i   I</span><br></pre></td></tr></table></figure>
<ul>
<li>可以看到，字节码文件中多出来一个 <em>”Exception table“</em> 的结构，<code>[from,to)</code> 是前闭后开的检测范围，一旦这个范围内的字节码执行出现异常，则通过 <code>type</code> 匹配异常类型，如果一致，进入 <code>target</code> 所指示行号；</li>
<li>8 行的字节码指令 <code>astore 2</code> 是将异常对象引用存入局部变量表的 <code>slot 2</code> 位置</li>
</ul>
<h5 id="2-9-2-单-try-多-catch-代码块-（一）"><a href="#2-9-2-单-try-多-catch-代码块-（一）" class="headerlink" title="2.9.2 单 try 多 catch 代码块 （一）"></a>2.9.2 单 <code>try</code> 多 <code>catch</code> 代码块 （一）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ClassFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i = <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            i = <span class="number">20</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            i = <span class="number">30</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字节码（重要的部分）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">   descriptor: ([Ljava/lang/String;)V</span><br><span class="line">   flags: (<span class="number">0x0009</span>) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">   Code:</span><br><span class="line">     stack=<span class="number">1</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">        <span class="number">0</span>: iconst_0</span><br><span class="line">        <span class="number">1</span>: istore_1		<span class="comment">// i = 0</span></span><br><span class="line">        <span class="number">2</span>: bipush        <span class="number">10</span></span><br><span class="line">        <span class="number">4</span>: istore_1		<span class="comment">// i = 10</span></span><br><span class="line">        <span class="number">5</span>: goto          <span class="number">19</span>	<span class="comment">// 没有异常，跳转 12</span></span><br><span class="line">        <span class="number">8</span>: astore_2		<span class="comment">// NullPointerException e</span></span><br><span class="line">        <span class="number">9</span>: bipush        <span class="number">20</span></span><br><span class="line">       <span class="number">11</span>: istore_1		<span class="comment">// i = 20</span></span><br><span class="line">       <span class="number">12</span>: goto          <span class="number">19</span></span><br><span class="line">       <span class="number">15</span>: astore_2		<span class="comment">// Execption e</span></span><br><span class="line">       <span class="number">16</span>: bipush        <span class="number">30</span></span><br><span class="line">       <span class="number">18</span>: istore_1		<span class="comment">// i = 30</span></span><br><span class="line">       <span class="number">19</span>: <span class="keyword">return</span></span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            <span class="number">2</span>     <span class="number">5</span>     <span class="number">8</span>   Class java/lang/NullPointerException</span><br><span class="line">            <span class="number">2</span>     <span class="number">5</span>    <span class="number">15</span>   Class java/lang/Exception</span><br><span class="line">     LocalVariableTable:</span><br><span class="line">       Start  Length  Slot  Name   Signature</span><br><span class="line">           <span class="number">9</span>       <span class="number">3</span>     <span class="number">2</span>     e   Ljava/lang/NullPointerException;</span><br><span class="line">          <span class="number">16</span>       <span class="number">3</span>     <span class="number">2</span>     e   Ljava/lang/Exception;		<span class="comment">// slot位置的复用</span></span><br><span class="line">           <span class="number">0</span>      <span class="number">20</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">           <span class="number">2</span>      <span class="number">18</span>     <span class="number">1</span>     i   I</span><br></pre></td></tr></table></figure>
<ul>
<li>因为异常出现时，只能进入 <code>Exception table</code> 中一个分支，所以局部变量表 <code>slot 2</code> 位置被共用</li>
</ul>
<h5 id="2-9-3-单-try-多-catch-代码块-（二）"><a href="#2-9-3-单-try-多-catch-代码块-（二）" class="headerlink" title="2.9.3 单 try 多 catch 代码块 （二）"></a>2.9.3 单 <code>try</code> 多 <code>catch</code> 代码块 （二）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ClassFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i = <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException | IllegalAccessError e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字节码（重要的部分）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">   descriptor: ([Ljava/lang/String;)V</span><br><span class="line">   flags: (<span class="number">0x0009</span>) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">   Code:</span><br><span class="line">     stack=<span class="number">1</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">        <span class="number">0</span>: iconst_0</span><br><span class="line">        <span class="number">1</span>: istore_1</span><br><span class="line">        <span class="number">2</span>: bipush        <span class="number">10</span></span><br><span class="line">        <span class="number">4</span>: istore_1</span><br><span class="line">        <span class="number">5</span>: goto          <span class="number">13</span></span><br><span class="line">        <span class="number">8</span>: astore_2</span><br><span class="line">        <span class="number">9</span>: aload_2</span><br><span class="line">       <span class="number">10</span>: invokevirtual #<span class="number">4</span>                  <span class="comment">// Method java/lang/Throwable.printStackTrace:()V</span></span><br><span class="line">       <span class="number">13</span>: <span class="keyword">return</span></span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            <span class="number">2</span>     <span class="number">5</span>     <span class="number">8</span>   Class java/lang/NullPointerException</span><br><span class="line">            <span class="number">2</span>     <span class="number">5</span>     <span class="number">8</span>   Class java/lang/IllegalAccessError</span><br><span class="line">     LocalVariableTable:</span><br><span class="line">       Start  Length  Slot  Name   Signature</span><br><span class="line">           <span class="number">9</span>       <span class="number">4</span>     <span class="number">2</span>     e   Ljava/lang/Throwable;</span><br><span class="line">           <span class="number">0</span>      <span class="number">14</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">           <span class="number">2</span>      <span class="number">12</span>     <span class="number">1</span>     i   I</span><br></pre></td></tr></table></figure>
<ul>
<li>本质上与之前是一样的。</li>
</ul>
<h5 id="2-9-4-finally-代码块"><a href="#2-9-4-finally-代码块" class="headerlink" title="2.9.4 finally 代码块"></a>2.9.4 <code>finally</code> 代码块</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ClassFile;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            i = <span class="number">10</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            i = <span class="number">20</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            i = <span class="number">30</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字节码（重要的部分）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: (<span class="number">0x0009</span>) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">1</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: iconst_0</span><br><span class="line">         <span class="number">1</span>: istore_1		<span class="comment">// i = 0</span></span><br><span class="line">         <span class="number">2</span>: bipush        <span class="number">10</span>	<span class="comment">// try代码块 -----------------------------</span></span><br><span class="line">         <span class="number">4</span>: istore_1		<span class="comment">// i = 10				|</span></span><br><span class="line">         <span class="number">5</span>: bipush        <span class="number">30</span>	<span class="comment">// finally				|</span></span><br><span class="line">         <span class="number">7</span>: istore_1		<span class="comment">// i = 30				|</span></span><br><span class="line">         <span class="number">8</span>: goto          <span class="number">27</span>	<span class="comment">// 没有异常，跳转 27 ----------------------</span></span><br><span class="line">        <span class="number">11</span>: astore_2		<span class="comment">// catch Exception e ---------------------</span></span><br><span class="line">        <span class="number">12</span>: bipush        <span class="number">20</span>	<span class="comment">//					|</span></span><br><span class="line">        <span class="number">14</span>: istore_1		<span class="comment">// i = 20				|</span></span><br><span class="line">        <span class="number">15</span>: bipush        <span class="number">30</span>	<span class="comment">// finally				|</span></span><br><span class="line">        <span class="number">17</span>: istore_1		<span class="comment">// i = 30				|</span></span><br><span class="line">        <span class="number">18</span>: goto          <span class="number">27</span>	<span class="comment">// 没有异常，跳转 27 ----------------------</span></span><br><span class="line">        <span class="number">21</span>: astore_3		<span class="comment">// catch any(slot 3) e -------------------</span></span><br><span class="line">        <span class="number">22</span>: bipush        <span class="number">30</span>	<span class="comment">// finally				|</span></span><br><span class="line">        <span class="number">24</span>: istore_1		<span class="comment">// i = 30				|</span></span><br><span class="line">        <span class="number">25</span>: aload_3		<span class="comment">// 					|</span></span><br><span class="line">        <span class="number">26</span>: athrow		<span class="comment">// throw ---------------------------------</span></span><br><span class="line">        <span class="number">27</span>: <span class="keyword">return</span></span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">             <span class="number">2</span>     <span class="number">5</span>    <span class="number">11</span>   Class java/lang/Exception</span><br><span class="line">             <span class="number">2</span>     <span class="number">5</span>    <span class="number">21</span>   any</span><br><span class="line">            <span class="number">11</span>    <span class="number">15</span>    <span class="number">21</span>   any</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">           <span class="number">12</span>       <span class="number">3</span>     <span class="number">2</span>     e   Ljava/lang/Exception;</span><br><span class="line">            <span class="number">0</span>      <span class="number">28</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">2</span>      <span class="number">26</span>     <span class="number">1</span>     i   I</span><br></pre></td></tr></table></figure>
<ul>
<li>可以看到 <code>finally</code> 中的代码被复制了 3 份，分别放入 <code>try</code> 流程，<code>catch</code> 流程以及 <code>catch</code> 剩余的异常类型流程</li>
</ul>
<h5 id="2-9-5-finally-块中返回值的问题"><a href="#2-9-5-finally-块中返回值的问题" class="headerlink" title="2.9.5 finally 块中返回值的问题"></a>2.9.5 <code>finally</code> 块中返回值的问题</h5><p>我们考虑如下代码，分析其最后的返回值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> test();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            i = <span class="number">20</span>;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    返回结果为 <code>20</code>。其字节码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">   descriptor: ()I</span><br><span class="line">   flags: (<span class="number">0x0009</span>) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">   Code:</span><br><span class="line">     stack=<span class="number">1</span>, locals=<span class="number">3</span>, args_size=<span class="number">0</span></span><br><span class="line">        <span class="number">0</span>: bipush        <span class="number">10</span></span><br><span class="line">        <span class="number">2</span>: istore_0</span><br><span class="line">        <span class="number">3</span>: iload_0</span><br><span class="line">        <span class="number">4</span>: istore_1		<span class="comment">// 思考，为何不直接return，而是将栈顶的10再次存入slot1中呢？</span></span><br><span class="line">        <span class="number">5</span>: bipush        <span class="number">20</span></span><br><span class="line">        <span class="number">7</span>: istore_0</span><br><span class="line">        <span class="number">8</span>: iload_0</span><br><span class="line">        <span class="number">9</span>: ireturn</span><br><span class="line">       <span class="number">10</span>: astore_2</span><br><span class="line">       <span class="number">11</span>: bipush        <span class="number">20</span></span><br><span class="line">       <span class="number">13</span>: istore_0</span><br><span class="line">       <span class="number">14</span>: iload_0</span><br><span class="line">       <span class="number">15</span>: ireturn</span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            <span class="number">3</span>     <span class="number">5</span>    <span class="number">10</span>   any</span><br><span class="line">     LocalVariableTable:</span><br><span class="line">       Start  Length  Slot  Name   Signature</span><br><span class="line">           <span class="number">3</span>      <span class="number">13</span>     <span class="number">0</span>     i   I</span><br></pre></td></tr></table></figure>
<p>我们再考虑如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoException</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">result</span> <span class="operator">=</span> test();</span><br><span class="line">        System.out.println(result);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            i = <span class="number">20</span>;</span><br><span class="line">          	<span class="comment">// return i;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​    返回结果为 <code>10</code>。其字节码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">test</span><span class="params">()</span>;</span><br><span class="line">   descriptor: ()I</span><br><span class="line">   flags: (<span class="number">0x0009</span>) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">   Code:</span><br><span class="line">     stack=<span class="number">1</span>, locals=<span class="number">3</span>, args_size=<span class="number">0</span></span><br><span class="line">        <span class="number">0</span>: bipush        <span class="number">10</span>	<span class="comment">// 将10压入栈顶，try ------------------------</span></span><br><span class="line">        <span class="number">2</span>: istore_0		<span class="comment">// 将栈顶的10存入slot0(i)中，i=10</span></span><br><span class="line">        <span class="number">3</span>: iload_0		<span class="comment">// 将slot0中的10加载到栈顶</span></span><br><span class="line">        <span class="number">4</span>: istore_1		<span class="comment">// 将栈顶的10存入slot1中</span></span><br><span class="line">        <span class="number">5</span>: bipush        <span class="number">20</span>	<span class="comment">// 将20压入栈顶，finally ---------------------</span></span><br><span class="line">        <span class="number">7</span>: istore_0		<span class="comment">// 将栈顶的20存入slot0(i)中，i=20</span></span><br><span class="line">        <span class="number">8</span>: iload_1		<span class="comment">// 将slot1中的10加载到栈顶，return -------------</span></span><br><span class="line">        <span class="number">9</span>: ireturn		<span class="comment">// 返回栈顶元素10</span></span><br><span class="line">       <span class="number">10</span>: astore_2</span><br><span class="line">       <span class="number">11</span>: bipush        <span class="number">20</span></span><br><span class="line">       <span class="number">13</span>: istore_0</span><br><span class="line">       <span class="number">14</span>: aload_2</span><br><span class="line">       <span class="number">15</span>: athrow</span><br><span class="line">     Exception table:</span><br><span class="line">        from    to  target type</span><br><span class="line">            <span class="number">3</span>     <span class="number">5</span>    <span class="number">10</span>   any</span><br><span class="line">     LocalVariableTable:</span><br><span class="line">       Start  Length  Slot  Name   Signature</span><br><span class="line">           <span class="number">3</span>      <span class="number">13</span>     <span class="number">0</span>     i   I</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>我们通过分析以上代码，画出以下流程图：</p>
<pre class="mermaid">sequenceDiagram
    participant e1 as 例1
    participant e2 as 例2

    Note over e1,e2 :将 10 入栈，栈[10]
    Note over e1,e2 :将栈顶元素 10 存入 i，栈[ ]，i=10

    e1 -> e2 :try 代码块
    Note over e1,e2 :将 i=10 入栈，栈[10]
    Note over e1,e2 :⚠️准备 return，但存在 finally 代码块，不能 return。将要返回的元素暂存
    Note over e1,e2 :将栈顶元素 10 存入本地变量表中，栈[ ]

    e1 -> e2 :finally 代码块
    Note over e1,e2 :将 20 入栈，栈[20]
    Note over e1,e2 :将栈顶元素 20 存入 i，栈[ ]，i=20

    Note over e1 :将 i=20 入栈，栈[20]
    Note over e1 :ireturn 栈顶元素 20
    Note over e1 :程序结束 ❌

    e1 -> e2 :finally 代码块结束，回到 try 中的 return
    Note over e2 :恢复 return，将之前暂存的 10 入栈，栈[10, 20]
    Note over e2 :ireturn 栈顶元素 10
    Note over e2 :程序结束 ❌</pre>



<blockquote>
<p>注意⚠️：</p>
<ul>
<li>由上我们可知，在 <code>try - catch - finally</code> 代码块中，<code>try</code> 中的 <code>return</code> 会因为 <code>finally</code> 代码块而被“打断”，从而需要暂存，以保护返回的值。</li>
</ul>
</blockquote>
<h4 id="2-10-synchronized-代码块分析"><a href="#2-10-synchronized-代码块分析" class="headerlink" title="2.10 synchronized 代码块分析"></a>2.10 <code>synchronized</code> 代码块分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoSynchronized</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">        <span class="keyword">synchronized</span> (lock) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;LOCK!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其字节码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: (<span class="number">0x0009</span>) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">4</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>	<span class="comment">// new Object</span></span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         <span class="number">4</span>: invokespecial #<span class="number">1</span>	<span class="comment">// 调用构造方法 &quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">7</span>: astore_1		<span class="comment">// lock对象的引用 -存到-&gt; slot1(lock) 中</span></span><br><span class="line">         <span class="number">8</span>: aload_1		<span class="comment">// lock引用加载到栈[lock_ref]【synchronized开始】</span></span><br><span class="line">         <span class="number">9</span>: dup			<span class="comment">// 复制，栈[lock_ref, lock_ref]</span></span><br><span class="line">        <span class="number">10</span>: astore_2		<span class="comment">// 栈顶lock对象的引用lock_ref -存到-&gt; slot2 中，栈[lock_ref]</span></span><br><span class="line">        <span class="number">11</span>: monitorenter	<span class="comment">// 加锁，栈[]</span></span><br><span class="line">        <span class="number">12</span>: getstatic     #<span class="number">3</span>	<span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">        <span class="number">15</span>: ldc           #<span class="number">4</span>	<span class="comment">// String LOCK!</span></span><br><span class="line">        <span class="number">17</span>: invokevirtual #<span class="number">5</span>	<span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">        <span class="number">20</span>: aload_2		<span class="comment">// 将slot2的lock_ref加载到栈，栈[lock_ref]</span></span><br><span class="line">        <span class="number">21</span>: monitorexit		<span class="comment">// 解锁，栈[]</span></span><br><span class="line">        <span class="number">22</span>: goto          <span class="number">30</span></span><br><span class="line">        <span class="number">25</span>: astore_3		<span class="comment">// 若出现异常，将异常对象的引用存入slot3</span></span><br><span class="line">        <span class="number">26</span>: aload_2		<span class="comment">// 将slot2的lock_ref加载到栈，栈[lock_ref]</span></span><br><span class="line">        <span class="number">27</span>: monitorexit		<span class="comment">// 解锁，栈[]</span></span><br><span class="line">        <span class="number">28</span>: aload_3		<span class="comment">// 将slot3中异常对象的引用加载到栈，栈[exception_ref]</span></span><br><span class="line">        <span class="number">29</span>: athrow		<span class="comment">// 抛出异常</span></span><br><span class="line">        <span class="number">30</span>: <span class="keyword">return</span></span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">            <span class="number">12</span>    <span class="number">22</span>    <span class="number">25</span>   any</span><br><span class="line">            <span class="number">25</span>    <span class="number">28</span>    <span class="number">25</span>   any</span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">31</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">8</span>      <span class="number">23</span>     <span class="number">1</span>  lock   Ljava/lang/Object;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意 ⚠️</p>
<ul>
<li>方法级别的 <code>synchronized</code> 不会体现在字节码指令中</li>
</ul>
</blockquote>
<h3 id="3-编译期处理"><a href="#3-编译期处理" class="headerlink" title="3 编译期处理"></a>3 编译期处理</h3><p>所谓的<strong><em><u>语法糖</u></em></strong>，其实就是指 java编译器把 <code>.java 源码</code>编译为 <code>.class 字节码</code> 的过程中，自动生成和转换的一些代码，主要是为了减轻程序员的负担，算是 java 编译器给我们的一个额外福利。</p>
<blockquote>
<p>注意⚠️</p>
<p>以下代码的分析，借助了 javap 工具，idea 的反编译功能，idea 插件 <code>jclasslib</code> 等工具。另外，编译器转换的结果直接就是 <code>class 字节码</code>，只是为了便于阅读，给出了几乎等价 的 java 源码方式，并不是编译器还会转换出中间的 java 源码，切记。</p>
</blockquote>
<h4 id="3-1-默认构造器"><a href="#3-1-默认构造器" class="headerlink" title="3.1 默认构造器"></a>3.1 默认构造器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Constructor</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译成 <code>.class</code> 后的等效代码为</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Constructor</span> &#123;</span><br><span class="line">  <span class="comment">// 这个无参构造是编译器帮助我们加上的</span></span><br><span class="line">  <span class="keyword">public</span> <span class="title function_">Constructor</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>();	<span class="comment">// 即调用父类 Object 的无参构造方法，即调用 java/lang/Object.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-2-自动拆装箱"><a href="#3-2-自动拆装箱" class="headerlink" title="3.2 自动拆装箱"></a>3.2 自动拆装箱</h4><p>这个特性是 JDK5 开始加入的，如下代码举例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BoxingUnboxing</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码在 JDK5 以前的版本是不能通过编译的，基本类型和包装类型还不能自动转化。必须改写成如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">BoxingUnboxing</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> Integer.valueOf(<span class="number">1</span>);</span><br><span class="line">    <span class="type">int</span> <span class="variable">y</span> <span class="operator">=</span> x.intValue();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>显然代码太麻烦了，需要在<u>基本类型</u>和包装类型之间来回转换（尤其是集合类中操作的都是包装类型），因此这些转换的事情在 JDK 5以后都<strong><em><u>由编译器在编译阶段完成</u></em></strong>。即代码片段 1 都会在编译阶段被转换为代码片段 2。</p>
<h4 id="3-3-范型集合取值"><a href="#3-3-范型集合取值" class="headerlink" title="3.3 范型集合取值"></a>3.3 范型集合取值</h4><p><strong><em><u>泛型</u></em></strong> 也是在 JDK5 开始加入的特性，但 java 在编译泛型代码后会执行<strong><em><u>泛型擦除</u></em></strong>的动作，即<strong>泛型信息在编译为字节码之后就丢失了，实际的类型都当做了 object 类型来处理</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoGeneric</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        list.add(<span class="number">10</span>); <span class="comment">// 实际调用的是 List.add(Object o);</span></span><br><span class="line">      	</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> list.get(<span class="number">0</span>); <span class="comment">// 实际是 Object o = list.get(int index);</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以在取值时，编译器真正生成的字节码中，还要额外做一个类型转换的操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 需要将 object 转为 Integer</span></span><br><span class="line"><span class="type">Integer</span> <span class="variable">x</span> <span class="operator">=</span> (Integer)list.get(<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>如果前面的 <code>x</code> 变量类型修改为 <code>int</code> 基本类型那么最终生成的字节码是：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//需要将 object 转为 Integer，并执行拆箱操作</span></span><br><span class="line"><span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> ((Integer)list.get(<span class="number">0</span>)).intValue()；</span><br></pre></td></tr></table></figure>
<p>在 JDK5 以后，以上操作在编译期间自动完成了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(java.lang.String[])</span>;</span><br><span class="line">    descriptor: ([Ljava/lang/String;)V</span><br><span class="line">    flags: (<span class="number">0x0009</span>) ACC_PUBLIC, ACC_STATIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=<span class="number">2</span>, locals=<span class="number">3</span>, args_size=<span class="number">1</span></span><br><span class="line">         <span class="number">0</span>: <span class="keyword">new</span>           #<span class="number">2</span>	<span class="comment">// class java/util/ArrayList</span></span><br><span class="line">         <span class="number">3</span>: dup</span><br><span class="line">         <span class="number">4</span>: invokespecial #<span class="number">3</span>	<span class="comment">// Method java/util/ArrayList.&quot;&lt;init&gt;&quot;:()V</span></span><br><span class="line">         <span class="number">7</span>: astore_1</span><br><span class="line">         <span class="number">8</span>: aload_1</span><br><span class="line">         <span class="number">9</span>: bipush        <span class="number">10</span></span><br><span class="line">        <span class="number">11</span>: invokestatic  #<span class="number">4</span>	<span class="comment">// Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span></span><br><span class="line">        <span class="number">14</span>: invokeinterface #<span class="number">5</span>,  <span class="number">2</span>	<span class="comment">// InterfaceMethod java/util/List.add:(Ljava/lang/Object;)Z</span></span><br><span class="line">        <span class="number">19</span>: pop</span><br><span class="line">        <span class="number">20</span>: aload_1</span><br><span class="line">        <span class="number">21</span>: iconst_0</span><br><span class="line">        <span class="number">22</span>: invokeinterface #<span class="number">6</span>,  <span class="number">2</span>	<span class="comment">// InterfaceMethod java/util/List.get:(I)Ljava/lang/Object;</span></span><br><span class="line">        <span class="number">27</span>: checkcast     #<span class="number">7</span>	<span class="comment">// class java/lang/Integer 强制类型转化，Object -&gt; Integer</span></span><br><span class="line">        <span class="number">30</span>: astore_2</span><br><span class="line">        <span class="number">31</span>: <span class="keyword">return</span></span><br><span class="line">      LocalVariableTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">0</span>      <span class="number">32</span>     <span class="number">0</span>  args   [Ljava/lang/String;</span><br><span class="line">            <span class="number">8</span>      <span class="number">24</span>     <span class="number">1</span>  list   Ljava/util/List;</span><br><span class="line">           <span class="number">31</span>       <span class="number">1</span>     <span class="number">2</span>     x   Ljava/lang/Integer;</span><br><span class="line">      LocalVariableTypeTable:</span><br><span class="line">        Start  Length  Slot  Name   Signature</span><br><span class="line">            <span class="number">8</span>      <span class="number">24</span>     <span class="number">1</span>  list   Ljava/util/List&lt;Ljava/lang/Integer;&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>擦除的是字节码上的泛型信息，可以看到 <code>LocalVariableTypeTable</code> 仍然保留了方法参数泛型的信息。可以供类型转换时使用。</p>
<h4 id="3-4-可变参数"><a href="#3-4-可变参数" class="headerlink" title="3.4 可变参数"></a>3.4 可变参数</h4><p>在 Java 5 中提供了变长参数，允许在调用方法时传入不定长度的参数。变长参数是 Java 的一个语法糖，本质上还是基于数组的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(String... args)</span>;</span><br><span class="line"><span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(String[] args)</span>;</span><br></pre></td></tr></table></figure>
<p>在定义方法时，在最后一个形参后加上三点 <strong>…</strong>，就表示该形参可以接受多个参数值，多个参数值被当成数组传入。上述定义有几个要点需要注意：</p>
<ul>
<li><p>可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数</p>
</li>
<li><p>由于可变参数必须是最后一个参数，所以一个函数最多只能有一个可变参数</p>
</li>
<li><p>Java 的可变参数，会被编译器转型为一个数组</p>
</li>
<li><p>变长参数在编译为字节码后，在方法签名中就是以数组形态出现的。这两个方法的签名是一致的，不能作为方法的重载。如果同时出现，是不能编译通过的。可变参数可以兼容数组，反之则不成立</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">foo</span><span class="params">(String...varargs)</span>&#123;&#125;</span><br><span class="line">foo(<span class="string">&quot;arg1&quot;</span>, <span class="string">&quot;arg2&quot;</span>, <span class="string">&quot;arg3&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//上述过程和下面的调用是等价的</span></span><br><span class="line">foo(<span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;arg1&quot;</span>, <span class="string">&quot;arg2&quot;</span>, <span class="string">&quot;arg3&quot;</span>&#125;);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="3-5-foreach-循环"><a href="#3-5-foreach-循环" class="headerlink" title="3.5 foreach 循环"></a>3.5 <code>foreach</code> 循环</h4><p><code>foreach</code> 语句是 java5 的新特征之一，在遍历数组、集合方面，<code>foreach</code> 为开发人员提供了极大的方便。</p>
<p><code>foreach</code> 语法格式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(type 元素变量x : 遍历对象obj)&#123; </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<p>以下实例演示了<u><strong><em>数组</em></strong></u>的 <code>for</code> 和 <code>foreach</code> 循环使用</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoForeach</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span>[] intary = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;; <span class="comment">// int[] intary = new int[]&#123;1,2,3,4&#125;;</span></span><br><span class="line">        forDisplay(intary);</span><br><span class="line">        foreachDisplay(intary);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">forDisplay</span><span class="params">(<span class="type">int</span>[] a)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">            System.out.print(a[i] + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">foreachDisplay</span><span class="params">(<span class="type">int</span>[] data)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> a : data) &#123;</span><br><span class="line">            System.out.print(a+ <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而对于<strong><em><u>集合</u></em></strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoForeach</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">      <span class="keyword">for</span> (Integer i : list) &#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际被编译器转换为对<strong><em><u>迭代器</u></em></strong>的调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoForeach</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">      List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);</span><br><span class="line">      <span class="type">Iterator</span> <span class="variable">iter</span> <span class="operator">=</span> list.iterator();</span><br><span class="line">      <span class="keyword">while</span> (iter.hasNext()) &#123;</span><br><span class="line">        <span class="type">Integer</span> <span class="variable">i</span> <span class="operator">=</span> (Integer) iter.next();</span><br><span class="line">        System.out.println(i);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-6-switch-字符串"><a href="#3-6-switch-字符串" class="headerlink" title="3.6 switch 字符串"></a>3.6 <code>switch</code> 字符串</h4><p>从 JDK 7开始，<code>switch</code> 可以作用于字符串和枚举类，这个功能其实也是语法糖，例如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoSwitch</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span>(str) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;hello&quot;</span>: &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello &quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">case</span> <span class="string">&quot;world&quot;</span>: &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;World!&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>⚠️注意</p>
<p><code>switch</code> 配合 <code>string</code> 和 <code>enum</code> 使用时，变量不能为 <code>null</code></p>
</blockquote>
<p>会被编译器转换为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoSwitch</span> &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">    <span class="type">byte</span> <span class="variable">x</span> <span class="operator">=</span> -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">switch</span>(str.hashCode()) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">99162322</span>: &#123;	<span class="comment">// hello 的hashCode</span></span><br><span class="line">        <span class="keyword">if</span> (str.equals(<span class="string">&quot;Hello &quot;</span>)) &#123;</span><br><span class="line">          x = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">case</span> <span class="number">113318802</span>: &#123;	<span class="comment">// world 的hashCode</span></span><br><span class="line">        <span class="keyword">if</span> (str.equals(<span class="string">&quot;World!&quot;</span>)) &#123;</span><br><span class="line">          x = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span>(x) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello &quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">      <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">        System.out.println(<span class="string">&quot;World!&quot;</span>);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，执行了两遍 <code>switch</code>，第一遍是根据字符串的 <code>hashCode()</code> 和 <code>equals()</code> 将字符串的转换为相应 <code>byte</code> 类型，第二遍才是利用 <code>byte</code> 执行进行比较。</p>
<blockquote>
<p>为什么第一遍时必须既比较 <code>hashCode</code>，又利用 <code>equals</code> 比较呢？</p>
<p>hashcode 是为了提高效率，减少可能的比较；而 <code>equals</code> 是为了防止 <code>hashCode</code> 冲突，例如 <code>&quot;EM&quot;</code> 和 <code>&quot;C.&quot;</code> 这两个字符串的 <code>hashCode</code> 值都是 <code>2123</code>。</p>
</blockquote>
<h4 id="3-7-switch-枚举"><a href="#3-7-switch-枚举" class="headerlink" title="3.7 switch 枚举"></a>3.7 <code>switch</code> 枚举</h4><p><code>switch</code> 枚举的例子如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> <span class="title class_">Gender</span> &#123;</span><br><span class="line">    MALE, FEMALE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoSwitchEnum</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span> <span class="params">(Gender g)</span> &#123;</span><br><span class="line">        <span class="keyword">switch</span> (g) &#123;</span><br><span class="line">            <span class="keyword">case</span> MALE:</span><br><span class="line">                System.out.println(<span class="string">&quot;MALE&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> FEMALE:</span><br><span class="line">                System.out.println(<span class="string">&quot;FEMALE&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转换后代码为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoSwitchEnum</span> &#123;</span><br><span class="line">  	<span class="comment">/**</span></span><br><span class="line"><span class="comment">  	* 定义一个合成类（仅jvm 使用，对我们不可见）</span></span><br><span class="line"><span class="comment">  	* 用来映射枚举的 ordinal 与数组元素的关系</span></span><br><span class="line"><span class="comment">  	* 枚举的 ordinal 表示枚举对象的序号，从0开始</span></span><br><span class="line"><span class="comment">  	* 即 MALE 的ordinal()=0, FEMALE的ordinal()=1</span></span><br><span class="line"><span class="comment">  	*/</span></span><br><span class="line">  	<span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">$MAP</span> &#123;</span><br><span class="line">      <span class="comment">// 数组大小即为枚举元素个数，里面存储case用来对比的数字</span></span><br><span class="line">      <span class="keyword">static</span> <span class="type">int</span>[] map = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">2</span>];</span><br><span class="line">      <span class="keyword">static</span> &#123;</span><br><span class="line">        map[Gender.MALE.ordinal()] = <span class="number">1</span>;</span><br><span class="line">        map[Gender.FEMALE.ordinal()] = <span class="number">2</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">print</span> <span class="params">(Gender g)</span> &#123;</span><br><span class="line">      <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> $MAP.map[g.ordinal()];</span><br><span class="line">        <span class="keyword">switch</span> (x) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;MALE&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                System.out.println(<span class="string">&quot;FEMALE&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-类加载阶段"><a href="#4-类加载阶段" class="headerlink" title="4 类加载阶段"></a>4 类加载阶段</h3><h4 id="4-1-加载"><a href="#4-1-加载" class="headerlink" title="4.1 加载"></a>4.1 加载</h4><ul>
<li><p>在 Java 类编译成字节码以后，在运行时通过<strong><em><u>类加载器</u></em></strong> 将类的字节码加载到<strong><em><u>方法区</u></em></strong> 中，内部采用 C++ 的<code>instanceKlass</code> 描述 Java 类，它的重要 field 有：</p>
<ul>
<li><p><code>_java_mirror</code> 即 Java 的类镜像，例如对 <code>String</code> 来说，就是 <code>String.class</code>，作用是把 <code>instanceKlass</code> 暴露给 Java 使用。对 <code>String</code> 来说， <u><code>String.class</code> 就是 <code>instanceKlass</code> 的类镜像</u>，它们两者间相互持有对方的指针。</p>
</li>
<li><p><code>_super</code> 即父类</p>
</li>
<li><p><code>_fields</code> 即成员变量</p>
</li>
<li><p><code>_methods</code> 即方法</p>
</li>
<li><p><code>_constants</code> 即常量池</p>
</li>
<li><p><code>_class_loader</code> 即类加载器</p>
</li>
<li><p><code>_vtable</code> 虚方法表</p>
</li>
<li><p><code>_itable</code> 接口方法表</p>
</li>
</ul>
</li>
<li><p>如果这个类还有父类没有加载，先加载父类</p>
</li>
<li><p>加载和链接可能是交替运行的</p>
</li>
</ul>
<blockquote>
<p>注意 ⚠️</p>
<ul>
<li><code>instanceKlass</code> 这样的“元数据”是存储在方法区（JDK 1.8 后是元空间），但 <code>_java_mirror</code> 是存储在队中的</li>
<li>可以通过 HSDB 工具查看</li>
</ul>
</blockquote>
<p><img src="/2022/03/22/JVM-1/image-20220823212538798.png" alt="image-20220823212538798" style="zoom:50%;"></p>
<h4 id="4-2-链接"><a href="#4-2-链接" class="headerlink" title="4.2 链接"></a>4.2 链接</h4><h6 id="1-验证"><a href="#1-验证" class="headerlink" title="(1) 验证"></a>(1) 验证</h6><p>验证 <code>.class</code> 文件是否符合 JVM 的规范，安全性检查。例如如果我们修改 <code>.class</code> 文件的字节码，JVM 会在加载过后验证类的规范性。如果不符合规范，则会报错。</p>
<h6 id="2-准备"><a href="#2-准备" class="headerlink" title="(2) 准备"></a>(2) 准备</h6><p>准备：为 <code>static</code> 静态变量分配空间，设置默认值</p>
<ul>
<li><p><code>static</code> 变量在 JDK 1.7 之前存储于 <code>instanceKlass</code> 末尾，从 JDK 1.7 开始，存储于 <code>_java mirror</code> 末尾</p>
</li>
<li><p><code>static</code> 变量分配空间和赋值是两个步骤，分配空间在<u>准备阶段</u>完成，赋值在<u>初始化阶段</u>完成</p>
</li>
<li><p>如果 <code>static</code> 变量是 <code>final</code> 的基本类型，那么<u>编译阶段</u>值就确定了，赋值在<u>准备阶段</u>完成</p>
</li>
<li><p>如果 <code>static</code> 变量是 <code>final</code> 的，但属于引用类型，那么赋值也会在初始化阶段完成。</p>
<p>因为引用一个新对象 <code>new Object()</code> 的时候，新对象引用的创建需要在堆中完成，所以需要在初始化阶段赋值。</p>
</li>
</ul>
<h6 id="3-解析"><a href="#3-解析" class="headerlink" title="(3) 解析"></a>(3) 解析</h6><p>将常量池中的符号引用，解析为直接引用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ClassLoad;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">C</span> &#123;</span><br><span class="line">    <span class="type">D</span> <span class="variable">d</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">D</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">D</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoLoad</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException, IOException &#123;</span><br><span class="line">        <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> DemoLoad.class.getClassLoader();</span><br><span class="line">        Class&lt;?&gt; c = classLoader.loadClass(<span class="string">&quot;ClassLoad.C&quot;</span>); <span class="comment">// loadClass() 不会导致类的解析和初始化</span></span><br><span class="line">        <span class="comment">// new C();</span></span><br><span class="line">        System.in.read();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>个人理解：在上述例子中，我们在通过 <code>loadClass()</code> 加载类的时候，由于 <code>C</code> 类不会被初始化，所以 <code>C</code> 类中引用的 <code>D</code> 类不会被加载，而是只是作为一个“<code>class ClassLoad.D</code>” 存在常量池中，并不是一个类。此所谓“符号引用”，“直接引用”则是 <code>D</code> 类也被加载，有了地址，此时引用的就是一个真实的类了。</p>
</blockquote>
<h4 id="4-3-初始化"><a href="#4-3-初始化" class="headerlink" title="4.3 初始化"></a>4.3 初始化</h4><p>初始化就是调用 <code>&lt;clinit&gt;()V</code>，虚拟机会保证这个<strong><em><u>类的构造方法</u></em></strong>的线程安全。</p>
<p>那么何时初始化呢？概括得说，类初始化是【懒情的】</p>
<ul>
<li><u><code>main</code> 方法</u>所在的类，总会被首先初始化</li>
<li>首次访问这个类的<u>静态变量或静态方法</u>时</li>
<li>子类初始化，会引发父类的初始化</li>
<li>子类访问父类的静态变量，只会触发父类的初始化</li>
<li>执行 <code>Class.forName</code> 时</li>
<li><code>new</code> 一个对象的时候，会导致该对象的初始化</li>
</ul>
<p>不会导致类初始化的情况</p>
<ul>
<li>访问类的 <code>static final</code> <u>静态常量</u>（<u>基本类型和字符串</u>） 不会触发初始化</li>
<li><code>xxx.class</code> 不会触发该类的初始化</li>
<li>创建该类的数组不会触发初始化</li>
<li>类加载器的 <code>loadClass</code> 方法</li>
<li><code>Class.forName</code> 的<code>参数2</code>为 <code>false</code> 时</li>
</ul>
<h4 id="4-4-练习"><a href="#4-4-练习" class="headerlink" title="4.4 练习"></a>4.4 练习</h4><h6 id="1"><a href="#1" class="headerlink" title="(1)"></a>(1)</h6><p>从字节码分析，使用 <code>a, b, c</code> 这三个常量是否会导致 <code>E</code> 初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ClassLoad;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoLoad2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        System.out.println(E.a); <span class="comment">// 不会</span></span><br><span class="line">        System.out.println(E.b); <span class="comment">// 不会</span></span><br><span class="line">        System.out.println(E.c); <span class="comment">// 会</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">E</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">b</span> <span class="operator">=</span> <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Integer</span> <span class="variable">c</span> <span class="operator">=</span> <span class="number">20</span>; <span class="comment">// Integer.valueOf(20);</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init E&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;&#125;;</span><br><span class="line">   descriptor: ()V</span><br><span class="line">   flags: (<span class="number">0x0008</span>) ACC_STATIC</span><br><span class="line">   Code:</span><br><span class="line">     stack=<span class="number">2</span>, locals=<span class="number">0</span>, args_size=<span class="number">0</span></span><br><span class="line">        <span class="number">0</span>: bipush        <span class="number">20</span></span><br><span class="line">        <span class="number">2</span>: invokestatic  #<span class="number">2</span>                  <span class="comment">// Method java/lang/Integer.valueOf:(I)Ljava/lang/Integer;</span></span><br><span class="line">        <span class="number">5</span>: putstatic     #<span class="number">3</span>                  <span class="comment">// Field c:Ljava/lang/Integer;</span></span><br><span class="line">        <span class="number">8</span>: getstatic     #<span class="number">4</span>                  <span class="comment">// Field java/lang/System.out:Ljava/io/PrintStream;</span></span><br><span class="line">       <span class="number">11</span>: ldc           #<span class="number">5</span>                  <span class="comment">// String init E</span></span><br><span class="line">       <span class="number">13</span>: invokevirtual #<span class="number">6</span>                  <span class="comment">// Method java/io/PrintStream.println:(Ljava/lang/String;)V</span></span><br><span class="line">       <span class="number">16</span>: <span class="keyword">return</span></span><br></pre></td></tr></table></figure>
<h6 id="2"><a href="#2" class="headerlink" title="(2)"></a>(2)</h6><p>完成懒惰初始化单例模式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ClassLoad;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Singleton</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Singleton</span><span class="params">()</span> &#123;&#125; <span class="comment">// 限制构造方法，其他类不能使用该构造方法</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">LazyHolder</span> &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">Singleton</span> <span class="variable">SINGLETON</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Singleton</span>();</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;lazy holder init&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title function_">getInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> LazyHolder.SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;testing...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoLoad3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// Singleton.test();</span></span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">singleton1</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        <span class="type">Singleton</span> <span class="variable">singleton2</span> <span class="operator">=</span> Singleton.getInstance();</span><br><span class="line">        System.out.println(singleton1 == singleton2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="5-类加载器"><a href="#5-类加载器" class="headerlink" title="5 类加载器"></a>5 类加载器</h3><p>在 JDK 中，类加载器有一定的层级关系。以 JDK 1.8 为例，从顶至底为：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>名称</th>
<th>加载哪里的类</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Bootstrap ClassLoader</code></td>
<td><code>JAVA_HOME/jre/lib</code></td>
<td>无法直接访问</td>
</tr>
<tr>
<td><code>Extension ClassLoader</code></td>
<td><code>JAVA_HOME/jre/lib/ext</code></td>
<td>上级为 <code>Bootstrap</code>，显示为 <code>null</code></td>
</tr>
<tr>
<td><code>Application ClassLoader</code></td>
<td><code>classpath</code></td>
<td>上级为 <code>Extension</code></td>
</tr>
<tr>
<td><code>自定义 ClassLoader</code></td>
<td>自定义</td>
<td>上级为 <code>Application</code></td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>类加载器在加载类时需要分层级加载。例如 <code>Application ClassLoader</code> 加载类时会检查该类是否被上级类加载器加载，若没有，则再由 <code>Extension ClassLoader</code> 向上层检查。若都没有，则由 <code>Application ClassLoader</code> 加载。（双亲委派）</li>
</ul>
<h4 id="5-1-Bootstrap-ClassLoader"><a href="#5-1-Bootstrap-ClassLoader" class="headerlink" title="5.1 Bootstrap ClassLoader"></a>5.1 <code>Bootstrap ClassLoader</code></h4><p>用 <code>Bootstrap ClassLoader</code> 加载类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ClassLoad;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Klass</span> &#123;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;BootStrap ClassLoader Klass init&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>执行</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ClassLoad;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoBootstrapClassLoader</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">        Class&lt;?&gt; klass = Class.forName(<span class="string">&quot;ClassLoad.Klass&quot;</span>);</span><br><span class="line">        System.out.println(klass.getClassLoader());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -Xbootclasspath/a:. ClassLoad.DemoBootstrapClassLoader</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BootStrap ClassLoader Klass init</span><br><span class="line">null</span><br></pre></td></tr></table></figure>
<h4 id="5-2-Extension-ClassLoader"><a href="#5-2-Extension-ClassLoader" class="headerlink" title="5.2 Extension ClassLoader"></a>5.2 <code>Extension ClassLoader</code></h4><p>还是上一节的例子，如果我们使用 <code>.jar</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jar .cvf Test_Klass.jar ClassLoad/Klass.class</span><br></pre></td></tr></table></figure>
<p>将我们打包好的 <code>Test_Klass.class</code> 复制到 Java 安装目录下的 <code>JAVA_HOME/jre/lib/ext</code> 扩展目录下。重新运行程序，我们得到以下输出：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Extension ClassLoader Klass init</span><br><span class="line">sun.misc.Launcher$ExtClassLoader@18b4aac2</span><br></pre></td></tr></table></figure>
<h4 id="5-3-双亲委派模式"><a href="#5-3-双亲委派模式" class="headerlink" title="5.3 双亲委派模式"></a>5.3 双亲委派模式</h4><p>所谓双亲委派，就是指调用类加载器的 <code>loadClass()</code> 方法时，查找上级类加载器是否已经加载该类的行为。</p>
<p>图解如下：</p>
<p><img src="/2022/03/22/JVM-1/image-20220824100940813.png" alt="image-20220824100940813" style="zoom:50%;"></p>
<h6 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="type">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">// First, check if the class has already been loaded</span></span><br><span class="line">          <span class="comment">// 首先检查该类加载器是否已经加载</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="variable">t0</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">                      <span class="comment">// 如果有上级</span></span><br><span class="line">                        c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">                      <span class="comment">// 递归调用上级的loadClass()</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                      <span class="comment">// 如果没有上级了(ExtClassLoader)，则委派BootstrapClassLoader</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">// ClassNotFoundException thrown if class not found</span></span><br><span class="line">                    <span class="comment">// from the non-null parent class loader</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order to find the class.</span></span><br><span class="line">                    <span class="comment">// 如果每一层都找不到，调用findClass方法（每个类加载器自己扩展）来加载</span></span><br><span class="line">                    <span class="type">long</span> <span class="variable">t1</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats 记录耗时</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-4-线程上下文类加载器"><a href="#5-4-线程上下文类加载器" class="headerlink" title="5.4 线程上下文类加载器"></a>5.4 线程上下文类加载器</h4><h4 id="5-5-自定义类加载器"><a href="#5-5-自定义类加载器" class="headerlink" title="5.5 自定义类加载器"></a>5.5 自定义类加载器</h4><p>需要自定义类加载器的场景：</p>
<ol>
<li>想加载非 classpath 随意路径中的类文件</li>
<li>都是通过接口来使用实现，希望解耦时，常用在框架设计</li>
<li>这些类希望予以隔离，不同应用的同名类都可以加载，不冲突，常见于 tomcat 容器</li>
</ol>
<p>【步骤】</p>
<ol>
<li>继承 <code>ClassLoader</code> 父类</li>
<li>要遵从<strong><em><u>双亲委派机制</u></em></strong>，重写 <code>findClass</code> 方法<ul>
<li>注意不是重写 <code>loadClass</code> 方法，否则不会走双亲委派机制</li>
</ul>
</li>
<li>读取类文件的字节码</li>
<li>调用父类的 <code>defineClass</code> 方法来加载类</li>
<li>使用者调用该类加载器的 <code>loadClass</code> 方法</li>
</ol>
<h3 id="6-运行期优化"><a href="#6-运行期优化" class="headerlink" title="6 运行期优化"></a>6 运行期优化</h3><h4 id="6-1-即时编译"><a href="#6-1-即时编译" class="headerlink" title="6.1 即时编译"></a>6.1 即时编译</h4><h5 id="分层编译"><a href="#分层编译" class="headerlink" title="分层编译"></a>分层编译</h5><p>我们先考虑一下例子</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoJit1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">200</span>; i++)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j&lt;<span class="number">1000</span> ; j++) &#123;</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            System.out.println( i + <span class="string">&quot;\t&quot;</span> + (end-start));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span>	<span class="number">42542</span></span><br><span class="line">   ...</span><br><span class="line"><span class="number">70</span>	<span class="number">11958</span></span><br><span class="line"><span class="number">71</span>	<span class="number">4750</span></span><br><span class="line"><span class="number">72</span>	<span class="number">4041</span></span><br><span class="line"><span class="number">73</span>	<span class="number">4167</span></span><br><span class="line">   ...</span><br></pre></td></tr></table></figure>
<p>我们可以看到，JVM 在执行这些相同的代码时所用的时间并不相同。</p>
<p>原因是什么呢？</p>
<p>JVM将执行状态分成了 5个层次：</p>
<ul>
<li>0层，解释执行 I (Interpreter)</li>
<li>1层，使用 C1 即时编译器编译执行 （不带 profiling)</li>
<li>2层，使用 C1 即时编译器编译执行（带基本的 profiling）</li>
<li>3层，使用 C1 即时编译器编译执行（带完全的 profiling)</li>
<li>4层，使用 C2 即时编译器编译执行</li>
</ul>
<blockquote>
<p>profling 是指在运行过程中收集一些程序执行状态的数据，例如<strong><em><u>方法的调用次数</u></em></strong>，<u><strong><em>循环的回边次数</em></strong></u> 等</p>
</blockquote>
<p>即时编译器（JIT） 与解释器的区别</p>
<ul>
<li>解释器 是将字节码解释为机器码，下次即使遇到相同的字节码，仍会执行重复的解释</li>
<li>JIT 是将一些字节码编译为机器码，并存入 Code Cache， 下次遇到相同的代码，直接执行，无需再编译</li>
<li>解释器是将字节码解释为针对所有平台都通用的机器码</li>
<li>JIT 会根据平台类型，生成平台特定的机器码</li>
</ul>
<p>对于占据大部分的不常用的代码，我们无需耗费时间将其编译成机器码，而是采取解释执行的方式运行；另<br>一方面，对于仅占据小部分的热点代码，我们则可以将其编译成机器码，以达到理想的运行速度。执行效率上 Interpreter &lt; C1 &lt; C2。目的是为了发现那些热点代码，加以优化。</p>
<p>这一种优化手段我们称之为【逃逸分析】，发现新建的对象是否逃逸。可以使用如下指令</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:-DoEscapeAnalysis</span><br></pre></td></tr></table></figure>
<p>关闭逃逸分析。</p>
<p>逃逸分析的作用：</p>
<p>经过逃逸分析的对象，可以直接在栈空间进行分配，而非堆空间。因为这样的对象不会在其他的方法中被引用，所以它可以被分配在当前栈上，可以随着栈消亡。从而极大的降低了 GC 次数，提升了程序整体的执行效率。</p>
<h5 id="方法内联-Inlining"><a href="#方法内联-Inlining" class="headerlink" title="方法内联 (Inlining)"></a>方法内联 (Inlining)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> i)</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> i * i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果发现 <code>square()</code> 是<strong><em><u>热点方法</u></em></strong>，并旦<strong><em><u>长度不太长</u></em></strong>时，会进行内联，所谓的内联就是把方法内代码拷贝、粘贴到调用者的位置：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">9</span> * <span class="number">9</span>):</span><br></pre></td></tr></table></figure>
<p>还能够进行常量折叠 (constant folding）的优化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(<span class="number">81</span>);</span><br></pre></td></tr></table></figure>
<p>实验：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DemoJit2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">x</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">600</span>; i++)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j&lt;<span class="number">1000</span> ; j++) &#123;</span><br><span class="line">                x = square(<span class="number">9</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">long</span> <span class="variable">end</span> <span class="operator">=</span> System.nanoTime();</span><br><span class="line">            System.out.println( i + <span class="string">&quot;\t&quot;</span> + x + <span class="string">&quot;\t&quot;</span> + (end-start));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">square</span><span class="params">(<span class="keyword">final</span> <span class="type">int</span> i)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> i * i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">0</span>	<span class="number">81</span>	<span class="number">26792</span></span><br><span class="line">   ...</span><br><span class="line"><span class="number">78</span>	<span class="number">81</span>	<span class="number">6375</span></span><br><span class="line">   ...</span><br><span class="line"><span class="number">410</span>	<span class="number">81</span>	<span class="number">42</span></span><br><span class="line"><span class="number">411</span>	<span class="number">81</span>	<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>可以使用如下指令打印内联信息</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:+UnlockDiagnosticVMOptions -XX:+PrintInlining</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-XX:CompileCommand=doninline,包名.类名.方法名	// 关闭方法的内联</span><br></pre></td></tr></table></figure>
<h5 id="JMH"><a href="#JMH" class="headerlink" title="JMH"></a>JMH</h5><p>JMH(Java Microbenchmark Harness)是用于代码微基准测试的工具套件，主要是基于方法层面的基准测试，精度可以达到纳秒级。当你定位到热点方法，希望进一步优化方法性能的时候，就可以使用 JMH 对优化的结果进行量化的分析。</p>
<p>JMH 比较典型的应用场景如下：</p>
<ol>
<li>想准确地知道某个方法需要执行多长时间，以及执行时间和输入之间的相关性</li>
<li>对比接口不同实现在给定条件下的吞吐量</li>
<li>查看多少百分比的请求在多长时间内完成</li>
</ol>
<p>关于 JMH 工具的具体运用，恕在此不作详解。</p>
<h2 id="五、JMM-内存模型"><a href="#五、JMM-内存模型" class="headerlink" title="五、JMM 内存模型"></a>五、JMM 内存模型</h2><p>本章节内容单独记录，点击链接以跳转</p>
<p><a href="https://dave0126.github.io/2022/08/26/JMM-Java-内存模型/">链接：JMM - Java 内存模型</a></p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Guohao
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://dave0126.github.io/2022/03/22/JVM-1/" title="Java 虚拟机 - JVM">https://dave0126.github.io/2022/03/22/JVM-1/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Java/" rel="tag"># Java</a>
              <a href="/tags/JVM/" rel="tag"># JVM</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/01/16/%E5%9B%BE%E8%AE%BA-Graphe/" rel="prev" title="图论 复习笔记">
      <i class="fa fa-chevron-left"></i> 图论 复习笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/03/23/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-1/" rel="next" title="Java 并发多线程编程 (JUC) (一)">
      Java 并发多线程编程 (JUC) (一) <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#JVM-%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0"><span class="nav-text">JVM 基础学习</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-JVM%EF%BC%9F"><span class="nav-text">什么是 JVM？</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%80%E3%80%81JVM-%E7%BB%93%E6%9E%84"><span class="nav-text">一、JVM 结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%8C%E3%80%81JVM-%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="nav-text">二、JVM 内存结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-text">1. 程序计数器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88"><span class="nav-text">2. 虚拟机栈</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-%E5%AE%9A%E4%B9%89"><span class="nav-text">2.1 定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-%E6%A0%88%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="nav-text">2.2 栈内存溢出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-%E7%BA%BF%E7%A8%8B%E8%BF%90%E8%A1%8C%E8%AF%8A%E6%96%AD"><span class="nav-text">2.3 线程运行诊断</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88"><span class="nav-text">3. 本地方法栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%A0%86"><span class="nav-text">4. 堆</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-%E5%AE%9A%E4%B9%89"><span class="nav-text">4.1 定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-%E5%A0%86%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="nav-text">4.2 堆内存溢出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-%E5%A0%86%E5%86%85%E5%AD%98%E8%AF%8A%E6%96%AD"><span class="nav-text">4.3 堆内存诊断</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="nav-text">5. 方法区</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-%E5%AE%9A%E4%B9%89"><span class="nav-text">5.1 定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-%E7%BB%84%E6%88%90"><span class="nav-text">5.2 组成</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="nav-text">5.3 方法区的内存溢出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0"><span class="nav-text">5.4 运行时常量池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-StringTable%E4%B8%B2%E6%B1%A0"><span class="nav-text">5.5 StringTable串池</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#5-5-1-%E4%B8%B2%E6%B1%A0"><span class="nav-text">5.5.1 串池</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-5-2-%E4%B8%B2%E6%B1%A0%EF%BC%9A%E6%8B%BC%E6%8E%A5%E5%8F%98%E9%87%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">5.5.2 串池：拼接变量字符串对象创建字符串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-5-3-%E4%B8%B2%E6%B1%A0%EF%BC%9A%E6%8B%BC%E6%8E%A5%E5%B8%B8%E9%87%8F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%96%B9%E6%B3%95%E5%88%9B%E5%BB%BA%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">5.5.3 串池：拼接常量字符串对象的方法创建字符串</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-5-4-%E4%B8%B2%E6%B1%A0%EF%BC%9Aintern-%E6%96%B9%E6%B3%95-JDK1-8"><span class="nav-text">5.5.4 串池：intern() 方法(JDK1.8)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BE%8B1"><span class="nav-text">例1</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BE%8B2"><span class="nav-text">例2</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BE%8B3"><span class="nav-text">例3</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-5-5-%E4%B8%B2%E6%B1%A0%E7%9A%84%E4%BD%8D%E7%BD%AE"><span class="nav-text">5.5.5 串池的位置</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-5-6-%E4%B8%B2%E6%B1%A0%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-text">5.5.6 串池的垃圾回收</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#5-5-7-%E4%B8%B2%E6%B1%A0%E7%9A%84%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98"><span class="nav-text">5.5.7 串池的性能调优</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98"><span class="nav-text">6. 直接内存</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-%E5%AE%9A%E4%B9%89"><span class="nav-text">6.1 定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-2-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8"><span class="nav-text">6.2 基本使用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-3-%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6%E5%8E%9F%E7%90%86"><span class="nav-text">6.3 分配和回收原理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#allocateDirect-%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%BA%95%E5%B1%82%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-text">allocateDirect() 的实现底层源码分析</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%89%E3%80%81JVM-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6"><span class="nav-text">三、JVM 垃圾回收</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#0-%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9%E5%A4%A7%E7%BA%B2"><span class="nav-text">0 主要内容大纲</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E8%A2%AB%E5%9B%9E%E6%94%B6"><span class="nav-text">1 如何判断对象可以被回收</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%B3%95"><span class="nav-text">1.1 引用计数法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95"><span class="nav-text">1.2 可达性分析算法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-%E4%BA%94%E7%A7%8D%E5%BC%95%E7%94%A8"><span class="nav-text">1.3 五种引用</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-1-%E5%BC%BA%E5%BC%95%E7%94%A8"><span class="nav-text">1.3.1 强引用</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-2-%E8%BD%AF%E5%BC%95%E7%94%A8-Soft-Reference"><span class="nav-text">1.3.2 软引用 (Soft Reference)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-3-%E5%BC%B1%E5%BC%95%E7%94%A8-Weak-Referrnce"><span class="nav-text">1.3.3 弱引用 (Weak Referrnce)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-4-%E8%99%9A%E5%BC%95%E7%94%A8-Phantom-Reference"><span class="nav-text">1.3.4 虚引用 (Phantom Reference)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#1-3-5-%E7%BB%88%E7%BB%93%E5%99%A8%E5%BC%95%E7%94%A8-Finalize-Reference"><span class="nav-text">1.3.5 终结器引用 (Finalize Reference)</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95"><span class="nav-text">2 垃圾回收算法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4-%E7%AE%97%E6%B3%95-Mark-Sweep"><span class="nav-text">2.1 标记 - 清除 算法 (Mark - Sweep)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86-%E7%AE%97%E6%B3%95-Mark-Compact"><span class="nav-text">2.2 标记 - 整理 算法 (Mark - Compact)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-%E5%A4%8D%E5%88%B6-%E7%AE%97%E6%B3%95-Copy"><span class="nav-text">2.3 复制 算法 (Copy)</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-%E6%80%BB%E7%BB%93"><span class="nav-text">2.4 总结</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6"><span class="nav-text">3 分代垃圾回收机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-%E5%88%86%E4%BB%A3%E5%9B%9E%E6%94%B6%E6%B5%81%E7%A8%8B"><span class="nav-text">3.1 分代回收流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-%E7%9B%B8%E5%85%B3%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%82%E6%95%B0"><span class="nav-text">3.2 相关虚拟机参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-GC%E5%88%86%E6%9E%90"><span class="nav-text">3.3  GC分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-1-%E5%A4%A7%E5%AF%B9%E8%B1%A1%E5%A4%84%E7%90%86%E7%AD%96%E7%95%A5"><span class="nav-text">3.3.1 大对象处理策略</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#3-3-2-%E7%BA%BF%E7%A8%8B%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA"><span class="nav-text">3.3.2 线程内存溢出</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-text">4 垃圾回收器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-0-%E6%A6%82%E8%BF%B0"><span class="nav-text">4.0 概述</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-%E4%B8%B2%E8%A1%8C%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-text">4.1 串行垃圾回收器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-%E5%90%9E%E5%90%90%E9%87%8F%E4%BC%98%E5%85%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-text">4.2 吞吐量优先垃圾回收器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4%E4%BC%98%E5%85%88%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-text">4.3 响应时间优先垃圾回收器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-G1-Garbage-First-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8"><span class="nav-text">4.4 G1 (Garbage First) 垃圾回收器</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-1-G1-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E9%98%B6%E6%AE%B5"><span class="nav-text">4.4.1 G1 垃圾回收阶段</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-2-Young-Collection"><span class="nav-text">4.4.2 Young Collection</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-3-Young-Collection-Concurrent-Mark"><span class="nav-text">4.4.3 Young Collection + Concurrent Mark</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-4-Mixed-Collection"><span class="nav-text">4.4.4 Mixed Collection</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-5-Full-GC"><span class="nav-text">4.4.5 Full GC</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#4-4-6-Young-Collection-%E7%9A%84%E8%B7%A8%E4%BB%A3%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98"><span class="nav-text">4.4.6 Young Collection 的跨代引用问题</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9B%9B%E3%80%81%E7%B1%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E5%AD%97%E8%8A%82%E7%A0%81%E6%8A%80%E6%9C%AF"><span class="nav-text">四、类加载与字节码技术</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#0-%E4%B8%BB%E8%A6%81%E5%86%85%E5%AE%B9%E5%A4%A7%E7%BA%B2-1"><span class="nav-text">0 主要内容大纲</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84"><span class="nav-text">1 类文件结构</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-1-%E9%AD%94%E6%95%B0-Magic"><span class="nav-text">1.1 魔数 Magic</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-2-%E7%89%88%E6%9C%AC-Version"><span class="nav-text">1.2 版本 Version</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-3-%E5%B8%B8%E9%87%8F%E6%B1%A0-Constant-Pool"><span class="nav-text">1.3 常量池 Constant Pool</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-4-%E8%AE%BF%E9%97%AE%E6%A0%87%E8%AF%86%E4%B8%8E%E7%BB%A7%E6%89%BF%E4%BF%A1%E6%81%AF"><span class="nav-text">1.4 访问标识与继承信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-5-%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F-Field"><span class="nav-text">1.5 成员变量 Field</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-6-%E6%96%B9%E6%B3%95-Method"><span class="nav-text">1.6 方法 Method</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#1-7-%E5%B1%9E%E6%80%A7-Attribute"><span class="nav-text">1.7 属性 Attribute</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-%E5%AD%97%E8%8A%82%E7%A0%81%E6%8C%87%E4%BB%A4"><span class="nav-text">2 字节码指令</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-%E5%85%A5%E9%97%A8"><span class="nav-text">2.1 入门</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-2-javap-%E5%B7%A5%E5%85%B7"><span class="nav-text">2.2 javap 工具</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-%E5%9B%BE%E8%A7%A3%E6%96%B9%E6%B3%95%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B"><span class="nav-text">2.3 图解方法执行流程</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-1-%E5%8E%9F%E5%A7%8B-Java-%E4%BB%A3%E7%A0%81"><span class="nav-text">2.3.1 原始 Java 代码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-2-%E7%BC%96%E8%AF%91%E5%90%8E%E7%9A%84%E5%AD%97%E8%8A%82%E7%A0%81%E6%96%87%E4%BB%B6"><span class="nav-text">2.3.2 编译后的字节码文件</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-3-%E5%B8%B8%E9%87%8F%E6%B1%A0%E8%BD%BD%E5%85%A5-%E2%80%9C%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0%E2%80%9D"><span class="nav-text">2.3.3 常量池载入 “运行时常量池”</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-4-%E6%96%B9%E6%B3%95%E5%AD%97%E8%8A%82%E7%A0%81%E8%BD%BD%E5%85%A5%E6%96%B9%E6%B3%95%E5%8C%BA"><span class="nav-text">2.3.4 方法字节码载入方法区</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-3-5-%E4%B8%BB%E7%BA%BF%E7%A8%8B%E5%BC%80%E5%A7%8B%E8%BF%90%E8%A1%8C%EF%BC%8C%E5%88%86%E9%85%8D%E6%A0%88%E5%B8%A7%E5%86%85%E5%AD%98"><span class="nav-text">2.3.5 主线程开始运行，分配栈帧内存</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#bipush-10"><span class="nav-text">bipush 10</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#istore-1"><span class="nav-text">istore 1</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#ldc-3"><span class="nav-text">ldc #3</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#istore-2"><span class="nav-text">istore 2</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#iload-1"><span class="nav-text">iload 1</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#iload-2"><span class="nav-text">iload 2</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#iadd"><span class="nav-text">iadd</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#istore-3"><span class="nav-text">istore 3</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#getstatic-4"><span class="nav-text">getstatic #4</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#iload-3"><span class="nav-text">iload 3</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#invokevirtual-5"><span class="nav-text">invokevirtual #5</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#return"><span class="nav-text">return</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-4-%E4%BB%8E%E5%AD%97%E8%8A%82%E7%A0%81%E8%A7%92%E5%BA%A6%E5%88%86%E6%9E%90-i-%E4%B8%8E-i"><span class="nav-text">2.4 从字节码角度分析 i++ 与 ++i</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-5-%E6%9D%A1%E4%BB%B6%E5%88%A4%E6%96%AD%E6%8C%87%E4%BB%A4"><span class="nav-text">2.5 条件判断指令</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-6-%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95"><span class="nav-text">2.6 构造方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-6-1-lt-clinit-gt-V"><span class="nav-text">2.6.1 &lt;clinit&gt;()V</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-6-2-lt-init-gt-V"><span class="nav-text">2.6.2 &lt;init&gt;()V</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-7-%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8"><span class="nav-text">2.7 方法的调用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-8-%E5%A4%9A%E6%80%81%E7%9A%84%E5%8E%9F%E7%90%86"><span class="nav-text">2.8 多态的原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-9-%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8"><span class="nav-text">2.9 处理异常</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#2-9-1-%E5%8D%95-try-catch-%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-text">2.9.1 单 try-catch 代码块</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-9-2-%E5%8D%95-try-%E5%A4%9A-catch-%E4%BB%A3%E7%A0%81%E5%9D%97-%EF%BC%88%E4%B8%80%EF%BC%89"><span class="nav-text">2.9.2 单 try 多 catch 代码块 （一）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-9-3-%E5%8D%95-try-%E5%A4%9A-catch-%E4%BB%A3%E7%A0%81%E5%9D%97-%EF%BC%88%E4%BA%8C%EF%BC%89"><span class="nav-text">2.9.3 单 try 多 catch 代码块 （二）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-9-4-finally-%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="nav-text">2.9.4 finally 代码块</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#2-9-5-finally-%E5%9D%97%E4%B8%AD%E8%BF%94%E5%9B%9E%E5%80%BC%E7%9A%84%E9%97%AE%E9%A2%98"><span class="nav-text">2.9.5 finally 块中返回值的问题</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-10-synchronized-%E4%BB%A3%E7%A0%81%E5%9D%97%E5%88%86%E6%9E%90"><span class="nav-text">2.10 synchronized 代码块分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-%E7%BC%96%E8%AF%91%E6%9C%9F%E5%A4%84%E7%90%86"><span class="nav-text">3 编译期处理</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#3-1-%E9%BB%98%E8%AE%A4%E6%9E%84%E9%80%A0%E5%99%A8"><span class="nav-text">3.1 默认构造器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-2-%E8%87%AA%E5%8A%A8%E6%8B%86%E8%A3%85%E7%AE%B1"><span class="nav-text">3.2 自动拆装箱</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-3-%E8%8C%83%E5%9E%8B%E9%9B%86%E5%90%88%E5%8F%96%E5%80%BC"><span class="nav-text">3.3 范型集合取值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-4-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="nav-text">3.4 可变参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-5-foreach-%E5%BE%AA%E7%8E%AF"><span class="nav-text">3.5 foreach 循环</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-6-switch-%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-text">3.6 switch 字符串</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-7-switch-%E6%9E%9A%E4%B8%BE"><span class="nav-text">3.7 switch 枚举</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E9%98%B6%E6%AE%B5"><span class="nav-text">4 类加载阶段</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#4-1-%E5%8A%A0%E8%BD%BD"><span class="nav-text">4.1 加载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-2-%E9%93%BE%E6%8E%A5"><span class="nav-text">4.2 链接</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1-%E9%AA%8C%E8%AF%81"><span class="nav-text">(1) 验证</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2-%E5%87%86%E5%A4%87"><span class="nav-text">(2) 准备</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#3-%E8%A7%A3%E6%9E%90"><span class="nav-text">(3) 解析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-3-%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="nav-text">4.3 初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-4-%E7%BB%83%E4%B9%A0"><span class="nav-text">4.4 练习</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#1"><span class="nav-text">(1)</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#2"><span class="nav-text">(2)</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-text">5 类加载器</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-Bootstrap-ClassLoader"><span class="nav-text">5.1 Bootstrap ClassLoader</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-Extension-ClassLoader"><span class="nav-text">5.2 Extension ClassLoader</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-3-%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%BC%8F"><span class="nav-text">5.3 双亲委派模式</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-text">源码分析</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-4-%E7%BA%BF%E7%A8%8B%E4%B8%8A%E4%B8%8B%E6%96%87%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-text">5.4 线程上下文类加载器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-5-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="nav-text">5.5 自定义类加载器</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-%E8%BF%90%E8%A1%8C%E6%9C%9F%E4%BC%98%E5%8C%96"><span class="nav-text">6 运行期优化</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-%E5%8D%B3%E6%97%B6%E7%BC%96%E8%AF%91"><span class="nav-text">6.1 即时编译</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E5%B1%82%E7%BC%96%E8%AF%91"><span class="nav-text">分层编译</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%96%B9%E6%B3%95%E5%86%85%E8%81%94-Inlining"><span class="nav-text">方法内联 (Inlining)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#JMH"><span class="nav-text">JMH</span></a></li></ol></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BA%94%E3%80%81JMM-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B"><span class="nav-text">五、JMM 内存模型</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Guohao</p>
  <div class="site-description" itemprop="description">间歇性踌躇满志, 持续性划水摸鱼</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Guohao</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">319k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">4:50</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>



        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  













<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : '[object Object]',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
