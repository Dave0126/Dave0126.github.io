<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.1.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"dave0126.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"mac"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Transition System(变迁系统) 与 TLA+概述本文章是根据法国国立高等电力技术、电子学、计算机、水力学与电信学校 (E.N.S.E.E.I.H.T.) 第八学期课程“Système de Transition”总结而来的课程笔记。碍于本人学识有限，部分叙述难免存在纰漏，请读者注意甄别。 参考：  系统分析与验证 - Campsisgrandiflora的博客  《 Introdu">
<meta property="og:type" content="article">
<meta property="og:title" content="Transition System(变迁系统) 与 TLA+">
<meta property="og:url" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/index.html">
<meta property="og:site_name" content="Lost N Found">
<meta property="og:description" content="Transition System(变迁系统) 与 TLA+概述本文章是根据法国国立高等电力技术、电子学、计算机、水力学与电信学校 (E.N.S.E.E.I.H.T.) 第八学期课程“Système de Transition”总结而来的课程笔记。碍于本人学识有限，部分叙述难免存在纰漏，请读者注意甄别。 参考：  系统分析与验证 - Campsisgrandiflora的博客  《 Introdu">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29%2013.16.51-8552669.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/20201127224956365.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29%2013.16.51-8552669.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29%2013.28.06-8553323.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29%2013.48.33-8554538.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29%2015.18.04.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29%2015.19.07-8559976.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29%2016.53.51-8565663.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29%2017.02.57.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29%2017.55.30.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30%2020.56.29.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30%2021.14.36.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30%2021.16.51.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30%2021.18.02.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30%2021.22.31.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30%2021.23.35.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30%2021.42.35.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30%2021.16.51-8669562.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30%2021.42.56.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30%2021.43.21.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30%2023.53.48.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/20201118212040185.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/20201118212152854.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/20201120223125939.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03%2012.10.42.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03%2012.23.47.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03%2014.11.29.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03%2014.11.29.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03%2014.45.46.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03%2014.11.29.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03%2015.06.04.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03%2012.23.47.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/20201126194333746.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/20201126192818563.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03%2016.06.08.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03%2017.18.20.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03%2017.34.49.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03%2017.18.20.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03%2022.03.52.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03%2022.11.22.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03%2022.19.49.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/20201209125629367.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-04%2022.04.31.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-04%2022.10.01.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-04%2023.03.07.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-04%2023.07.21.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-04%2023.08.46.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-04%2023.08.46.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/20201209125629367.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2020121517502211.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/20201215203132106.png">
<meta property="og:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/20201215204837482.png">
<meta property="article:published_time" content="2022-03-29T08:59:58.000Z">
<meta property="article:modified_time" content="2022-06-14T12:50:38.697Z">
<meta property="article:author" content="Guohao">
<meta property="article:tag" content="课程笔记">
<meta property="article:tag" content="系统">
<meta property="article:tag" content="TLA+">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29%2013.16.51-8552669.png">

<link rel="canonical" href="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Transition System(变迁系统) 与 TLA+ | Lost N Found</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Lost N Found" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Lost N Found</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/Dave0126" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Guohao">
      <meta itemprop="description" content="间歇性踌躇满志, 持续性划水摸鱼">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Lost N Found">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Transition System(变迁系统) 与 TLA+
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-03-29 10:59:58" itemprop="dateCreated datePublished" datetime="2022-03-29T10:59:58+02:00">2022-03-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-06-14 14:50:38" itemprop="dateModified" datetime="2022-06-14T14:50:38+02:00">2022-06-14</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" itemprop="url" rel="index"><span itemprop="name">课程笔记</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>42k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>39 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="Transition-System-变迁系统-与-TLA"><a href="#Transition-System-变迁系统-与-TLA" class="headerlink" title="Transition System(变迁系统) 与 TLA+"></a>Transition System(变迁系统) 与 TLA+</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p><a href="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/">本文章</a>是根据法国国立高等电力技术、电子学、计算机、水力学与电信学校 (E.N.S.E.E.I.H.T.) 第八学期课程“Système de Transition”总结而来的课程笔记。碍于本人学识有限，部分叙述难免存在纰漏，请读者注意甄别。</p>
<p>参考：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/campsisgrandiflora/category_10509594.html">系统分析与验证 - Campsisgrandiflora的博客</a> </li>
<li>《 Introduction to TLA 》- Lesie Lamport</li>
</ul>
<span id="more"></span>
<h4 id="变迁系统"><a href="#变迁系统" class="headerlink" title="变迁系统"></a>变迁系统</h4><p>在计算机科学和控制理论中，“变迁系统”用数学的方法描述离散系统的行为。变迁系统主要由“状态”和状态之间的“状态迁移”组成。 有标号的变迁系统可以从已定义的标签集合中选择相应标签来标记状态迁移，而且相同的标签可能被应用在多个状态迁移上。 变迁系统也可以是无标记的，此时也可以认为标签集合中只有单一标签元素，从而省略了状态迁移上的标签记号。</p>
<p>变迁系统在数学定义上和<strong>有向图</strong>一致，但与<strong>有限状态自动机</strong>有一定不同。</p>
<p>变迁系统的特点有：</p>
<ul>
<li>系统状态的集合不一定是有限的或可数的；</li>
<li>状态迁移的集合不一定是有限的或可数的；</li>
<li>变迁系统并不需要给出“开始”状态或“最终”状态；</li>
<li>变迁系统可以表示为<strong>有向图</strong>，有限状态自动机则不能。</li>
</ul>
<p>资料来源于<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F">维基百科：变迁系统</a></p>
<h4 id="TLA"><a href="#TLA" class="headerlink" title="TLA+"></a>TLA+</h4><h5 id="形式化验证"><a href="#形式化验证" class="headerlink" title="形式化验证"></a>形式化验证</h5><p>形式化验证技术想要解决的核心问题是：软件总是可能存在 Bug 的，而测试始终无法涵盖所有可能性，特别是对于并发系统及分布式系统来说，就算单元测试达到了 100% 分支覆盖率，也不能肯定的说这个系统在线程安全，一致性等方面不会出问题。那如何更好的来验证我们的程序是否符合预期呢？</p>
<p>形式化验证就旨在使用严谨的数学证明方法来证明某一算法是正确的。</p>
<h5 id="TLA-1"><a href="#TLA-1" class="headerlink" title="TLA+"></a>TLA+</h5><p><strong>T</strong>emporal <strong>L</strong>ogic of <strong>A</strong>ctions <strong>+</strong>是由<em>Leslie Lamport</em>开发的一种【形式化验证语言】。它用于设计、建模、记录和验证程序，尤其是并发系统和分布式系统。TLA +被描述为可完全测试的伪代码，其用途类似于为软件系统绘制蓝图。</p>
<p>由于 TLA+ 写的代码并不是用来实际运行的，故一般将其代码称为模型（Model）而非程序（Program）。</p>
<h4 id="学习资源"><a href="#学习资源" class="headerlink" title="学习资源"></a>学习资源</h4><ol>
<li><a target="_blank" rel="noopener" href="https://learntla.com/">Learn TLA+</a></li>
<li><a target="_blank" rel="noopener" href="https://lamport.azurewebsites.net/video/videos.html">L. Lamport 关于TLA+的视频</a></li>
<li><a target="_blank" rel="noopener" href="https://lamport.azurewebsites.net/tla/tla.html">其他资源</a></li>
</ol>
<h3 id="第一部分：Transition-System"><a href="#第一部分：Transition-System" class="headerlink" title="第一部分：Transition System"></a>第一部分：Transition System</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><h5 id="变迁系统-1"><a href="#变迁系统-1" class="headerlink" title="变迁系统"></a>变迁系统</h5><p>Transition System在计算机科学中通常用作描述系统行为的模型，它是一种有向图，节点代表状态，边代表着状态的转化。</p>
<p>状态（state）描述了系统在其行为的特定时刻的一些信息。<br>例如，交通灯的状态指示灯的当前颜色。类似地，顺序计算机程序的状态指示所有程序变量的当前值，以及指示要执行的下一个程序语句的程序计数器的当前值。</p>
<p>转变（transition）指定系统如何从一种状态演变为另一种状态。<br>对交通信号灯来说，转换表示从一种颜色切换到另一种颜色。而对于顺序程序，转换通常对应于语句的执行，并且可能涉及某些变量和程序计数器的更改。</p>
<p>下面给出一种Transition System（TS）的定义</p>
<p>变迁系统是一个三元组$⟨S,I,R⟩$:</p>
<ul>
<li>$S$ 是状态集。包含 <strong>终结状态</strong> 和 <strong>非终结状态</strong></li>
<li>$I \subseteq S$ 是一个 <strong>初始状态</strong></li>
<li>$R \subseteq S \times S$ 是状态对之间的（转换）关系。$(s,s’) \in R$ 表示系统从状态 $s$ 到状态$s’$ 的转换。我们假定 $s$ 表示现在时刻的状态集合， $s$ 中的变量称为现态， $s’$ 表示发生转变之后的状态集合， $s’$ 中的变量称为次态。</li>
</ul>
<p>例：</p>
<script type="math/tex; mode=display">S = {S_0, S_1, S_2, S_3,S_4}</script><script type="math/tex; mode=display">I = {S_0}</script><script type="math/tex; mode=display">R = \{(S_0,S_0), (S_0,S_1), (S_0,S_2), (S_2,S_3), (S_3,S_4), (S_4,S_3)\}</script><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29 13.16.51-8552669.png" alt="2022-03-29 13.16.51" style="zoom:67%;"></p>
<h6 id="直接后继（Direct-Successors）"><a href="#直接后继（Direct-Successors）" class="headerlink" title="直接后继（Direct Successors）"></a>直接后继（Direct Successors）</h6><p>定义为：</p>
<script type="math/tex; mode=display">
Post(s,α)=\{s'∈S | s\xrightarrow{α}s' \}</script><p>就是指状态$s$执行动作$α$之后能达到的状态的集合</p>
<p>如果α为任意动作，可以记为：</p>
<script type="math/tex; mode=display">
Post(s)=\bigcup_{α∈Act}Post(s,α)</script><h6 id="直接前任（Direct-Predecessors）"><a href="#直接前任（Direct-Predecessors）" class="headerlink" title="直接前任（Direct Predecessors）"></a>直接前任（Direct Predecessors）</h6><script type="math/tex; mode=display">
Pre(s, α) =\{s'∈S|s'\xrightarrow{α}s\}</script><p>指通过执行动作α之后能达到状态s的状态集合</p>
<p>同理，α如果为任意动作，则记为：</p>
<script type="math/tex; mode=display">
Pre(s)=\bigcup_{α∈Act}Pre(s,α)</script><p>用图来表示前任和后继的话就是这样子的：</p>
<p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/20201127224956365.png" alt="20201127224956365" style="zoom:50%;"></p>
<h6 id="终止状态"><a href="#终止状态" class="headerlink" title="终止状态"></a>终止状态</h6><p>对于TS模型来说，终止状态就是指没有后继状态的状态，即$Post(s)=\varnothing$</p>
<p>串行程序的终止状态代表着程序的终止。</p>
<p>对于并行程序来说，我们一般不考虑它的终止状态，因为并行程序大都要求持续运行下去。</p>
<h6 id="确定性TS（Deterministic-Transition-System）"><a href="#确定性TS（Deterministic-Transition-System）" class="headerlink" title="确定性TS（Deterministic Transition System）"></a>确定性TS（Deterministic Transition System）</h6><p>如果</p>
<script type="math/tex; mode=display">
|S_{0}|≤1\;and\;|Post(s,α)|≤1</script><p>那么这个TS就可以称为动作确定的TS</p>
<p>如果</p>
<script type="math/tex; mode=display">
|S_{0}|≤1\;and\;|Post(s,α)\cap \{s'∈S|L(s')=A\}|≤1(A∈2^{AP})</script><p>那么这个TS就可以称为AP确定的TS</p>
<h5 id="序列（Sequence）"><a href="#序列（Sequence）" class="headerlink" title="序列（Séquence）"></a>序列（Séquence）</h5><p>$S$ 是状态集：</p>
<ul>
<li>$S^<em>$ 是 $S$ 上的<em>*有限序列集</em></em>；</li>
<li>$S^w$ 是 $S$ 上的<strong>无限数据集</strong>；</li>
<li>$\sigma _i$ 是序列 $\sigma$ 从 0 开始的第 $i$个元素。</li>
<li>序列 $S$ 用以下形式表示：$⟨s1 → s2 → …⟩$</li>
<li>$⟨⟩$ 表示空序列；</li>
</ul>
<p>对于一个有限序列$\sigma$ ：</p>
<ul>
<li>$\sigma^<em>$ 是由任意的 $\sigma $ 重复产生的<em>*有限序列集</em></em>。</li>
<li>$\sigma^+ \triangleq \sigma^* \backslash \{ ⟨⟩ \}$</li>
<li>$\sigma^w$  是由任意的 $\sigma $ 重复产生的无限序列集。</li>
</ul>
<h5 id="迹（trace）"><a href="#迹（trace）" class="headerlink" title="迹（trace）"></a>迹（trace）</h5><h6 id="有限轨迹（Traces-finies）"><a href="#有限轨迹（Traces-finies）" class="headerlink" title="有限轨迹（Traces finies）"></a>有限轨迹（Traces finies）</h6><p>令 $⟨S, I, R⟩$ 是一个变迁系统。我们称有限迹为有限序列$\sigma \in S^*$ 使得</p>
<ul>
<li><p>$\sigma = ⟨s_0 → s_1 → … → s_{n-1} → s_n ⟩$</p>
</li>
<li><p>$\forall i \in [0 … n[:(s_i, s_{i-1}) \in R$</p>
</li>
</ul>
<h6 id="最大有限轨迹（Traces-finies-maximales）"><a href="#最大有限轨迹（Traces-finies-maximales）" class="headerlink" title="最大有限轨迹（Traces finies maximales）"></a>最大有限轨迹（Traces finies maximales）</h6><p>当有限轨迹$⟨s_0 → s_1 → … → s_{n-1} → s_n ⟩ \in S^*$ 时，我们称它是最大的。$s_n$没有后继状态，即$\forall s \in S:(s_n, s) \notin R$</p>
<h6 id="无限轨迹（Trace-infinies）"><a href="#无限轨迹（Trace-infinies）" class="headerlink" title="无限轨迹（Trace infinies）"></a>无限轨迹（Trace infinies）</h6><p>令 $⟨S, I, R⟩$ 是一个变迁系统，并且$s_0 \in S$。我们称从 $s_0$开始到元素 $tr \in S^w$ 的无限序列为</p>
<ul>
<li><p>$tr = ⟨s_0 → s_1 → s_2 → … ⟩$</p>
</li>
<li><p>$\forall i \in \mathbb{N}:(s_i, s_{i+1}) \in R$</p>
</li>
</ul>
<h6 id="来自状态的轨迹（Traces-issues-d’un-etat）"><a href="#来自状态的轨迹（Traces-issues-d’un-etat）" class="headerlink" title="来自状态的轨迹（Traces issues d’un état）"></a>来自状态的轨迹（Traces issues d’un état）</h6><p>令 $⟨S, I, R⟩$ 是一个变迁系统，并且$s \in S$。</p>
<ul>
<li>$Traces(s) $ 是从状态$s$ 开始的最大无限或有限轨迹的集合。</li>
</ul>
<h5 id="执行（Executions）"><a href="#执行（Executions）" class="headerlink" title="执行（Exécutions）"></a>执行（Exécutions）</h5><p>令 $⟨S, I, R⟩$ 是一个变迁系统，</p>
<p>一次执行片段 $σ = ⟨s_0 →…⟩ $ 是满足 $s_0 ∈ I $ 的最大无限或有限轨迹（如果是有限执行片段，那么它结束于终止状态，或者该片段是一个无限执行片段）。</p>
<ul>
<li>$Exec(S)$ 是 $S = \bigcup_{s_0 \in I} Traces(s_0)$ 的执行集。</li>
<li>如果 $I = ∅$，则我们有一个（也是唯一一个）空执行$ ⟨⟩$。</li>
<li>如果一个初始、有限执行片段的终止状态为s，那么s称为<strong>可达的</strong>(reachable)，直观来说，可达表示从初始状态开始能够到达某个状态。我们把所有的可达状态记为<strong>Reach(TS)</strong></li>
</ul>
<h5 id="练习一"><a href="#练习一" class="headerlink" title="练习一"></a>练习一</h5><h6 id="例一"><a href="#例一" class="headerlink" title="例一"></a>例一</h6><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29 13.16.51-8552669.png" alt="2022-03-29 13.16.51" style="zoom:67%;"></p>
<p>$s_0 → s_0 → s_2 → s_3$ 是一段非最大的有限轨迹。</p>
<ol>
<li>$Traces(s_1) = ⟨s_1⟩$</li>
<li>$Traces(s_3) = ⟨(s_3 → s_4)^w⟩$</li>
<li>$Traces(s_2) = ⟨s_2 → (s_3 → s_4)^w⟩$</li>
<li>$Traces(s_0) = ⟨{s_0}^w⟩, ⟨{s_0}^+ → s_1⟩, ⟨s_0 → s_2 → (s_3 → s_4)^w⟩$</li>
<li>$Exec(S) = Traces(s_0)$</li>
</ol>
<h6 id="例二"><a href="#例二" class="headerlink" title="例二"></a>例二</h6><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29 13.28.06-8553323.png" alt="2022-03-29 13.28.06" style="zoom:67%;"></p>
<ol>
<li>$Traces(s_2) = ⟨s_2 → s_4⟩, ⟨(s_2 → s_3 → s_0 → s_1)^w⟩, ⟨(s_2 → s_3 → s_0 → s_1)^* → s_2 → s_4⟩$</li>
<li>$Traces(s_0) = ⟨(s_0 → s_1 → s_2 → s_3⟩^w, ⟨s_0 → s_1 → (s_2 → s_3 → s_0 → s_1)^* → s_2 → s_4⟩$</li>
<li>$Exec(S) = Traces(s_0)$</li>
</ol>
<h6 id="例三"><a href="#例三" class="headerlink" title="例三"></a>例三</h6><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29 13.48.33-8554538.png" alt="2022-03-29 13.48.33" style="zoom:67%;"></p>
<ol>
<li>$Traces(s_2) = ⟨(s_2 → s_3)^w⟩, ⟨(s_2 → s_3)^* → s_2 → s_4⟩$</li>
<li>$Traces(s_0) = ⟨(s_0 → (s_2 → s_3)^w⟩, ⟨(s_0 → (s_2 → s_3)^* → s_2 → s_4⟩$</li>
<li>$Traces(s_1) = ⟨(s_1 → (s_3 → s_2)^w⟩, ⟨(s_1 → (s_3 → s_2)^+ → s_4⟩$</li>
<li>$Exec(S) = Traces(s_0) \cup Traces(s_1)$</li>
</ol>
<h5 id="可访问状态（Etats-accessibles）"><a href="#可访问状态（Etats-accessibles）" class="headerlink" title="可访问状态（Etats accessibles）"></a>可访问状态（Etats accessibles）</h5><p>令 $⟨S, I, R⟩$ 是一个变迁系统。</p>
<ul>
<li>$s ∈ S$ 是一个可访问状态 $\triangleq $ 有一个通过 $s$ 的执行（或等价的，有一个以 $s$ 结尾的执行前缀）;</li>
<li>$Acc(S)$ 是 $S$ 的可访问状态集。</li>
</ul>
<h5 id="执行图（Graphe-des-Executions）"><a href="#执行图（Graphe-des-Executions）" class="headerlink" title="执行图（Graphe des Exécutions）"></a>执行图（Graphe des Exécutions）</h5><p>令 $⟨S, I, R⟩$ 是一个变迁系统。</p>
<p>执行图是有向图，其中：</p>
<ul>
<li>顶点集是 $Acc(S)$；</li>
<li>有向边的集合是 $R$，仅限于可访问状态。</li>
</ul>
<p>因此它是$ ⟨S ∩ Acc(S), R ∩ (Acc(S) × Acc(S))⟩ $ 的图。</p>
<h5 id="被标记的变迁系统（Systeme-de-Transitions-etiquete-）"><a href="#被标记的变迁系统（Systeme-de-Transitions-etiquete-）" class="headerlink" title="被标记的变迁系统（Systeme de Transitions étiqueté ）"></a>被标记的变迁系统（Systeme de Transitions étiqueté ）</h5><p>被标记的变迁系统 是一个五元组$⟨S、I、R、L、Etiq⟩$：</p>
<ul>
<li>$S$：状态集。</li>
<li>$I ⊆ S$：初始状态集。</li>
<li>$R ⊆ S × S$：状态对之间的转换关系。</li>
<li>$L$：标签集。</li>
<li>$Etiq$：将标签与每个转换(transition) 相关联的函数：$Etiq ∈ R → L$。带</li>
</ul>
<p>被标记的变迁系统 非常接近自动机。但是没有 terminal state + infinity execution。</p>
<p>被标记的变迁系统 $⟨S, I, R, L, Etiq⟩$ <strong>等价于</strong>由如下定义的 未标记系统$⟨S’, I’, R’⟩$ ：</p>
<ul>
<li>$S’ = (L \cup \{ \epsilon \}) \times S$</li>
<li>$I’ = \{ \epsilon \} \times I$</li>
<li>$R’ = \{ ( ⟨I,s⟩, ⟨I’,s’⟩ )| (s, s’) \in R \land I’ = Etiq(s,s’)\}$</li>
</ul>
<p>转换(transition) $s_1 \xrightarrow{a} s_2 $ 可变成 $ ⟨$_$,s_1⟩ \to ⟨a,s_2⟩$，其中 _ 是任何标签。</p>
<p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29 15.18.04.png" alt="2022-03-29 15.18.04" style="zoom:50%;"></p>
<p>可变为</p>
<p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29 15.19.07-8559976.png" alt="2022-03-29 15.19.07" style="zoom:50%;"></p>
<h5 id="变迁系统-不等于-自动机"><a href="#变迁系统-不等于-自动机" class="headerlink" title="变迁系统 不等于 自动机"></a>变迁系统 不等于 自动机</h5><ul>
<li>转换没有标签：Pas d’étiquette sur les transitions (ou comme si)</li>
<li>转换不是由环境引起的：Une transition n’est pas causée par l’environnement</li>
<li>没有终结状态：Pas d’états terminaux</li>
<li>可能有许多的有限状态：Nombre d’états infini possible</li>
<li>可能有无限的执行：Exécution infinie possible</li>
</ul>
<h4 id="表示形式"><a href="#表示形式" class="headerlink" title="表示形式"></a>表示形式</h4><h5 id="显式的表示"><a href="#显式的表示" class="headerlink" title="显式的表示"></a>显式的表示</h5><p>在执行图(Graphe d’exécution) 中显式地给出，例如以图像形式或通过顶点和边的集合。仅适用于<strong>状态和转换数量有限</strong>的变迁系统。</p>
<h5 id="隐式的表示"><a href="#隐式的表示" class="headerlink" title="隐式的表示"></a>隐式的表示</h5><p>基于变量的变迁系统的三元组$ ⟨V, Init,Trans⟩ $ 中，</p>
<ul>
<li>$V = \{ v_1, …, v_n\}$：有限的的变量集；</li>
<li>$Init(v_1, …, v_n)$ ：定义初始状态并与变量 $v_i$ 相关的谓词（系数）</li>
<li>$Trans(v_1, …, v_n, {v_1}’, …, {v_n}’)$：谓词定义转换，涉及表示当前状态的变量 $v_i$ 和表示后续状态的变量 ${v_i}’$。</li>
</ul>
<h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><h6 id="有界计数器"><a href="#有界计数器" class="headerlink" title="有界计数器"></a>有界计数器</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; N) &#123;</span><br><span class="line">	i = i+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在显式的表示中，$N = 5$:</li>
</ol>
<script type="math/tex; mode=display">
⟨(0, 1, 2, 3, 4, 5), \{ 0\}, \{ (0,1), (1,2), (2,3), (3,4), (4,5)\}⟩</script><p>​    执行图(Graphe d’exécution)为</p>
<script type="math/tex; mode=display">
0 \to 1 \to 2 \to 3 \to 4 \to5</script><ol>
<li>隐式的表示为：</li>
</ol>
<ul>
<li>$V \triangleq i \in \mathbb{N}$</li>
<li>$Init \triangleq i = 0$</li>
<li>$Trans \triangleq i &lt; N \land i’ = i+1$ 或 $Trans \triangleq i’ \leq N \land i’-i=1$ </li>
</ul>
<h6 id="循环计数器"><a href="#循环计数器" class="headerlink" title="循环计数器"></a>循环计数器</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">	i = (i+<span class="number">1</span>) % N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在显式的表示中，$N = 4$:</li>
</ol>
<script type="math/tex; mode=display">
⟨(0, 1, 2, 3, 4), \{ 0\}, \{ (0,1), (1,2), (2,3), (3,4), (4,0)\}⟩</script><p>​    执行图(Graphe d’exécution)为</p>
<p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29 16.53.51-8565663.png" alt="2022-03-29 16.53.51" style="zoom:40%;"></p>
<ol>
<li>隐式的表示为：</li>
</ol>
<ul>
<li>$V \triangleq i \in \mathbb{N}$</li>
<li>$Init \triangleq i = 0$</li>
<li>$Trans \triangleq i’ = (i+1) \mod N $ </li>
</ul>
<h6 id="振荡整数"><a href="#振荡整数" class="headerlink" title="振荡整数"></a>振荡整数</h6><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">		i &gt; <span class="number">0</span> -&gt; i = i - <span class="number">1</span>;</span><br><span class="line">	or</span><br><span class="line">  	i &lt; N -&gt; i = i + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>在显式的表示中，$N = 5$:</li>
</ol>
<script type="math/tex; mode=display">
⟨(0, 1, 2, 3, 4, 5), \{ 0\}, \{ (0,1), (1,2), (2,3), (3,4), (4,5), (5,4), (4,3), (3,2), (2,1)\}⟩</script><p>​    执行图(Graphe d’exécution)为</p>
<p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29 17.02.57.png" alt="2022-03-29 17.02.57" style="zoom:40%;"></p>
<ol>
<li>隐式的表示为：</li>
</ol>
<ul>
<li>$V \triangleq i \in \mathbb{N}$</li>
<li>$Init \triangleq i = 0$</li>
<li>$Trans \triangleq (i &gt; 0 \land i’=i-1) \lor (i &lt; N \land i’=i+1) $ 或 $Trans \triangleq \left| i’ -i \right| = 1 \land 0 \leq i’ \leq N$</li>
</ul>
<h5 id="表示形式所对应的变迁系统"><a href="#表示形式所对应的变迁系统" class="headerlink" title="表示形式所对应的变迁系统"></a>表示形式所对应的变迁系统</h5><p>对于符号描述$⟨V, Init,Trans⟩$，对应的变迁系统是$⟨S, I, R⟩$，其中：</p>
<ul>
<li>$S = \prod_{i \in 1..n} D_i$ ，其中$D_1,…,D_n$ 是变量 $v_1, …, v_n$ 的域（类型）</li>
<li>$I = \{ (v_1,…,v_n) | Init(v_1, …, v_n)\}$</li>
<li>$R = \{ ((v_1, …, v_n),({v_1}’, …, {v_n}’)) | Trans(v_1, …, v_n,{v_1}’, …, {v_n}’)\}$</li>
</ul>
<h5 id="状态谓词（Predicat-d’etat）"><a href="#状态谓词（Predicat-d’etat）" class="headerlink" title="状态谓词（Prédicat d’état）"></a>状态谓词（Prédicat d’état）</h5><p>状态谓词是与隐式表示的系统的（状态）变量有关的谓词。</p>
<p>状态谓词可以看作是 S 的一部分的特征函数。</p>
<h5 id="转换谓词（Predicat-de-transition）"><a href="#转换谓词（Predicat-de-transition）" class="headerlink" title="转换谓词（Prédicat de transition）"></a>转换谓词（Prédicat de transition）</h5><p>转换谓词是与已启动和未启动（状态）变量相关的谓词。</p>
<p>转换谓词可以看作是 $S × S$ 子集的特征函数。</p>
<h5 id="实例：谓词"><a href="#实例：谓词" class="headerlink" title="实例：谓词"></a>实例：谓词</h5><p>$V \triangleq n \in \mathbb{N} $ </p>
<p>$Init \triangleq -5 \leq n \leq 5$</p>
<p>$Trans \triangleq n \neq 1 \land ((n’ = n/2 \land n \equiv 0[2]) \lor (n’ = (3n+1)/2 \land n \equiv 1[2]))$</p>
<ul>
<li><p>Prédicat d’état : $ Init, n &lt; 20 $</p>
</li>
<li><p>Prédicat de transition : $Trans, n’ − n &gt; 3$</p>
</li>
</ul>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><h5 id="阻塞（Blocage）"><a href="#阻塞（Blocage）" class="headerlink" title="阻塞（Blocage）"></a>阻塞（Blocage）</h5><h6 id="死锁（Interblocage）"><a href="#死锁（Interblocage）" class="headerlink" title="死锁（Interblocage）"></a>死锁（Interblocage）</h6><p>一个系统有一个死锁  $\triangleq$  存在一个可访问的状态，没有关系 R 的后继。等效地，如果执行（execution）有限，系统就会出现死锁。</p>
<p>对于建模经典顺序程序的系统，死锁相当于终止。</p>
<h5 id="可复位（Reinitialisable）"><a href="#可复位（Reinitialisable）" class="headerlink" title="可复位（Réinitialisable）"></a>可复位（Réinitialisable）</h5><p>一个系统可以从任何可访问的状态重置  $\triangleq$  有一个有限轨迹导致一个初始状态。</p>
<p>这个属性意味着在任何时候，都有一系列的转换（transitions）返回到系统的初始状态，从而重新启动。 这样的系统只有无限的执行。</p>
<h5 id="重复（Begaiement）"><a href="#重复（Begaiement）" class="headerlink" title="重复（Bégaiement）"></a>重复（Bégaiement）</h5><p>重复状态  $\triangleq$  状态有一个循环：$(s,s) ∈ R$。</p>
<p>一个重复变迁系统  $\triangleq$  任何状态都有一个到自身的循环：$Id ⊆ R$。</p>
<p><strong>用处</strong></p>
<ol>
<li>我们可以在 $s_0$ 中停留任意时间后进入 $s_1$。</li>
</ol>
<p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-29 17.55.30.png" alt="2022-03-29 17.55.30" style="zoom:50%;"></p>
<ol>
<li>无限的执行：在无重复系统中，任何没有后继者的状态都有一个独特的后继者：它自己。</li>
<li>终止状态时（或死锁）$… \to s_i$  就相当于  $… \to {s_i}^w$</li>
<li>可以组成几个变迁系统。</li>
</ol>
<h4 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h4><h5 id="自由组合"><a href="#自由组合" class="headerlink" title="自由组合"></a>自由组合</h5><p>变迁系统 $⟨V,I,T⟩$  由带有重复的 $⟨V_1, I_1,T_1⟩$ 和 $⟨V_2, I_2, T_2⟩ $ 组成， 其中：</p>
<ul>
<li>$V \triangleq V_1 \cup V_2$ ：变量$V_1$和$V_2$的并集</li>
<li>$I \triangleq I_1 \land I_2$ ：每个子系统都从它的一个初始状态开始</li>
<li>$ T \triangleq T_1 ∧ T_2 $ ：每个子系统都根据其转换（transition）演变</li>
</ul>
<p>由于 $T_1$ 和 $T_2$ 中有循环的状态，因此 $T_1 ∧ T_2$ 意味着我们可以单独执行 $T_1$ 的转换和 $T_2$ 的循环，反之亦然，甚至可以与 $T_2$ 同时执行 $T_1$。</p>
<p>例：</p>
<script type="math/tex; mode=display">
\left(
    \begin{matrix}
        V_1 \triangleq i \in \mathbb{N}\\
        I_1 \triangleq i = 0 \\
        T_1 \triangleq
            \begin{cases}
                i'=i+1\\
        \lor \ i'=i\\
            \end{cases}\\
    \end{matrix}
\right)

\otimes

\left(
    \begin{matrix}
        V_2 \triangleq j \in \mathbb{N}\\
        I_2 \triangleq j = 0 \\
        T_2 \triangleq
            \begin{cases}
                j'=j+1\\
        \lor \ j'=j\\
            \end{cases}\\
    \end{matrix} 
\right)

\to

\left(
    \begin{matrix}
        V \triangleq i,j \in \mathbb{N}\\
        I \triangleq i=0 \land j=0\\
        T \triangleq
            \begin{cases}
                i'=i+1 \land j' = j\\
        \lor \ (i'=i \land j'=j+1)\\
        \lor \ (i'=i+1 \land j'=j+1)\\
        \lor \ (i'=i \land j'=j)
            \end{cases}\\
    \end{matrix}
\right)</script><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30 20.56.29.png" alt="2022-03-30 20.56.29" style="zoom:40%;"></p>
<h5 id="严格同步的组合"><a href="#严格同步的组合" class="headerlink" title="严格同步的组合"></a>严格同步的组合</h5><p>变迁系统 $⟨S,I,R,L⟩$  由标记为 $⟨S_1,I_1,R_1,L_1⟩$ 和  $⟨S_2,I_2,R_2,L_2⟩$ 严格同步地组成， 其中：</p>
<ul>
<li>$S \triangleq S_1 \times S_2$ ：状态对</li>
<li>$I \triangleq I_1 \times I_2$ ：每个子系统都从它的一个初始状态开始</li>
<li>$R \triangleq \{ ((s_1, s_2), ({s_1}’, {s_2}’)) | (s_1, {s_1}’) \in R_1 \land (s_2, {s_2}’) \in R_2 \land Etiq((s_1, {s_1}’)) = Etiq((s_2, {s_2}’)) \}$ ：这两个子系统严格根据带有相同标签转换</li>
<li>$ L \triangleq L_1 \cap L_2 $ </li>
</ul>
<p>例：</p>
<p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30 21.14.36.png" alt="2022-03-30 21.14.36" style="zoom:45%;"></p>
<ol>
<li>Synchronizé strict avec LIFO 2 éléments (pile)</li>
</ol>
<p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30 21.16.51.png" alt="2022-03-30 21.16.51" style="zoom:45%;"></p>
<p>​    Donne：</p>
<p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30 21.18.02.png" alt="2022-03-30 21.18.02" style="zoom:40%;"></p>
<ol>
<li>Synchronizé strict avec FIFO 2 éléments (file)</li>
</ol>
<p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30 21.22.31.png" alt="2022-03-30 21.22.31" style="zoom:45%;"></p>
<p>​    Donne:</p>
<p>​    <img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30 21.23.35.png" alt="2022-03-30 21.23.35" style="zoom:40%;"></p>
<h5 id="Synchronise-ouvert-的组合"><a href="#Synchronise-ouvert-的组合" class="headerlink" title="Synchronisé ouvert 的组合"></a>Synchronisé ouvert 的组合</h5><p>变迁系统 $⟨S,I,R,L⟩$  由标记为 $⟨S_1,I_1,R_1,L_1⟩$ 和  $⟨S_2,I_2,R_2,L_2⟩$ 同步地组成， 其中：</p>
<ul>
<li><p>$S \triangleq S_1 \times S_2$ ：状态对</p>
</li>
<li><p>$I \triangleq I_1 \times I_2$ ：每个子系统都从它的一个初始状态开始</p>
</li>
<li><script type="math/tex; mode=display">
R \triangleq 
\begin{cases}
    ((s_1, s_2), ({s_1}', {s_2}')) | (s_1, {s_1}') \in R_1 \land (s_2, {s_2}') \in R_2 \land Etiq((s_1, {s_1}')) = Etiq((s_2, {s_2}'))\\
    ((s_1, s_2), ({s_1}', {s_2})) | (s_1, {s_1}') \in R_1 \land Etiq((s_1, {s_1}')) \notin L_2\\
    ((s_1, s_2), ({s_1}, {s_2}')) | (s_2, {s_2}') \in R_2 \land Etiq((s_2, {s_2}')) \notin L_1
\end{cases}</script></li>
<li><p>$ L \triangleq L_1 \cap L_2 $ </p>
</li>
</ul>
<p>例：</p>
<p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30 21.42.35.png" alt="2022-03-30 21.42.35" style="zoom:50%;"></p>
<p>Synchronizé strict avec LIFO 2 éléments (pile)</p>
<p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30 21.16.51-8669562.png" alt="2022-03-30 21.16.51" style="zoom:45%;"></p>
<p>Donne：</p>
<ul>
<li>strict：</li>
</ul>
<p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30 21.42.56.png" alt="2022-03-30 21.42.56" style="zoom:50%;"></p>
<ul>
<li><p>ouvert</p>
<p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30 21.43.21.png" alt="2022-03-30 21.43.21" style="zoom:45%;"></p>
</li>
</ul>
<h3 id="第二部分：Action"><a href="#第二部分：Action" class="headerlink" title="第二部分：Action"></a>第二部分：Action</h3><p>在《概述》中，我们提到<strong>T</strong>emporal <strong>L</strong>ogic of <strong>A</strong>ctions <strong>+</strong>是由<em>Leslie Lamport</em>开发的一种<strong>【形式化验证语言】</strong>。</p>
<p>本章我们会简单介绍这种语言。</p>
<h4 id="规约-Specification"><a href="#规约-Specification" class="headerlink" title="规约 Specification"></a>规约 Specification</h4><h5 id="规约的结构"><a href="#规约的结构" class="headerlink" title="规约的结构"></a>规约的结构</h5><p>一个TLA+的Model里应该包含的元素有：</p>
<ul>
<li>常数 Constant</li>
<li>变量 Variable（状态 = 变量的值）</li>
<li>Init. State 由状态谓词定义的一组初始状态 </li>
<li>动作 Action = 连接两个状态的转换谓词：<ol>
<li>当前状态，未启动的变量</li>
<li>到达状态，主要变量</li>
</ol>
</li>
<li>由动作的析取构造的过渡谓词（≈无限重复动作）</li>
</ul>
<p>例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">---------------- MODULE example ----------------</span><br><span class="line">EXTENDS Naturals</span><br><span class="line">VARIABLE x</span><br><span class="line"></span><br><span class="line">\* 初始状态 Init是初始化谓词（initial predicate）</span><br><span class="line">Init == x \in 0..2				\* 等价于x属于自然数 并且 0 &lt;= x &lt; 3</span><br><span class="line"></span><br><span class="line">\* 动作</span><br><span class="line">Plus == x&#x27;=x+1</span><br><span class="line">Sub == x&gt;0 /\ x&#x27;=x-1</span><br><span class="line">Next == Plus \/ Sub				\* Next是Next-state动作（action）</span><br><span class="line">Spec == Init /\ [] [ Next ]_&lt;&lt;x&gt;&gt;		</span><br></pre></td></tr></table></figure>
<p>上述规约语言等价于下述变迁系统</p>
<ul>
<li>$V \triangleq x \in \mathbb{N}$</li>
<li>$I \triangleq 0 \le x \le 2$</li>
<li>$R \triangleq \begin{cases} x’ = x+1\\ \lor x&gt;0 \land x’=x-1\\ \lor x’=x \end{cases}$</li>
</ul>
<p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-03-30 23.53.48.png" alt="2022-03-30 23.53.48" style="zoom:40%;"></p>
<h5 id="常量-Constantes"><a href="#常量-Constantes" class="headerlink" title="常量 Constantes"></a>常量 Constantes</h5><ul>
<li>显式常量：0、1、true、false、“string”</li>
<li>命名常量：$_{CONSTANT} \ N$，通常伴随着属性：$_{ASSUME}\ N \in Nat \land N \ge 2$</li>
</ul>
<h5 id="表达式-Expression"><a href="#表达式-Expression" class="headerlink" title="表达式 Expression"></a>表达式 Expression</h5><p>一切可以公理化的东西：</p>
<ul>
<li>逻辑表达式：$¬， ∧， ∨， ∀x ∈ S:p(x)， ∃x ∈ S:p(x)$</li>
<li>算术表达式：$+，-，&gt;，…$</li>
<li>集合表达式： $∈$，$∪$，$∩$，$⊂$，$\{e1, e2, . . . , en\}$，$n..m$，$\{x ∈ S : p(x)\}$，$\{f (x) : x ∈ S\}$，$_{UNION}\  S$，$_{SUBSET} \ S$</li>
<li>$_{IF}$ … $_{THEN}$ … $_{ELSE}$ …</li>
<li>从 X 到 Y 的函数</li>
<li>元组、序列等</li>
</ul>
<h5 id="集合运算符-Operateurs-ensemblistes"><a href="#集合运算符-Operateurs-ensemblistes" class="headerlink" title="集合运算符 Operateurs ensemblistes"></a>集合运算符 Operateurs ensemblistes</h5><ul>
<li>$\{e_1, …,e_n\}$ ： 扩展成集合</li>
<li>$n ..m$ ： $i \in Nat : n \le i \le m$</li>
<li>$\{ x \in S : p(x)\}$ ：S 中满足性质 p 的元素集合<ul>
<li>例1，$\{ n \in 1..10 : n\%2=0\} = \{2,4,6,8,10\} $ </li>
<li>例2，$\{ n \in Nat : n\%2=1\} = \{所有的奇数\} $ </li>
</ul>
</li>
<li>$\{ f(x) :x \in S\} $ ：所有$f(x)$ 的值的集合<ul>
<li>例1，$\{ 2*n: n \in 1..5\} = \{2,4,6,8,10\} $ </li>
<li>例2，$\{2*n+1 : n \in Nat\} = \{所有的奇数\} $ </li>
</ul>
</li>
<li>$_{UNION}\ S$ ：S 的元素的并集<ul>
<li>$_{UNION} \{ \{ 1,2\},  \{ 3,4\}\} =  \{ 1,2,3,4\}$</li>
</ul>
</li>
<li>$_{SUBSET}\ S$：S的所有子集的集合<ul>
<li>$_{SUBSET} \{ 1,2\} = \{ \{\}, \{1\}, \{ 2\}, \{ 1,2\}\}$</li>
</ul>
</li>
</ul>
<h4 id="动作-Action"><a href="#动作-Action" class="headerlink" title="动作 Action"></a>动作 Action</h4><h5 id="操作符-Action-Operators"><a href="#操作符-Action-Operators" class="headerlink" title="操作符 Action Operators"></a>操作符 Action Operators</h5><ul>
<li>$e’$ :  The value of e in the final state of a step (迭代器中e的更新值)</li>
<li>$[A]_e$ : $[A ∨ (e’ = e)]$ </li>
<li>$⟨A⟩_e$ : $[A ∧ (e’ \ne e)]$</li>
<li>$_{ENABLE} \ A$ : [An A step is possible]</li>
<li>$_{UNCHANGED}\ E$ : $[e’ = e]$</li>
<li>$A · B$ : [Composition of actions]</li>
</ul>
<p>动作 = 转换谓词 = 包含常量、变量和引发变量的布尔表达式。</p>
<p>动作 不等于 任务</p>
<ul>
<li><p>$\begin{aligned} &amp; x’=x+1\\   &amp; \equiv x’-x=1\\   &amp; \equiv x=x’-1\\  &amp; \equiv (x&gt;1 \land x’/x=1 \land x’\%x=1) \lor (1=x \land 2=x’) \lor (x=0 \land x’ \in \{y \in Nat:y+1=2*y\})\\ \end{aligned}$</p>
</li>
<li><p>Other types of actions:</p>
<ul>
<li>$x’ &gt; x$ 或 $x’ ∈ \{x + 1, x + 2, x + 3\}$（不确定性）</li>
<li>$x’ ∈ \{y ∈ \mathbb{N}: ∃z ∈ N: z ∗ y = x ∧ z \% 2 = 0\}$（不可评估）</li>
<li>$x’ = y ∧ y’ = x$（多个变量）</li>
</ul>
</li>
</ul>
<h5 id="由连词组成的动作"><a href="#由连词组成的动作" class="headerlink" title="由连词组成的动作"></a>由连词组成的动作</h5><ol>
<li>仅与起始状态有关的状态谓词</li>
<li>确定性转移谓词 $var’ = . . .$ 或 非确定性转移谓词 $var’ ∈ …$</li>
</ol>
<p>例：$x &lt; 10 ∧ x’ = x + 1$，而不是 $x′ = x + 1 ∧ x’ &lt; 11$ 或 $x′ - x = 1 ∧ x’ &lt; 11$</p>
<h5 id="重复（Begaiement）-1"><a href="#重复（Begaiement）-1" class="headerlink" title="重复（Bégaiement）"></a>重复（Bégaiement）</h5><h6 id="Begaiement"><a href="#Begaiement" class="headerlink" title="Bégaiement"></a>Bégaiement</h6><p>$[\mathcal{A}]_f \triangleq \mathcal{A} ∨ f’ = f$ ，其中 $f$ 是变量元组。</p>
<p>示例：</p>
<p>$\begin{aligned} {[x’=x+1]_{⟨x,y⟩}} &amp; = {(x’=x+1 ∨ (⟨x, y⟩’=⟨x,y⟩))} \\     &amp; = {(x’= x+1 ∨ (x’=x ∧ y’=y))} \\ \end{aligned}$</p>
<h6 id="Non-Begaiement"><a href="#Non-Begaiement" class="headerlink" title="Non Bégaiement"></a>Non Bégaiement</h6><p>$[\mathcal{A}]_f \triangleq \mathcal{A} ∨ f’ \ne f$ ，其中 $f$ 是变量元组。</p>
<h6 id="无约束变量-Variables-non-contraintes"><a href="#无约束变量-Variables-non-contraintes" class="headerlink" title="无约束变量 Variables non contraintes"></a>无约束变量 Variables non contraintes</h6><p>$\begin{aligned} {(x′=x+1)} &amp; = {(x’=x+1 \land y’= 任何值 )} \\     &amp; \ne {(x’=x+1 \land y’=y)} \\ \end{aligned}$</p>
<h6 id="UNCHANGED"><a href="#UNCHANGED" class="headerlink" title="UNCHANGED"></a>UNCHANGED</h6><p>$_{UNCHANGED}\ e \triangleq e’ = e$</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">---------------- MODULE AlternatingBit ----------------</span><br><span class="line">EXTENDS Naturals</span><br><span class="line">CONSTANT Data</span><br><span class="line">VARIABLE val, ready, ack</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">\* 初始状态 Init是初始化谓词（initial predicate）</span><br><span class="line">Init == /\ val \in Data</span><br><span class="line">		/\ ready \in &#123;0,1&#125;</span><br><span class="line">		/\ ack = ready</span><br><span class="line">		</span><br><span class="line">Send == /\ ready = ack</span><br><span class="line">		/\ val&#x27; \in Data</span><br><span class="line">		/\ ready&#x27; = 1 - ready</span><br><span class="line">		/\ UNCHANGED ack</span><br><span class="line">		</span><br><span class="line">Receive == /\ ready # ac k</span><br><span class="line">		/\ ack&#x27; = 1 - ack</span><br><span class="line">		/\ UNCHANGED &lt;&lt;val, ready&gt;&gt;</span><br><span class="line">-------------------------------------------------------</span><br><span class="line">Next == Send \/ Receive				\* Next是Next-state动作（action）</span><br><span class="line">Spec == Init /\ [] [ Next ]_&lt;&lt;val, ready, ack&gt;&gt;		</span><br><span class="line">=========================================================</span><br></pre></td></tr></table></figure>
<h4 id="函数-Function"><a href="#函数-Function" class="headerlink" title="函数 Function"></a>函数 Function</h4><p>“映射(mapping) ”意义上的函数，对应：</p>
<ul>
<li>$X \to Y$ : 从 X 到 Y 的一组函数。</li>
<li>$f \in [X \to Y]$ : X 在 Y 中的 f 函数</li>
<li>$f[x]$ : x 处的 f 值。</li>
</ul>
<p>一个函数就是一个值。<br>一个包含函数的变量可以改变它的值⇒“函数改变”。</p>
<h5 id="符号的定义-Definition-of-symbol"><a href="#符号的定义-Definition-of-symbol" class="headerlink" title="符号的定义 Definition of symbol"></a>符号的定义 Definition of symbol</h5><p>$f[x \in Nat]$ : 关于x的表达式。例 : $Inc[x \in Nat] \triangleq x+1$</p>
<h5 id="值的定义-Definition-of-value"><a href="#值的定义-Definition-of-value" class="headerlink" title="值的定义 Definition of value"></a>值的定义 Definition of value</h5><p>$[x \in S \mapsto expr]$. 例 : $x \in 1..4 \mapsto 2*x$</p>
<h5 id="表-Table"><a href="#表-Table" class="headerlink" title="表 Table"></a>表 Table</h5><p>函数 $t ∈ [X → Y ]$ 其中 X 是整数区间。</p>
<h5 id="定义域-Domain"><a href="#定义域-Domain" class="headerlink" title="定义域 Domain"></a>定义域 Domain</h5><p>$_{DOMAIN}\ f$ : f 的定义域</p>
<h5 id="值域-Codomaine"><a href="#值域-Codomaine" class="headerlink" title="值域 Codomaine"></a>值域 Codomaine</h5><p>$Codomain(f) \triangleq \{ f[x]:x \in _{DOMAIN}f\}$</p>
<h5 id="EXCEPT"><a href="#EXCEPT" class="headerlink" title="EXCEPT"></a>EXCEPT</h5><p>$[a \ _{EXCEPT}\ ![i] =v] \triangleq [j\in _{DOMAIN} \ a \mapsto _{IF}\ j=i\ _{THEN}\ v\ _{ELSE}\ a[j]]$</p>
<p>例：$[a’ = a \ _{EXCEPT}\ ![2] =8] \not\equiv (a[2]’ =8)$</p>
<h5 id="IncF"><a href="#IncF" class="headerlink" title="IncF"></a>IncF</h5><p>IncF 是数学意义上的函数定义，等价于 $IncF \triangleq [x ∈ Nat \mapsto x + 1]$</p>
<ul>
<li>它的定义域：$_{DOMAIN}\ IncF$</li>
<li>它的值域：$ \{IncF[x] : x ∈ _{DOMAIN}IncF\}$</li>
<li>$IncF \in [X \mapsto Y]$</li>
</ul>
<h5 id="IncO"><a href="#IncO" class="headerlink" title="IncO"></a>IncO</h5><p>IncO 是运算符(Operator) 的定义</p>
<ul>
<li>写因式分解：类似于一个宏，其文本可以替换</li>
<li>没有定义域 和 值域</li>
<li>$IncO ∈ [X → Y ]$ 没有意义</li>
</ul>
<h5 id="记录-Record"><a href="#记录-Record" class="headerlink" title="记录 Record"></a>记录 Record</h5><p>记录是 $[X → Y]$ 的函数，其中 X 是一组字符串。</p>
<p>简写作：<br>$[“qwerty” \mapsto 1, “asdfgh” \mapsto 2] = [qwerty \mapsto 1,asdfgh \mapsto 2]$$</p>
<p>$rec[“qwerty”] = rec.qwerty$</p>
<h5 id="递归定义-Definition-recursive"><a href="#递归定义-Definition-recursive" class="headerlink" title="递归定义 Définition récursive"></a>递归定义 Définition récursive</h5><p>定义（函数或运算符）时，可以给出递归定义：</p>
<ul>
<li>函数：$fact[n \in Nat] \triangleq _{IF}\ n=0\ _{THEN}\ 1\ _{ELSE}\ n*fact(n-1)$</li>
<li>运算符：$fact(n) \triangleq _{IF}\ n=0\ _{THEN}\ 1\ _{ELSE}\ n*fact(n-1)$</li>
</ul>
<p>从理论上讲，必须证明这些定义的有效性。</p>
<h5 id="n元组-n-Tuple"><a href="#n元组-n-Tuple" class="headerlink" title="n元组 n-Tuple"></a>n元组 n-Tuple</h5><p>符号：⟨a, b, c⟩。</p>
<ul>
<li>n元组是定义域函数= $\{1,. . .,n\} :⟨a, b, c⟩[3] = c$</li>
<li>用于表示关系：$\{⟨x, y⟩ ∈ X × Y: R(x, y)\}$。示例：$\{⟨a, b⟩ ∈ Nat × Nat:a=2*b\}$。</li>
</ul>
<h5 id="序列-Sequence"><a href="#序列-Sequence" class="headerlink" title="序列 Sequence"></a>序列 Sequence</h5><p>$\begin{aligned} Seq(T) &amp; \triangleq _{UNION} \{[1..n → T]: n ∈ Nat\}\\ &amp; \triangleq 包含 T 的有限序列集 \end{aligned}$</p>
<p>运算符：$Len(s)$，$s ◦ t$（连接），$Append(s,e)$，$Head(s)$，$Tail(s)$。</p>
<h5 id="局部定义-Local-Definition"><a href="#局部定义-Local-Definition" class="headerlink" title="局部定义 Local Definition"></a>局部定义 Local Definition</h5><p>$LET$</p>
<ul>
<li><p>表达式： $_{LET}\ v \triangleq e\ _{IN}\ f$</p>
<p>等效于表达式 $f$，其中所有的符号 $v$ 的都被 $e$ 替换。例子：$_{LET}\ i \triangleq g(x)\ _{IN}\ f (i)≡ f (g(x))$</p>
</li>
</ul>
<p>例：</p>
<p>$Pythagore(x, y, z) \triangleq _{LET}\ square(n) \triangleq n∗n\ _{IN}\ square(x) + square(y) = square(z)$</p>
<h5 id="选择-CHOOSE"><a href="#选择-CHOOSE" class="headerlink" title="选择 CHOOSE"></a>选择 CHOOSE</h5><ul>
<li><p>$_{CHOOSE}\ x \in S:p$ ：确定性任意选择集合 S 中满足谓词 p 的元素。</p>
</li>
<li><p>$max[S \in _{SUBSET}\ Nat] \triangleq\ _{CHOOSE}\ m \in S:(\forall p \in S : m \ge p)$</p>
</li>
</ul>
<p>对于集合 S 和属性 p，选择的元素在所有执行过程中始终相同。 它不是一个随机选择器，它在每次调用时都给出一个不同的元素。所以$_{CHOOSE}\ x \in S:p = _{CHOOSE}\ x \in S:p$。</p>
<p><strong>规约</strong></p>
<ul>
<li><p>$(x =\ _{CHOOSE}\ n : n ∈ Nat) ∧ \Box [x’=_{CHOOSE}\ n : n ∈ Nat]_{⟨x⟩}$</p>
<p>有一个独特的执行：$ x = c → x = c → …$其中 c 是一个不确定的整数（由选择指定）。</p>
</li>
<li><p>$(x ∈ Nat) ∧ \Box [x’ ∈ Nat]_{⟨x⟩}$</p>
<p>有无限次执行，其中一些在每个状态中 x 是不同的，另一些在 x 是恒定的，另一些在 x 中循环</p>
</li>
</ul>
<h3 id="第三部分：线性时间属性-LT-Properties"><a href="#第三部分：线性时间属性-LT-Properties" class="headerlink" title="第三部分：线性时间属性(LT Properties)"></a>第三部分：线性时间属性(LT Properties)</h3><h4 id="刻画线性时间属性-LT-Properties"><a href="#刻画线性时间属性-LT-Properties" class="headerlink" title="刻画线性时间属性(LT Properties)"></a>刻画线性时间属性(LT Properties)</h4><p>因为线性时间属性（LT Properties）是TS中迹的要求，所以在原子命题（AP）上的线性时间属性是$S^{w}$<br>的子集。$S^{w}$表示的是AP中命题的无限级联的集合</p>
<p>如果AP={a,b}，那么$(2^{AP})^{w}$ 可以表示为</p>
<script type="math/tex; mode=display">
\{\{a\}\{a,b\}\varnothing ...，\{b\}\{a\}\varnothing\varnothing...，...\}</script><p>类似该集合中的元素，由无限个字符级联在一起组成的序列称为无限字(infinite word)，无限字可以表示为:</p>
<script type="math/tex; mode=display">
W=A_{0}A_{1}A_{2}...</script><p>当这个序列是有限时，便称为有限字(finite word)，有限字可以表示为:</p>
<script type="math/tex; mode=display">
W=A_{0}A_{1}A_{2}...A_{n}</script><p>因为TS不考虑终止状态，所以也就无需使用有限字。</p>
<p>如果一个TS满足线性时间属性P，那么就表明：</p>
<script type="math/tex; mode=display">
TS \vDash P\text{ 当且仅当}Traces(TS) ⊆ P</script><blockquote>
<p>我个人的理解是线性时间属性P刻画了AP上能够出现的原子命题序列，而迹表示的是系统在AP上出现的原子命题序列，如果系统的迹是P的子集，那么肯定这个系统就满足了线性时间属性P。</p>
</blockquote>
<h6 id="刻画基于信号量互斥系统的属性"><a href="#刻画基于信号量互斥系统的属性" class="headerlink" title="刻画基于信号量互斥系统的属性"></a>刻画基于信号量互斥系统的属性</h6><p>一说到信号量和互斥，再次搬出这个例子：</p>
<p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/20201118212040185.png" alt="20201118212040185" style="zoom:50%;"></p>
<p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/20201118212152854.png" alt="20201118212152854" style="zoom:60%;"></p>
<p>在这里，$AP=\{crit_1, crit_2\}$，这个系统中的约束有一条：</p>
<blockquote>
<p>“Always at most one process is in its critical section”</p>
<p>就是最多有一个进程能够进入临界区</p>
</blockquote>
<p>用形式化的语言描述就是：</p>
<script type="math/tex; mode=display">
P_{mutex} = 一个无限字的集合\{A_0A_1A_2...\} 且满足对于所有0\le i,\{crit_1, crit_2\} \nsubseteq A_{i}</script><p>这就完成对系统属性的刻画，描述一下就是对于这个TS的运行轨迹来说不存在$\{crit_1, crit2\}$满足条件的情况。</p>
<p>所以无限字可以是类似$\{crit_1\}\{crit_2\}\{crit_1\}\{crit_2\}…$或者$\varnothing\varnothing\varnothing\varnothing\varnothing…$反正就是不能出现$\{crit_1, crit2\}$这个元素。</p>
<p>那么再问一个问题，上面的那个TS系统满足这个$P_{mutex}$ 性质嘛？</p>
<ul>
<li>Yes，因为从图上看不存在$\{crit_1, crit2\}$以满足了我们定义的互斥性性质。</li>
</ul>
<h6 id="刻画无饥饿-starvation-freedom-系统的属性"><a href="#刻画无饥饿-starvation-freedom-系统的属性" class="headerlink" title="刻画无饥饿(starvation freedom)系统的属性"></a>刻画无饥饿(starvation freedom)系统的属性</h6><p>不存在饥饿的系统要求满足条件:</p>
<blockquote>
<p>“A process that wants to enter the critical section is eventually able to do so”</p>
<p>如果一个进程想要进入临界区，那么它最终总是能够进入临界区。</p>
</blockquote>
<p>这一次让$AP=\{crit_1,wait_1,crit_2,wait_2\}$</p>
<p>用形式化的语言描述为LT性质就是：</p>
<script type="math/tex; mode=display">
P_{nostarve} = 一个无限字的集合\{A_0A_1A_2...\} \\ 满足(\overset{\infty}∃ j.\;wait_{i}∈A_{j})\Rightarrow (\overset{\infty}∃ j.\;crit_{i}∈A_{j})\; for\;each\;i∈\{1,2\}</script><p>其中 $\overset{\infty}∃$ 代表无限多</p>
<p>描述一下就是当一个进程进入等待状态后，之后肯定会进入临界区</p>
<p>那么基于信号量的互斥系统满足无饥饿性质嘛？no，如果是这样一条迹:$\varnothing\{wait_2\}\{wait_1,wait_2\}\{crit_1,wait_2\}\{wait_2\}\{wait_1,wait_2\}\{crit_1,wait_2\}…$，那么进程2将永远的不能进入临界区。</p>
<h5 id="不变性-Invariants"><a href="#不变性-Invariants" class="headerlink" title="不变性(Invariants)"></a>不变性(Invariants)</h5><p>事实上，上述（互斥与无死锁）安全性是一种特殊的性质：不变性。不变性是LT属性，由状态的条件$Φ$给出，并且要求$Φ$对所有可达到的状态保持不变。不变性是安全性的一种，也就是安全性的子集。</p>
<p>如果在AP上的线性属性$P_{inv}$是不变性，那么它具有如下形式：</p>
<script type="math/tex; mode=display">
P_{inv}=\{A_{0}A_{1}A_{2}... ∈ (2^{AP})^{w} | ∀j \ge 0. A_{j} \vDash Φ \}</script><p>其中$Φ$AP上的逻辑命题公式，$Φ$ 被称为$P_{inv}$ 的不变条件。</p>
<p>让我们回想一下先前的基于信号量的互斥系统，在那个系统中$Φ=\lnot crit1\vee \lnot crit2$, 保证crit1和crit2不能同时为真。</p>
<script type="math/tex; mode=display">
Invariants \triangleq \forall crit_1,crit_2 \; Value:Chosen(crit_1) \land Chosen(crit_2) \quad \Rightarrow \quad crit_1 = crit_2</script><p>设TS是一个没有终止状态的转换系统，那么有：</p>
<ul>
<li>$TS\vDash P_{inv}$<ul>
<li>$iff\; trace(\pi)∈ P_{inv}\; for\; all\; paths\;\pi \; in\; TS$</li>
<li>$iff\; L(s)\vDash Φ\; for\; all\; states\;s\;that\;belong\; to\; a\;path\; of\;TS$</li>
<li>$iff\; L(s)\vDash Φ\; for\; all\; states\;s∈Reach(TS)$</li>
</ul>
</li>
</ul>
<p>注意上面的最后一个式子，我们将TS能否满足不变性，转换成为了所有可达状态是否满足不变性这一问题。基于此我们可以设计检验不变性的算法。</p>
<h6 id="我们该如何检验一个系统是否满足了不变性呢？"><a href="#我们该如何检验一个系统是否满足了不变性呢？" class="headerlink" title="我们该如何检验一个系统是否满足了不变性呢？"></a>我们该如何检验一个系统是否满足了不变性呢？</h6><p>我们只要遍历系统的每个状态，从初始状态开始，利用深度优先(Dfs)或者广度优先(Bfs)算法，检查每一个可达状态是否满足$Φ$，只要找到一个可达状态不满足$Φ$，那么系统就不满足不变性，如果我们遍历所有状态发现均满足$Φ$，那么系统就满足不变性。</p>
<h5 id="安全性-safety"><a href="#安全性-safety" class="headerlink" title="安全性(safety)"></a>安全性(safety)</h5><p>上面我们可以看到，不变性可以被视为状态属性，并且可以通过考虑可达状态来检查。但是安全性不能仅考虑可达状态来验证，而是需要对有限路径片段提出要求。</p>
<blockquote>
<p>个人理解，不变性的要求是满足所有可达状态满足要求，而安全性是要求所有的系统上出现的有限路径片段满足要求，从这个角度来看，不变性就是安全性的一种特例，如果安全性要求的有限路径片段的长度为1的话，那就变成了不变性要求。</p>
</blockquote>
<p>我们考虑一个自动取款机（ATM）的例子，ATM机的要求是，只有在提供了正确的个人识别码（PIN）后，才能从自动取款机中取款。这个属性不是不变量，因为它不是一个单纯的状态属性。但是，它是一种安全性，例如</p>
<script type="math/tex; mode=display">
"提供正确的PIN","取款",...</script><p>这样的路径片段是满足安全性的，但如果出现</p>
<script type="math/tex; mode=display">
"提供错误的PIN","取款"...</script><p>这样的路径片段是是不满足安全性的，我们可以看到，一旦出现了这样”坏(bad)”的片段，不管后面如何都是不满足安全性的，我们引入前缀、坏前缀等概念来帮助我们定义安全性。</p>
<p>安全性通常被描述为“<strong>不会发生不好的事情</strong>”(nothing bad should happen)</p>
<h6 id="安全性的例子"><a href="#安全性的例子" class="headerlink" title="安全性的例子"></a>安全性的例子</h6><ul>
<li><strong>互斥性</strong>是一种典型的安全性，它要求在临界区最终只有一个进程存在，bad thing指的是在临界区存在两个或两个以上的进程，这种坏事要求永远不会发生</li>
<li><strong>无死锁性</strong>(deadlock freedom)是另一个典型的安全属性。在哲学家问题中，发生死锁的特征是所有哲学家都拿起了一把筷子，并且正在等待拿起第二把筷子，这种坏的（或unwanted，即不必要的）情况要求永远都不会发生。</li>
</ul>
<h6 id="安全性定义为"><a href="#安全性定义为" class="headerlink" title="安全性定义为"></a>安全性定义为</h6><script type="math/tex; mode=display">
对于所有的\sigma∈(2^{AP})^w\setminus P_{safe}存在一个\sigma的有限前缀\hat{\sigma}满足 \\ P_{safe}\cap\{\sigma'∈(2^{AP})^w|\hat{\sigma}是\sigma'的有限前缀\}=\varnothing</script><p>解释一下，对于所有的无限字$\sigma=A_{0}A_{1}A_{2}…\in(2^{AP})^w\setminus P_{safe}$ ，存在$\sigma$的有限前缀 $\hat{\sigma}=A_{0}A_{1}…A_{n} $<br>，使得以 $\hat{\sigma}$ 有限前缀起始的字$A_{0}A_{1}…A_{n}B_{n+1}B_{n+2}…$ 不属于$P_{safe}$。</p>
<p>有限字 $\hat{\sigma}=A_{0}A_{1}…A_{n}$ 被称为$P_{safe}$ 的坏前缀(bad prefix)，符号表示为 $BadPref(P_{safe})$ 。</p>
<p>如果 $\hat{\sigma} $被称为 $P_{safe}$ 的最小坏前缀(minimal bad prefix)，那么就是说 $\hat{\sigma}$ 中没有比 $\hat{\sigma} $ 长度更小的坏前缀，符号表示为$MinBadPref(P_{safe})$。</p>
<p>对于一个TS系统满足安全性，那么当且仅当： </p>
<ul>
<li>$TS\models P_{safe}$</li>
<li>$iff\; trace(TS)\subseteq P_{safe}$</li>
<li>$iff\; trace_{fin}(TS) \cap BadPref=\varnothing$</li>
<li>$iff\; trace_{fin}(TS) \cap MinBadPref=\varnothing$</li>
</ul>
<p>以红绿灯系统为例，它拥有一个属性</p>
<blockquote>
<p>each red phase should be immediately preceded by a yellow phase<br>只有在黄灯亮了之后红灯才能亮</p>
</blockquote>
<p>AP定义为$\{red,yellow\}$，用形式化的符号表述为：</p>
<script type="math/tex; mode=display">
一个无限字的集合\{A_{0}A_{1}A_{2}...\}\; 对于所有i>0满足red∈A_{i},yellow∈A_{i-1}</script><p>类似于$\varnothing\varnothing\{red\}$，$\varnothing\{red\}$ 都是最小坏前缀，因为 $\{red\}$之前没有出现 $\{yellow\}$</p>
<p>而类似于$\{yellow\}\{yellow\}\{red\}\{red\}\varnothing\{red\}$是坏前缀而不是最小坏前缀，因为存在比它更小的坏前缀 $\{yellow\}\{yellow\}\{red\}\{red\}$</p>
<h5 id="活性-liveness"><a href="#活性-liveness" class="headerlink" title="活性(liveness)"></a>活性(liveness)</h5><p>安全性规定“<strong>不好的事情永远不会发生</strong>”，一个算法可以很容易地实现一个安全性，只要检验一下看看会不会出现不好的情况。但是这很多时候是不需要的，有时候没有必要保证永远不会发生不好的事情，为此需要一些其他属性来补充。这样的属性称为”活性(liveness)”属性。可以说，活性表示<strong>“好事”将会发生</strong>(something good will happen)</p>
<h6 id="活性的例子"><a href="#活性的例子" class="headerlink" title="活性的例子"></a>活性的例子</h6><ul>
<li>“每个进程最终都会进入临界区”</li>
<li>“每个哲学家将会无限经常次吃到饭”</li>
</ul>
<p>从上面的定义中我们就可以知道，对于活性的判断和安全性完全不同，因为<u>安全性只要有一个坏前缀就可以驳倒安全性，不论后面的序列如何</u>。而<u>活性需要考虑未来无限路径中需要满足的特性</u>。</p>
<p>如果 $P_{live}$ 是AP上上的活性，那么无论何时：p$ref(P_{live})=(2^{AP})^{*}$ 被称为活性，那么每个在AP上的有限字都能够扩展成为 $P_{live}$ 中的无限字</p>
<h5 id="活性-vs-安全性"><a href="#活性-vs-安全性" class="headerlink" title="活性 vs 安全性"></a>活性 vs 安全性</h5><ul>
<li><p>活性和安全性是不相交的嘛？</p>
<p>是的</p>
</li>
<li><p>所有线性时间属性都是活性或者安全性嘛？</p>
<p>不是</p>
</li>
<li><p>有哪些既不是安全性也不是活性的例子？</p>
<p>例如：“机器在提供三次雪碧之后，会无限次提供啤酒”</p>
<p>这个例子由两个部分组成，一个是“提供三次雪碧之后”，这是一个安全属性，我们给出一个坏前缀，提供一次雪碧后提供啤酒，另一部分是“无限次提供啤酒”，这是一个活性属性。所以这种包含了安全性和活性的特性，既不属于安全性也不属于活性。</p>
</li>
<li><p>是否所有的线性时间属性都可以表示为安全性和活性的交集？</p>
<p>是的</p>
<p>根据分解定理(Decomposition theorem)</p>
<p>对于任何AP上的线性时间属性P，存在安全性$P_{safe}$ 和活性 $P_{live}$ 使得</p>
<script type="math/tex; mode=display">
P=P_{safe}\cap P_{live}</script></li>
</ul>
<ul>
<li><p>线性时间属性的分类（注：不变性是包含在安全性里面，中间那块黄色的区域既是安全性又是活性，代表的含义是True）</p>
<p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/20201120223125939.png" alt="20201120223125939" style="zoom:60%;"></p>
</li>
</ul>
<h3 id="第四部分：Fairness"><a href="#第四部分：Fairness" class="headerlink" title="第四部分：Fairness"></a>第四部分：Fairness</h3><p>系统的一个重要方面是公平性，公平性排除了被认为是不现实(unrealistic)的无限行为，并且这一步通常是建立活性属性所必需的。</p>
<p>我们通过在并发系统中经常遇到的一个问题来说明公平的概念：</p>
<blockquote>
<p>现有一个并发系统N，有进程 $P_{1},P_{2}…P_{N}$，它们在有需要时就会请求服务，但是现在只有一个服务进程名叫Server会为这些进程提供服务，现在Server采用如下策略：</p>
<ol>
<li>从P1开始检查，如果P1请求了服务，那么就为P1提供服务;</li>
<li>如果P1没有请求，那么就检查下一个进程P2，直到检查完毕，然后从头开始检查……</li>
</ol>
<p>我们可以想见，如果P1一直请求服务，那么Server会为P1无限次提供服务，而剩下的进程都会陷入无限等待的过程，这对除P1外的进程来说是是不公平(unfair)的，这种行为就属于不现实的无限行为。</p>
</blockquote>
<p>为了获得由TS建模的并行系统的行为的真实描述，我们需要一种另一种形式的LT属性，来解决TS中不确定性决策的问题。</p>
<p>于是，为了排除上述不现实的行为，我们需要添加公平性约束(Fairness Constraints)，而公平的执行或者轨迹(execute or trace)就是满足了某些公平性约束。</p>
<h4 id="公平性约束-Contraintes-d’equite"><a href="#公平性约束-Contraintes-d’equite" class="headerlink" title="公平性约束 Contraintes d’équité"></a>公平性约束 Contraintes d’équité</h4><p>公平性约束指定在程序的任何执行中必须<strong>经常无限</strong>地访问（或执行）某些状态（某些转换）。</p>
<p>通常，公平性约束用于将程序或其环境约束为<strong><u>活性（liveness）</u></strong>，而不涉及有关这些约束的实际实现的细节。</p>
<p>公平约束通过消除不尊重公平约束的执行来减少合法执行的集合。</p>
<h5 id="循环状态集-（Ensemble-recurrent-d’etats）"><a href="#循环状态集-（Ensemble-recurrent-d’etats）" class="headerlink" title="循环状态集 （Ensemble recurrent d’etats）"></a>循环状态集 （Ensemble recurrent d’etats）</h5><p>令 $⟨S, I, R⟩$ 是一个变迁系统，且$\sigma = \langle s_0 \to … \rangle$是一段执行。状态集$P$在$\sigma$ 中是循环的，当</p>
<ul>
<li>情况1：$\sigma$是无限的：$\forall i \in \mathbb{N} : ∃ j \ge i : s_j \in P$ （$P在\sigma中出现无限次$）</li>
<li>情况2：$\sigma$是有限的：$\sigma$的最终状态在$P$里</li>
</ul>
<blockquote>
<p>$Inf_S(P,\sigma)$ ：$P$是在$\sigma$中的循环状态集</p>
</blockquote>
<h5 id="循环转换集（Ensemble-recurrent-de-transitions）"><a href="#循环转换集（Ensemble-recurrent-de-transitions）" class="headerlink" title="循环转换集（Ensemble recurrent de transitions）"></a>循环转换集（Ensemble recurrent de transitions）</h5><p>令 $⟨S, I, R⟩$ 是一个变迁系统，且$\sigma = \langle s_0 \to … \rangle$是一段执行。转换集$Q$在$\sigma$ 中是循环的，当</p>
<ul>
<li>情况1：$\sigma$是无限的：$\forall i \in \mathbb{N} : ∃ j \ge i : s_j \to s_{j+1} \in Q$ （$Q在\sigma中出现无限次$）</li>
<li>情况2：$\sigma$是有限的：$\sigma$的最终转换在$Q$里</li>
</ul>
<blockquote>
<p>$Inf_T(Q,\sigma)$ ：$Q$是在$\sigma$中的循环状态集</p>
</blockquote>
<p>例（循环状态）：</p>
<p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03 12.10.42.png" alt="2022-04-03 12.10.42" style="zoom:30%;"></p>
<ul>
<li><p>$s_1 \; is\;recurrent\;in\;⟨(s_0 → s_1 → s_3)^ω⟩$</p>
</li>
<li><p>$s_1 \; is\;recurrent\;in\;⟨(s_0 → s_1 → s_3 \to s_0 \to s_2 \to s_3)^ω⟩$</p>
</li>
<li><p>$s_1 \; is\;NOT\;recurrent\;in\;⟨(s_0 → s_1 → s_3)^* \to (s_0 \to s_2 \to s_3)^ω⟩$</p>
<blockquote>
<p>个人理解，这里在说循环状态时有两个判断标准：</p>
<ol>
<li>当这段执行是<strong>无限</strong>的时，该状态应该在这段<strong>无限执行内</strong>；</li>
<li>当这段执行是<strong>有限</strong>的时，该状态应该是这段<strong>有限执行的最终状态</strong>。</li>
</ol>
<p>下列循环转换可类比于循环状态</p>
</blockquote>
</li>
<li><p>$s_1 \to s_3 \; is\;recurrent\;in\;⟨(s_0 → s_1 → s_3 \to s_0 \to s_2 \to s_3)^ω⟩$</p>
</li>
<li><p>$s_1 \to s_3 \; is\;NOT\;recurrent\;in\;⟨(s_0 → s_1 → s_3)^* \to (s_0 \to s_2 \to s_3)^ω⟩$</p>
</li>
</ul>
<h4 id="关于状态的公平性"><a href="#关于状态的公平性" class="headerlink" title="关于状态的公平性"></a>关于状态的公平性</h4><h5 id="简单公平性"><a href="#简单公平性" class="headerlink" title="简单公平性"></a>简单公平性</h5><p>令 $⟨S, I, R⟩$ 是一个变迁系统，如果$ F ⊆ S $ 是一组公平的状态，那么任何执行 $σ$ 必须满足循环状态集 $Inf_S (F, σ)$。</p>
<p>例：</p>
<p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03 12.23.47.png" alt="2022-04-03 12.23.47" style="zoom:40%;"></p>
<p>$Exec(S) = ⟨{s_0}^ω⟩,⟨{s_0}^+ \to s_1⟩,⟨{s_0}^+ \to s_2 \to (s_3 \to s_4) ^w⟩,⟨{s_0}^+ \to s_2 \to (s_3 \to s_4) ^+ \to s_5⟩$</p>
<ul>
<li>满足 $\{s_0\}$ 简单公平性的执行是：$⟨{s_0}^ω⟩$</li>
<li>满足 $\{s_1, s_4\}$ 简单公平性的执行是：$⟨{s_0}^+ \to s_1⟩,⟨{s_0}^+ \to s_2 \to (s_3 \to s_4) ^w⟩$</li>
<li>满足 $\{s_1, s_5\}$ 简单公平性的执行是：$⟨{s_0}^+ \to s_1⟩,⟨{s_0}^+ \to s_2 \to (s_3 \to s_4) ^+ \to s_5⟩$</li>
</ul>
<blockquote>
<p>满足 $\{s_0, s_1\}$ 简单公平性意味着<strong>分别满足</strong>$\{s_0\}$ 和 $\{s_1\}$ 的简单公平性</p>
</blockquote>
<h5 id="多重公平性"><a href="#多重公平性" class="headerlink" title="多重公平性"></a>多重公平性</h5><p>令 $⟨S, I, R⟩$ 是一个变迁系统，给定一个可枚举的集合，可由一组整数$ J = \{0, 1, 2,…\}$，公平集 $\{F_i\}i ∈ J$。</p>
<p>任何执行 $σ$ 必须满足 $∀i ∈ J : Inf_S (F_i, σ)$。</p>
<p>例：</p>
<p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03 14.11.29.png" alt="2022-04-03 14.11.29" style="zoom:40%;"></p>
<p>$Exec(S) = ⟨{s_0}^ω⟩,⟨{s_0}^+ \to {s_1}^w⟩,⟨({s_0}^+ \to {s_1}^+)^w⟩,⟨({s_0}^+ \to {s_1}^+)^* \to {s_0}^+ \to {s_1}^w⟩$</p>
<ul>
<li>满足 $\{s_0\}$ 简单公平性的执行是：$⟨{s_0}^ω⟩, ⟨({s_0}^+ \to {s_1}^+)^w⟩$</li>
<li>满足 $\{s_0, s_1\}$ 简单公平性的执行是：$Exec(S)$</li>
<li>满足 $\{s_0\}\{s_1\}$ <strong>多重公平性</strong>的执行是：$⟨({s_0}^+ \to {s_1}^+)^w⟩$</li>
</ul>
<blockquote>
<p>满足 $\{s_0\}\{s_1\}$ <strong>多重公平性</strong>意味着<strong>同时满足</strong>$\{s_0\}$ 和 $\{s_1\}$ 的简单公平性</p>
</blockquote>
<h6 id="有限多重公平性-↔-简单公平性"><a href="#有限多重公平性-↔-简单公平性" class="headerlink" title="有限多重公平性 ↔ 简单公平性"></a>有限多重公平性 ↔ 简单公平性</h6><ol>
<li><p>简单情况：$J$ 是有限的。 $|J|$ 是 $J$ 的基数(cardinalite)。</p>
<p>下面的简单公平性系统$⟨S’, I’, R’⟩$ 是等价的（执行的平等投影到 S）：</p>
<ul>
<li>$S’ = S \times J$</li>
<li>$I’ = I \times \{0\}$</li>
<li>$\begin{aligned} R’ = &amp;\{ (⟨s,j⟩,⟨s’,j+1 \mod |J|⟩) | (s,s’) \in R \land s \in F_j\}\\ &amp;∪ \{(⟨s, j⟩,⟨s’, j⟩) |(s,s’) ∈ R ∧ s \notin F_j \} \end{aligned}$</li>
<li>简单公平状态$F’ = F_0 \times \{0\}$</li>
</ul>
<p>例：</p>
<p>带有多重公平性$F_0 = \{s_0\}$，$ F_1 =\{s_1\}$ 的ST系统<img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03 14.11.29.png" alt="2022-04-03 14.11.29" style="zoom:30%;">与下述带有简单公平性$\{(s_0,0)\}$的ST系统等价：</p>
<p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03 14.45.46.png" alt="2022-04-03 14.45.46" style="zoom:40%;"></p>
</li>
</ol>
<ol>
<li><p>一般情况（J 可能无限）。</p>
<p>下面的简单公平性系统$⟨S’, I’, R’⟩$ 是等价的（执行的平等投影到 S）：</p>
<ul>
<li><p>$S’ = S \times J \times J$</p>
</li>
<li><p>$I’ = I \times \{0\} \times \{0\}$</p>
</li>
<li><p>$\begin{aligned} R’ = &amp;\{ (⟨s,i,i⟩,⟨s’,i⊕1,0⟩) | (s,s’) \in R \land s \in F_j\}\\ &amp;∪ \{(⟨s,i,j⟩,⟨s’,i,j+1⟩) | j &lt; i \land (s,s’) \in R \land s \in F_j\} \\&amp;∪ \{(⟨s,i,j⟩,⟨s’,i,j⟩) |(s,s’) ∈ R ∧ s \notin F_j \} \end{aligned}$</p>
</li>
<li><p>简单公平状态$F’ = F_0 \times J \times \{0\}$</p>
<p>注：$ i⊕1 \triangleq \begin{cases} i+1\;(if\;J是无限的) \\ i+1 \mod |J| \;(else)\end{cases}$</p>
</li>
</ul>
</li>
</ol>
<blockquote>
<p>在公平执行中，计数器 i、j 形成一个三角形：$⟨(0, 0) → (1, 0) → (1, 1) → (2, 0) → (2, 1) → (2, 2) → (3, 0) → …⟩$</p>
</blockquote>
<p>例：带有多重公平性$F_0 = \{s_0\}$，$ F_1 =\{s_1\}$ 的ST系统<img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03 14.11.29.png" alt="2022-04-03 14.11.29" style="zoom:30%;">与下述带有简单公平性$\{(s_0,0,0)\}$，$\{(s_0,1,0)\}$的ST系统等价：</p>
<p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03 15.06.04.png" alt="2022-04-03 15.06.04" style="zoom:30%;"></p>
<h5 id="条件公平性"><a href="#条件公平性" class="headerlink" title="条件公平性"></a>条件公平性</h5><p>令 $⟨S, I, R⟩$ 是一个变迁系统，我们有两个集合 F 和 G。</p>
<p>任何执行 σ 必须满足 $Inf_S (F, σ) ⇒ Inf_S (G, σ)$。如果 $F$ 在 $σ$ 中循环，则 $G$ 必须在 $σ$ 中循环。</p>
<p>例：</p>
<p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03 12.23.47.png" alt="2022-04-03 12.23.47" style="zoom:40%;"></p>
<p>$Exec(S) = ⟨{s_0}^ω⟩,⟨{s_0}^+ \to s_1⟩,⟨{s_0}^+ \to s_2 \to (s_3 \to s_4) ^w⟩,⟨{s_0}^+ \to s_2 \to (s_3 \to s_4) ^+ \to s_5⟩$</p>
<ul>
<li>满足 $\{s_0\} ⇒ \{s_5\} $ 简单公平性的执行是：$⟨{s_0}^+ \to s_1⟩,⟨{s_0}^+ \to s_2 \to (s_3 \to s_4) ^w⟩,⟨{s_0}^+ \to s_2 \to (s_3 \to s_4) ^+ \to s_5⟩$</li>
<li>满足 $\{s_3\} ⇒ \{s_4\} $ 简单公平性的执行是：$Exec(S)$</li>
</ul>
<blockquote>
<p>满足 $\{s_3\} ⇒ \{s_4\}$ 条件公平性意味着什么？</p>
</blockquote>
<h4 id="关于转换的公平性"><a href="#关于转换的公平性" class="headerlink" title="关于转换的公平性"></a>关于转换的公平性</h4><h5 id="基于动作的公平性约束"><a href="#基于动作的公平性约束" class="headerlink" title="基于动作的公平性约束"></a>基于动作的公平性约束</h5><p>如何表述这类公平性约束？这里采用基于动作 $\mathcal{A}$ (action)的观点.</p>
<hr>
<p>弱可能性 ( $WF$ )：</p>
<p>我们说，一个 TLA 的 Action 动作 $\mathcal{A}$ 在状态 $s$ 下是“使能的” 或者“可触发的”(Enabled)，当且仅当系统的行为序列中可能存在着一个状态 $t$ 是 $s$ 的一个下一个后续状态，即 $⟨上一个状态\;s, 下一个状态\;t⟩$，并且这个二元组可以满足 $\mathcal{A}⟨s\to t⟩$ 这个动作规范。 </p>
<p>$WF_f(\mathcal{A})$ 表示一个这样的系统行为：如果存在这样的一个 TLA 动 作 $\mathcal{A} ∧ (f’ \neq f)$，一旦变成是“使能的”、“可触发的”，就保持着， 并且永远是“使能的”，“可触发的”，我们认为，那么这个系统就会出现无限多次（Infinitely Many) 的 $\mathcal{A} ∧ (f’ \neq f)$ 步骤。<u>换言之， 如果一旦<strong>出现一个 Action 动作的可能性</strong>并且一直保持着这种系统<strong>会执行这个动作的可能性</strong>，那么就<strong>一定会出现和发生</strong>，或者说，<strong>被执行无限多次</strong>。</u></p>
<p>强可能性 ( $SF$ )：</p>
<p>TLA 规约另外也定义了强公平性 (Strong Fairness) $SF_f (\mathcal{A})$，其中 $f$ 是一个状态函数，$\mathcal{A}$ 是一个 TLA 动作范式。 强公平性范式表示，如果 $\mathcal{A} ∧ (f’ \neq f)$ 在一个无限的系统行为里<strong>存在着</strong>无限频繁多次的可能性，那么 $\mathcal{A} ∧ (f’ \neq f)$ 就一定会出现无限多次。<u>如果一个动作范式在某个时间点变得永远可能，那么 也满足“无限经常”的条件。</u>因此，强公平性 $SF_f(\mathcal{A})$ 中蕴含了 $WF_f(\mathcal{A})$</p>
<blockquote>
<p>个人理解：</p>
<ul>
<li>在弱可能性 $WF_f(\mathcal{A})$ 中，$\mathcal{A}$ 满足 $⟨上一个状态\;s, 下一个状态\;t⟩$ 的二元组，即 $s \to t$。当 TLA 处于当前状态 $s$ 时，动作 $\mathcal{A}$ 是 “Enable”，<strong>则该动作 $\mathcal{A}$ 一定会发生（被执行无限多次）</strong>。</li>
<li>在强可能性 $SF_f(\mathcal{A})$ 中，$\mathcal{A}$ 满足 $⟨上一个状态\;s, 下一个状态\;t⟩$ 的二元组，即 $s \to t$。当 TLA 处于当前状态 $s$ 时，动作 $\mathcal{A}$ 是 “Enable”，<strong>则该动作 $\mathcal{A}$ 可能会发生（存在被执行无限多次的可能性）</strong>。</li>
</ul>
</blockquote>
<hr>
<p>公平属性是 <a target="_blank" rel="noopener" href="https://wikichi.icu/wiki/Precondition">前提条件</a> 施加在系统上以排除不切实际的痕迹。</p>
<ul>
<li>无条件公平的形式是<strong>“每个过程都会无休止地轮流使用”</strong>。</li>
<li>强公平性 (SF) 的形式是<strong>“如果无限频繁地启用它，则每个过程都将无限次地轮流运行”</strong>。</li>
<li>弱公平性 (WF) 的形式是<strong>“如果从某个特定点连续进行，则每个过程都会无限制地轮流转动”</strong>。</li>
</ul>
<p>之前我们看到了，LTL公式可以用来描述两进程互斥问题的公平性属性，现在我们将它推广到一般的公平性问题</p>
<p>设 $\phi$ 和 $\psi$ 是命题公式：</p>
<ul>
<li>无条件的公平性：$\Box\Diamond\psi$</li>
<li>强公平性：$\Box\Diamond\phi\rightarrow\Box\Diamond\psi$</li>
<li>弱公平性：$\Diamond\Box\phi\rightarrow\Box\Diamond\psi$</li>
</ul>
<p>对于公平性假设fair和LTL公式 $\phi$，我们有如下结论</p>
<script type="math/tex; mode=display">
s\vDash_{fair}\phi \\ \text{当且仅当 对于所有的π∈Paths(s),如果}π\vDash fair，那么π\vDash\phi \\ \text{当且仅当 }s\vDash (fair\rightarrow\phi)</script><p>其实这里想要表达的意思是，如果我们有了一套算法或者说流程可以验证TS系统是否满足LTL公式，那么我们可以用相同的流程步骤来检测在加入公平性约束的情况下，TS系统是否满足LTL公式。</p>
<p>对于一个没有终止状态的$TS=⟨S,I,R⟩$，$ \alpha ⊆ Act$，TS上的无限执行片段$ρ =s{0}\xrightarrow{α{0}} s{1}\xrightarrow{α{1}}…$，公平约束具有三种：</p>
<ol>
<li><p>如果$\rho$是<strong>无条件公平性（unconditionally A-fair）</strong>，那么无论何时</p>
<script type="math/tex; mode=display">
\text{if }\overset{∞}∃ j\ge 0,a_{j}∈A.</script><p>无条件A-fair的含义是，<u>无论在什么情况下，A中的动作总能无限经常次执行。</u></p>
</li>
<li><p>如果$\rho$是<strong>强公平性（strongly A-fair）</strong>，那么无论何时</p>
<script type="math/tex; mode=display">
(\overset{∞}∃ j.Act(s_{j}\cap A\ne ∅)\Rightarrow(\text{if }\overset{∞}∃ j\ge 0,a_{j}∈A)</script><blockquote>
<p>strongly A-fair的含义是，<u><strong>存在无限经常次A为enabled时，A中动作将会无限经常次执行</strong>。</u></p>
</blockquote>
</li>
<li><p>如果$\rho$是<strong>弱公平性（weakly A-fair）</strong>，那么无论何时</p>
<script type="math/tex; mode=display">
(\overset{∞}\forall j.Act(s_{j}\cap A\ne ∅)\Rightarrow(\text{if }\overset{∞}∃ j\ge 0,a_{j}∈A)</script><blockquote>
<p>weakly A-fair的含义是，<u><strong>从某个时刻起，A将会为enabled，从而A中动作将会无限经常次执行</strong>。</u></p>
</blockquote>
</li>
</ol>
<p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/20201126194333746.png" alt="20201126194333746" style="zoom:70%;"></p>
<blockquote>
<p>strong和weak引入了enabled这个概念，</p>
<p>strongly A-fair要求在enable的片段中动作能够无限经常次执行，而在not enabled的片段中没有规定</p>
<p>weakly A-fair则是，不管之前如何，如果在某一个时间点之后，动作持续一直enabled，那么在这片段中动作要求能够无限经常次执行。</p>
<p>从上面的定义中我们可以容易得到</p>
<script type="math/tex; mode=display">
\text{unconditionally A-fair}\Rightarrow \text{strongly A-fair}\Rightarrow \text{weakly A-fair}</script><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/20201126192818563.png" alt="20201126192818563" style="zoom:60%;"></p>
</blockquote>
<h3 id="第五部分：-LTL"><a href="#第五部分：-LTL" class="headerlink" title="第五部分：$LTL$"></a>第五部分：$LTL$</h3><h4 id="时间逻辑TL（Temporal-Logic）"><a href="#时间逻辑TL（Temporal-Logic）" class="headerlink" title="时间逻辑TL（Temporal Logic）"></a>时间逻辑TL（Temporal Logic）</h4><p>时间逻辑TL：用以表达与系统执行相关的属性。不能表达没有明确的转换关系，没有初始状态的概念。</p>
<p>TL逻辑定义为：</p>
<ul>
<li>一种语法：经典逻辑运算符加上时间运算符来谈论未来和过去。</li>
<li>语义：对象域（称为模型），我们将在其上测试公式的有效性，以及运算符的解释。</li>
</ul>
<h4 id="线性时间逻辑LTL（Linear-Temporal-Logic）"><a href="#线性时间逻辑LTL（Linear-Temporal-Logic）" class="headerlink" title="线性时间逻辑LTL（Linear Temporal Logic）"></a>线性时间逻辑LTL（Linear Temporal Logic）</h4><h5 id="LTL模型"><a href="#LTL模型" class="headerlink" title="LTL模型"></a>LTL模型</h5><p>LTL 公式总是与系统的<strong>给定迹</strong> $σ$ 相关：<strong>迹构成该逻辑的模型。</strong></p>
<blockquote>
<p>注意：我们经常说即时而不是状态，以指定迹 $σ$ 的元素。</p>
</blockquote>
<h5 id="LTL语法"><a href="#LTL语法" class="headerlink" title="LTL语法"></a>LTL语法</h5><ul>
<li>$s$：表示s在<strong>当前时刻成立</strong>，在轨迹表现为在第一个位置成立</li>
<li>$\neg P$</li>
<li>$P \lor Q$</li>
<li>$P \land Q$</li>
<li>$\bigcirc P$：表示P在<strong>下一个时刻成立</strong>，在轨迹表现为第二个位置成立</li>
<li>$\Box P$：表示<strong>P总是(always)成立</strong>，即在<strong>全部的时刻都成立</strong>，在轨迹上表现为每个位置都成立，$\Box P=\lnot \Diamond \lnot P$ </li>
<li>$\Diamond P$：表示的是<strong>P最终(eventually)能够成立</strong>，在轨迹上表现为，在<strong>某一个时刻的时候P成立</strong>，$\Diamond P = \lnot \Box \lnot P$ : $P$ 不永远为假 $\to$ 存在 $P$ 为真（在这个序列的某个点上 $F$ 为真，哪个点我不关心） </li>
<li>$\Diamond \Box P$：表示在某一个点之后 $F$ 永远为真。 </li>
<li>$\Box \Diamond P$：表示存在无穷多个点 $F$ 为真。有一个执行序列 $Exec$，任给一个迹 $\sigma$，总要包含一个 $F$ 为真。</li>
<li>$P \mathcal{U} Q$：表示<strong>直到Q成立前，P一直成立</strong></li>
<li>$P \rightsquigarrow Q$：表示<strong>当P成立时，Q一会后也成立</strong>。如果 $P$ 在某个点上为真了，那么 $Q$一定在后面的某个点上为真</li>
</ul>
<p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03 16.06.08.png" alt="2022-04-03 16.06.08" style="zoom:40%;"></p>
<h6 id="最小的运算符"><a href="#最小的运算符" class="headerlink" title="最小的运算符"></a>最小的运算符</h6><p>最小的运算符是$\bigcirc P$ 和 $P \mathcal{U}Q$：</p>
<ul>
<li>$\Diamond P \triangleq True \; \mathcal{U} P$</li>
<li>$\Box P \triangleq \neg \Diamond \neg P$ </li>
<li>$P \rightsquigarrow Q \triangleq \Box (P ⇒ \Diamond Q)$</li>
</ul>
<h6 id="替代语法"><a href="#替代语法" class="headerlink" title="替代语法"></a>替代语法</h6><p>我们可以使用另一种语法：</p>
<ul>
<li>$\Box ↔ G$（Globally）</li>
<li>$\Diamond ↔ F$（Finally）</li>
<li>$\bigcirc↔ X$（Next）</li>
</ul>
<h6 id="互补运算符"><a href="#互补运算符" class="headerlink" title="互补运算符"></a>互补运算符</h6><p>运算符 <code>wating-for</code>（或 <code>unless</code> 或 <code>weak-less</code>）: Q 可能最终为真，同时 P 仍然为真</p>
<p>$P\; \mathcal{W}\;Q \triangleq \Box P ∨ P \mathcal{U}Q$</p>
<h6 id="释放运算符"><a href="#释放运算符" class="headerlink" title="释放运算符"></a>释放运算符</h6><p>$P \; \mathcal{R} \; Q \triangleq Q \mathcal{U}(P ∧ Q)$Q :  保持为真，直到 P 变为真。</p>
<h6 id="过去式运算符"><a href="#过去式运算符" class="headerlink" title="过去式运算符"></a>过去式运算符</h6><ul>
<li>$\ominus P$：<code>previous</code> : P 在前一个瞬间为真</li>
<li>$\boxminus P$：<code>has-always-been</code> : P 一直是真实的直到当前时刻</li>
<li>$ \diamond P$：<code>once</code> : P 在过去是真的</li>
<li>$P\; \mathcal{S}\;Q$：<code>since</code> : 自 Q 过去一直为真，而 P 自上次出现 Q 以来一直为真</li>
<li>$P\; \mathcal{B}\;Q$：<code>back-to</code> : P 自上次出现 Q 以来为真，或者如果 Q 从未为真，则自初始时刻起为真</li>
</ul>
<h5 id="LTL语义"><a href="#LTL语义" class="headerlink" title="LTL语义"></a>LTL语义</h5><p>我们用 $(σ, i)$ 表示后缀为 $⟨s_i → s_i+1 → …⟩$ 的迹 $σ = ⟨s0 → s1 → …⟩$</p>
<h6 id="系统验证"><a href="#系统验证" class="headerlink" title="系统验证"></a>系统验证</h6><p>系统 $S$ 验证（valid）公式 $F$ 当且仅当 $S$ 的所有执行从初始时刻验证它：</p>
<script type="math/tex; mode=display">
\frac{\forall σ \in Exec(S):(σ,0) \models F}{S \models F}</script><h6 id="P-land-Q"><a href="#P-land-Q" class="headerlink" title="$P\land Q$"></a>$P\land Q$</h6><p>$(\sigma,i) \models P \land Q$ 当且仅当$(\sigma ,i) \models P$ <strong>并且</strong> $(\sigma ,i) \models Q$ </p>
<script type="math/tex; mode=display">
\frac{(\sigma,i) \models P\qquad(\sigma,i) \models Q}{(\sigma,i) \models P \land Q}</script><h6 id="P-lor-Q"><a href="#P-lor-Q" class="headerlink" title="$P\lor Q$"></a>$P\lor Q$</h6><p>$(\sigma,i) \models P \land Q$ 当且仅当$(\sigma ,i) \models P$ <strong>或者</strong> $(\sigma ,i) \models Q$ </p>
<script type="math/tex; mode=display">
\frac{(\sigma,i) \models P}{(\sigma,i) \models P \lor Q} \qquad
\frac{(\sigma,i) \models Q}{(\sigma,i) \models P \lor Q}</script><h6 id="neg-P"><a href="#neg-P" class="headerlink" title="$\neg P$"></a>$\neg P$</h6><script type="math/tex; mode=display">
\frac{\neg (\sigma,i) \models P}{(\sigma,i) \models \neg P}</script><h6 id="s"><a href="#s" class="headerlink" title="$s$"></a>$s$</h6><script type="math/tex; mode=display">
\frac{\sigma_i=s}{(\sigma,i) \models s}</script><h6 id="bigcirc-P"><a href="#bigcirc-P" class="headerlink" title="$\bigcirc P$"></a>$\bigcirc P$</h6><p>$(\sigma,i) \models \bigcirc P$ 当且仅当对使$suffix(\sigma,1) = \sigma_{1},\sigma_{2},\sigma_{3}…\models P$</p>
<script type="math/tex; mode=display">
\frac{(\sigma,i+1) \models P}{(\sigma,i) \models \bigcirc P}</script><h6 id="P-mathcal-U-Q"><a href="#P-mathcal-U-Q" class="headerlink" title="$P\;\mathcal{U}\;Q$"></a>$P\;\mathcal{U}\;Q$</h6><p>$(\sigma,i) \models P\;\mathcal{U}\;Q$ 存在 $j \ge 0$ 使得 $suffix(\sigma,j)=\sigma_{j},\sigma_{j+1},\sigma_{j+2}…\models Q$ 且 $suffix(\sigma,i)=\sigma_{i}, \sigma_{i+1}, \sigma_{i+2}…\models P$ ，$0\le i\lt 1$</p>
<script type="math/tex; mode=display">
\frac{\{∃ k \ge 0:(\sigma,i+k) \models Q\} \land \{ \forall k',0 \le k' \le k:(\sigma, i+k')\models P\} } {(\sigma,i) \models P \mathcal{U} Q}</script><h6 id="Diamond-P"><a href="#Diamond-P" class="headerlink" title="$\Diamond P$"></a>$\Diamond P$</h6><p>$(\sigma,i) \models \Diamond P$ 当且仅当<strong>存在</strong> $i \ge 0$使得 $\sigma_{j},\sigma_{j+1},\sigma_{j+2}…\models P$</p>
<script type="math/tex; mode=display">
\frac{∃k \ge 0 :(\sigma ,i+k) \models P}{(\sigma,i) \models \Diamond P}</script><h6 id="Box-P"><a href="#Box-P" class="headerlink" title="$\Box P$"></a>$\Box P$</h6><p>$(\sigma,i) \models \Box P$ 当且仅当<strong>对所有</strong> $i \ge 0$使得 $\sigma_{j},\sigma_{j+1},\sigma_{j+2}…\models P$</p>
<script type="math/tex; mode=display">
\frac{\forall k \ge 0 :(\sigma ,i+k) \models P}{(\sigma,i) \models \Box P}</script><h6 id="P-rightsquigarrow-Q"><a href="#P-rightsquigarrow-Q" class="headerlink" title="$P \rightsquigarrow Q$"></a>$P \rightsquigarrow Q$</h6><script type="math/tex; mode=display">
\frac{\{\forall k \ge 0 :(\sigma ,i+k) \models P \} \Rightarrow \{∃ k' \ge k :(\sigma ,i+k') \models Q\} } { (\sigma,i) \models P \rightsquigarrow Q}</script><h5 id="简化为纯逻辑"><a href="#简化为纯逻辑" class="headerlink" title="简化为纯逻辑"></a>简化为纯逻辑</h5><p>线性时序逻辑具有这样的表达能力，以至于它可以准确地表示根据转换系统描述的任何操作规范，因此：</p>
<ul>
<li>检查变迁系统 M 是否具有时间属性 $F_{\mathcal{S}pec}$：</li>
</ul>
<script type="math/tex; mode=display">
\mathcal{M} \models F_{\mathcal{S}pec}</script><ul>
<li>相当于确定以下各项的有效性：<script type="math/tex; mode=display">
F_{\mathcal{M}} ⇒ F_{\mathcal{S}pec}</script>其中 $F_{\mathcal{M}}$ 是一个公式，准确地表示模型 ${\mathcal{M}}$ 的执行（即它的初始状态、它的转换、它的公平性约束）。</li>
</ul>
<h4 id="例题（考试必考）"><a href="#例题（考试必考）" class="headerlink" title="例题（考试必考）"></a>例题（考试必考）</h4><h5 id="例1"><a href="#例1" class="headerlink" title="例1"></a>例1</h5><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03 17.18.20.png" alt="2022-04-03 17.18.20" style="zoom:50%;"></p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>无公平性</th>
<th>简单公平性($s_1,s_2$)</th>
</tr>
</thead>
<tbody>
<tr>
<td>$s_0 \land \bigcirc s_0$</td>
<td>$n (s_0→{s_1}^ω) $</td>
<td>n</td>
</tr>
<tr>
<td>$s_0 \land \bigcirc (s_0 \lor s_1)$</td>
<td>o</td>
<td>o</td>
</tr>
<tr>
<td>$\Box (s_0 ⇒ \bigcirc s_0)$</td>
<td>$n (s_0→{s_1}^ω) $</td>
<td>n</td>
</tr>
<tr>
<td>$\Box (s_0 ⇒ \bigcirc (s_0 \lor s_1)$</td>
<td>o</td>
<td>o</td>
</tr>
<tr>
<td>$\Box (s_0 ⇒ \bigcirc s_1)$</td>
<td>o</td>
<td>o</td>
</tr>
<tr>
<td>$\Diamond (s_0 ⇒ \bigcirc s_1)$</td>
<td>$n ({s_0}^ω) $</td>
<td>o</td>
</tr>
<tr>
<td>$\Box s_0$</td>
<td>$n (s_0→{s_1}^ω) $</td>
<td>n</td>
</tr>
<tr>
<td>$\Diamond \neg s_0$</td>
<td>$n ({s_0}^ω) $</td>
<td>o</td>
</tr>
<tr>
<td>$\Diamond \Box s_0$</td>
<td>$n ({s_0}^ω) $</td>
<td>o</td>
</tr>
<tr>
<td>$s_0 \mathcal{W} s_1$</td>
<td>o</td>
<td>o</td>
</tr>
<tr>
<td>$s_0 \mathcal{U} s_1$</td>
<td>$n ({s_0}^ω) $</td>
<td>o</td>
</tr>
</tbody>
</table>
</div>
<h5 id="例2"><a href="#例2" class="headerlink" title="例2"></a>例2</h5><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03 17.34.49.png" alt="2022-04-03 17.34.49" style="zoom:50%;"></p>
<p>$Exec(S) = ⟨s_0 \to {s_1}^w⟩, ⟨(s_0 \to {s_1}^+)^w⟩, ⟨(s_0 \to {s_1}^+)^+ \to {s_2}^w⟩$</p>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>无公平性</th>
<th>$\mathcal{W_{eak}F_{airness}}(s_1,s_2)$</th>
<th>$\mathcal{S_{trong}F_{airness}}(s_1,s_2)$</th>
</tr>
</thead>
<tbody>
<tr>
<td>$\Box \Diamond \neg s_1$</td>
<td>$n (s_0→{s_1}^ω) $</td>
<td>o</td>
<td>o</td>
</tr>
<tr>
<td>$\Box (s_1 ⇒ \Diamond s_2)$</td>
<td>$n (s_0→{s_1}^ω) $</td>
<td>$n ((s_0→s_1)^ω) $</td>
<td>o</td>
</tr>
<tr>
<td>$\Diamond \Box (s_1 \lor s_2)$</td>
<td>$n ((s_0→s_1)^ω) $</td>
<td>n</td>
<td>o</td>
</tr>
<tr>
<td>$\Box (s_1 \mathcal{U} s_2)$</td>
<td>$n (s_0→…) $</td>
<td>n</td>
<td>n</td>
</tr>
<tr>
<td>$\Box (s_0 ⇒ s_0 \mathcal{U} s_1)$</td>
<td>o</td>
<td>o</td>
<td>o</td>
</tr>
<tr>
<td>$\Box(s_0 \mathcal{U} (s_1 \lor s_2))$</td>
<td>o</td>
<td>o</td>
<td>o</td>
</tr>
<tr>
<td>$\Box (s_1 ⇒ s_1 \mathcal{U} s_2)$</td>
<td>$n (s_0→{s_1}^ω) $</td>
<td>$n ((s_0→s_1)^ω) $</td>
<td>$n (s0→s1→s0→s1→s2^ω) $</td>
</tr>
<tr>
<td>$\Diamond (s_1 \mathcal{U} s_2)$</td>
<td>$n (s_0→{s_1}^ω) $</td>
<td>$n ((s_0→s_1)^ω) $</td>
<td>o</td>
</tr>
<tr>
<td>$\Diamond (s_1 \mathcal{W} s_2)$</td>
<td>$n ((s_0→s_1)^ω) $</td>
<td>n</td>
<td>o</td>
</tr>
<tr>
<td>$\Box \Diamond (s_1 \mathcal{U} (s_0 \lor s_2))$</td>
<td>$n (s_0→{s_1}^ω) $</td>
<td>o</td>
<td>o</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>个人理解：以例1中的第一行 $\Box \Diamond \neg s_1 $ 为例，可以将其视为一个条件，意为在该条件下是否满足“无公平性” 和 “$WF(s_1,s_2)$”：</p>
<p>$\Box \Diamond \neg s_1 $ 意为 “对于所有迹，最终都会不出现 $s_1$” ，此时我们需要找出有否所有的迹都符合该条件。</p>
<ol>
<li><p>对于“无公平性”：由图可见存在一个迹 $\sigma = ⟨s_0 \to {s_1}^w⟩$ ，并不符合$\Box \Diamond \neg s_1 $ ，所以为<code>n(means no)</code>。</p>
</li>
<li><p>对于“$WF(s_1, s_2)$”：在转换 $s_0 \to s_1$ 下，条件 $\Box \Diamond \neg s_1 $ 并<strong>总是成立</strong></p>
</li>
<li><p>对于“$SF(s_1, s_2)$”：在转换 $s_0 \to s_1$ 下，条件 $\Box \Diamond \neg s_1 $ 并<strong>会成立</strong></p>
</li>
</ol>
</blockquote>
<h4 id="时间逻辑TL属性"><a href="#时间逻辑TL属性" class="headerlink" title="时间逻辑TL属性"></a>时间逻辑TL属性</h4><h5 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h5><p>没有什么不好的事情发生（<a href="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/#%E5%AE%89%E5%85%A8%E6%80%A7-safety">详见第三部分</a>）= 在执行的有限前缀上无效的属性：</p>
<ul>
<li>$\Box P$, $\Box (P ⇒ \Box P)$, $P \mathcal{W} Q$, …</li>
</ul>
<h5 id="活性"><a href="#活性" class="headerlink" title="活性"></a>活性</h5><p>美好的事情终会发生 = 始终可以通过扩展运行前缀来验证的属性：</p>
<ul>
<li>$\Diamond P$, $P \rightsquigarrow Q$, …</li>
</ul>
<h5 id="活性与安全性的组合属性"><a href="#活性与安全性的组合属性" class="headerlink" title="活性与安全性的组合属性"></a>活性与安全性的组合属性</h5><p> 一些活性与安全性的组合属性，例如</p>
<ul>
<li>$P \mathcal{U} Q$, $\Box P \land \Diamond Q$, …</li>
<li>Reponse: $\Box \Diamond P$</li>
<li>Persistance: $\Diamond \Box P$</li>
</ul>
<h5 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h5><p>指定系统可达状态的超集（<a href="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/#%E4%B8%8D%E5%8F%98%E6%80%A7-Invariants">详见第三部分</a>：</p>
<script type="math/tex; mode=display">
\mathcal{S} \models \Box P</script><p>其中 P 是状态谓词。</p>
<h5 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h5><p>指定情况发生时的稳定性：</p>
<script type="math/tex; mode=display">
\mathcal{S} \models \Box(P ⇒ \Box P)</script><p>其中 P 是状态谓词</p>
<h5 id="可能性"><a href="#可能性" class="headerlink" title="可能性"></a>可能性</h5><p>指定在某个执行中可能达到满足 $P$ 的某个状态：</p>
<ul>
<li>对于任意 $P$ 是不可能的，但对于 $P$ 是一个状态谓词：<script type="math/tex; mode=display">
\mathcal{S} \nvDash \Box \neg P</script>请注意<strong>否定性</strong>：$\neg \Box P = \Diamond \neg P$  但是 $\mathcal{S} \nvDash \Box P \nRightarrow \mathcal{S} \models \Diamond \neg P$</li>
</ul>
<h5 id="否定性"><a href="#否定性" class="headerlink" title="否定性"></a>否定性</h5><ul>
<li><p>对于 $σ$ 执行：$σ \models ¬P ≡ σ \nvDash P$</p>
</li>
<li><p>对于 $\mathcal{S}$ 系统： $\mathcal{S} \models ¬P ⇒ \mathcal{S} \nvDash P$ , 但不是等价的！</p>
<blockquote>
<p>$\mathcal{S} \nvDash P$ 表示至少有一次执行使 Q 无效（  $¬Q$ 有效），但并非所有执行都如此。</p>
<p>在 LTL 中，我们可以有$ S \nvDash Q ∧ S \nvDash ¬Q$ : </p>
<p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03 17.18.20.png" alt="2022-04-03 17.18.20" style="zoom:50%;"></p>
<script type="math/tex; mode=display">
\frac { {s_0}^+ → {s_1}^w \nvDash \Box s_0}{\mathcal{S} \nvDash \Box s_0} \qquad
\frac { {s_0}^w \nvDash \Diamond \neg s_0}{\mathcal{S} \nvDash \Diamond \neg s_0}</script></blockquote>
</li>
</ul>
<h5 id="无限经常"><a href="#无限经常" class="headerlink" title="无限经常"></a>无限经常</h5><p>指定 $P$ 在任何执行中都无限地经常为真：</p>
<script type="math/tex; mode=display">
\mathcal{S} \models \Box \Diamond P</script><h5 id="最终总是"><a href="#最终总是" class="headerlink" title="最终总是"></a>最终总是</h5><p>指定 $P$ 最终保持绝对真：</p>
<script type="math/tex; mode=display">
\mathcal{S} \models \Diamond \Box P</script><h4 id="LTL公式的性质"><a href="#LTL公式的性质" class="headerlink" title="LTL公式的性质"></a>LTL公式的性质</h4><h5 id="对偶率-Duality-laws"><a href="#对偶率-Duality-laws" class="headerlink" title="对偶率(Duality laws)"></a>对偶率(Duality laws)</h5><script type="math/tex; mode=display">
\lnot\Box\phi\equiv\Diamond\lnot\phi \\ \lnot\Diamond\phi\equiv\Box\lnot\phi \\ \lnot\bigcirc\phi\equiv\bigcirc\lnot\phi</script><h5 id="幂等律-Idempotence-laws"><a href="#幂等律-Idempotence-laws" class="headerlink" title="幂等律(Idempotence laws)"></a>幂等律(Idempotence laws)</h5><script type="math/tex; mode=display">
\Box\Box\phi\equiv\Box\phi \\ \Diamond\Diamond\phi\equiv\Diamond\phi \\ \phi U(\phi U\psi)\equiv\phi U\psi \\ (\phi U\psi)U\psi\equiv\phi U\psi</script><h5 id="吸收率-Absorption-laws"><a href="#吸收率-Absorption-laws" class="headerlink" title="吸收率(Absorption laws)"></a>吸收率(Absorption laws)</h5><script type="math/tex; mode=display">
\Diamond\Box\Diamond\phi\equiv\Box\Diamond\phi \\ \Box\Diamond\Box\phi\equiv\Diamond\Box\phi</script><h5 id="分配律-Distributive-laws"><a href="#分配律-Distributive-laws" class="headerlink" title="分配律(Distributive laws)"></a>分配律(Distributive laws)</h5><script type="math/tex; mode=display">
\bigcirc(\phi U\psi)\equiv (\bigcirc\phi)U(\bigcirc\psi) \\ \Diamond(\phi \vee\psi)\equiv (\Diamond\phi)\vee(\Diamond\psi) \\ \Box(\phi\wedge\psi)\equiv\Box\phi\wedge\Box\psi</script><h5 id="扩展率-Expansion-laws"><a href="#扩展率-Expansion-laws" class="headerlink" title="扩展率(Expansion laws)"></a>扩展率(Expansion laws)</h5><script type="math/tex; mode=display">
\phi U\psi\equiv\psi\vee(\phi\wedge\bigcirc(\phi U\psi)) \\ \Diamond\phi\equiv\phi\vee\bigcirc\Diamond\phi \\ \Box\phi\equiv\phi\wedge\bigcirc\Box\phi</script><p><strong>扩展率是非常重要的一条性质</strong>，之后的LTL模型检测都会基于此。</p>
<p>特别是这个第一条公式，我个人感觉其实它的意思就是基于当前项然后向后走了一步，就拿 $\phi \mathcal{U}\psi$ 来说，它代表 $\psi$ 成立前 $\phi$ 一直成立，</p>
<ol>
<li>首先看扩展出来的第一个 $\psi$ ，如果当前项是 $\psi$ 那么就代表到达了公式成立的条件，后面的也就可以不用管了；</li>
<li>然后再看第二项 $\phi\wedge\bigcirc(\phi U\psi)$ 如果当前项是 $\phi$ 还没有达到公式成立的条件，那么如果公式成立，对于下一步来说肯定是满足 $\phi \mathcal{U}\psi$ 的。</li>
</ol>
<h4 id="用公式来表示LT性质"><a href="#用公式来表示LT性质" class="headerlink" title="用公式来表示LT性质"></a>用公式来表示LT性质</h4><h5 id="公平性"><a href="#公平性" class="headerlink" title="公平性"></a>公平性</h5><p>例如我们可以用它来表示两进程互斥问题中的公平性：</p>
<ul>
<li>无条件的公平性：$\Box \Diamond crit_{i}$</li>
<li>强公平性：$\Box \Diamond wait_{i}\rightarrow \Box \Diamond crit_{i}$</li>
<li>弱公平性：$\Diamond\Box wait_{i}\rightarrow \Box \Diamond crit_{i}$</li>
</ul>
<h5 id="Weak-until"><a href="#Weak-until" class="headerlink" title="Weak until"></a>Weak until</h5><p>前面介绍的until操作，它是一种比较强的限制，而weak until操作（或者称为unless）定义为:</p>
<script type="math/tex; mode=display">
\phi W\psi=(\phi U\psi)\vee\Box\phi
ϕWψ=(ϕUψ)∨□ϕ</script><p>也就是说 $\phi \mathcal{W} \psi$ 表示为 $\phi \mathcal{U} \psi$ 成立或者 $\Box\phi$ 成立</p>
<p>weak until和until操作是对偶的，具体表现为：</p>
<script type="math/tex; mode=display">
\lnot(\phi \mathcal{U}\psi)=(\phi \wedge\lnot\psi)\mathcal{W}(\lnot\phi\wedge\lnot\psi) \\ \lnot(\phi \mathcal{W}\psi)=(\phi \wedge\lnot\psi)\mathcal{U}(\lnot\phi\wedge\lnot\psi)</script><p>weak until和until两者的表达能力是相同的，两者之间可以互换</p>
<script type="math/tex; mode=display">
\phi \mathcal{U} \psi=(\phi \mathcal{W} \psi)\wedge\lnot\Box\lnot\psi</script><p>也可以用它来表示一些其他属性：</p>
<h5 id="可达性"><a href="#可达性" class="headerlink" title="可达性"></a>可达性</h5><h6 id="简单可达性"><a href="#简单可达性" class="headerlink" title="简单可达性"></a>简单可达性</h6><script type="math/tex; mode=display">
\Diamond\psi</script><h6 id="带条件的可达性"><a href="#带条件的可达性" class="headerlink" title="带条件的可达性"></a>带条件的可达性</h6><script type="math/tex; mode=display">
\phi \mathcal{U} \psi</script><h6 id="安全性中的不变性"><a href="#安全性中的不变性" class="headerlink" title="安全性中的不变性"></a>安全性中的不变性</h6><script type="math/tex; mode=display">
\Box\phi</script><h6 id="活性-1"><a href="#活性-1" class="headerlink" title="活性"></a>活性</h6><script type="math/tex; mode=display">
\Box(\phi\Rightarrow\Diamond\psi)</script><h4 id="LTL公式的一些例子"><a href="#LTL公式的一些例子" class="headerlink" title="LTL公式的一些例子"></a>LTL公式的一些例子</h4><h5 id="Client-Server"><a href="#Client-Server" class="headerlink" title="Client / Server"></a>Client / Server</h5><h6 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h6><p>指定系统（扮演服务器的角色）总是响应（Q）给定的请求（P）：</p>
<script type="math/tex; mode=display">
\mathcal{S} \models \Box (P ⇒ \Diamond Q)</script><p>通常称为<code>lead-to</code>：</p>
<script type="math/tex; mode=display">
\mathcal{S} \models P \rightsquigarrow Q</script><h6 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h6><p>指定来自系统（扮演客户端的角色）的请求 P 只要没有有利的响应 Q 就稳定：</p>
<script type="math/tex; mode=display">
\mathcal{S} \models \Box (P ⇒ P \mathcal{W} Q)</script><h5 id="互斥问题"><a href="#互斥问题" class="headerlink" title="互斥问题"></a>互斥问题</h5><p>两个进程不能同时进入临界区：</p>
<script type="math/tex; mode=display">
\Box(\lnot crit_{1}\vee \lnot crit_{2}) \\
OR \qquad \Box(\forall i,j \in 0..N-1: state[i]=crit \;\land\;state[j]=crit \quad \Rightarrow \quad i=j )</script><h5 id="无饥饿"><a href="#无饥饿" class="headerlink" title="无饥饿"></a>无饥饿</h5><p>两个进程可以无限经常次访问临界区：</p>
<script type="math/tex; mode=display">
(\Box\Diamond w_{1}\Rightarrow\Box\Diamond c_{1})\wedge(\Box\Diamond w_{2}\Rightarrow\Box\Diamond c_{2})\\
OR \qquad \forall i \in 0..N-1:state[i]=waiting \;\rightsquigarrow\; state[i]=crit</script><h5 id="火车轨道通行问题"><a href="#火车轨道通行问题" class="headerlink" title="火车轨道通行问题"></a>火车轨道通行问题</h5><script type="math/tex; mode=display">
\Box(train\_is\_near\rightarrow gate\_is\_close)</script><h5 id="进程通信"><a href="#进程通信" class="headerlink" title="进程通信"></a>进程通信</h5><script type="math/tex; mode=display">
 \Box(request\rightarrow \Diamond response)</script><h3 id="第六部分：-TLA"><a href="#第六部分：-TLA" class="headerlink" title="第六部分：$TLA^+$"></a>第六部分：$TLA^+$</h3><h4 id="TLA-逻辑"><a href="#TLA-逻辑" class="headerlink" title="$TLA+$ 逻辑"></a>$TLA+$ 逻辑</h4><p>$TLA+$ 是一种状态机思维，只要初始是正确的，规则是正确的，那么结果就一定是正确的。不管系统经历了怎样的运行路径。（类似于数学归纳法）</p>
<h5 id="逻辑表达式"><a href="#逻辑表达式" class="headerlink" title="逻辑表达式"></a>逻辑表达式</h5><p>带有 $\Box$ , $\Diamond$ , $\rightsquigarrow$的 LTL 表达式和引发变量 + 量词 $∀$，$∃$。</p>
<p>没有 $\mathcal{U}$，也没有 $\mathcal{W}$，但是：</p>
<ul>
<li>$\Box (p ⇒ (p \mathcal{W}q)) = \Box (p ⇒ (p’ \lor q))$</li>
<li>$\Box (p ⇒ (p \mathcal{U}q)) = \Box (p ⇒ (p’ \lor q)) \land \Box(p ⇒ \Diamond q)$</li>
</ul>
<h5 id="公平性-1"><a href="#公平性-1" class="headerlink" title="公平性"></a>公平性</h5><h6 id="ENABLE"><a href="#ENABLE" class="headerlink" title="ENABLE"></a>ENABLE</h6><p>$_{ENABLE} \mathcal{A}$ 是在状态 $s$ 中为真的状态函数，当且仅当存在通过动作 $\mathcal{A}$  从 $s$ 可访问的状态 t。</p>
<h6 id="弱-强公平"><a href="#弱-强公平" class="headerlink" title="弱/强公平"></a>弱/强公平</h6><ul>
<li><p>$\mathcal{WF}_e(\mathcal{A}) \triangleq \Box \Diamond \neg (_{ENABLE} ⟨\mathcal{A}⟩_e) \lor \Box \Diamond ⟨\mathcal{A}⟩_e$</p>
<p>如果 $\mathcal{A}$ 是持续可触发的，它将被触发。</p>
</li>
<li><p>$\mathcal{SF}_e(\mathcal{A}) \triangleq \Diamond \Box \neg (_{ENABLE} ⟨\mathcal{A}⟩_e) \lor \Box \Diamond ⟨\mathcal{A}⟩_e$</p>
<p>如果 A 是无限频繁可触发的，它将被触发。</p>
</li>
</ul>
<h5 id="TLA-规范的形式"><a href="#TLA-规范的形式" class="headerlink" title="TLA+ 规范的形式"></a>TLA+ 规范的形式</h5><p>通常，TLA+ 规范是一系列谓词的连词(conjonction)：</p>
<script type="math/tex; mode=display">
\mathcal{I} \land \Box [\mathcal{N}]_v \land \mathcal{E}</script><ul>
<li>$\mathcal{I}$ = 描述初始状态的状态谓词；</li>
<li>$\mathcal{N}$ = 动作 $A_1 ∨ A_2 ∨ A_3 ∨… $的分解(disjonction)；</li>
<li>$\mathcal{E}$ = 行动公平性约束的合取(conjonction)：$\mathcal{WF}_v(\mathcal{A}_1) \land \mathcal{WF}_v(\mathcal{A}_3) \land …$</li>
</ul>
<h5 id="规约的细化"><a href="#规约的细化" class="headerlink" title="规约的细化"></a>规约的细化</h5><p>如果 $P_c ⇒ P_a$，则一个具体的规约 $P_c$ 细化（raffine）一个抽象的规约 $P_a$：$P_c$ 所做的一切在 $P_a$ 中都是可能的。</p>
<p>这意味着如果 $P_a \models P$ 满足 LTL 属性，则 $P_c \models P$ 也满足LTL属性。</p>
<h6 id="例1-1"><a href="#例1-1" class="headerlink" title="例1"></a>例1</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">-----------------module somme1----------------</span><br><span class="line">EXTENDS Naturals</span><br><span class="line">CONSTANT N</span><br><span class="line">VARIABLE res</span><br><span class="line"></span><br><span class="line">TypeInvariant == res \in Nat</span><br><span class="line">Init == res = 0</span><br><span class="line">Next == res′ = ((N + 1) * N) / 2</span><br><span class="line">Spec == Init ∧ [][Next]_res /\ WF_res (Next)</span><br></pre></td></tr></table></figure>
<p>当 $N = 3$ 时的执行图:</p>
<p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03 22.03.52.png" alt="2022-04-03 22.03.52" style="zoom:40%;"></p>
<h6 id="例2-1"><a href="#例2-1" class="headerlink" title="例2"></a>例2</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">----------------- module somme2 ----------------</span><br><span class="line">EXTENDS Naturals</span><br><span class="line">CONSTANT N</span><br><span class="line">VARIABLE res, acc, disp</span><br><span class="line"></span><br><span class="line">TypeInvariant == res \in Nat</span><br><span class="line">		/\ acc \in Nat</span><br><span class="line">		/\ disp \in SUBSET 1..N</span><br><span class="line">Init == res = 0</span><br><span class="line">	/\ acc = 0</span><br><span class="line">	/\ disp = 1..N</span><br><span class="line">Next == \/ \E i \in disp : acc&#x27; = acc + i /\ disp&#x27; = disp \ &#123;i&#125;</span><br><span class="line">					/\ UNCHANGED res</span><br><span class="line">	\/ disp = &#123;&#125; /\ res&#x27; = acc /\ UNCHANGED res</span><br><span class="line">Spec == Init ∧ [][Next]_&lt;&lt;res, disp, acc&gt;&gt; /\ WF_&lt;&lt;res, disp, acc&gt;&gt; (Next)</span><br></pre></td></tr></table></figure>
<p>当 $N = 3$ 时的执行图:</p>
<p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03 22.11.22.png" alt="2022-04-03 22.11.22"></p>
<p>分解：引入中间转换</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---------------- module somme2_raffine_somme1 ----------------</span><br><span class="line">EXTENDS somme2</span><br><span class="line">Orig == INSTANCE somme1</span><br><span class="line">Raffinement == Orig ! Spec</span><br><span class="line">THEOREM Spec =&gt; Orig ! Spec</span><br></pre></td></tr></table></figure>
<h6 id="例3"><a href="#例3" class="headerlink" title="例3"></a>例3</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">----------------- module somme3 ----------------</span><br><span class="line">EXTENDS Naturals</span><br><span class="line">CONSTANT N</span><br><span class="line">VARIABLE res, acc, i</span><br><span class="line"></span><br><span class="line">TypeInvariant == res \in Nat</span><br><span class="line">		/\ acc \in Nat</span><br><span class="line">		/\ i \in 1..N</span><br><span class="line">Init == res = 0</span><br><span class="line">	/\ acc = 0</span><br><span class="line">	/\ i = N</span><br><span class="line">Next == \/ i &gt; 0 /\ acc&#x27; = acc + i /\ i&#x27; = i - 1 /\ UNCHANGED res</span><br><span class="line">	\/ i = 0 /\ res&#x27; = acc /\ UNCHANGED &lt;&lt;i, res&gt;&gt;</span><br><span class="line">Spec == Init ∧ [][Next]_&lt;&lt;res, i, acc&gt;&gt; /\ WF_&lt;&lt;res, i, acc&gt;&gt; (Next)</span><br></pre></td></tr></table></figure>
<p>当 $N = 3$ 时的执行图:</p>
<p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-03 22.19.49.png" alt="2022-04-03 22.19.49" style="zoom:50%;"></p>
<p>减少非确定性 + 表示变化（数据细化） $disp = 1..i$</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---------------- module somme3_raffine_somme2 ----------------</span><br><span class="line">EXTENDS somme3</span><br><span class="line">dispMapping == 1..i</span><br><span class="line">Orig == INSTANCE somme2 WITH disp &lt;- dispMapping</span><br><span class="line">Raffinement == Orig ! Spec</span><br><span class="line">THEOREM Spec =&gt; Orig ! Spec</span><br></pre></td></tr></table></figure>
<h4 id="公理证明"><a href="#公理证明" class="headerlink" title="公理证明"></a>公理证明</h4><h5 id="简单时序逻辑"><a href="#简单时序逻辑" class="headerlink" title="简单时序逻辑"></a>简单时序逻辑</h5><script type="math/tex; mode=display">
\frac{F 在命题逻辑中可证明}{\Box F} \;STL1</script><p>意义：</p>
<script type="math/tex; mode=display">
\frac{}{\Box F ⇒ F} \;STL2</script><script type="math/tex; mode=display">
\frac{}{\Box \Box F = \Box G} \;STL3</script><script type="math/tex; mode=display">
\frac{F ⇒ G}{\Box F ⇒ \Box G} \;STL4</script><script type="math/tex; mode=display">
\frac{}{\Box (F \land G) = (\Box F) \land (\Box G)} \;STL5</script><script type="math/tex; mode=display">
\frac{}{ (\Diamond \Box F) \land (\Diamond \Box G) = \Diamond \Box (F \land G)} \;STL6</script><h5 id="不变性-1"><a href="#不变性-1" class="headerlink" title="不变性"></a>不变性</h5><script type="math/tex; mode=display">
\frac{P \land (v' = v) ⇒ P'}{\Box P = P \land \Box [P ⇒ P']_v} \;TLA1</script><script type="math/tex; mode=display">
\frac{P \land [\mathcal{A}]_{v1} ⇒ Q \land [\mathcal{B}]_{v2}}{\Box P \land \Box [\mathcal{A}]_{v1} ⇒ \Box Q \land \Box[\mathcal{B}]_{v2}} \;TLA2</script><script type="math/tex; mode=display">
\frac{I \land [\mathcal{N}]_{v} ⇒ I'}{I \land \Box[\mathcal{N}]_{v} ⇒ \Box I} \;INV1</script><script type="math/tex; mode=display">
\frac{}{\Box I ⇒ (\Box[\mathcal{N}]_{v} = \Box [\mathcal{N} \land I \land I']_v)} \;INV2</script><h5 id="活性-2"><a href="#活性-2" class="headerlink" title="活性"></a>活性</h5><script type="math/tex; mode=display">
\frac{\begin{aligned} P \land [\mathcal{N}]_v ⇒ (P' \lor Q') \\ P \land ⟨\mathcal{N} \land \mathcal{A}⟩_v ⇒ Q' \\ P ⇒ _{ENABLE} ⟨\mathcal{A}⟩_v\end{aligned}}{\Box [\mathcal{N}]_v) \land WF_v(\mathcal{A}) ⇒ (P \rightsquigarrow Q)} \;WF1</script><script type="math/tex; mode=display">
\frac{\begin{aligned} P \land [\mathcal{N}]_v ⇒ (P' \lor Q') \\ P \land ⟨\mathcal{N} \land \mathcal{A}⟩_v ⇒ Q' \\ \Box P \land \Box [\mathcal{N}]_v \land \Box F ⇒ \Diamond  _{ENABLE} ⟨\mathcal{A}⟩_v\end{aligned}}{\Box [\mathcal{N}]_v) \land SF_v(\mathcal{A}) \land \Box F ⇒ (P \rightsquigarrow Q)} \;WF1</script><h5 id="推导规则"><a href="#推导规则" class="headerlink" title="推导规则"></a>推导规则</h5><script type="math/tex; mode=display">
\frac{\Box(P ⇒ \Box P) \land \Diamond P}{\Diamond \Box P} \;LDSTBL</script><script type="math/tex; mode=display">
\frac{P \rightsquigarrow Q \land Q \rightsquigarrow R}{P \rightsquigarrow R} \;TRANS</script><script type="math/tex; mode=display">
\frac{\forall m \in W : P(m) \rightsquigarrow Q}{(∃ m \in W : P(m)) \rightsquigarrow Q} \;INFDIJ</script><h4 id="模型检查"><a href="#模型检查" class="headerlink" title="模型检查"></a>模型检查</h4><p>原则：构建执行图并研究属性。</p>
<ul>
<li>$\Box P$，其中 $P$ 是一个状态谓词（没有初始变量）：随着状态的构建。</li>
<li>$\Box P (v,v’)$，其中 $P(v,v’)$ 是一个转换谓词（具有带素变量和非素数变量的非时间谓词）：计算转换时。</li>
<li>活跃度 $\Diamond P$ ,  $P \rightsquigarrow Q$ , … ：一旦建立了图，寻找一个尊重公平约束并使属性无效的循环。</li>
</ul>
<h5 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h5><p>让系统 $\mathcal{S} = ⟨S, I, R⟩$ 的状态数$|S|$ 和 LTL的 $\mathcal{F}$ 公式的大小$|F|$（时间运算符的数量）。</p>
<p>验证 $\mathcal{S} \models \mathcal{F}$ 的时间（和空间）复杂度为</p>
<script type="math/tex; mode=display">
O(|S| × 2^{|F|})</script><h5 id="TLC检查器"><a href="#TLC检查器" class="headerlink" title="TLC检查器"></a>TLC检查器</h5><p>TLC 模型检查器可以检查：</p>
<ol>
<li><p>带有保护的动作的规约；</p>
</li>
<li><p>没有初始变量的不变量 $\Box P$，其中 P 是状态谓词；</p>
</li>
<li><p>带有素变量（prime variables ）和重复（begaiement）的纯安全公式 $\Box [P]_v$ , 其中 P 是转换谓词；</p>
</li>
<li><p>$P \rightsquigarrow Q$ , 其中 P 和 Q 是状态谓词（没有素变量）；</p>
</li>
<li><p>将 $\Box$、$\Diamond $ 组合在一起的公式，没有带底数的变量。</p>
<p>注意：系统和公式的状态空间必须是有限的：例如任何有界量化。</p>
</li>
</ol>
<h3 id="第七部分：-CTL"><a href="#第七部分：-CTL" class="headerlink" title="第七部分：$CTL$"></a>第七部分：$CTL$</h3><p>在前面我们已经介绍了线性属性，为了方便地去描述这个线性属性，我们又介绍了线性时序逻辑，本节要介绍一种新的逻辑计算树逻辑（CTL），这种逻辑可以描述LTL不能描述的部分。</p>
<p>如果用文氏图来表示的话就是：</p>
<p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/20201209125629367.png" alt="20201209125629367" style="zoom:40%;"></p>
<hr>
<p>让我们先来回想一下LTL之所以称为线性的，是因为时间的定性概念是<strong>基于路径</strong>的，并且被视为<strong>线性的</strong>：在每个时刻只有唯一的一个可能的后继状态，因此每个时刻都有一个唯一的可能的未来。 从技术上讲，这是基于以下事实：<u>LTL公式的解释是根据路径（即状态序列）定义的</u>。</p>
<p>但是路径本身可能<strong>存在着分支</strong>，例如在一个TS系统中，一个状态也许有着多个后继状态，从这个角度来看这种解释是基于状态分支的。我们想到，某些时候在一个状态的所有可能计算都满足某个条件，或者有些时候一个状态的部分可能计算满足某个条件，为了表述这些个性质，我们加入$\forall$ 和 $∃$ 符号。</p>
<p>LTL描述的从某个状态开始所有的路径情况，例如$s \models \Box(x\le 20)$，它表示对于从s开始的所有路径都满足 $x\le 20$</p>
<p>而<u>CTL描述的是从某个状态开始的所有或部分路径情况</u></p>
<p>例如$s\models \forall\Box(x\le 20)$,它表示对于从s开始的所有路径都满足$x\le 20$ , 而 $s\models∃\Box(x\le 20)$表示对于从s开始的某些路径满足$x\le 20$</p>
<h5 id="线性时间-vs-分支时间"><a href="#线性时间-vs-分支时间" class="headerlink" title="线性时间 vs 分支时间"></a>线性时间 vs 分支时间</h5><div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th>linear time</th>
<th>branching time</th>
</tr>
</thead>
<tbody>
<tr>
<td>行为behavior</td>
<td>path-based:trace(s)</td>
<td>state-based:computation tree of s</td>
</tr>
<tr>
<td>时间逻辑temporal logic</td>
<td>LTL path formulas</td>
<td>CTL state formulas</td>
</tr>
<tr>
<td>模型检测</td>
<td>$PSPACE-complete O(size(TS)·2^{\mid\phi\mid})$</td>
<td>$PTIME O(size(TS)·\mid\phi\mid)$</td>
</tr>
<tr>
<td>公平性</td>
<td>可以直接表示</td>
<td>需要额外的技术</td>
</tr>
</tbody>
</table>
</div>
<h5 id="执行集-vs-执行树"><a href="#执行集-vs-执行树" class="headerlink" title="执行集 vs 执行树"></a>执行集 vs 执行树</h5><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-04 22.04.31.png" alt="2022-04-04 22.04.31" style="zoom:50%;"></p>
<ul>
<li><p>执行集：$Exec(S) = ⟨({s_0}^+ → s_1 → s_2)^∗ → {s_0}^ω⟩,⟨({s_0}^+ → s_1 → s_2)^ω⟩,⟨({s_0}^+ → s_1 → s_2)^+ → s_3^ω⟩$</p>
</li>
<li><p>执行树：</p>
<p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-04 22.10.01.png" alt="2022-04-04 22.10.01" style="zoom:50%;"></p>
</li>
</ul>
<h4 id="计算树逻辑CTL"><a href="#计算树逻辑CTL" class="headerlink" title="计算树逻辑CTL"></a>计算树逻辑CTL</h4><h5 id="模型描述"><a href="#模型描述" class="headerlink" title="模型描述"></a>模型描述</h5><p>CTL 公式始终与系统的给定状态 s 相关，迹 Trace(s) 源自该状态。S 的状态构成了这个逻辑的模型。</p>
<p>与 LTL 的区别（从句法上讲）在于迹量词的时间运算符的出现。</p>
<h4 id="CTL-语义"><a href="#CTL-语义" class="headerlink" title="CTL 语义"></a>CTL 语义</h4><h5 id="CTL状态公式的语义"><a href="#CTL状态公式的语义" class="headerlink" title="CTL状态公式的语义"></a>CTL状态公式的语义</h5><h6 id="s-models-a"><a href="#s-models-a" class="headerlink" title="$ s\models a$"></a>$ s\models a$</h6><p>当且仅当 $a∈L_(s)$</p>
<script type="math/tex; mode=display">
\frac{}{s \models a}</script><h6 id="s-models-P-land-Q"><a href="#s-models-P-land-Q" class="headerlink" title="$s\models P \land Q$"></a>$s\models P \land Q$</h6><p>当且仅当 $s\models P$ 并且 $s\models Q$</p>
<script type="math/tex; mode=display">
\frac{s \models P \qquad s \models Q}{s \models P \land Q}</script><h6 id="s-models-P-lor-Q"><a href="#s-models-P-lor-Q" class="headerlink" title="$s \models P \lor Q$"></a>$s \models P \lor Q$</h6><p>当且仅当 $s \models P$ 或者 $s \models Q$</p>
<script type="math/tex; mode=display">
\frac{s \models P}{s \models P \lor Q} \qquad
\frac{s \models Q}{s \models P \lor Q}</script><h6 id="s-nvDash-neg-P"><a href="#s-nvDash-neg-P" class="headerlink" title="$s\nvDash \neg P$"></a>$s\nvDash \neg P$</h6><p>当且仅当 $ s\models P$</p>
<script type="math/tex; mode=display">
\frac{s \models P}{s \nvDash \neg P}</script><h6 id="s-models-∃-φ"><a href="#s-models-∃-φ" class="headerlink" title="$s\models ∃ φ$"></a>$s\models ∃ φ$</h6><p>当且仅当 $\pi\vDash\phi$ 对于<strong>某些</strong>从s开始的路径成立</p>
<h6 id="s-models-forall-φ"><a href="#s-models-forall-φ" class="headerlink" title="$s\models \forall φ$"></a>$s\models \forall φ$</h6><p>当且仅当 $\pi\vDash\phi$ 对于<strong>所有</strong>从s开始的路径成立</p>
<h5 id="CTL路径公式的语义"><a href="#CTL路径公式的语义" class="headerlink" title="CTL路径公式的语义"></a>CTL路径公式的语义</h5><ul>
<li>$\pi\vDash\bigcirc P$ 当且仅当 $\pi[1]=P$</li>
<li>$\pi\vDash P \mathcal{U} Q$ 当且仅当<strong>存在</strong> $j\ge0$ 使得 $s_{j}\vDash Q$ 且对于 $0\le k\lt j,\pi[k]\vDash P$</li>
</ul>
<h5 id="CTL在TS上的语义"><a href="#CTL在TS上的语义" class="headerlink" title="CTL在TS上的语义"></a>CTL在TS上的语义</h5><p>对于一个CTL公式 $\phi$，它的可满足集合(satisfaction set) $Sat(\phi)$ 定义为 :</p>
<script type="math/tex; mode=display">
Sat(\phi)=\{s\in S | s\vDash \phi\}</script><p>说白了就是一些满足CTL公式$\phi$的状态的集合</p>
<p>如果我们说一个TS满足CTL公式 $\phi$ , 那么当且仅当公式 $\phi$ 在所有的初始状态上成立，用公式表示为：</p>
<script type="math/tex; mode=display">
TS\vDash\phi\text{ 当且仅当 }S_{0}\subseteq Sat(\phi) \text{ 当且仅当 }\forall s_{0}\in S_{0}.s_{0}\vDash\phi</script><p>上面的 $S_{0}$ 就是初始状态的集合</p>
<h5 id="全称量词-从-s-开始的任何轨迹（对于-s-状态）"><a href="#全称量词-从-s-开始的任何轨迹（对于-s-状态）" class="headerlink" title="全称量词 : 从 s 开始的任何轨迹（对于 s 状态）"></a>全称量词 : 从 s 开始的任何轨迹（对于 s 状态）</h5><p>提醒：对于迹 $\sigma$，$\sigma_i$ 是从 0 开始的 $\sigma$ 的第 i 个元素，对于状态 s，Traces(s) 是来自 s 的迹线集合）</p>
<h6 id="s-models-forall-bigcirc-P"><a href="#s-models-forall-bigcirc-P" class="headerlink" title="$s \models \forall \bigcirc P$"></a>$s \models \forall \bigcirc P$</h6><p> P 在下一瞬间为真</p>
<script type="math/tex; mode=display">
\frac{\forall \sigma \in Traces(S) :a_1 \models P}{s \models \forall \bigcirc P}</script><h6 id="s-models-forall-Box-P"><a href="#s-models-forall-Box-P" class="headerlink" title="$s \models \forall \Box P$"></a>$s \models \forall \Box P$</h6><p>P 在每个状态下始终为真</p>
<script type="math/tex; mode=display">
\frac{\forall \sigma \in Traces(S) : \forall i \ge 0 :a_i \models P}{s \models \forall \Box P}</script><h6 id="s-models-forall-Diamond-P"><a href="#s-models-forall-Diamond-P" class="headerlink" title="$s \models \forall \Diamond P$"></a>$s \models \forall \Diamond P$</h6><p>P 最终为真（未来）</p>
<script type="math/tex; mode=display">
\frac{\forall \sigma \in Traces(S) : ∃ i \ge 0 :a_i \models P}{s \models \forall \Diamond P}</script><h6 id="s-models-P-forall-mathcal-U-Q"><a href="#s-models-P-forall-mathcal-U-Q" class="headerlink" title="$s \models P\;\forall\;\mathcal{U}\;Q$"></a>$s \models P\;\forall\;\mathcal{U}\;Q$</h6><p>P 最终为真，同时 P 仍然为真</p>
<script type="math/tex; mode=display">
\frac{\forall \sigma \in Traces(S) : ∃ j \ge 0 :a_j \models Q \land \forall i < j : \sigma_i \models P}{s \models P\;\forall\;\mathcal{U}\;Q}</script><h5 id="存在量词-从-s-开始的至少一条迹线（对于-s-状态）"><a href="#存在量词-从-s-开始的至少一条迹线（对于-s-状态）" class="headerlink" title="存在量词 : 从 s 开始的至少一条迹线（对于 s 状态）"></a>存在量词 : 从 s 开始的至少一条迹线（对于 s 状态）</h5><h6 id="s-models-∃-bigcirc-P"><a href="#s-models-∃-bigcirc-P" class="headerlink" title="$s \models ∃ \bigcirc P$"></a>$s \models ∃ \bigcirc P$</h6><p>P 在下一瞬间为真</p>
<script type="math/tex; mode=display">
\frac{∃ \sigma \in Traces(S) :a_1 \models P}{s \models ∃ \bigcirc P}</script><h6 id="s-models-∃-Box-P"><a href="#s-models-∃-Box-P" class="headerlink" title="$s \models ∃ \Box P$"></a>$s \models ∃ \Box P$</h6><p>P 在每个状态下始终为真</p>
<script type="math/tex; mode=display">
\frac{∃ \sigma \in Traces(S) : \forall i \ge 0 :a_i \models P}{s \models ∃ \Box P}</script><h6 id="s-models-∃-Diamond-P"><a href="#s-models-∃-Diamond-P" class="headerlink" title="$s \models ∃ \Diamond P$"></a>$s \models ∃ \Diamond P$</h6><p>P 最终为真（未来）</p>
<script type="math/tex; mode=display">
\frac{∃ \sigma \in Traces(S) : ∃ i \ge 0 :a_i \models P}{s \models ∃ \Diamond P}</script><h6 id="s-models-P-∃-mathcal-U-Q"><a href="#s-models-P-∃-mathcal-U-Q" class="headerlink" title="$s \models P\;∃\;\mathcal{U}\;Q$"></a>$s \models P\;∃\;\mathcal{U}\;Q$</h6><p>Q 最终为真，同时 P 仍然为真</p>
<script type="math/tex; mode=display">
\frac{∃ \sigma \in Traces(S) : ∃ j \ge 0 :a_j \models Q \land \forall i < j : \sigma_i \models P}{s \models P\;∃\;\mathcal{U}\;Q}</script><h5 id="forall-bigcirc-，-∃-bigcirc-图解"><a href="#forall-bigcirc-，-∃-bigcirc-图解" class="headerlink" title="$\forall \bigcirc$，$∃ \bigcirc$ 图解"></a>$\forall \bigcirc$，$∃ \bigcirc$ 图解</h5><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-04 23.03.07.png" alt="2022-04-04 23.03.07" style="zoom:40%;"></p>
<h5 id="forall-Box-，-∃-Box-图解"><a href="#forall-Box-，-∃-Box-图解" class="headerlink" title="$\forall \Box$，$∃ \Box$ 图解"></a>$\forall \Box$，$∃ \Box$ 图解</h5><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-04 23.07.21.png" alt="2022-04-04 23.07.21" style="zoom:40%;"></p>
<h5 id="forall-Diamond-，-∃-Diamond-图解"><a href="#forall-Diamond-，-∃-Diamond-图解" class="headerlink" title="$\forall \Diamond$，$∃ \Diamond$ 图解"></a>$\forall \Diamond$，$∃ \Diamond$ 图解</h5><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-04 23.08.46.png" alt="2022-04-04 23.08.46" style="zoom:40%;"></p>
<p>$\forall \mathcal{U}$，$∃ \mathcal{U}$ 图解</p>
<p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2022-04-04 23.08.46.png" alt="2022-04-04 23.08.46" style="zoom:45%;"></p>
<h4 id="CTL-语法"><a href="#CTL-语法" class="headerlink" title="CTL 语法"></a>CTL 语法</h4><h5 id="最小运算符"><a href="#最小运算符" class="headerlink" title="最小运算符"></a>最小运算符</h5><p>$\{ \forall \bigcirc , \forall \mathcal{U}, ∃ \mathcal{U}\} \lor \{ ∃  \bigcirc , ∃ \Box, ∃ \mathcal{U}\} \lor \{ ∃  \diamond , ∃ \mathcal{U}, ∃ \bigcirc \}$</p>
<ul>
<li>$∃ \bigcirc P \triangleq \neg \forall \neg P$</li>
<li>$\forall \Diamond P \triangleq True \; \forall \mathcal{U} P$</li>
<li>$∃ \Diamond P \triangleq True \; ∃  \mathcal{U} P$</li>
<li>$\forall \Box P \triangleq \neg ∃ \Diamond \neg P$</li>
<li>$∃ \Box P \triangleq \neg \forall \Diamond \neg P$</li>
</ul>
<h5 id="替代语法-1"><a href="#替代语法-1" class="headerlink" title="替代语法"></a>替代语法</h5><ul>
<li>$∀ ↔ A$ (all) </li>
<li>$∃ ↔ E$ (exists) </li>
<li>$\Box ↔ G$ (globally)</li>
<li>$\Diamond ↔ F$ (finally)</li>
<li>$\bigcirc ↔ X$ (next)</li>
<li>$\mathcal{U} ↔ U$ (until)</li>
</ul>
<h5 id="互补运算符-1"><a href="#互补运算符-1" class="headerlink" title="互补运算符"></a>互补运算符</h5><ul>
<li>$P∃ \mathcal{W}Q \triangleq ∃ \Box P \lor P ∃ \mathcal{U} Q$</li>
<li>$P\forall \mathcal{W}Q $ 不等于 $  \forall \Box P \lor P \forall \mathcal{U} Q$；$P\forall \mathcal{W}Q \triangleq \neg (\neg Q ∃ \mathcal{U} (\neg P \land \neg Q))$</li>
</ul>
<h5 id="否定性-1"><a href="#否定性-1" class="headerlink" title="否定性"></a>否定性</h5><p>与 LTL 不同，对于任何 CTL 属性，我们有：</p>
<script type="math/tex; mode=display">
S \models F，或\; S \models \neg F，
或\; S \nvDash F ≡ S \models ¬F。</script><p>公式的否定$ ∀, ∃, \Box, \Diamond$</p>
<p>对基于 $ ∀, ∃, \Box, \Diamond$ 的公式的求反只需将每个运算符反转为对偶即可。</p>
<p>例：</p>
<ul>
<li><p>$¬(∀ \Diamond ∃ \Box p) = ∃\Box ∀\Diamond ¬p$</p>
</li>
<li><p>$(∀\Diamond ¬s_0 ⇒ ∀\Diamond s_3) = (∃\Box s_0 ∨ ∀\Diamond s_3) \qquad 因为 (p ⇒ q) = (¬p ∨ q)$</p>
</li>
</ul>
<h5 id="定点定义"><a href="#定点定义" class="headerlink" title="定点定义"></a>定点定义</h5><p>一旦定义了 $∃\bigcirc$ 和 $∀\bigcirc$，每个操作符就是最小的点</p>
<p>其归纳定义：</p>
<ul>
<li><p>$∀ \Box f = f ∧ ∀ \bigcirc ∀ \Box f$</p>
</li>
<li><p>$∃ \Box f = f ∧ ∃ \bigcirc ∃ \Box f$</p>
</li>
<li><p>$∀ \Diamond f = f ∨ ∀ \bigcirc ∀ \Diamond \Box f$</p>
</li>
<li><p>$∃ \Diamond f = f ∨ ∃ \bigcirc ∃ \Diamond \Box f$</p>
</li>
<li><p>$f ∀ \mathcal{U} g = g ∨ (f ∧ ∀\bigcirc (f ∀ \mathcal{U} g))$</p>
</li>
<li><p>$f ∃ \mathcal{U} g = g ∨ (f ∧ ∃\bigcirc (f ∃ \mathcal{U} g))$</p>
<p>（对于实现模型检查器特别有用）</p>
</li>
</ul>
<h3 id="第八部分：-LTL-vs-CTL"><a href="#第八部分：-LTL-vs-CTL" class="headerlink" title="第八部分：$LTL \; vs \; CTL$"></a>第八部分：$LTL \; vs \; CTL$</h3><h4 id="LTL和CTL的等价"><a href="#LTL和CTL的等价" class="headerlink" title="LTL和CTL的等价"></a>LTL和CTL的等价</h4><p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/20201209125629367.png" alt="20201209125629367" style="zoom:50%;"></p>
<p>由之前的一张图我们看到，CTL和LTL有部分的表达是有交集的，这部分既可以用LTL表达，又可以用CTL表达，那么如何形式化地定义等价这个概念呢？</p>
<p>如果一个LTL公式 $φ$ 和一个CTL公式 $\Phi$ 是等价的（记为 $φ\equiv\Phi$），那么当且仅当，对于AP上的TS来说</p>
<script type="math/tex; mode=display">
TS\vDash φ\Leftrightarrow TS\vDash\Phi</script><p>例如有这些个公式是等价的</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">CTL公式 $\Phi$</th>
<th style="text-align:center">LTL公式 $φ$</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">$a$</td>
<td style="text-align:center">$a$</td>
</tr>
<tr>
<td style="text-align:center">$ \forall\bigcirc a$</td>
<td style="text-align:center">$\bigcirc a$</td>
</tr>
<tr>
<td style="text-align:center">$\forall(a\mathcal{U}b)$</td>
<td style="text-align:center">$a\mathcal{U}b$</td>
</tr>
<tr>
<td style="text-align:center">$\forall\Box a$</td>
<td style="text-align:center">$\Box a$</td>
</tr>
<tr>
<td style="text-align:center">$\forall\Diamond a$</td>
<td style="text-align:center">$\Diamond a$</td>
</tr>
<tr>
<td style="text-align:center">$\forall(a\mathcal{W}b)$</td>
<td style="text-align:center">$a\mathcal{W}b$</td>
</tr>
<tr>
<td style="text-align:center">$\forall\Box\forall\Diamond a$</td>
<td style="text-align:center">$\Box\Diamond a$</td>
</tr>
</tbody>
</table>
</div>
<h4 id="LTL和CTL各自能表达的部分"><a href="#LTL和CTL各自能表达的部分" class="headerlink" title="LTL和CTL各自能表达的部分"></a>LTL和CTL各自能表达的部分</h4><p>由上面的文氏图我们知道，LTL和CTL的表达能力并不完全等价，因为存在着只要有各自能够表达的部分</p>
<p>某些LTL公式不能表示成CTL公式，例如</p>
<ul>
<li>$\Diamond\Box a$</li>
<li>$\Diamond(a\land\bigcirc a)$</li>
</ul>
<p>某些CTL公式不能表示成LTL公式，例如</p>
<ul>
<li>$\forall\Diamond\forall\Box a$</li>
<li>$ \forall\Diamond(a\land\forall\bigcirc a)$</li>
<li>$\forall\Box\exist\Diamond a$</li>
</ul>
<h4 id="不等价案例"><a href="#不等价案例" class="headerlink" title="不等价案例"></a>不等价案例</h4><p>$\Diamond(a\wedge\bigcirc a)$ 与 $ \forall\Diamond(a\wedge\forall\bigcirc a)$ 不等价</p>
<p>例如下面这张图：</p>
<p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/2020121517502211.png" alt="2020121517502211" style="zoom:40%;"></p>
<p>我们可以看到它能表示LTL公式 $ \Diamond(a\land\bigcirc a)$，但是不能表示CTL公式$\forall\Diamond(a\land\forall\bigcirc a)$，因为看到 $S_{0},S_{3}$这条路径，对于用CTL表示的 $\forall\Diamond(a\wedge\forall\bigcirc a)$ 来说，从 $S_{0}$ 的角度看，它不满足所有的下一个状态 $a$ 成立。</p>
<p>再看另一个例子，$\Diamond\Box a$ 和 $\forall\Diamond\forall\Box a$ 不等价</p>
<p>就如下图所示</p>
<p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/20201215203132106.png" alt="20201215203132106" style="zoom:40%;"></p>
<p>它能够表示LTL公式 $\Diamond\Box a$，但是不能表示CTL公式 $\forall\Diamond\forall\Box a$，我们把它的计算树画出来</p>
<p><img src="/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/20201215204837482.png" alt="20201215204837482"></p>
<p>我们看到最左边的那条路径，也就是说如果走的路径为 $S_{0}S_{0}S_{0}S_{0}S_{0}S_{0}…$ S 那么就会有一条路径不满足$\forall\Diamond\forall\Box a$。</p>
<h4 id="模型检测的复杂度"><a href="#模型检测的复杂度" class="headerlink" title="模型检测的复杂度"></a>模型检测的复杂度</h4><p>LTL模型检测的时间复杂度为</p>
<script type="math/tex; mode=display">
O(|TS|·2^{|\phi|})</script><p>CTL模型检测的时间复杂度为</p>
<script type="math/tex; mode=display">
O(|TS|·|\phi|)</script>
    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Guohao
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://dave0126.github.io/2022/03/29/%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%E4%B8%8ETLA-%E4%B8%80/" title="Transition System(变迁系统) 与 TLA+">https://dave0126.github.io/2022/03/29/变迁系统与TLA-一/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" rel="tag"># 课程笔记</a>
              <a href="/tags/%E7%B3%BB%E7%BB%9F/" rel="tag"># 系统</a>
              <a href="/tags/TLA/" rel="tag"># TLA+</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/03/28/JUC-Java%E5%A4%9A%E7%BA%BF%E7%A8%8B-3/" rel="prev" title="Java 并发多线程编程 (JUC) (三)">
      <i class="fa fa-chevron-left"></i> Java 并发多线程编程 (JUC) (三)
    </a></div>
      <div class="post-nav-item">
    <a href="/2022/04/11/%E4%BA%8B%E5%8A%A1transaction%E7%AE%80%E4%BB%8B/" rel="next" title="事务 Transaction 简介">
      事务 Transaction 简介 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Transition-System-%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F-%E4%B8%8E-TLA"><span class="nav-text">Transition System(变迁系统) 与 TLA+</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A6%82%E8%BF%B0"><span class="nav-text">概述</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F"><span class="nav-text">变迁系统</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TLA"><span class="nav-text">TLA+</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BD%A2%E5%BC%8F%E5%8C%96%E9%AA%8C%E8%AF%81"><span class="nav-text">形式化验证</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TLA-1"><span class="nav-text">TLA+</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90"><span class="nav-text">学习资源</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%80%E9%83%A8%E5%88%86%EF%BC%9ATransition-System"><span class="nav-text">第一部分：Transition System</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89"><span class="nav-text">定义</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F-1"><span class="nav-text">变迁系统</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E5%90%8E%E7%BB%A7%EF%BC%88Direct-Successors%EF%BC%89"><span class="nav-text">直接后继（Direct Successors）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E5%89%8D%E4%BB%BB%EF%BC%88Direct-Predecessors%EF%BC%89"><span class="nav-text">直接前任（Direct Predecessors）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%BB%88%E6%AD%A2%E7%8A%B6%E6%80%81"><span class="nav-text">终止状态</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%A1%AE%E5%AE%9A%E6%80%A7TS%EF%BC%88Deterministic-Transition-System%EF%BC%89"><span class="nav-text">确定性TS（Deterministic Transition System）</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BA%8F%E5%88%97%EF%BC%88Sequence%EF%BC%89"><span class="nav-text">序列（Séquence）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%B9%EF%BC%88trace%EF%BC%89"><span class="nav-text">迹（trace）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9C%89%E9%99%90%E8%BD%A8%E8%BF%B9%EF%BC%88Traces-finies%EF%BC%89"><span class="nav-text">有限轨迹（Traces finies）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9C%80%E5%A4%A7%E6%9C%89%E9%99%90%E8%BD%A8%E8%BF%B9%EF%BC%88Traces-finies-maximales%EF%BC%89"><span class="nav-text">最大有限轨迹（Traces finies maximales）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%97%A0%E9%99%90%E8%BD%A8%E8%BF%B9%EF%BC%88Trace-infinies%EF%BC%89"><span class="nav-text">无限轨迹（Trace infinies）</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9D%A5%E8%87%AA%E7%8A%B6%E6%80%81%E7%9A%84%E8%BD%A8%E8%BF%B9%EF%BC%88Traces-issues-d%E2%80%99un-etat%EF%BC%89"><span class="nav-text">来自状态的轨迹（Traces issues d’un état）</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%EF%BC%88Executions%EF%BC%89"><span class="nav-text">执行（Exécutions）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%83%E4%B9%A0%E4%B8%80"><span class="nav-text">练习一</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BE%8B%E4%B8%80"><span class="nav-text">例一</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BE%8B%E4%BA%8C"><span class="nav-text">例二</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BE%8B%E4%B8%89"><span class="nav-text">例三</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AF%E8%AE%BF%E9%97%AE%E7%8A%B6%E6%80%81%EF%BC%88Etats-accessibles%EF%BC%89"><span class="nav-text">可访问状态（Etats accessibles）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E5%9B%BE%EF%BC%88Graphe-des-Executions%EF%BC%89"><span class="nav-text">执行图（Graphe des Exécutions）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A2%AB%E6%A0%87%E8%AE%B0%E7%9A%84%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F%EF%BC%88Systeme-de-Transitions-etiquete-%EF%BC%89"><span class="nav-text">被标记的变迁系统（Systeme de Transitions étiqueté ）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F-%E4%B8%8D%E7%AD%89%E4%BA%8E-%E8%87%AA%E5%8A%A8%E6%9C%BA"><span class="nav-text">变迁系统 不等于 自动机</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A1%A8%E7%A4%BA%E5%BD%A2%E5%BC%8F"><span class="nav-text">表示形式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%98%BE%E5%BC%8F%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="nav-text">显式的表示</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9A%90%E5%BC%8F%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="nav-text">隐式的表示</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A4%BA%E4%BE%8B"><span class="nav-text">示例</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9C%89%E7%95%8C%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-text">有界计数器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E8%AE%A1%E6%95%B0%E5%99%A8"><span class="nav-text">循环计数器</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%8C%AF%E8%8D%A1%E6%95%B4%E6%95%B0"><span class="nav-text">振荡整数</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A1%A8%E7%A4%BA%E5%BD%A2%E5%BC%8F%E6%89%80%E5%AF%B9%E5%BA%94%E7%9A%84%E5%8F%98%E8%BF%81%E7%B3%BB%E7%BB%9F"><span class="nav-text">表示形式所对应的变迁系统</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%8A%B6%E6%80%81%E8%B0%93%E8%AF%8D%EF%BC%88Predicat-d%E2%80%99etat%EF%BC%89"><span class="nav-text">状态谓词（Prédicat d’état）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BD%AC%E6%8D%A2%E8%B0%93%E8%AF%8D%EF%BC%88Predicat-de-transition%EF%BC%89"><span class="nav-text">转换谓词（Prédicat de transition）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9E%E4%BE%8B%EF%BC%9A%E8%B0%93%E8%AF%8D"><span class="nav-text">实例：谓词</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B1%9E%E6%80%A7"><span class="nav-text">属性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%98%BB%E5%A1%9E%EF%BC%88Blocage%EF%BC%89"><span class="nav-text">阻塞（Blocage）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%AD%BB%E9%94%81%EF%BC%88Interblocage%EF%BC%89"><span class="nav-text">死锁（Interblocage）</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AF%E5%A4%8D%E4%BD%8D%EF%BC%88Reinitialisable%EF%BC%89"><span class="nav-text">可复位（Réinitialisable）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E5%A4%8D%EF%BC%88Begaiement%EF%BC%89"><span class="nav-text">重复（Bégaiement）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E5%90%88"><span class="nav-text">组合</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%87%AA%E7%94%B1%E7%BB%84%E5%90%88"><span class="nav-text">自由组合</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%A5%E6%A0%BC%E5%90%8C%E6%AD%A5%E7%9A%84%E7%BB%84%E5%90%88"><span class="nav-text">严格同步的组合</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Synchronise-ouvert-%E7%9A%84%E7%BB%84%E5%90%88"><span class="nav-text">Synchronisé ouvert 的组合</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%8C%E9%83%A8%E5%88%86%EF%BC%9AAction"><span class="nav-text">第二部分：Action</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A7%84%E7%BA%A6-Specification"><span class="nav-text">规约 Specification</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%84%E7%BA%A6%E7%9A%84%E7%BB%93%E6%9E%84"><span class="nav-text">规约的结构</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B8%B8%E9%87%8F-Constantes"><span class="nav-text">常量 Constantes</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A1%A8%E8%BE%BE%E5%BC%8F-Expression"><span class="nav-text">表达式 Expression</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%9B%86%E5%90%88%E8%BF%90%E7%AE%97%E7%AC%A6-Operateurs-ensemblistes"><span class="nav-text">集合运算符 Operateurs ensemblistes</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%8A%A8%E4%BD%9C-Action"><span class="nav-text">动作 Action</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%93%8D%E4%BD%9C%E7%AC%A6-Action-Operators"><span class="nav-text">操作符 Action Operators</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%94%B1%E8%BF%9E%E8%AF%8D%E7%BB%84%E6%88%90%E7%9A%84%E5%8A%A8%E4%BD%9C"><span class="nav-text">由连词组成的动作</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%87%8D%E5%A4%8D%EF%BC%88Begaiement%EF%BC%89-1"><span class="nav-text">重复（Bégaiement）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Begaiement"><span class="nav-text">Bégaiement</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Non-Begaiement"><span class="nav-text">Non Bégaiement</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%97%A0%E7%BA%A6%E6%9D%9F%E5%8F%98%E9%87%8F-Variables-non-contraintes"><span class="nav-text">无约束变量 Variables non contraintes</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#UNCHANGED"><span class="nav-text">UNCHANGED</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%87%BD%E6%95%B0-Function"><span class="nav-text">函数 Function</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AC%A6%E5%8F%B7%E7%9A%84%E5%AE%9A%E4%B9%89-Definition-of-symbol"><span class="nav-text">符号的定义 Definition of symbol</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%80%BC%E7%9A%84%E5%AE%9A%E4%B9%89-Definition-of-value"><span class="nav-text">值的定义 Definition of value</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A1%A8-Table"><span class="nav-text">表 Table</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E4%B9%89%E5%9F%9F-Domain"><span class="nav-text">定义域 Domain</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%80%BC%E5%9F%9F-Codomaine"><span class="nav-text">值域 Codomaine</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#EXCEPT"><span class="nav-text">EXCEPT</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#IncF"><span class="nav-text">IncF</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#IncO"><span class="nav-text">IncO</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%AE%B0%E5%BD%95-Record"><span class="nav-text">记录 Record</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E5%AE%9A%E4%B9%89-Definition-recursive"><span class="nav-text">递归定义 Définition récursive</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#n%E5%85%83%E7%BB%84-n-Tuple"><span class="nav-text">n元组 n-Tuple</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BA%8F%E5%88%97-Sequence"><span class="nav-text">序列 Sequence</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B1%80%E9%83%A8%E5%AE%9A%E4%B9%89-Local-Definition"><span class="nav-text">局部定义 Local Definition</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%89%E6%8B%A9-CHOOSE"><span class="nav-text">选择 CHOOSE</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%89%E9%83%A8%E5%88%86%EF%BC%9A%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E5%B1%9E%E6%80%A7-LT-Properties"><span class="nav-text">第三部分：线性时间属性(LT Properties)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%88%BB%E7%94%BB%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E5%B1%9E%E6%80%A7-LT-Properties"><span class="nav-text">刻画线性时间属性(LT Properties)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%BB%E7%94%BB%E5%9F%BA%E4%BA%8E%E4%BF%A1%E5%8F%B7%E9%87%8F%E4%BA%92%E6%96%A5%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-text">刻画基于信号量互斥系统的属性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%88%BB%E7%94%BB%E6%97%A0%E9%A5%A5%E9%A5%BF-starvation-freedom-%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%B1%9E%E6%80%A7"><span class="nav-text">刻画无饥饿(starvation freedom)系统的属性</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8D%E5%8F%98%E6%80%A7-Invariants"><span class="nav-text">不变性(Invariants)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%88%91%E4%BB%AC%E8%AF%A5%E5%A6%82%E4%BD%95%E6%A3%80%E9%AA%8C%E4%B8%80%E4%B8%AA%E7%B3%BB%E7%BB%9F%E6%98%AF%E5%90%A6%E6%BB%A1%E8%B6%B3%E4%BA%86%E4%B8%8D%E5%8F%98%E6%80%A7%E5%91%A2%EF%BC%9F"><span class="nav-text">我们该如何检验一个系统是否满足了不变性呢？</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7-safety"><span class="nav-text">安全性(safety)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="nav-text">安全性的例子</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7%E5%AE%9A%E4%B9%89%E4%B8%BA"><span class="nav-text">安全性定义为</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B4%BB%E6%80%A7-liveness"><span class="nav-text">活性(liveness)</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B4%BB%E6%80%A7%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="nav-text">活性的例子</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B4%BB%E6%80%A7-vs-%E5%AE%89%E5%85%A8%E6%80%A7"><span class="nav-text">活性 vs 安全性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%9B%9B%E9%83%A8%E5%88%86%EF%BC%9AFairness"><span class="nav-text">第四部分：Fairness</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%AC%E5%B9%B3%E6%80%A7%E7%BA%A6%E6%9D%9F-Contraintes-d%E2%80%99equite"><span class="nav-text">公平性约束 Contraintes d’équité</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E7%8A%B6%E6%80%81%E9%9B%86-%EF%BC%88Ensemble-recurrent-d%E2%80%99etats%EF%BC%89"><span class="nav-text">循环状态集 （Ensemble recurrent d’etats）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%BE%AA%E7%8E%AF%E8%BD%AC%E6%8D%A2%E9%9B%86%EF%BC%88Ensemble-recurrent-de-transitions%EF%BC%89"><span class="nav-text">循环转换集（Ensemble recurrent de transitions）</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E7%8A%B6%E6%80%81%E7%9A%84%E5%85%AC%E5%B9%B3%E6%80%A7"><span class="nav-text">关于状态的公平性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E5%85%AC%E5%B9%B3%E6%80%A7"><span class="nav-text">简单公平性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%9A%E9%87%8D%E5%85%AC%E5%B9%B3%E6%80%A7"><span class="nav-text">多重公平性</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9C%89%E9%99%90%E5%A4%9A%E9%87%8D%E5%85%AC%E5%B9%B3%E6%80%A7-%E2%86%94-%E7%AE%80%E5%8D%95%E5%85%AC%E5%B9%B3%E6%80%A7"><span class="nav-text">有限多重公平性 ↔ 简单公平性</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9D%A1%E4%BB%B6%E5%85%AC%E5%B9%B3%E6%80%A7"><span class="nav-text">条件公平性</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%B3%E4%BA%8E%E8%BD%AC%E6%8D%A2%E7%9A%84%E5%85%AC%E5%B9%B3%E6%80%A7"><span class="nav-text">关于转换的公平性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9F%BA%E4%BA%8E%E5%8A%A8%E4%BD%9C%E7%9A%84%E5%85%AC%E5%B9%B3%E6%80%A7%E7%BA%A6%E6%9D%9F"><span class="nav-text">基于动作的公平性约束</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%BA%94%E9%83%A8%E5%88%86%EF%BC%9A-LTL"><span class="nav-text">第五部分：$LTL$</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E9%80%BB%E8%BE%91TL%EF%BC%88Temporal-Logic%EF%BC%89"><span class="nav-text">时间逻辑TL（Temporal Logic）</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4%E9%80%BB%E8%BE%91LTL%EF%BC%88Linear-Temporal-Logic%EF%BC%89"><span class="nav-text">线性时间逻辑LTL（Linear Temporal Logic）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#LTL%E6%A8%A1%E5%9E%8B"><span class="nav-text">LTL模型</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#LTL%E8%AF%AD%E6%B3%95"><span class="nav-text">LTL语法</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E7%9A%84%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">最小的运算符</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%9B%BF%E4%BB%A3%E8%AF%AD%E6%B3%95"><span class="nav-text">替代语法</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BA%92%E8%A1%A5%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">互补运算符</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E9%87%8A%E6%94%BE%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">释放运算符</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E8%BF%87%E5%8E%BB%E5%BC%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">过去式运算符</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#LTL%E8%AF%AD%E4%B9%89"><span class="nav-text">LTL语义</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%B3%BB%E7%BB%9F%E9%AA%8C%E8%AF%81"><span class="nav-text">系统验证</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#P-land-Q"><span class="nav-text">$P\land Q$</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#P-lor-Q"><span class="nav-text">$P\lor Q$</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#neg-P"><span class="nav-text">$\neg P$</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#s"><span class="nav-text">$s$</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#bigcirc-P"><span class="nav-text">$\bigcirc P$</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#P-mathcal-U-Q"><span class="nav-text">$P\;\mathcal{U}\;Q$</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Diamond-P"><span class="nav-text">$\Diamond P$</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Box-P"><span class="nav-text">$\Box P$</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#P-rightsquigarrow-Q"><span class="nav-text">$P \rightsquigarrow Q$</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E5%8C%96%E4%B8%BA%E7%BA%AF%E9%80%BB%E8%BE%91"><span class="nav-text">简化为纯逻辑</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BE%8B%E9%A2%98%EF%BC%88%E8%80%83%E8%AF%95%E5%BF%85%E8%80%83%EF%BC%89"><span class="nav-text">例题（考试必考）</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BE%8B1"><span class="nav-text">例1</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BE%8B2"><span class="nav-text">例2</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%97%B6%E9%97%B4%E9%80%BB%E8%BE%91TL%E5%B1%9E%E6%80%A7"><span class="nav-text">时间逻辑TL属性</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7"><span class="nav-text">安全性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B4%BB%E6%80%A7"><span class="nav-text">活性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B4%BB%E6%80%A7%E4%B8%8E%E5%AE%89%E5%85%A8%E6%80%A7%E7%9A%84%E7%BB%84%E5%90%88%E5%B1%9E%E6%80%A7"><span class="nav-text">活性与安全性的组合属性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8D%E5%8F%98%E6%80%A7"><span class="nav-text">不变性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%A8%B3%E5%AE%9A%E6%80%A7"><span class="nav-text">稳定性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AF%E8%83%BD%E6%80%A7"><span class="nav-text">可能性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%A6%E5%AE%9A%E6%80%A7"><span class="nav-text">否定性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%A0%E9%99%90%E7%BB%8F%E5%B8%B8"><span class="nav-text">无限经常</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E7%BB%88%E6%80%BB%E6%98%AF"><span class="nav-text">最终总是</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LTL%E5%85%AC%E5%BC%8F%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="nav-text">LTL公式的性质</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AF%B9%E5%81%B6%E7%8E%87-Duality-laws"><span class="nav-text">对偶率(Duality laws)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%B9%82%E7%AD%89%E5%BE%8B-Idempotence-laws"><span class="nav-text">幂等律(Idempotence laws)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%B8%E6%94%B6%E7%8E%87-Absorption-laws"><span class="nav-text">吸收率(Absorption laws)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E5%BE%8B-Distributive-laws"><span class="nav-text">分配律(Distributive laws)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E7%8E%87-Expansion-laws"><span class="nav-text">扩展率(Expansion laws)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%94%A8%E5%85%AC%E5%BC%8F%E6%9D%A5%E8%A1%A8%E7%A4%BALT%E6%80%A7%E8%B4%A8"><span class="nav-text">用公式来表示LT性质</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%AC%E5%B9%B3%E6%80%A7"><span class="nav-text">公平性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Weak-until"><span class="nav-text">Weak until</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%8F%AF%E8%BE%BE%E6%80%A7"><span class="nav-text">可达性</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E5%8F%AF%E8%BE%BE%E6%80%A7"><span class="nav-text">简单可达性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%B8%A6%E6%9D%A1%E4%BB%B6%E7%9A%84%E5%8F%AF%E8%BE%BE%E6%80%A7"><span class="nav-text">带条件的可达性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%AE%89%E5%85%A8%E6%80%A7%E4%B8%AD%E7%9A%84%E4%B8%8D%E5%8F%98%E6%80%A7"><span class="nav-text">安全性中的不变性</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E6%B4%BB%E6%80%A7-1"><span class="nav-text">活性</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LTL%E5%85%AC%E5%BC%8F%E7%9A%84%E4%B8%80%E4%BA%9B%E4%BE%8B%E5%AD%90"><span class="nav-text">LTL公式的一些例子</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Client-Server"><span class="nav-text">Client &#x2F; Server</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#Server"><span class="nav-text">Server</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#Client"><span class="nav-text">Client</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%92%E6%96%A5%E9%97%AE%E9%A2%98"><span class="nav-text">互斥问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%97%A0%E9%A5%A5%E9%A5%BF"><span class="nav-text">无饥饿</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%81%AB%E8%BD%A6%E8%BD%A8%E9%81%93%E9%80%9A%E8%A1%8C%E9%97%AE%E9%A2%98"><span class="nav-text">火车轨道通行问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1"><span class="nav-text">进程通信</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%85%AD%E9%83%A8%E5%88%86%EF%BC%9A-TLA"><span class="nav-text">第六部分：$TLA^+$</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#TLA-%E9%80%BB%E8%BE%91"><span class="nav-text">$TLA+$ 逻辑</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E9%80%BB%E8%BE%91%E8%A1%A8%E8%BE%BE%E5%BC%8F"><span class="nav-text">逻辑表达式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%AC%E5%B9%B3%E6%80%A7-1"><span class="nav-text">公平性</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#ENABLE"><span class="nav-text">ENABLE</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E5%BC%B1-%E5%BC%BA%E5%85%AC%E5%B9%B3"><span class="nav-text">弱&#x2F;强公平</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TLA-%E8%A7%84%E8%8C%83%E7%9A%84%E5%BD%A2%E5%BC%8F"><span class="nav-text">TLA+ 规范的形式</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E8%A7%84%E7%BA%A6%E7%9A%84%E7%BB%86%E5%8C%96"><span class="nav-text">规约的细化</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BE%8B1-1"><span class="nav-text">例1</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BE%8B2-1"><span class="nav-text">例2</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#%E4%BE%8B3"><span class="nav-text">例3</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%85%AC%E7%90%86%E8%AF%81%E6%98%8E"><span class="nav-text">公理证明</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%AE%80%E5%8D%95%E6%97%B6%E5%BA%8F%E9%80%BB%E8%BE%91"><span class="nav-text">简单时序逻辑</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%B8%8D%E5%8F%98%E6%80%A7-1"><span class="nav-text">不变性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%B4%BB%E6%80%A7-2"><span class="nav-text">活性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%8E%A8%E5%AF%BC%E8%A7%84%E5%88%99"><span class="nav-text">推导规则</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B%E6%A3%80%E6%9F%A5"><span class="nav-text">模型检查</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-text">复杂度</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#TLC%E6%A3%80%E6%9F%A5%E5%99%A8"><span class="nav-text">TLC检查器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E4%B8%83%E9%83%A8%E5%88%86%EF%BC%9A-CTL"><span class="nav-text">第七部分：$CTL$</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BA%BF%E6%80%A7%E6%97%B6%E9%97%B4-vs-%E5%88%86%E6%94%AF%E6%97%B6%E9%97%B4"><span class="nav-text">线性时间 vs 分支时间</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E9%9B%86-vs-%E6%89%A7%E8%A1%8C%E6%A0%91"><span class="nav-text">执行集 vs 执行树</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AE%A1%E7%AE%97%E6%A0%91%E9%80%BB%E8%BE%91CTL"><span class="nav-text">计算树逻辑CTL</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B%E6%8F%8F%E8%BF%B0"><span class="nav-text">模型描述</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CTL-%E8%AF%AD%E4%B9%89"><span class="nav-text">CTL 语义</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#CTL%E7%8A%B6%E6%80%81%E5%85%AC%E5%BC%8F%E7%9A%84%E8%AF%AD%E4%B9%89"><span class="nav-text">CTL状态公式的语义</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#s-models-a"><span class="nav-text">$ s\models a$</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#s-models-P-land-Q"><span class="nav-text">$s\models P \land Q$</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#s-models-P-lor-Q"><span class="nav-text">$s \models P \lor Q$</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#s-nvDash-neg-P"><span class="nav-text">$s\nvDash \neg P$</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#s-models-%E2%88%83-%CF%86"><span class="nav-text">$s\models ∃ φ$</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#s-models-forall-%CF%86"><span class="nav-text">$s\models \forall φ$</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CTL%E8%B7%AF%E5%BE%84%E5%85%AC%E5%BC%8F%E7%9A%84%E8%AF%AD%E4%B9%89"><span class="nav-text">CTL路径公式的语义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#CTL%E5%9C%A8TS%E4%B8%8A%E7%9A%84%E8%AF%AD%E4%B9%89"><span class="nav-text">CTL在TS上的语义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%85%A8%E7%A7%B0%E9%87%8F%E8%AF%8D-%E4%BB%8E-s-%E5%BC%80%E5%A7%8B%E7%9A%84%E4%BB%BB%E4%BD%95%E8%BD%A8%E8%BF%B9%EF%BC%88%E5%AF%B9%E4%BA%8E-s-%E7%8A%B6%E6%80%81%EF%BC%89"><span class="nav-text">全称量词 : 从 s 开始的任何轨迹（对于 s 状态）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#s-models-forall-bigcirc-P"><span class="nav-text">$s \models \forall \bigcirc P$</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#s-models-forall-Box-P"><span class="nav-text">$s \models \forall \Box P$</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#s-models-forall-Diamond-P"><span class="nav-text">$s \models \forall \Diamond P$</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#s-models-P-forall-mathcal-U-Q"><span class="nav-text">$s \models P\;\forall\;\mathcal{U}\;Q$</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AD%98%E5%9C%A8%E9%87%8F%E8%AF%8D-%E4%BB%8E-s-%E5%BC%80%E5%A7%8B%E7%9A%84%E8%87%B3%E5%B0%91%E4%B8%80%E6%9D%A1%E8%BF%B9%E7%BA%BF%EF%BC%88%E5%AF%B9%E4%BA%8E-s-%E7%8A%B6%E6%80%81%EF%BC%89"><span class="nav-text">存在量词 : 从 s 开始的至少一条迹线（对于 s 状态）</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#s-models-%E2%88%83-bigcirc-P"><span class="nav-text">$s \models ∃ \bigcirc P$</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#s-models-%E2%88%83-Box-P"><span class="nav-text">$s \models ∃ \Box P$</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#s-models-%E2%88%83-Diamond-P"><span class="nav-text">$s \models ∃ \Diamond P$</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#s-models-P-%E2%88%83-mathcal-U-Q"><span class="nav-text">$s \models P\;∃\;\mathcal{U}\;Q$</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#forall-bigcirc-%EF%BC%8C-%E2%88%83-bigcirc-%E5%9B%BE%E8%A7%A3"><span class="nav-text">$\forall \bigcirc$，$∃ \bigcirc$ 图解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#forall-Box-%EF%BC%8C-%E2%88%83-Box-%E5%9B%BE%E8%A7%A3"><span class="nav-text">$\forall \Box$，$∃ \Box$ 图解</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#forall-Diamond-%EF%BC%8C-%E2%88%83-Diamond-%E5%9B%BE%E8%A7%A3"><span class="nav-text">$\forall \Diamond$，$∃ \Diamond$ 图解</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#CTL-%E8%AF%AD%E6%B3%95"><span class="nav-text">CTL 语法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9C%80%E5%B0%8F%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="nav-text">最小运算符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%9B%BF%E4%BB%A3%E8%AF%AD%E6%B3%95-1"><span class="nav-text">替代语法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E4%BA%92%E8%A1%A5%E8%BF%90%E7%AE%97%E7%AC%A6-1"><span class="nav-text">互补运算符</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%90%A6%E5%AE%9A%E6%80%A7-1"><span class="nav-text">否定性</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%AE%9A%E7%82%B9%E5%AE%9A%E4%B9%89"><span class="nav-text">定点定义</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%AC%AC%E5%85%AB%E9%83%A8%E5%88%86%EF%BC%9A-LTL-vs-CTL"><span class="nav-text">第八部分：$LTL \; vs \; CTL$</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#LTL%E5%92%8CCTL%E7%9A%84%E7%AD%89%E4%BB%B7"><span class="nav-text">LTL和CTL的等价</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#LTL%E5%92%8CCTL%E5%90%84%E8%87%AA%E8%83%BD%E8%A1%A8%E8%BE%BE%E7%9A%84%E9%83%A8%E5%88%86"><span class="nav-text">LTL和CTL各自能表达的部分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%B8%8D%E7%AD%89%E4%BB%B7%E6%A1%88%E4%BE%8B"><span class="nav-text">不等价案例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%9E%8B%E6%A3%80%E6%B5%8B%E7%9A%84%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="nav-text">模型检测的复杂度</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Guohao</p>
  <div class="site-description" itemprop="description">间歇性踌躇满志, 持续性划水摸鱼</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">16</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Guohao</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">266k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">4:02</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>



        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  













<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : '[object Object]',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
