<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>【笔记】Modelling Control Systeme Using IEC61499 | Lost N Found</title><meta name="author" content="Guohao"><meta name="copyright" content="Guohao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="关于《Modelling Control Systeme Using IEC61499》的读书笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="【笔记】Modelling Control Systeme Using IEC61499">
<meta property="og:url" content="https://lostnfound.top/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/index.html">
<meta property="og:site_name" content="Lost N Found">
<meta property="og:description" content="关于《Modelling Control Systeme Using IEC61499》的读书笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lostnfound.top/linear-gradient(45deg,%20#8EC3B0,%20#9ED5C5,%20#F8C4B4,%20#FF8787)">
<meta property="article:published_time" content="2023-05-16T02:46:01.000Z">
<meta property="article:modified_time" content="2023-05-25T09:45:42.626Z">
<meta property="article:author" content="Guohao">
<meta property="article:tag" content="自动化">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lostnfound.top/linear-gradient(45deg,%20#8EC3B0,%20#9ED5C5,%20#F8C4B4,%20#FF8787)"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://lostnfound.top/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":100,"languages":{"author":"作者: Guohao","link":"链接: ","source":"来源: Lost N Found","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【笔记】Modelling Control Systeme Using IEC61499',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-25 17:45:42'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/atom.xml" title="Lost N Found" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-battery-full"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-calendar-check"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-hashtag"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user-circle"></i><span> 关于我</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/Dave0126"><i class="fa-fw fab fa-github"></i><span> Github</span></a></li><li><a class="site-page child" href="mailto:dave980126@outlook.com"><i class="fa-fw fas fa-envelope"></i><span> Mail</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: linear-gradient(45deg, #8EC3B0, #9ED5C5, #F8C4B4, #FF8787)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Lost N Found</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-battery-full"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-calendar-check"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-hashtag"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user-circle"></i><span> 关于我</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/Dave0126"><i class="fa-fw fab fa-github"></i><span> Github</span></a></li><li><a class="site-page child" href="mailto:dave980126@outlook.com"><i class="fa-fw fas fa-envelope"></i><span> Mail</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【笔记】Modelling Control Systeme Using IEC61499</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-16T02:46:01.000Z" title="发表于 2023-05-16 10:46:01">2023-05-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-25T09:45:42.626Z" title="更新于 2023-05-25 17:45:42">2023-05-25</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%87%AA%E5%8A%A8%E5%8C%96/">自动化</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">28.5k</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>写在前面：</p>
<p>本文章是根据 Robert Lewis 所著《Modelling Control Systems Using IEC 61499》翻译、整理而来。碍于本人学识有限，同时并非本专业人士，部分叙述难免存在纰漏，请读者注意甄别。</p>
<p>参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://books.google.com/books?id=m3LaTv7VefwC&amp;lpg=PR5&amp;ots=bygTVzfRst&amp;dq=Modelling%20Control%20Systems%20Using%20IEC%2061499">《Modelling Control Systems Using IEC 61499》, Lewis R. W., ISBN:978-0-85296-796-6 </a></li>
</ul>
<hr>
<h1 id="1-介绍"><a class="markdownIt-Anchor" href="#1-介绍"></a> 1. 介绍</h1>
<h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2>
<p>目前为止，工业控制系统分成了两大阵营。一类是基于传统的分布式控制系统(DCS)，另一类是基于可编程逻辑控制器（PLC）。</p>
<ul>
<li>
<p>现行的DCS 主要应用于化工厂和炼油厂。它们是由少量的大型中央处理器构成，提供监控和数据采集。通过本地网络和部署在工厂中的众多控制器，仪表，传感器和执行部件相联。</p>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230516105230518.png" alt="image-20230516105230518" style="zoom:80%;">
<p>系统可以具有分立的仪表和超级工作站。超级工作站由本地控制器和一串仪表构成。在一个DCS 中，许多的监控来自于一个或者多个中心处理器。工厂中的仪表提供本地的闭环控制，例如PID 控制。</p>
</li>
<li>
<p>在许多机器控制和生产过程控制中（特别是自动化生产线中），控制系统是使用PLC来设计的。</p>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230516105952159.png" alt="image-20230516105952159" style="zoom:80%;">
<p>大型PLC 系统通常由多个PLC ，它们通过一个或者多个特定的高速网络相互通信。PLC 一般连接大量的输入输出（I/O) 信号，由它们处理传感器和执行部件。在这种场合，分立仪表，比如温度，压力传感器也连接到PLC 上。</p>
</li>
</ul>
<p>使用这两种设计方法，系统都倾向编写一个大型单一的软件包。这种软件通常很难在新的应用中重复使用，相互之间集成也非常困难。DCS和PLC 两种系统<u><em><strong>难以修改和扩展，不能提供高度的灵活性</strong></em></u>。而这一点却是先进，灵活的控制系统所期望的。</p>
<h2 id="iec-61499-function-block-standard"><a class="markdownIt-Anchor" href="#iec-61499-function-block-standard"></a> IEC 61499 function block standard</h2>
<p>IEC 已经开发了一个专门的标准 IEC61499 ，它定义了如何将功能块（<u><em><strong>function block</strong></em></u>）用于分布式工业过程，测量和控制系统。这项工作有助于解决语义集成的问题。</p>
<blockquote>
<p>&quot;In industrial systems, function blocks are an established concept for defining robust, re-usable software components. A function block can provide a software solution to a small problem, such as the control of a valve, or control a major unit of plant, such as a complete production line.</p>
<p>Function blocks allow industrial algorithms to be encapsulated in a form that can be readily understood and applied by people who are not software specialists. Each block has a defined set of input parameters, which are read by the internal algorithm when it executes. The results from the algorithm are written to the block’s outputs. Complete applications can be built from networks of function blocks formed by interconnecting block inputs and outputs.&quot;</p>
<p>在工业系统中，功能块建立了定义鲁棒性，可重用软件组件的概念。一个功能块能够提供解决小问题的软件解决方法，比如控制阀门。也可以解决一个工厂的主要部件，例如完整的生产线。</p>
<p>功能块允许工业算法封装在一种可理解的形式中，使非软件专家的人士可以使用。每个功能块都有数据输入，供算法执行时读取。算法的结果写入功能块的输出。完整的应用由功能块输入输出互联的功能块网络组成。</p>
</blockquote>
<p>现场总线是连接智能现场设备和自动化系统的数字式、双向传输、多分支结构的通讯网络。也就是说基于现场总线的系统是以单个分散的，数字化，智能化的测量和控制设备作为网络的节点，用总线相连，实现信息的相互交换，使得不同网络，不同现场设备之间可以信息共享。</p>
<h3 id="为什么使用功能块"><a class="markdownIt-Anchor" href="#为什么使用功能块"></a> 为什么使用功能块？</h3>
<p>在面向对象程序设计中的<u><em><strong>对象</strong></em></u>在某种程度上类似于<u><em><strong>功能块</strong></em></u>。对象的概念之所以成功，是因为它们能够为在真实世界的概念和项目建立行为建模。</p>
<blockquote>
<p>使用对象带来的好处：</p>
<ol>
<li>对象反映现实世界。将与应用程序关联的现实世界实体表示为对象，更为自然和直观</li>
<li>对象是稳定的。通常，对象是经过验证的软件元素，不会发生重大变化</li>
<li>对象降低了复杂性。开发人员可以在不真正理解对象内部如何工作的情况下使用对象。可以通过创建和链接对象来开发应用程序通常不需要了解对象的内部结构</li>
<li>对象是可重用的。一旦一个对象被开发和测试，它就可以成为开发人员的一部分（类库）。</li>
</ol>
</blockquote>
<p>功能块也具有这些特性中的大部分，由此所带来的好处有：</p>
<ul>
<li>减少了为应用程序开发的控制软件的数量</li>
<li>减少了开发控制系统所需的时间</li>
<li>使用相同类型功能块的控制系统将具有更一致的行为</li>
<li>使得控制系统更易于测试</li>
</ul>
<h3 id="功能块与对象的联系与区别"><a class="markdownIt-Anchor" href="#功能块与对象的联系与区别"></a> 功能块与对象的联系与区别</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Objects</th>
<th>FBs</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>封装数据</td>
<td>✅</td>
<td>✅</td>
<td>对象可能包含同时也是其他对象实例的数据；<br>功能块可能包含其他功能块的实例。</td>
</tr>
<tr>
<td>外部接口</td>
<td>✅</td>
<td>✅</td>
<td>在 IEC 61499 中，私有接口和公共接口之间没有区别和事件</td>
</tr>
<tr>
<td>调用</td>
<td>对象有含参方法和返回值</td>
<td>FB输入输出变量和事件</td>
<td>在FB中，数据可以与事件同步</td>
</tr>
<tr>
<td>继承</td>
<td>✅</td>
<td>❌</td>
<td>目前在 IEC 61499 中没有功能块继承行为的机制</td>
</tr>
<tr>
<td>多态</td>
<td>✅</td>
<td>✅</td>
<td>IEC 61499 引入了一个“Adaptor”概念，允许功能块共享公共接口</td>
</tr>
<tr>
<td>实例化</td>
<td>对象类和功能块类型是同义的</td>
<td>功能块实例是由功能块类型定义的</td>
<td></td>
</tr>
</tbody>
</table>
<h1 id="2-iec-61499中的模型与概念"><a class="markdownIt-Anchor" href="#2-iec-61499中的模型与概念"></a> 2. IEC 61499中的模型与概念</h1>
<p>本章将回顾 IEC 61499 中定义的主要模型和概念，以全面了解功能块标准。IEC 61499 的主要目的不是作为一种编程方法，而是作为分布式系统的架构和模型。按照定义，该标准无意直接由编程工具使用。相反，IEC 61499 提供了一组模型来描述使用功能块编程的分布式系统。</p>
<p>本章涵盖的主题包括：</p>
<ul>
<li>分布式控制系统的系统、设备和资源模型</li>
<li>表示分布式应用程序的模型</li>
<li>功能块的特性及其执行</li>
<li>不同形式的功能块的类型规范</li>
<li>服务接口功能块提供硬件和操作系统的接口</li>
<li>适配器（Adaptor）用于共享块接口</li>
<li>用于定义 IEC 61499 实体的文本语法。</li>
</ul>
<h2 id="21-系统模型"><a class="markdownIt-Anchor" href="#21-系统模型"></a> 2.1 系统模型</h2>
<p>我们将从IEC 61499 中定义的顶层系统模型开始，这定义了通信设备和应用程序之间的关系。</p>
<p>分布式应用程序将被设计为连接功能块的网络。但是，当应用程序加载到系统上时，它通常会作为<br>
一系列功能块网络片段加载到不同的设备中。由各个设备提供的通行服务确保构成应用程序一部分的功能块维护其数据和事件连接。</p>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230518144157171.png" alt="image-20230518144157171" style="zoom:60%;">
<blockquote>
<p>IEC 61499 系统模型允许设备支持多个应用程序的执行。该标准定义了一种设备模型，可以在不干扰现有应用程序的情况下加载和卸载分布式应用程序；这是通过使用设备内的管理服务来实现的这些将在第 4 章后面进行介绍</p>
</blockquote>
<h2 id="22-设备模型"><a class="markdownIt-Anchor" href="#22-设备模型"></a> 2.2 设备模型</h2>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230518151147145.png" alt="image-20230518151147145" style="zoom:70%;">
<p>一个设备能够支持一个或多个资源。 IEC 61499 中的资源具有与 PLC 编程语言标准 IEC 61131‑3 中定义的资源概念类似的属性。资源提供功能块网络的独立执行和控制。</p>
<p>设备模型有一个“进程接口”，它提供使资源能够与物理设备上的输入和输出 (I/O) 点交换数据的服务。还有一个通信接口，为资源提供通信服务，通过外部网络与远程设备中的资源交换数据。</p>
<p>过程和通信接口的内部结构和行为不在 IEC 61499 的范围内，但它们有望提供一系列服务以支持资源内功能块的执行。</p>
<p>该设备的目的是提供一种基础设施来维持一种或多种资源。功能块网络的片段分布在本地设备或远程设备资源中的资源之间。</p>
<h2 id="23-资源模型"><a class="markdownIt-Anchor" href="#23-资源模型"></a> 2.3 资源模型</h2>
<p>该资源提供设施和服务以支持一个或多个功能块应用程序片段的执行。IEC 61499 的主要重点是对每个资源内功能块的行为进行建模。该资源为通信系统和“设备特定进程”提供接口，即与设备紧密相连的外部服务和子系统，例如设备 I/O 子系统。</p>
<blockquote>
<p>例如，每个资源都将有一个到通信系统的接口，以允许功能块与远程资源中的块交换数据，以及一个接口来读取和写入本地设备输入和输出（I/O）。</p>
</blockquote>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230519093741295.png" alt="image-20230519093741295" style="zoom:80%;">
<p>图 2.3 描述了 IEC 61499 资源的主要特征，它显示了一个由数据和事件流链接的互连功能块网络。资源提供的调度功能确保功能块内的算法以正确的顺序执行，即按照事件到达每个功能块的要求。</p>
<ul>
<li>其中，“服务接口” (Service Interface) 功能块是一种特殊形式的功能块，它提供功能块和资源接口之间的链接。例如，通信 SI 块可用于读取数据或将数据发送到远程资源中的功能块。</li>
</ul>
<p>资源的一个重要特征是它支持独立操作，不会影响同一设备或网络中的其他资源。</p>
<blockquote>
<p>注意 ⚠️：</p>
<p>分布式应用程序的管理可能需要协调控制加载功能块网络片段的许多资源。实现这种协调所需的设施是 IEC 61499 <u><em><strong>尚未完全解决</strong></em></u>的问题。</p>
</blockquote>
<h2 id="24-应用模型"><a class="markdownIt-Anchor" href="#24-应用模型"></a> 2.4 应用模型</h2>
<p>在IEC 61499中，应用被定义为由事件和数据流链接的互连功能块网络。</p>
<ul>
<li>应用程序可以分散并分布在许多资源上。</li>
<li>在应用程序中，可以使用子应用程序进一步分解。</li>
<li>子应用程序具有功能块的外部特征，但可以包含功能块网络，这些功能块本身可以分布在其他资源上。该标准定义了应用程序分解的“分形”形式，允许在需要时将子应用程序进一步分解为更小的子应用程序。</li>
</ul>
<p>该应用程序定义了各个块之间所需的事件和数据流之间的关系。分布块的各种资源必须确保事件用于在正确的优先级和时间安排块内的适当算法。</p>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230519100703886.png" alt="image-20230519100703886" style="zoom:80%;">
<blockquote>
<p>注意，IEC 61499 功能块包含用于定义其完整行为的所有算法和初始化值。</p>
</blockquote>
<p>实际上，应用程序是解决特定自动化控制问题的一整套功能块和互连（interconnection）。应用程序由功能块实例和互连定义组成，在某些情况下，它们包括特定块类型的功能块的多个实例。 IEC 61499 的原则是所有行为都根据功能块定义。结果，我们将看到应用程序中没有可以存在于功能块之外的全局或局部变量。这是为基于<br>
IEC 61131‑3 的 PLC 创建的应用程序与 IEC 61499 应用程序之间的重要区别。</p>
<h2 id="25-功能块模型"><a class="markdownIt-Anchor" href="#25-功能块模型"></a> 2.5 功能块模型</h2>
<p>功能块（Function Block）是支持整个 IEC 61499 的核心，其具有自己的数据结构，并且由一个或者多个算法来处理它们。功能块类型（function block  type）提供了数据结构和算法的形式化描述。</p>
<p>功能块可以有多个实例（instance）。从形式上看，功能块和面向对象中的对象非常类似。</p>
<ul>
<li>
<p>每个功能块有一个类型名称和一个实例名称。</p>
</li>
<li>
<p>每一个功能块都有一系列事件输入（<code>Evnet Input</code>）。它们能够接收其它功能块通过事件连接传递的事件。</p>
</li>
<li>
<p>每个功能块都能有事件输出（<code>Evnet Output</code>）。它们向其它功能块传递事件。</p>
</li>
<li>
<p>每个功能块会有数据输入（<code>Data Input</code>）。传递给它其它功能块内部产生的数据。</p>
</li>
<li>
<p>每个功能块会有数据输出（<code>Data Output</code>）。将该功能块内部产生的数据传递该其它功能块。</p>
</li>
<li>
<p>每个区块都会有一组内部变量，用来保存算法调用之间保留的数值。</p>
</li>
<li>
<p>事件可以使用 “<code>WITH</code>” 修饰词与数据关联。在图形表示中，将事件和相关联的数据连接线交叉点画一个小方块。</p>
</li>
<li>
<p>功能块的行为定义为一系列的算法和状态信息。利用块的状态和状态的变化，可以建立各种策略的模型，以定义哪些算法将在响应特定事件时执行。</p>
</li>
</ul>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230519103529416.png" alt="image-20230519103529416" style="zoom:80%;">
<p>上图描述了 IEC 61499 功能块的主要特性：</p>
<ul>
<li>功能块的顶部，称为“执行控制（Execution Control）”部分，在某些情况下包含一个定义，以状态机的形式给出，用于将事件映射到算法；即它定义了下半部分定义的哪些算法在各种事件到达“执行控制”时被触发，以及输出事件何时被触发标准称之为“事件输入、事件输出和算法执行之间的因果关系”。该标准定义了映射到达事件输入的事件、内部算法的执行和输出事件的触发之间的关系的方法，这将在本章后面的部分中讨论。</li>
<li>功能块的下半部分包含算法和内部数据，它们都隐藏在功能块中。功能块是一种软件组件，如果设计得当，<br>
则不需要用户详细了解其内部设计。</li>
</ul>
<p>功能块依赖于其包含资源的支持来提供设施来调度算法并将请求映射到通信和处理接口。</p>
<p>该标准规定资源可以选择性地提供附加功能以允许访问功能块的内部。显然，在现场总线设备中，能够检查块内的内部变量对于维护或调试目的总是有用的。所以可能有“后门”方法来访问功能块内部；然而，从 IEC 61499 体系结构的角度来看，控制变量和事件仅通过外部公开接口传递。</p>
<h2 id="26-功能块类型"><a class="markdownIt-Anchor" href="#26-功能块类型"></a> 2.6 功能块类型</h2>
<p>IEC 61499 中的一个重要概念是定义功能块类型的能力，该类型定义了可以从该类型创建的功能块实例的行为和接口。这与面向对象软件中对象实例的行为由关联对象的类定义定义的方式同义。<br>
复合功能块和子应用程序类型的内部行为由功能块实例网络定义。因此，该定义包括需要存在于内部功能块实例之间的数据和事件连接。<br>
功能块类型由<u><em><strong>类型名称</strong></em></u>、块的<u><em><strong>输入和输出事件</strong></em></u>的正式定义以及<u><em><strong>输入和输出变量</strong></em></u>的定义定义。</p>
<h3 id="基本功能块类型"><a class="markdownIt-Anchor" href="#基本功能块类型"></a> 基本功能块类型</h3>
<p>基本功能块的行为是根据响应输入事件而调用的算法来定义的。当算法执行时，它们会触发输出事件，以表示块内发生了某些状态变化。事件到算法的映射使用称为执行控制图 (ECC)的特殊状态转换符号来表示。</p>
<h4 id="基本功能块的执行模型"><a class="markdownIt-Anchor" href="#基本功能块的执行模型"></a> 基本功能块的执行模型</h4>
<p>借助下图对基本功能块进行描述，功能块上的编号特征显示了块的不同部分由底层“调度功能”处理的顺序。该模型假设功能块所在的资源提供了一个调度功能，确保功能块执行的每个阶段以正确的顺序和正确的优先级发生。</p>
<p>在下图中有许多离散的时序阶段，每个时序阶段可能需要一段时间才能过去，这是基本功能块执行所必需的；每个阶段都取决于功能块和底层调度功能之间定义的交互。下图描述了基本功能块运行必须顺序出现的8个时序点；每个阶段的结束由特定编号的时间点定义：</p>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230519110753009.png" alt="image-20230519110753009" style="zoom:80%;">
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">T</mi><mi mathvariant="bold">i</mi><mi mathvariant="bold">m</mi><msub><mi mathvariant="bold">e</mi><mn mathvariant="bold">1</mn></msub></mrow><annotation encoding="application/x-tex">\mathbf{Time_1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbf">T</span><span class="mord mathbf">i</span><span class="mord mathbf">m</span><span class="mord"><span class="mord mathbf">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>：来自外部功能块的值（Data）在功能块输入处稳定</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">T</mi><mi mathvariant="bold">i</mi><mi mathvariant="bold">m</mi><msub><mi mathvariant="bold">e</mi><mn mathvariant="bold">2</mn></msub></mrow><annotation encoding="application/x-tex">\mathbf{Time_2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbf">T</span><span class="mord mathbf">i</span><span class="mord mathbf">m</span><span class="mord"><span class="mord mathbf">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>：与输入值（Data）关联的事件（Event）到达事件输入</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">T</mi><mi mathvariant="bold">i</mi><mi mathvariant="bold">m</mi><msub><mi mathvariant="bold">e</mi><mn mathvariant="bold">3</mn></msub></mrow><annotation encoding="application/x-tex">\mathbf{Time_3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbf">T</span><span class="mord mathbf">i</span><span class="mord mathbf">m</span><span class="mord"><span class="mord mathbf">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>：功能块执行控制向调度功能发送信号，表明它具有输入值并准备好执行其算法</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">T</mi><mi mathvariant="bold">i</mi><mi mathvariant="bold">m</mi><msub><mi mathvariant="bold">e</mi><mn mathvariant="bold">4</mn></msub></mrow><annotation encoding="application/x-tex">\mathbf{Time_4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbf">T</span><span class="mord mathbf">i</span><span class="mord mathbf">m</span><span class="mord"><span class="mord mathbf">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>​：在资源的加载和性能特征确定的一段时间后，调度功能开始执行功能块的算法</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">T</mi><mi mathvariant="bold">i</mi><mi mathvariant="bold">m</mi><msub><mi mathvariant="bold">e</mi><mn mathvariant="bold">5</mn></msub></mrow><annotation encoding="application/x-tex">\mathbf{Time_5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbf">T</span><span class="mord mathbf">i</span><span class="mord mathbf">m</span><span class="mord"><span class="mord mathbf">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>​：该算法处理输入值，在某些情况下，还处理内部存储的值以创建写入功能块输出的新输出值</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">T</mi><mi mathvariant="bold">i</mi><mi mathvariant="bold">m</mi><msub><mi mathvariant="bold">e</mi><mn mathvariant="bold">6</mn></msub></mrow><annotation encoding="application/x-tex">\mathbf{Time_6}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbf">T</span><span class="mord mathbf">i</span><span class="mord mathbf">m</span><span class="mord"><span class="mord mathbf">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>：算法完成其执行，并向调度函数发出信号以指示输出值稳定并准备就绪</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">T</mi><mi mathvariant="bold">i</mi><mi mathvariant="bold">m</mi><msub><mi mathvariant="bold">e</mi><mn mathvariant="bold">7</mn></msub></mrow><annotation encoding="application/x-tex">\mathbf{Time_7}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbf">T</span><span class="mord mathbf">i</span><span class="mord mathbf">m</span><span class="mord"><span class="mord mathbf">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>​：调度功能调用功能块的执行控制以生成输出事件。根据到达的输入事件和执行控制的内部状态，可能会产生不同的输出事件</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">T</mi><mi mathvariant="bold">i</mi><mi mathvariant="bold">m</mi><msub><mi mathvariant="bold">e</mi><mn mathvariant="bold">8</mn></msub></mrow><annotation encoding="application/x-tex">\mathbf{Time_8}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbf">T</span><span class="mord mathbf">i</span><span class="mord mathbf">m</span><span class="mord"><span class="mord mathbf">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>​：执行控制依次在功能块的输出事件接口上创建适当的输出事件。下游功能块使用输出事件表示它们现在可以使用此块生成的输出值</li>
</ul>
<blockquote>
<p>注意 ⚠️：</p>
<p>这些时序阶段不能重叠，并且必须按功能块正确执行的规定顺序发生。</p>
</blockquote>
<p>该标准定义了以下在构建应用程序时非常重要的持续时间：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="bold">T</mi><mrow><mi mathvariant="bold">s</mi><mi mathvariant="bold">e</mi><mi mathvariant="bold">t</mi><mi mathvariant="bold">u</mi><mi mathvariant="bold">p</mi></mrow></msub><mo>=</mo><mrow><mi mathvariant="bold">T</mi><mi mathvariant="bold">i</mi><mi mathvariant="bold">m</mi><msub><mi mathvariant="bold">e</mi><mn mathvariant="bold">2</mn></msub></mrow><mi mathvariant="normal">–</mi><mrow><mi mathvariant="bold">T</mi><mi mathvariant="bold">i</mi><mi mathvariant="bold">m</mi><msub><mi mathvariant="bold">e</mi><mn mathvariant="bold">1</mn></msub></mrow></mrow><annotation encoding="application/x-tex">\mathbf{T_{setup}}= \mathbf{Time_2} – \mathbf{Time_1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.972218em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.294444em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathbf mtight">s</span><span class="mord mathbf mtight">e</span><span class="mord mathbf mtight">t</span><span class="mord mathbf mtight">u</span><span class="mord mathbf mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbf">T</span><span class="mord mathbf">i</span><span class="mord mathbf">m</span><span class="mord"><span class="mord mathbf">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mord" style="margin-right:0.02778em;">–</span><span class="mord"><span class="mord mathbf">T</span><span class="mord mathbf">i</span><span class="mord mathbf">m</span><span class="mord"><span class="mord mathbf">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>：接收输入值与其关联的输入事件到达之间的时间</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="bold">T</mi><mrow><mi mathvariant="bold">s</mi><mi mathvariant="bold">t</mi><mi mathvariant="bold">a</mi><mi mathvariant="bold">r</mi><mi mathvariant="bold">t</mi></mrow></msub><mo>=</mo><mrow><mi mathvariant="bold">T</mi><mi mathvariant="bold">i</mi><mi mathvariant="bold">m</mi><msub><mi mathvariant="bold">e</mi><mn mathvariant="bold">4</mn></msub></mrow><mi mathvariant="normal">–</mi><mrow><mi mathvariant="bold">T</mi><mi mathvariant="bold">i</mi><mi mathvariant="bold">m</mi><msub><mi mathvariant="bold">e</mi><mn mathvariant="bold">2</mn></msub></mrow></mrow><annotation encoding="application/x-tex">\mathbf{T_{start}}= \mathbf{Time_4} – \mathbf{Time_2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83611em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.29444400000000004em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathbf mtight">s</span><span class="mord mathbf mtight">t</span><span class="mord mathbf mtight">a</span><span class="mord mathbf mtight">r</span><span class="mord mathbf mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbf">T</span><span class="mord mathbf">i</span><span class="mord mathbf">m</span><span class="mord"><span class="mord mathbf">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mord" style="margin-right:0.02778em;">–</span><span class="mord"><span class="mord mathbf">T</span><span class="mord mathbf">i</span><span class="mord mathbf">m</span><span class="mord"><span class="mord mathbf">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>：收输入事件和执行算法之间的时间； 这个持续时间可能取决于资源加载，即调度函数的待处理队列中还有多少其他功能块</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="bold">T</mi><mrow><mi mathvariant="bold">a</mi><mi mathvariant="bold">l</mi><mi mathvariant="bold">g</mi><mi mathvariant="bold">o</mi></mrow></msub><mo>=</mo><mrow><mi mathvariant="bold">T</mi><mi mathvariant="bold">i</mi><mi mathvariant="bold">m</mi><msub><mi mathvariant="bold">e</mi><mn mathvariant="bold">6</mn></msub></mrow><mi mathvariant="normal">–</mi><mrow><mi mathvariant="bold">T</mi><mi mathvariant="bold">i</mi><mi mathvariant="bold">m</mi><msub><mi mathvariant="bold">e</mi><mn mathvariant="bold">4</mn></msub></mrow></mrow><annotation encoding="application/x-tex">\mathbf{T_{algo}}= \mathbf{Time_6} – \mathbf{Time_4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.972218em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathbf mtight">a</span><span class="mord mathbf mtight">l</span><span class="mord mathbf mtight" style="margin-right:0.01597em;">g</span><span class="mord mathbf mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbf">T</span><span class="mord mathbf">i</span><span class="mord mathbf">m</span><span class="mord"><span class="mord mathbf">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mord" style="margin-right:0.02778em;">–</span><span class="mord"><span class="mord mathbf">T</span><span class="mord mathbf">i</span><span class="mord mathbf">m</span><span class="mord"><span class="mord mathbf">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>：功能块算法开始和完成之间的时间</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="bold">T</mi><mrow><mi mathvariant="bold">f</mi><mi mathvariant="bold">i</mi><mi mathvariant="bold">n</mi></mrow></msub><mo>=</mo><mrow><mi mathvariant="bold">T</mi><mi mathvariant="bold">i</mi><mi mathvariant="bold">m</mi><msub><mi mathvariant="bold">e</mi><mn mathvariant="bold">8</mn></msub></mrow><mi mathvariant="normal">–</mi><mrow><mi mathvariant="bold">T</mi><mi mathvariant="bold">i</mi><mi mathvariant="bold">m</mi><msub><mi mathvariant="bold">e</mi><mn mathvariant="bold">6</mn></msub></mrow></mrow><annotation encoding="application/x-tex">\mathbf{T_{fin}}= \mathbf{Time_8} – \mathbf{Time_6}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83611em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathbf mtight" style="margin-right:0.10903em;">f</span><span class="mord mathbf mtight">i</span><span class="mord mathbf mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbf">T</span><span class="mord mathbf">i</span><span class="mord mathbf">m</span><span class="mord"><span class="mord mathbf">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mord" style="margin-right:0.02778em;">–</span><span class="mord"><span class="mord mathbf">T</span><span class="mord mathbf">i</span><span class="mord mathbf">m</span><span class="mord"><span class="mord mathbf">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>：从完成算法到引发输出事件的时间</li>
</ul>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230519134256803.png" alt="image-20230519134256803" style="zoom:80%;">
<p>在不同的实现中，可能需要多种机制来确保功能块能够使用一致的数据来执行。例如，重要的是输入数据值在算法执行时保持稳定。该算法应该只使用在输入事件到达时存在的输入值，即输入事件可用于快照准备算法执行的输入值。</p>
<h3 id="复合功能块类型"><a class="markdownIt-Anchor" href="#复合功能块类型"></a> 复合功能块类型</h3>
<p>复合功能块和子应用程序类型的内部行为由功能块实例网络定义。因此，该定义包括需要存在于内部功能块实例之间的数据和事件连接。</p>
<h3 id="服务接口功能块类型"><a class="markdownIt-Anchor" href="#服务接口功能块类型"></a> 服务接口功能块类型</h3>
<p>服务接口 (SI) 功能块提供功能块域和外部服务之间的接口，例如与远程设备中的功能块通信或读取硬件实时时钟的值。因为 SI 功能块类型主要与数据事务有关，所以它是使用<u><em><strong>时序图定</strong></em></u>义的。这种形式的图更常用于定义跨通信接口的事务。时序图将在本章后面的服务接口块部分进行描述。</p>
<h2 id="27-分布式模型"><a class="markdownIt-Anchor" href="#27-分布式模型"></a> 2.7 分布式模型</h2>
<p>应用程序和子应用程序都可以“分布式”，即配置为在多个资源上运行。分布式应用程序将由功能块网络组成，功能块的片段在指定资源上运行。请注意，IEC 61499 认为分布涉及不同资源上功能块的排列。因为一个设备可以支持多种资源，所以分布式应用程序可以在单个设备上运行，即使用同一设备内的资源。子应用程序是一种较小的应用程序形式，可以复制，但在其他方面具有与应用程序相同的分布特征。</p>
<p>功能块和应用程序之间存在重要区别。</p>
<ul>
<li>应用程序或子应用程序的时间和性能将取决于它所分布的资源以及连接它们的通信网络。如果两个网络的通信数据速率差异很大，因此两个子应用程序显然会由于网络延迟而具有不同的性能和响应时间，尽管它们的内部软件算法是相同的。</li>
<li>相反，功能块被假定为“原子的”并且仅在单个资源中运行。在这方面，功能块的性能不受通信网络特性的影响。但是，性能可能会在较小程度上受到实例化块的资源和设备的行为和特性的影响。下表总结了这些分布特征。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Distributable</th>
<th>Timing</th>
<th>Reliability</th>
<th>Replication</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Function Block</strong></td>
<td>❌</td>
<td>只依赖于设备</td>
<td>只依赖于设备</td>
<td>FB类型的实例</td>
</tr>
<tr>
<td><strong>Sub-Application</strong></td>
<td>✅</td>
<td>依赖于设备和通讯</td>
<td>依赖于设备和通讯</td>
<td>子应用类型的副本</td>
</tr>
<tr>
<td><strong>Application</strong></td>
<td>✅</td>
<td>依赖于设备和通讯</td>
<td>依赖于设备和通讯</td>
<td>无</td>
</tr>
</tbody>
</table>
<h2 id="28-管理模型"><a class="markdownIt-Anchor" href="#28-管理模型"></a> 2.8 管理模型</h2>
<p>在上面我们说到，资源可以支持构成分布式应用程序或子应用程序的一部分的功能块网络片段。但这些应用程序分段如何被创建和管理？</p>
<p>为此，IEC 61499 还定义了一种特殊形式的应用程序，称为“管理应用程序（Management Application）” ，负责在资源内创建功能块网络。管理应用程序具有比普通应用程序更高的特权功能，可以通过创建功能块和连接来构造其他应用程序的一部分。它通常会通过通信链路与远程编程站等外部代理进行交互。</p>
<p>管理应用程序的功能将包括：</p>
<ul>
<li>在一个资源中创建功能块实例</li>
<li>将功能块片段与一个特定的应用程序联系起来</li>
<li>在功能块和服务接口块之间建立数据和事件连接</li>
<li>作为分布式应用的一部分启动功能块的执行</li>
<li>提供服务以支持从通信链路上查询功能块实例的状态功能块实例的查询</li>
<li>删除功能块实例以及它们的数据和事件连接。</li>
</ul>
<p>一个重要的约束是管理应用程序应该能够为不同的应用程序加载功能块网络片段，而不会干扰其他正<br>
在运行的应用程序的执行。</p>
<p>管理应用程序的一部分可能将以非易失性形式存在于设备中，并且总是能够在设备加电时加载应用程序。</p>
<p>该标准提出了两种提供管理应用程序的方案：</p>
<ul>
<li>
<p>下图描绘了一个具有特殊“管理资源”的设备，该资源包含管理应用程序，这些应用程序提供在设备中提供的相邻资源中建立和维护功能块网络的功能。</p>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230519152240514.png" alt="image-20230519152240514" style="zoom:90%;">
</li>
<li>
<p>在图2.9中，定义了另一种方案，即每个资源包含一个管理应用程序，负责在同一资源中加载功能块网络。<br>
管理应用程序的建模方式与其他使用功能块网络和服务接口功能块的应用程序的建模方式完全相同。一个管理应用程序很可能需要一些服务接口功能块来处理与外部通信链路的接口，例如，处理创建功能块实例的请求。</p>
</li>
</ul>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230519153022606.png" alt="image-20230519153022606" style="zoom:80%;">
<p>管理应用程序的功能尚未在IEC 61499中详细定义，但显然这是一个需要标准化的重要领域，然后才能以一致的方式加载和配置符合IEC 61499的设备。统一的方式加载和配置IEC 61499兼容的设备。</p>
<h2 id="29-运行状态模型"><a class="markdownIt-Anchor" href="#29-运行状态模型"></a> 2.9 运行状态模型</h2>
<p>基于 IEC 61499 功能块网络的大型系统通常会分几个阶段进行开发、调试和投产。因此，在功能块网络中，IEC 61499 提出“生命周期”的概念被建模并应用于功能单元，例如设备、资源和应用程序。</p>
<p>操作状态模型尚未在标准中完全定义，但建议每个功能单元都有明确定义的状态，例如：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">S</mi><mi mathvariant="bold">T</mi><mi mathvariant="bold">O</mi><mi mathvariant="bold">P</mi><mi mathvariant="bold">P</mi><mi mathvariant="bold">E</mi><mi mathvariant="bold">D</mi></mrow><annotation encoding="application/x-tex">\mathbf{STOPPED}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">S</span><span class="mord mathbf">T</span><span class="mord mathbf">O</span><span class="mord mathbf">P</span><span class="mord mathbf">P</span><span class="mord mathbf">E</span><span class="mord mathbf">D</span></span></span></span></span>：单元未运行</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">L</mi><mi mathvariant="bold">O</mi><mi mathvariant="bold">A</mi><mi mathvariant="bold">D</mi><mi mathvariant="bold">E</mi><mi mathvariant="bold">D</mi></mrow><annotation encoding="application/x-tex">\mathbf{LOADED}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">L</span><span class="mord mathbf">O</span><span class="mord mathbf">A</span><span class="mord mathbf">D</span><span class="mord mathbf">E</span><span class="mord mathbf">D</span></span></span></span></span>：单元已加载，例如，当应用程序的所有功能块定义和相关功能块实例已加载到设备中时，设备可能处于“已加载”状态</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">C</mi><mi mathvariant="bold">O</mi><mi mathvariant="bold">N</mi><mi mathvariant="bold">F</mi><mi mathvariant="bold">I</mi><mi mathvariant="bold">G</mi><mi mathvariant="bold">U</mi><mi mathvariant="bold">R</mi><mi mathvariant="bold">A</mi><mi mathvariant="bold">B</mi><mi mathvariant="bold">L</mi><mi mathvariant="bold">E</mi></mrow><annotation encoding="application/x-tex">\mathbf{CONFIGURABLE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">C</span><span class="mord mathbf">O</span><span class="mord mathbf">N</span><span class="mord mathbf">F</span><span class="mord mathbf">I</span><span class="mord mathbf">G</span><span class="mord mathbf">U</span><span class="mord mathbf">R</span><span class="mord mathbf">A</span><span class="mord mathbf">B</span><span class="mord mathbf">L</span><span class="mord mathbf">E</span></span></span></span></span>：单元已加载并准备好在开始运行之前进行配置；当功能块实例已加载但仍<br>
等待功能块连接详细信息时，设备将处于“可配置”状态</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">O</mi><mi mathvariant="bold">P</mi><mi mathvariant="bold">E</mi><mi mathvariant="bold">R</mi><mi mathvariant="bold">A</mi><mi mathvariant="bold">T</mi><mi mathvariant="bold">I</mi><mi mathvariant="bold">O</mi><mi mathvariant="bold">N</mi><mi mathvariant="bold">A</mi><mi mathvariant="bold">L</mi></mrow><annotation encoding="application/x-tex">\mathbf{OPERATIONAL}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">O</span><span class="mord mathbf">P</span><span class="mord mathbf">E</span><span class="mord mathbf">R</span><span class="mord mathbf">A</span><span class="mord mathbf">T</span><span class="mord mathbf">I</span><span class="mord mathbf">O</span><span class="mord mathbf">N</span><span class="mord mathbf">A</span><span class="mord mathbf">L</span></span></span></span></span>：单元已加载和配置并准备好开始执行或支持执行部分加载的应用程序</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">R</mi><mi mathvariant="bold">U</mi><mi mathvariant="bold">N</mi><mi mathvariant="bold">N</mi><mi mathvariant="bold">I</mi><mi mathvariant="bold">N</mi><mi mathvariant="bold">G</mi></mrow><annotation encoding="application/x-tex">\mathbf{RUNNING}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">R</span><span class="mord mathbf">U</span><span class="mord mathbf">N</span><span class="mord mathbf">N</span><span class="mord mathbf">I</span><span class="mord mathbf">N</span><span class="mord mathbf">G</span></span></span></span></span>：装置完全可操作并正在运行</li>
</ul>
<p>为了控制和同步分布式应用程序的加载，该标准建议制定策略以确保“跨组件的一致操作状态”。</p>
<p>例如，分布式应用程序可能需要将功能块网络的片段加载到位于各种不同的（在某些情况下）远程设备中的许多不同资源上。驻留在不同设备中的功能块的加载和配置可能发生在不同时间；但是，可能需要同步所有关联设备和资源从“运行”状态到“运行”状态的切换，才能使应用程序正确启动。</p>
<p>该标准还预见到某些特权功能单元可能会控制其他功能单元的情况。</p>
<blockquote>
<p>例如，设备 A 中的“作业加载器”功能块可用于在远程设备 B 和 C 中加载新的功能块定义，以便为特定类型的批处理配置文件修改应用程序。在这种情况下，需要能够赋予某些块加载、配置和更改其<br>
他块状态的权限。本章已经介绍的管理应用程序功能块显然需要具有特殊权限才能加载和启动完整的应用程序。</p>
</blockquote>
<p>应用程序管理和应用程序操作状态的控制是 IEC 61499 中仍有待开发的领域，可能会在该标准的其他部分中解决。</p>
<h2 id="210-使用适配器的通用接口"><a class="markdownIt-Anchor" href="#210-使用适配器的通用接口"></a> 2.10 使用适配器的通用接口</h2>
<p>面向对象软件的一大优势是能够让不同的对象共享相同的接口。在面向对象软件中，表示具有相似基本特征的实体的对象具有共同的外部接口部分是一种普遍的做法。例如，在设计图形用户界面 (GUI) 时，具有相似特征的图形实体（例如表示圆和正方形的对象）通常具有通用的接口方法（表示正方形和圆形等项目的对象可能有许多共同的方法，例如用于调整大小、移动、复制和颜色填充）。</p>
<p>面相对象软件中的行为共享是通过一种称为“继承”的技术实现的。这允许新的专用对象“继承”，即共享来自另一个更通用类型的对象的相同接口和基本行为。拥有具有通用接口的不同类型的对象在软件设计中具有显着的优势。</p>
<blockquote>
<p>一个很好的例子是处理具有相似特性的传感器的功能块。我们可以设想块处理模拟传感器，比如温度和压差，在它们的接口中有一些共同的特征。例如，两者都需要能够设置高低警报级别，并检测超出范围的情况。能够使用相同的软件来处理不同类型传感器的功能块的共同方面显然是有用的。</p>
</blockquote>
<p>为了促进对通用接口的支持，IEC 61499 定义了一个称为“<u><em><strong>适配器接口</strong></em></u>”的特殊概念。这允许具有相似行为的功能块通过附加特殊类型的功能块来共享相同的接口。</p>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230519165313119.png" alt="image-20230519165313119" style="zoom:80%;">
<p>这种类型的功能块称为“适配器”。它类似于可以连接到其他设备的电子设备，这些设备使用插头和插座布置提供专门的行为。图 2.10 以图形方式描述了这个概念；该图的左侧显示了能够与其上方的专用块紧密连接的适配器块；在右侧，我们看到两个块连接在一起形成适配器连接。</p>
<blockquote>
<p>为了进一步阐明使用适配器的好处，考虑功能块的设计来处理各种形式的模拟输入。</p>
<p>让我们考虑一个块来处理温度输入，另一个块来处理差压输入。显然，每个块都需要自己专门的接口输入和输出。温度块将需要输入来定义热电偶范围、校准偏移、缩放等，而差压输入将需要专门的输入和输出来定义压力滞后和压力传感器特性。</p>
<p>但是，这两个块也将具有一系列通用的输入和输出。只需考虑警报定义和创建的要求； 将报警处理的标准实现封装在一个块中显然会更加高效和一致。 图 2.11 描述了如何使用适配器概念为警报管理提供一个公共块，该公共块可以连接到具有特定行为和不同类型传感器接口的专用块。</p>
<p>在 IEC 61499 中，功能块可以配置为适配器“提供者（Provider）”或“接受者（Acceptor）”。在我们的示例中，警报块 <code>Alarm</code> 被描述为适配器“提供者”，而传感器专用块“<code>Temperature</code>”和“<code>Diff_Pressure</code>”是适配器“接受者”。</p>
<p>请注意，可以用不同的方式对常见行为进行建模。在此示例中，也可以将通用传感器块作为具有所有共享行为的适配器接受器，然后将专用块附加为适配器提供者以提供传感器专业化。</p>
</blockquote>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230519165655643.png" alt="image-20230519165655643" style="zoom:80%;">
<h2 id="211-iec-61499-实体的文本语法"><a class="markdownIt-Anchor" href="#211-iec-61499-实体的文本语法"></a> 2.11 IEC 61499 实体的文本语法</h2>
<p>IEC 61499 标准的一个显着特征是丰富的文本语法（textual syntax），允许以文本语言描述应用程序和功能块等实体模型。文本定义可用于明确定义模型，以便可以自动且一致地创建图形表示。</p>
<blockquote>
<p>例如，一个复合功能块可以由几个具有适当数据和事件连接的较小块组成的网络构成。复合块内部设计的所有方面都可以使用 IEC 61499 文本句法表示。</p>
</blockquote>
<p>可以设想，编译文本定义作为检查特定模型有效性的手段是可能的。文本形式对于将模型设计从一个工作站平台移植到另一个工作站平台当然很有用。它定义了模型的语义方面，但没有完全描述图形细节。</p>
<blockquote>
<p>注意 ⚠️：</p>
<p>在 IEC 61499 标准的第 2 部分中，可以使用基于 XML 的文件交换格式来传输图形属性。这在第 7 章中进行了回顾。</p>
</blockquote>
<blockquote>
<p>例如，可能已经开发了一个特定的模型，显示位于网络图中某些位置的功能块。实际位置和更精细的图形细节（例如颜色和字体）不是此语法的一部分。但是，块之间的逻辑连接是精确定义的。</p>
<p>该标准包含一个详尽的附件，描述了文本句法所有特征的生成规则。请注意，此语法的某些方面将在本书中进行描述，但对于完整和准确的定义，建议参阅 IEC 61499标准第 1 部分中的附录 B</p>
</blockquote>
<h3 id="示例-3选2投票算法"><a class="markdownIt-Anchor" href="#示例-3选2投票算法"></a> 【示例】- 3选2投票算法</h3>
<p>这里使用一个简单的功能块来说明文本语法的一些特性。语法的许多特性将在后面的章节中进行更详细的讨论。</p>
<p>考虑一个功能块，它在三个输入 <code>A</code>、<code>B</code> 和 <code>C</code> 上应用“3 选 2 投票”算法。这可以建模为“基本”功能块，如下所示：</p>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230519170644887.png" alt="image-20230519170644887" style="zoom:80%;">
<p>该块有两个事件输入，<code>Reset</code> 和 <code>Vote</code>。</p>
<ul>
<li><code>Reset</code> 事件会触发一种算法来重置存储的选民内部状态。当 <code>Reset</code> 算法成功完成后，在 <code>Ready</code> 输出端产生一个事件。</li>
<li><code>Vote</code> 事件用于触发主投票算法，该算法检查三个布尔输入 <code>A</code>、<code>B</code> 和 <code>C</code> 的状态。如果两个或多个输入为真，则输出状态设置为真并保持为真，直到执行 <code>Reset</code> 算法。当选举算法完成后，将在 <code>Voted</code> 事件输出中生成一个事件。</li>
</ul>
<p>描述 <code>Voter</code> 功能块的文本语法（textual syntax）如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">FUNCTION_BLOCK VOTER (* Voter FB *)</span><br><span class="line"></span><br><span class="line">EVENT_INPUT</span><br><span class="line">	Reset; (* Reset event *)</span><br><span class="line">	Vote WITH A,B,C; (* Trigger Voter *)</span><br><span class="line">END_EVENT</span><br><span class="line"></span><br><span class="line">EVENT_OUTPUT</span><br><span class="line">	Ready;</span><br><span class="line">	Voted WITH State;</span><br><span class="line">END_EVENT</span><br><span class="line"></span><br><span class="line">VAR_INPUT</span><br><span class="line">	A : BOOL;</span><br><span class="line">	B : BOOL;</span><br><span class="line">	C : BOOL;</span><br><span class="line">END_VAR</span><br><span class="line"></span><br><span class="line">VAR_OUTPUT</span><br><span class="line">	State : BOOL;</span><br><span class="line">END_VAR</span><br><span class="line"></span><br><span class="line">EC_STATES</span><br><span class="line">	Ready : ResetAlg -&gt; Ready;</span><br><span class="line">	Voted : VoteAlg -&gt; Voted;</span><br><span class="line">END_STATES</span><br><span class="line"></span><br><span class="line">EC_TRANSITIONS</span><br><span class="line">	Ready TO Voted := Vote;</span><br><span class="line">	Voted TO Voted := Vote;</span><br><span class="line">	Voted TO Ready := Reset;</span><br><span class="line">END_TRANSITIONS</span><br><span class="line"></span><br><span class="line">ALGORITHM ResetAlg IN ST; (* Reset Algorithm *)</span><br><span class="line">	State := 0; (* Reset the state output *)</span><br><span class="line">END_ALGORITHM</span><br><span class="line"></span><br><span class="line">ALGORITHM VoteAlg IN ST; (* Voter algorithm *)</span><br><span class="line">	IF State = 0 THEN</span><br><span class="line">		State := (A AND B) OR (A AND C) OR (B AND C);</span><br><span class="line">	END_IF;</span><br><span class="line">END_ALGORITHM</span><br><span class="line"></span><br><span class="line">END_FUNCTION_BLOCK</span><br></pre></td></tr></table></figure>
<p>从这个例子中可以看出以下几点：</p>
<ul>
<li>文本定义包括 <code>EVENT_</code> 和 <code>VAR_</code> 部分，用于声明块的输入和输出接口的所有事件和数据</li>
<li>块的内部状态被定义并与触发状态转换的事件相关联；这是在 <code>EC_STATES</code> 和 <code>EC_TRANSITIONS</code> 部分中声明的</li>
<li>当块处于块定义的 <code>EC_STATES</code> 部分中定义的特定状态时，算法由事件触发</li>
<li>每个算法都可以用特定的文本语言定义。在本例中，<code>ResetAlg</code> 和 <code>VoteAlg</code> 算法都是使用结构化文本 (ST) 语言定义的；这是 PLC 编程语言标准 IEC 61131‑3 中定义的高级语言。但请注意，IEC 61499 并不排除使用其他语言（例如 JAVA 或 C）来定义算法内容。事实上，IEC 61499 并没有定义算法定义的文本语法，而是允许使用任何现有的标准文本语言。</li>
</ul>
<h2 id="212-总结"><a class="markdownIt-Anchor" href="#212-总结"></a> 2.12 总结</h2>
<p>我们现在已经回顾了 IEC 61499 引入的主要概念，这些概念提供了一个框架和体系结构来为面向功能块的分布式系统建模。</p>
<p>总结一下：</p>
<ul>
<li>系统模型定义了一组可以通过网络连接进行通信的互连设备。</li>
<li>设备模型支持一种或多种资源，这些资源为功能块网络的加载、配置和执行提供支持。</li>
<li>应用程序可以驻留在一个或多个资源上。 每个资源可以支持应用程序的一部分的管理和执行，每个部分作为功能块网络的一个片段分布。</li>
<li>有基本功能块和复合功能块，用于处理不同形式的块构造和块层次结构。</li>
<li>服务接口块提供网络通信和硬件接口设施。</li>
<li>适配器概念允许功能块共享通用接口。</li>
<li>IEC 61499 文本句法为移植和创建功能块和应用程序等实体的定义提供了一种简洁且可编译的形式。</li>
</ul>
<h1 id="3-定义功能块和子应用程序类型"><a class="markdownIt-Anchor" href="#3-定义功能块和子应用程序类型"></a> 3. 定义功能块和子应用程序类型</h1>
<p>在本章中，我们将回顾如何为功能块和子应用程序创建类型定义，并展示如何使用这些定义来创建功能块实例和子应用程序的副本。</p>
<p>具体我们会：</p>
<ul>
<li>查看不同形式的功能块定义</li>
<li>显示如何定义事件和数据接口</li>
<li>检查算法是如何构建的以及如何与事件执行相关联</li>
<li>考虑功能块实例的行为方式</li>
<li>查看可以使用子应用程序的位置，并将它们的行为和属性与复合功能块进行比较。</li>
</ul>
<h2 id="31-类型与实例"><a class="markdownIt-Anchor" href="#31-类型与实例"></a> 3.1 类型与实例</h2>
<p>在继续定义 IEC 61499 中提供的机制以更详细地定义功能块类型之前，让我们回顾一下功能块类型和实例的作用。</p>
<ul>
<li>功能块类型定义描述了特定类型功能块的外部接口和内部行为。</li>
<li>然而，功能块实例实际上是使用功能块类型定义创建的功能块的工作副本。</li>
</ul>
<p>在大型系统中，功能块类型定义很可能保存在各种库中，用于“控制算法”、“警报管理”、“输入传感器”等目的。基于大型功能块的系统的配置将需要选择合适的功能块类型库，然后根据所选功能块类型声明功能块实例。因此，功能块类型的清晰、精确和明确的定义与有效使用 IEC 61499 密切相关。</p>
<h2 id="32-不同形式的功能块"><a class="markdownIt-Anchor" href="#32-不同形式的功能块"></a> 3.2 不同形式的功能块</h2>
<p>该标准为三种不同形式的功能块提供了类型定义；每种形式都有自己特定的属性和用途，如下表中所列。</p>
<table>
<thead>
<tr>
<th>形式</th>
<th>是否可分布化</th>
<th>定义</th>
<th>注释</th>
</tr>
</thead>
<tbody>
<tr>
<td>基本功能块<br>Basic FB</td>
<td>❌</td>
<td>使用执行控制图 (ECC) 定义的状态。<br>使用适当语言定义的算法，<br>例如 结构化文本，Java。</td>
<td>基本功能块不能分布化； <br>它只能在单个资源上运行。 <br>基本功能块定义了可以构建大型复合块的基本块。</td>
</tr>
<tr>
<td>复合功能块<br>Composite FB</td>
<td>❌</td>
<td>由基本功能块和复合功能块组成的网络构成。<br>定义是根据功能块之间的数据和事件连接给出的。</td>
<td>复合功能块是从较低级别功能块的网络构建的。<br>这些可以是基本的或较低级别的复合块。</td>
</tr>
<tr>
<td>子应用<br>Sub-App</td>
<td>✅</td>
<td>由基本功能块和复合功能块组成的网络构成。<br>一个子应用程序又可以包含更小的子应用程序的副本。</td>
<td>这种类型的块旨在提供可以<br>分布在许多资源上的应用程序的可重用部分。</td>
</tr>
</tbody>
</table>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230520142126665.png" alt="image-20230520142126665" style="zoom:80%;">
<p>这三种形式的主要特征如上图 3.1 所示。应该注意的是，</p>
<ul>
<li>基本功能块和复合功能块始终驻留在单个资源上，并在其输入和输出处提供变量以保存数据值。</li>
<li>基本块还需要用于执行控制状态机的内部存储。</li>
<li>然而，相比之下，子应用程序并没有专门存储输入、输出和事件。对于子应用程序，此类存储由存在于子应用程序主体中的内部功能块提供。</li>
</ul>
<h2 id="33-基本功能块的定义"><a class="markdownIt-Anchor" href="#33-基本功能块的定义"></a> 3.3 基本功能块的定义</h2>
<p>基本功能块（Basic FB）可以使用 IEC 61499 文本句法以文本方式或图形方式进行描述。</p>
<p>有两种图形表示形式共同描述了基本功能块的属性和行为：(i) 外部接口声明和 (ii) 定义事件、状态和算法执行之间关系的执行控制图 (ECC)。</p>
<h3 id="对外接口声明"><a class="markdownIt-Anchor" href="#对外接口声明"></a> 对外接口声明</h3>
<p>如图3.2所示的对外接口声明具有以下特点：</p>
<ul>
<li>功能块类型名称应位于主块的中心，如图3.2 中的“<code>Ramp</code>”所示。</li>
<li>块的<u><em><strong>输入</strong></em></u>始终显示在块的左侧；***输出***显示为来自块的右侧。</li>
<li><u><em><strong>输入事件</strong></em></u>被描述为进入块上部的左侧，<u><em><strong>输出事件</strong></em></u>显示为来自右侧。</li>
<li>输入和输出变量的名称显示在块内与其关联的图形连接器旁边。</li>
<li>输入和输出的数据类型显示分别在图形连接器的左侧和右侧</li>
</ul>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230520151944945.png" alt="image-20230520151944945" style="zoom:80%;">
<p>图形表示提供了足够的信息以用作正式的类型声明。事实上，IEC 61499 的主要目标是图形表示始终具有精确的文本表示。设想图形建模工具将始终能够将图形形式转换为文本表示，反之亦然。</p>
<ul>
<li>
<p>【<u><em><strong>输入事件</strong></em></u>】：例如图 3.2 中描绘的 <code>E_Init</code> 事件，显示为进入功能块标题，如果需要，可以与一个或多个输入相关联。如果模块需要在运行内部算法之前对输入值进行采样，这通常是必需的。在 <code>Ramp</code> 功能块示例中，无论何时发生 <code>E_Init</code> 事件，即在块初始化的瞬间，输入<code>X0</code>、<code>X1</code>、<code>Cycle</code> 和 <code>Duration</code> 都需要保持稳定。同样，当 <code>E_Run</code> 事件发生时，<code>PV</code> 输入值将被采样。</p>
</li>
<li>
<p>【<u><em><strong>输入事件与输入数据的关联</strong></em></u>】使用 IEC 61499 表示为 <code>WITH</code> 限定符的构造。在图形表示中，这使用将事件与其关联数据链接的小正方形显示。</p>
<p>也可以将输出事件与某些输出变量相关联。这用于表示那些已由内部算法更新并在触发输出事件时准备就绪的输出变量。在图 3.2 的基本功能示例中，当内部斜坡算法更新输出 <code>Out</code> 和 <code>Hold</code> 时，会发生 <code>E_Ex0</code> 输出事件。</p>
</li>
<li>
<p>【<u><em><strong>事件</strong></em></u>】可以定义为具有可选的事件类型。这是为了让功能块可以设计为仅在其事件输入处接受特定类型的事件。事件类型提高了设计的鲁棒性。这是对数据类型用于提高设计完整性的方式的逻辑扩展，仅允许连接携带兼容数据的输入和输出。</p>
</li>
<li>
<p>【<u><em><strong>初始化事件</strong></em></u>】：例如，不可能将 <code>E_stop</code> 类型的关闭事件连接到此事件输入。</p>
</li>
<li>
<p>如果未给块事件输入或输出指定事件类型，则应用默认类型 <code>EVENT</code>。这种通用类型 <code>EVENT</code> 的事件可以连接到 <code>EVENT</code> 类型的任何其他事件输入。相反，<code>EVENT</code> 类型的事件输入可以接收任何事件类型的事件。</p>
</li>
</ul>
<blockquote>
<p>注意 ⚠️：</p>
<p>基本功能块的每个输入和输出必须分别与至少一个事件输入或输出相关联。</p>
<p>这是因为，当输入值被采样或输出值发生变化时，总是需要至少一个事件来发出信号。另一种查看方式是将事件及其关联数据视为一种消息类型，允许事件及其数据作为连贯集在块之间传递。</p>
</blockquote>
<p>基本功能块行为的一个重要方面涉及对事件和算法执行之间的关系进行建模。这是使用称为执行控制图(ECC)的概念实现的。与块的其他功能一样，ECC 可以图形方式或文本方式定义。此功能的一个结果是暗示块必须具有存储空间来保存事件样本之间的输入值。同样，它有存储空间来保存输出事件触发之间的输出值。当然总是有这样的可能性，一个块可能以比块可以存储然后处理更快的速率接收带有数据的事件。该标准规定，在这种情况下，底层调度功能应优先考虑功能块算法的执行，以确保此类过载情况不会发生。</p>
<h3 id="内部行为"><a class="markdownIt-Anchor" href="#内部行为"></a> 内部行为</h3>
<p>基本功能块内部行为的描述有两个方面：<u><em><strong>算法体</strong></em></u>和<u><em><strong>算法执行控制</strong></em></u>。</p>
<p>基本块通常包含一种或多种算法。每个算法都由资源调度功能调用，以响应到达块接口的特定输入事件。</p>
<ol>
<li>当算法执行时，它处理来自输入和内部变量的数据，为内部和输出变量创建新值。</li>
<li>当算法完成其执行的某些阶段时，它可能会触发输出事件以表示输出数据已准备就绪并且可以被其他块“使用”。</li>
</ol>
<p>每种算法都<u><em><strong>必须</strong></em></u>触发至少<u><em><strong>一个输出事件</strong></em></u>，以表明它已完成执行。</p>
<p>IEC 61499 没有定义应该用于算法定义的语言。只要可以在输入和输出数据变量及其数据类型和算法语言内的变量之间定义映射，就可以使用任何高级语言。</p>
<p>基本功能块行为的一个重要方面涉及对事件和算法执行之间的关系进行建模。这是使用称为<u><em><strong>执行控制图</strong></em></u>(ECC)的概念实现的。与块的其他功能一样，ECC 可以图形方式或文本方式定义。ECC 是一种<u><em><strong>状态转换图</strong></em></u>，与 IEC 61131‑3 中的图形顺序功能图有许多相似之处。然而，作为一种状态建模技术，它的目的非常不同，不应与 SFC1 等图形编程语言混淆。</p>
<p>每个基本功能块都需要一个 ECC 来定义以下内容：</p>
<ul>
<li>块的主要内部状态；</li>
<li>块将如何响应每种类型的输入事件；</li>
<li>响应输入事件激活哪些算法；</li>
<li>执行算法时触发哪些输出事件。</li>
</ul>
<blockquote>
<p>下图3.3是一个执行控制图（ECC），其描述了我们之前讨论过的 “Ramp” 功能块。在该 ECC 中描述了三个状态 <code>START</code>、<code>INIT</code> 和 <code>RAMP</code>，他们对应功能块中的三个主要状态：</p>
<ul>
<li>“<code>START</code>”状态表示块在等待接收事件时的静止状态。</li>
<li>当模块运行初始化算法“<code>ALG_INIT</code>”时，会出现“<code>INIT</code>”状态。</li>
<li>在“ramping”算法运行时存在“<code>RAMP</code>”状态，即“<code>ALG_RAMP</code>“</li>
</ul>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230522142130287.png" alt="image-20230522142130287" style="zoom:80%;">
<p>状态之间的转换由布尔表达式描述，涉及事件变量和在功能块主体内声明的布尔变量。事件变量提供输入事件的内部表示，并用于描述状态之间的转换。表 3.2 列出了此示例 ECC 的转换条件。</p>
<table>
<thead>
<tr>
<th>FROM state</th>
<th>TO state</th>
<th>Transiton</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>START</code></td>
<td><code>INIT</code></td>
<td><code>E_Init</code> (event)</td>
</tr>
<tr>
<td><code>INIT</code></td>
<td><code>START</code></td>
<td><code>1</code> (always true)</td>
</tr>
<tr>
<td><code>START</code></td>
<td><code>RAMP</code></td>
<td><code>E_Run</code> (event)</td>
</tr>
<tr>
<td><code>RAMP</code></td>
<td><code>START</code></td>
<td><code>1</code> (always true)</td>
</tr>
</tbody>
</table>
<p>在此示例中，“<code>INIT</code>”和“<code>RAMP</code>”是仅在算法执行时存在的瞬态。在更复杂的块中，状态可以表示块的基本状态或模式。</p>
</blockquote>
<h3 id="执行控制图ecc功能"><a class="markdownIt-Anchor" href="#执行控制图ecc功能"></a> 执行控制图（ECC）功能</h3>
<p>该标准定义了一系列适用于执行控制图（ECC）的规则和功能，总结如下：</p>
<ul>
<li>
<p>一个基本功能块只有一个执行控制图，它是使用功能块类型定义的执行控制块部分中的文本句法定义的；</p>
</li>
<li>
<p>每个 ECC 必须有一个初始状态，在图中使用两个同心圆表示；</p>
</li>
<li>
<p>圆形和矩形都可以用来表示 ECC 内的状态（本书中用矩形表示）；</p>
</li>
<li>
<p>ECC 可以使用事件变量作为事件输入。通常，状态之间的转换由使用事件输入变量的逻辑表达式来定义；</p>
</li>
<li>
<p>ECC 还可以测试或修改事件输出，同样在ECC内部表示为布尔事件输出变量；</p>
</li>
<li>
<p>ECC 也可以测试但不修改在功能块体内声明的布尔变量。这使得ECC的行为可以根据功能块主体的内部状态来修改。</p>
<blockquote>
<p>例如，一个功能块可能有两种主要模式，如 &quot;手动 &quot;和 “自动”，由一个内部布尔变量 “<code>ManualFlag</code>” 定义。在一个特定的输入事件到来时，ECC 可以测试 “<code>ManualFlag</code>” 并进入适当的状态以调用手动或自动算法。</p>
</blockquote>
</li>
<li>
<p>触发 ECC 内部状态变化的过渡表达式通常涉及输入事件变量。然而，这些表达式也可以包括代表输出事件的变量、功能块内部状态，以及基于块的主要输入和输出变量值的条件表达式。</p>
</li>
<li>
<p>每个 ECC 状态可以有零个或多个动作。作为一个例子，图 3.4 描述了一个状态 “<code>MAIN</code>”，它有两个动作来调用算法 “<code>CALC</code>” 和 “<code>FILTER</code>”；当它们完成执行时，分别触发输出事件 “<code>ExO_1</code>” 和 “<code>ExO_2</code>”。每个动作通常与一个算法和一个输出事件相关。</p>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230522145717158.png" alt="image-20230522145717158" style="zoom:80%;">
<p>当状态被激活时，为该状态定义的所有动作都会被执行。然而，一个动作可以有一个空的算法，它只需要触发一个输出事件。也有可能出现没有输出事件的动作。通常情况下，一个状态至少会有一个具有输出事件的动作，以向外部世界发出信号，表明某些输出已经被更新。</p>
</li>
</ul>
<blockquote>
<p>注意 ⚠️</p>
<p>只有在转换之前的状态处于活动状态时，才会测试 ECC 内的转换条件。因此，即使一个功能块可能有一个非常复杂的 ECC，在状态之间有大量的转换，测试转换所涉及的开销可能很小，因为在任何时候只有一个状态是活动的。</p>
<p>ECC 主要用于表示输入事件、算法执行和输出事件触发之间的关系。它不应用于对应用程序状态行为进行建模，例如对各种控制模式进行建模。应用程序状态和相关行为应在功能块算法本身中定义。对于大多数相当复杂的功能块，ECC 应该相对简单，只有四五个状态。</p>
</blockquote>
<h3 id="文本语法textual-syntax示例"><a class="markdownIt-Anchor" href="#文本语法textual-syntax示例"></a> 文本语法（Textual syntax）示例</h3>
<p>我们依旧以之前讨论的 “Ramp” 功能块为例，考虑其行为，使用 IEC 61499 标准对其进行建模。</p>
<ul>
<li>该功能块将输出“<code>OUT</code>”从输入“<code>X0</code>”给出的初始值“ramp”到目标值在“<code>Duration</code>”输入给定的时间内为“<code>X1</code>”。</li>
<li>“<code>Cycle</code>”输入定义了&quot;ramp&quot;输出更新之间的经过时间。</li>
<li>该块还检查输出是否超过输入“<code>PV</code>”，在这种情况下，“<code>Hold</code>”输出设置为真。假设 “ramp” 块以“<code>Cycle</code>”时间给定的更新速率重复调用；例如，它可能被配置为每 <code>200 ms</code> 执行一次。</li>
</ul>
<p>我们已经回顾了这个基本功能块的两个图形视图：（i）图形功能块类型声明（见图3.2）和（ii）执行控制图 ECC（见图3.3）。这两个图中给出的信息也可以用 IEC 61499 文本语法来表示，它与使用 IEC 61131-3 结构化文本语言（ST）表达的算法一起提供了“Ramp”块的完整文本定义，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">FUNCTION_BLOCK Ramp</span><br><span class="line">	(* Ramp function block type definition *)</span><br><span class="line">	</span><br><span class="line">EVENT_INPUT</span><br><span class="line">	E_Init WITH X0,X1,Cycle,Duration;</span><br><span class="line">	E_Run WITH PV;</span><br><span class="line">END_EVENT</span><br><span class="line"></span><br><span class="line">EVENT_OUTPUT</span><br><span class="line">	E_Rdy;</span><br><span class="line">	E_Ex0 WITH Out,Hold;</span><br><span class="line">END_EVENT</span><br><span class="line"></span><br><span class="line">EC_STATE</span><br><span class="line">	START; (* Initial state *)</span><br><span class="line">	INIT: ALG_INIT -&gt; E_Rdy;</span><br><span class="line">	RAMP: ALG_RAMP -&gt; E_Ex0;</span><br><span class="line">END_STATES</span><br><span class="line"></span><br><span class="line">EC_TRANSITIONS</span><br><span class="line">	START TO INIT := E_Init;</span><br><span class="line">	INIT TO START := 1;</span><br><span class="line">	START TO RAMP := E_Run;</span><br><span class="line">	RAMP TO START := 1;</span><br><span class="line">END_TRANSITIONS</span><br><span class="line"></span><br><span class="line">VAR_INPUT</span><br><span class="line">	X0 : REAL;</span><br><span class="line">	X1 : REAL;</span><br><span class="line">	Cycle : TIME;</span><br><span class="line">	Duration : TIME;</span><br><span class="line">	PV : REAL;</span><br><span class="line">END_VAR</span><br><span class="line"></span><br><span class="line">VAR_OUTPUT</span><br><span class="line">	Out : REAL;</span><br><span class="line">	Hold : BOOL;</span><br><span class="line">END_VAR</span><br><span class="line"></span><br><span class="line">VAR</span><br><span class="line">	T : TIME; (* Time into Ramp *)</span><br><span class="line">END_VAR</span><br><span class="line"></span><br><span class="line">(* Algorithm definitions *)</span><br><span class="line">ALGORITHM ALG_INIT IN ST:</span><br><span class="line">	T := T#0s;</span><br><span class="line">END_ALGORITHM</span><br><span class="line"></span><br><span class="line">ALGORITHM ALG_RAMP IN ST:</span><br><span class="line">	IF T &lt; Duration THEN</span><br><span class="line">		OUT := X0 + (X1-X0) * TIME_TO_REAL(T) / TIME_TO_REAL(Duration);</span><br><span class="line">		T := T + Cycle;</span><br><span class="line">		Hold := PV &gt; Out;</span><br><span class="line">	END_IF;</span><br><span class="line">END_ALGORITHM</span><br><span class="line"></span><br><span class="line">END_FUNCTION_BLOCK</span><br></pre></td></tr></table></figure>
<p>“Ramp”功能块在上述类型声明中被完全定义。在初始化事件 “<code>E_Init</code>”到来时，描述“ramp”行为的输入值，即 <code>X0</code>，<code>X1</code> ，<code>Duration</code> 和 <code>Cycle</code>。<br>
“<code>INIT</code>”状态被激活，导致初始化算法“<code>ALG_INIT</code>”被调用。这就重置了内部定时器变量 “<code>T</code>”。当初始化算法结束时，输出事件“<code>E_rdy</code>”被触发，如 <code>EC_STATE</code> 声明中所定义。<br>
同样，当收到运行事件“<code>E_Run</code>”时，会发生向状态“<code>RAMP</code>”的转换，导致“<code>ALG_RAMP</code>”算法运行。这个算法根据<code>X0</code>、<code>X1</code>、<code>Cycle</code> 和 <code>Duration</code> 的值以及进入 <code>RAMP</code> 的时间 <code>T</code> 来计算 <code>OUT</code> 的新输出值。该算法还检查输出是否超过了“<code>PV</code>”的输入值，在这种情况下，输出“<code>Hold</code>”被设置为真。</p>
<h3 id="基础功能块实例的行为"><a class="markdownIt-Anchor" href="#基础功能块实例的行为"></a> 基础功能块实例的行为</h3>
<p>使用文本或图形声明，都可以定义从基本功能块类型定义中创建的实例。一个基本功能块类型的实例将具有由其类型定义所定义的行为，但它将有自己的输入和输出变量、事件变量和保持其 ECC 状态的存储。换句话说，每个基本函数实例的状态是完全独立于其他实例的。<br>
声明了基本功能块的资源，将在第一次激活该功能块之前初始化每个基本功能实例。这种初始化包括以下内容：</p>
<ul>
<li>每个输入、输出和内部变量的值被设置为在块类型定义中给出的声明中定义的初始值。如果没有给出初始化值，将采用特定数据类型的默认值。例如，没有定义初始值的布尔输入将总是被初始化为 “<code>FALSE</code>”，这是布尔变量的默认初始值。</li>
<li>在 ECC 中使用的所有事件输入和输出变量将被初始化为 “<code>FALSE</code>”。</li>
<li>算法的内部状态将被初始化。例如，如果一个算法是用 IEC 61131-3 顺序功能图（SFC）语言定义的，那么该算法将被重置，以便它在 SFC 初始步骤中开始。</li>
<li>实例 ECC 的初始状态将被设置为激活；ECC 内的所有其他状态将不激活。</li>
</ul>
<h3 id="算法的执行"><a class="markdownIt-Anchor" href="#算法的执行"></a> 算法的执行</h3>
<p>该标准非常精确地定义了到达功能块事件输入的事件触发 ECC 内状态变化的方式，然后反过来引起资源对功能块算法的调度。这一行为的主要方面总结如下：</p>
<ul>
<li>该资源存储和更新事件变量，以记录输入事件在功能块实例接口处的到达；</li>
<li>然后，该资源只允许在 ECC 内改变状态，如果： (a) 已收到输入事件，(b) 从当前活动状态（即从过渡的前身状态）开始的过渡条件得到满足，© 当前状态下的行动所调用的所有算法已停止执行。</li>
</ul>
<p>这种 IEC 61499算法执行模型的一个后果是，<u><em><strong>如果在算法执行之前或期间，一个输入事件有多次出现，该事件可能会丢失</strong></em></u>。由于这个原因，在标准中指出，资源应该提供检测这种过载条件存在时的手段，并采取适当的行动来恢复错误。</p>
<blockquote>
<p>注意 ⚠️</p>
<p>通过各种手段，应该总是可以创建一个避免事件过载的模型；例如，通过创建块来提供事件和数据队列，或者通过将加载信息反馈给上游块来修改事件输出生成率。</p>
</blockquote>
<p>基本功能块实例的执行控制图（ECC）在任何时候都可以处于<u><em><strong>与资源调度功能有关的三种主要状态</strong></em></u>（<code>Idle</code>、<code>Scheduling_algo</code> 和 <code>Waiting_for_algo_complete</code>）之一。这些状态形成了一个简单的状态机，如下图 3.5 所示，并在下表中描述。</p>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230522153731924.png" alt="image-20230522153731924" style="zoom:80%;">
<table>
<thead>
<tr>
<th>State</th>
<th>Condition</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">S_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td>
<td>Idle</td>
<td>在这种状态下，区块中没有任何东西正在执行或待执行。该区块正在等待输入事件的到来。</td>
</tr>
<tr>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">S_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td>
<td>Scheduling algorithms</td>
<td>当处于状态 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">S_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 时，资源已经检测到一个输入事件的到来，并将在其他当前活动的或其他区块的更高优先级的算法结束后安排该区块的算法。</td>
</tr>
<tr>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">S_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td>
<td>Waiting for algorithms to complete</td>
<td>该资源已经开始执行该区块所选择的算法，现在正在等待，直到该算法结束。</td>
</tr>
</tbody>
</table>
<p>资源调度功能对与这些状态之间的变化相关的转换进行以下操作：</p>
<ul>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">S_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">S_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 与到达的输入事件相关的输入事件变量被设置为真，任何与使用’<code>WITH</code>'结构的事件相关的输入变量被采样并存储在块内。</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">S_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">S_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 资源安排块的算法运行，即资源开始执行与新的活动 ECC 状态相关的算法。在算法执行期间，各种输出事件变量可能被设置为 “<code>TRUE</code>”。在这段时间内，算法通常会更新各种输出变量的值。</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">S_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">S_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 该资源检测到算法已经完成执行。</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">S_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 至 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">S_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 该资源触发与算法执行期间设置的输出事件变量相关的输出事件。所有被定义为 &quot;<code>WITH</code> &quot;特定输出事件的输出变量现在都可以被外部连接的块采样。</p>
<p>当回到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">S_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 空闲状态时，输入事件变量也会被清空。<br>
返回到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">S_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 空闲状态时，输入事件变量也被清除，为新事件的到来做好准备。</p>
</li>
</ul>
<p>一个资源实际执行一个基本功能块的特定算法的方式在某种程度上是 “取决于实现（implementation-dependent）”的。如前所述，一个算法可以用各种语言来表达，因此它的行为不被认为是在 IEC 61499的范围内。然而，算法的实现应具有以下特点：</p>
<ul>
<li><u>输入</u>和<u>输出变量</u>以及<u>事件变量</u>应准确无误地<u>映射到算法中的变量</u>。</li>
<li><u>算法应该被封装</u>，以至于它只能在功能块体内读写变量。</li>
<li>相对于将触发其执行的事件的预期到达率而言，<u>算法的执行时间应该很短</u>。显然，如果一个算法被设计为每 100 毫秒执行一次，并且要使用 100 毫秒的时钟事件来触发，那么它最坏的情况下的执行时间应该远远低于 100 毫秒，以便让其他算法执行。</li>
<li>该<u>算法应该有一个明确的初始状态</u>，当该块第一次被资源准备好执行时，它可以进入这个状态。</li>
</ul>
<h2 id="34-复合功能块的定义"><a class="markdownIt-Anchor" href="#34-复合功能块的定义"></a> 3.4 复合功能块的定义</h2>
<p>复合功能块提供了一种方法，可以从基本功能块和其他较小的复合功能块中分层次地建立起更复杂的功能块。</p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">复</mi><mi mathvariant="normal">合</mi><mi mathvariant="normal">功</mi><mi mathvariant="normal">能</mi><mi mathvariant="normal">块</mi><mo>=</mo><mi mathvariant="normal">基</mi><mi mathvariant="normal">本</mi><mi mathvariant="normal">功</mi><mi mathvariant="normal">能</mi><mi mathvariant="normal">块</mi><mi mathvariant="normal">之</mi><mi mathvariant="normal">间</mi><mi mathvariant="normal">/</mi><mi mathvariant="normal">或</mi><mi mathvariant="normal">与</mi><mi mathvariant="normal">其</mi><mi mathvariant="normal">他</mi><mi mathvariant="normal">复</mi><mi mathvariant="normal">合</mi><mi mathvariant="normal">功</mi><mi mathvariant="normal">能</mi><mi mathvariant="normal">块</mi><mi mathvariant="normal">之</mi><mi mathvariant="normal">间</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">合</mi></mrow><annotation encoding="application/x-tex">复合功能块 = 基本功能块之间/或与其他复合功能块之间的组合</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mord cjk_fallback">复</span><span class="mord cjk_fallback">合</span><span class="mord cjk_fallback">功</span><span class="mord cjk_fallback">能</span><span class="mord cjk_fallback">块</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">基</span><span class="mord cjk_fallback">本</span><span class="mord cjk_fallback">功</span><span class="mord cjk_fallback">能</span><span class="mord cjk_fallback">块</span><span class="mord cjk_fallback">之</span><span class="mord cjk_fallback">间</span><span class="mord">/</span><span class="mord cjk_fallback">或</span><span class="mord cjk_fallback">与</span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">他</span><span class="mord cjk_fallback">复</span><span class="mord cjk_fallback">合</span><span class="mord cjk_fallback">功</span><span class="mord cjk_fallback">能</span><span class="mord cjk_fallback">块</span><span class="mord cjk_fallback">之</span><span class="mord cjk_fallback">间</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">合</span></span></span></span></p>
</blockquote>
<p>复合功能块的类型定义包含对选定类型的功能块实例的声明，这些实例通过数据和事件连接被连接起来。该标准将在复合块中使用的块视为组件功能块。组件块之间的数据连接定义了块输出到输入之间的数据值传输，而事件连接定义了块内算法的执行顺序。</p>
<h3 id="复合块类型规范的规则"><a class="markdownIt-Anchor" href="#复合块类型规范的规则"></a> 复合块类型规范的规则</h3>
<p>关于复合功能块类型定义的规范有一些规则和限制，特别是关于外部事件和数据输入和输出与内部组件块的连接。</p>
<p>这些规则的产生是因为事件不能直接被扇出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow></mrow><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span>（fanned-out）；也就是说，在事件输出和事件输入之间必须有<u><em><strong>一对一的连接</strong></em></u>。通过使用 <code>E_SPLIT</code> 功能块可以使一个事件产生多个并发的事件；这是第五章中讨论的IEC 61499的特殊事件功能块之一。相比之下，数据输入可以是扇形的，即允许一个数据输出来驱动许多不同的数据输入。</p>
<blockquote>
<p><strong>扇出系数</strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow></mrow><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span>（英语：Fan-out）是电子技术中表明逻辑门带负载能力的一个量度，其定义为一个逻辑门电路能驱动与之同类逻辑门的个数。大多数晶体管—晶体管逻辑（TTL）门能够为10个其他数字门或设备提供信号。因而，一个典型的晶体管—晶体管逻辑门有10个扇出。</p>
<p>（资料来源<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%89%87%E5%87%BA">维基百科</a>）</p>
</blockquote>
<h3 id="事件连接的规则"><a class="markdownIt-Anchor" href="#事件连接的规则"></a> 事件连接的规则</h3>
<ol>
<li><u><em><strong>每个复合事件输入</strong></em></u>必须正好<u><em><strong>连接到内部组件功能块的一个输入事件</strong></em></u>，或者必须“通过路由（through routed）”到复合块的事件输出。也就是说，事件输入不可能直接连接到不同组件块的多个事件输入。</li>
</ol>
<p>如果需要，<code>E_SPLIT</code> 等事件功能块可用于从单个输入事件中创建扇出事件，见第5章。</p>
<ol start="2">
<li>
<p>每个<u><em><strong>组件的事件输入端</strong></em></u>必须准确地<u><em><strong>连接到</strong></em></u><u><em><strong>一个组件输出事件</strong></em></u>或<u><em><strong>一个复合块事件输入端</strong></em></u>。</p>
</li>
<li>
<p>类似地，<u><em><strong>组件功能块的每个事件输出</strong></em></u>只能精确地<u><em><strong>连接到一个组件输入事件</strong></em></u>或<u><em><strong>一个复合事件输出</strong></em></u>。</p>
</li>
<li>
<p>每个<u><em><strong>复合块的输出事件</strong></em></u>必须正好与<u><em><strong>一个组件的输出事件</strong></em></u>相连接，或者直接<u><em><strong>来自一个复合输入事件</strong></em></u>。</p>
</li>
</ol>
<blockquote>
<p>注意 ⚠️</p>
<p>一些组件块的输入和输出事件可能保持不连接。在这种情况下，仅与未连接的输入事件相关的算法将不会被执行。</p>
</blockquote>
<h3 id="数据连接的规则"><a class="markdownIt-Anchor" href="#数据连接的规则"></a> 数据连接的规则</h3>
<p>以下规则适用于复合块<u><em><strong>数据</strong></em></u>输入和输出与组件输入和输出之间的连接。</p>
<ol>
<li>
<p>复合块的每个数据输入可以</p>
<ul>
<li>连接到内部组件块的一个或多个数据输入，</li>
<li>或直接连接到一个或多个复合功能块的输出，</li>
<li>或同时连接。</li>
</ul>
</li>
<li>
<p>每个组件块的数据输入可以是</p>
<ul>
<li>不连接，</li>
<li>或连接到一个其他组件块的输出，</li>
<li>或连接到复合块的数据输入。</li>
</ul>
<p>显然，该标准不允许一个成分块输入连接到多个输出，因为这样输入就会有一个不确定的值。</p>
</li>
<li>
<p>每个组件块数据输出可以</p>
<ul>
<li>不连接，</li>
<li>或连接到一个或多个组件数据输入，</li>
<li>也可以连接到一个或多个复合数据输出。</li>
</ul>
</li>
<li>
<p>每个复合块数据输出必须连接到</p>
<ul>
<li>一个组件数据输出，</li>
<li>或从一个复合数据通过通过路由（through routed）的方式输入 。</li>
</ul>
</li>
</ol>
<h3 id="复合块示例"><a class="markdownIt-Anchor" href="#复合块示例"></a> 复合块示例</h3>
<p>考虑一下图 3.6 中描述的功能块例子，它被选来演示复合功能块的许多特性。</p>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230522162322847.png" alt="image-20230522162322847" style="zoom:80%;">
<p>该图显示了一个复合块的图形主体，它被描绘成一个连接在一起的功能块网络，形成一个新的块。在这个例子中，一个额外的比较类型的组件功能块和事件功能块 <code>E_MERGE</code> 被用来扩展“Ramp”功能块的功能，形成一个“Sawtooth”发生器。</p>
<blockquote>
<p>注意 ⚠️</p>
<p><code>Ramp1</code> 是 <code>Ramp</code> 基本块的一个实例，如本章前一节所述。每个组件块的实例名称就显示在图形主体中每个块的轮廓上方。</p>
</blockquote>
<p>这个新块的外部接口如图 3.7 所示。</p>
<blockquote>
<p>注意 ⚠️</p>
<p>它的外观与基本功能块相同。事实上，从外部角度来看，仅仅从一个块的外部接口是不可能区分出基本块和复合块的。</p>
</blockquote>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230522162608842.png" alt="image-20230522162608842" style="zoom:80%;">
<p>现在我们将回顾这个块的行为，并说明它是如何被模拟成一个复合功能块的。</p>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230522163306494.png" alt="image-20230522163306494" style="zoom:80%;">
<p>这个块的目的是提供一个输出值，如图 3.8 所示，遵循一个 “sawtooth”曲线，即重复地将输出从 <code>0.0</code> “ramp”到一个目标值，然后复位并从 <code>0.0</code> 重新开始“ramp”。</p>
<ol>
<li>该模块通过输入事件 <code>E_Init</code> 的初始化事件进行初始化。此时，输入<code>X0</code>、<code>X1</code>、<code>Cycle</code> 和 <code>Duration</code> 的输入值被存储在 “<code>Ramp1</code>”输入变量中。
<ul>
<li>在这个例子中，<code>X0</code> 和 <code>X1</code> 被固定在 <code>0.0</code> 和 <code>1000.0</code> 的值上，由复合块主体中定义的常数有效地设置了 ramp 输出 <code>Out</code> 的限制。</li>
<li><code>Cycle</code> 和 <code>Duration</code> 的值来自于块的外部接口提供的值，并定义了“sawtooth”波形的时间特征。</li>
</ul>
</li>
<li>在初始化之后，该块已经准备好在事件输入端 <code>E_Run</code> 接收定期的事件流。<code>E_Run</code>输入的每个事件都会触发<code>Ramp1</code> 块向 <code>X1</code> 设定的上限递增其输出 <code>Out</code>。</li>
<li>每次 <code>Ramp1</code> 内部算法完成其执行，一个输出事件 <code>E_ExO</code> 被传递给 <code>Compare1</code> 块，然后它将 <code>Out</code> 的值与 <code>Target</code> 的值进行检查，即它比较输入<code>X</code> 和 <code>Y</code>。</li>
<li>最终，当 <code>Ramp1.Out</code> 值达到目标值时，比较块检测到输入 <code>X</code> 大于输入 <code>Y</code> 并触发其输出事件 <code>E_GT</code>。</li>
<li>这个事件被反馈给 <code>Merge1</code> 块，它为 <code>Ramp1</code> 块产生一个新的初始化事件。<code>Ramp1</code> 块被重新初始化，输出被重置为 <code>0.0</code>。</li>
<li>只要该块继续在其事件输入 <code>E_Run</code> 接收事件，它将继续产生锯齿形的波形。</li>
</ol>
<p>锯齿（sawtooth）形曲线的斜率可以通过在事件输入端 <code>E_Init</code> 发出不同的持续时间值的初始化事件来改变该块。<code>Merge1</code>是第 5 章中描述的标准事件功能块的一个实例，它提供了一个将多个事件合并为一个新的事件流的方法。在这种情况下，<code>Merge</code> 被用来允许 <code>Ramp</code> 块由外部事件输入 <code>E_Init</code> 或由内部产生的来自比较块的事件来初始化。</p>
<h3 id="with-结构的使用"><a class="markdownIt-Anchor" href="#with-结构的使用"></a> <code>WITH</code> 结构的使用</h3>
<p>通过使用 <code>WITH</code> 结构，可以用图形显示哪些数据输入和输出分别与特定的输入和输出事件相关。</p>
<blockquote>
<p>例如，在图 3.7 中，初始化事件 <code>E_Init</code> 与输入 <code>Cycle</code> 和 <code>Duration</code> 有关。</p>
</blockquote>
<p>然而，与基本功能块的行为不同，<code>WITH</code> 构造并<u><em><strong>不表示输入被存储在属于该块界面的变量中</strong></em></u>。</p>
<p>对于复合块来说，<code>WITH</code> 是一种手段，用来显示<u><em><strong>当一个特定的输入事件发生时，哪些输入需要准备好</strong></em></u>。输入值实际上被采样并存储在内部组件块的输入变量中。同样地，对于输出事件，使用 <code>WITH</code> 构造可以显示当某个特定事件发生时哪些输出值是准备好的，例如在图 3.7 中，当输出事件 <code>E_Ex0</code> 发生时，数据输出 <code>Out</code> 是准备好的。</p>
<blockquote>
<p>注意 ⚠️</p>
<p>标准规定复合功能块声明中的<u><em><strong>每个数据输入和数据输出</strong></em></u>都<u><em><strong>必须与至少一个</strong></em></u> <code>WITH</code> <u><em><strong>构造相关联</strong></em></u>。</p>
<ul>
<li>对于输入来说，这可以确保它们的值至少被一个事件所采样；</li>
<li>对于输出来说，这可以确保有一个明确的时间点来更新输出。</li>
</ul>
</blockquote>
<h3 id="复合功能块的执行"><a class="markdownIt-Anchor" href="#复合功能块的执行"></a> 复合功能块的执行</h3>
<p>复合功能块的实例可以作为资源中存在的功能块网络的一部分来创建，可以存在于顶层，也可以在其他更大的复合功能块的定义中使用。在所有情况下，复合块的执行都是由<u><em><strong>其事件输入的到来</strong></em></u>决定的。该标准定义了以下简单的规则，决定了事件的处理方式：</p>
<ol>
<li>
<p>如果一个复合块的输入事件被直接路由（thought route）到一个复合块的事件输出，那么在事件输入端发生的事件将在该块的事件输出端产生一个事件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">复合块A:OUTPUT --&quot;直接路由&quot;--&gt; 复合块B:INPUT</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果一个输入事件被连接到一个内部组件功能块，那么输入事件的发生将导致一个事件到达组件的输入事件。然后，该组件块将被资源的调度功能安排执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">input_evt1([输入事件]) -.-&gt; componentA</span><br><span class="line"></span><br><span class="line">subgraph 复合块A</span><br><span class="line">	componentA[[组件A]]</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>同样，如果一个组件块的输出事件与另一个组件块的输入事件相连，那么第一个组件块的输出事件将导致第二个组件块被安排执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">flowchart TB</span><br><span class="line">componentA ---&gt; componentB</span><br><span class="line"></span><br><span class="line">subgraph 复合块A</span><br><span class="line">	componentA[[组件A]]</span><br><span class="line">	componentB[[组件B]]</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果一个复合输出事件与一个组件块的输出事件相连，那么当组件块产生一个输出事件时，复合输出事件就会产生。</p>
</li>
</ol>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line"></span><br><span class="line">componentA -.-&gt; output_evt1([输出事件])</span><br><span class="line"></span><br><span class="line">subgraph 复合块A</span><br><span class="line">	componentA[[组件A:OUTPUT]]</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>这些简单的规则在事件和块的执行之间提供了一个直观和逻辑的联系。从本质上讲，事件通过复合功能块的网络传播，从输入端到复合块的输出端进行传播。</p>
<h3 id="复合功能块的文本语法示例"><a class="markdownIt-Anchor" href="#复合功能块的文本语法示例"></a> 复合功能块的文本语法示例</h3>
<p>到目前为止，我们集中讨论了复合功能块的图形表示。与基本功能块一样，IEC 61499文本语法也可以用来描述构成复合功能块的结构和内部网络。例如，图3.6中描述的锯齿形块可以用以下文字描述来表示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">FUNCTION_BLOCK SAWTOOTH</span><br><span class="line">(* Event definitions *)</span><br><span class="line"></span><br><span class="line">EVENT_INPUT</span><br><span class="line">	E_RUN WITH TARGET;</span><br><span class="line">	E_INIT WITH CYCLE, DURATION;</span><br><span class="line">END_EVENT</span><br><span class="line"></span><br><span class="line">EVENT_OUTPUT</span><br><span class="line">	E_RDY;</span><br><span class="line"> 	E_ExO WITH OUT;</span><br><span class="line">END_EVENT</span><br><span class="line"></span><br><span class="line">(* Variable definitions *)</span><br><span class="line">VAR_INPUT</span><br><span class="line">	CYCLE : TIME;</span><br><span class="line">	DURATION : TIME;</span><br><span class="line">	TARGET : REAL;</span><br><span class="line">END_VAR</span><br><span class="line"></span><br><span class="line">VAR_OUTPUT</span><br><span class="line">	OUT : REAL;</span><br><span class="line">END_VAR</span><br><span class="line"></span><br><span class="line">(* Function blocks *)</span><br><span class="line">FBS</span><br><span class="line">	RAMP1 : RAMP;</span><br><span class="line">	COMPARE1 : COMPARE;</span><br><span class="line">	MERGE1 : E_MERGE;</span><br><span class="line">END_FBS</span><br><span class="line"></span><br><span class="line">(* Event connections *)</span><br><span class="line">EVENT_CONNECTIONS</span><br><span class="line">	E_RUN TO RAMP1.E_RUN;</span><br><span class="line">	E_INIT TO MERGE1.EI1;</span><br><span class="line">	MERGE1.EO TO RAMP1.E_INIT;</span><br><span class="line">	RAMP1.E_Rdy TO E_Rdy;</span><br><span class="line">	RAMP1.E_ExO TO E_ExO;</span><br><span class="line">	COMPARE.E_GT TO MERGE1.EI2;</span><br><span class="line">END_CONNECTIONS</span><br><span class="line"></span><br><span class="line">(* Data connections *)</span><br><span class="line">DATA_CONNECTIONS</span><br><span class="line">	0.0 TO RAMP1.X0;</span><br><span class="line">	1000.0 TO RAMP1.X1;</span><br><span class="line">	CYCLE TO RAMP1.CYCLE;</span><br><span class="line">	DURATION TO RAMP1.DURATION;</span><br><span class="line">	RAMP1.OUT TO COMPARE1.X;</span><br><span class="line">	TARGET TO COMPARE1.Y;</span><br><span class="line">	Compare1.X0 TO OUT;</span><br><span class="line">END_CONNECTIONS</span><br><span class="line"></span><br><span class="line">END_FUNCTION_BLOCK;</span><br></pre></td></tr></table></figure>
<p>文本形式比较像电子电路的构建清单。它描述了所有的<u><em><strong>事件和数据输入和输出</strong></em></u>、<u><em><strong>内部功能块</strong></em></u>以及<u><em><strong>事件和数据连接</strong></em></u>。</p>
<p>定义的每一部分都由一个块的关键字引入，例如，<code>EVENT_INPUT</code> … <code>END_EVENT</code> 定义了该块的所有输入事件，同样，<code>DATA_CONNECTIONS</code> … <code>END_CONNECTIONS</code> 定义了外部接口和内部块之间的所有数据连接。</p>
<p>文本语法的开发是为了形成一种通用和可移植的格式，可以用来表达复合块的结构。它并不直接表达块的行为的算法方面，但它确实<u><em><strong>明确地定义了块是如何构建的</strong></em></u>，从中可以推导出它的行为。事实上，目前正在开发的软件工具可以自动在图形和文本表示之间进行转换。</p>
<h2 id="35-子应用的定义"><a class="markdownIt-Anchor" href="#35-子应用的定义"></a> 3.5 子应用的定义</h2>
<p>一个子应用可以被看作是一种特殊形式的复合功能块，它被设计为 “分布式”。也就是说，它可以在一个以上的资源上运行。它的结构与复合功能块相似，但关于数据和事件的使用的一些规则被放松了。一个子应用功能块类型只能在其他较大的子应用的主体中和完整的应用中使用。然而，一个子应用类型本身可以使用复合、基本和其他子应用功能块来定义。</p>
<p>与复合功能块相比，子应用的主要对比特征是它可以选择在多个资源上运行。请注意，基本功能块和复合功能块只能在同一资源上运行，也就是说，不可能将它们分解成可以在不同资源上运行的部分。然而，一个子应用可以在一个资源上运行，也可以分布在不同的资源上运行；换句话说，它是可分布的。</p>
<p>关于子应用的一种方式是，它代表一个可重复使用的部分功能块网络。它通常被用来定义功能块和连接的安排，可以在不同的网络配置中重复使用。在许多方面，子应用类型的定义类似于软件的宏，因为它允许一个特定的解决方案以功能块网络的形式被轻易地复制。</p>
<blockquote>
<p>例如，考虑一个提供温度控制回路的子应用块，如图 3.9a 所示。</p>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230523113657703.png" alt="image-20230523113657703" style="zoom:80%;">
<p>它由一个模拟输入块 <code>Input 1</code>、一个PID控制块 <code>PID 1</code> 和一个模拟输出块 <code>Output 1</code> 组成。通常，这将用于控制一个设备的温度，例如，一个加热容器或炉子。这个控制回路的主要功能是：(i)测量当前温度，(ii)将其值与设定值或期望温度进行比较，然后(iii)调整一个输出值，驱动加热设备来校正温度。</p>
<p>这三个功能被映射到构成子程序的三个组件功能块上。<code>Input 1</code> 模块读取外部传感器的电流值。<code>PID 1</code> 块提供一个 ***PID 算法***来比较测量值（过程值）和设定值并创建输出值。<code>Input 1</code> 模块获取 <code>PID 1</code> 模块创建的值，并将其传输给外部执行器。<br>
<code>Input 1</code> 和 <code>Output 1</code> 将被构造成复合功能块，每个功能块都需要至少一个服务接口功能块来提供与底层控制器的接口，以便从控制器硬件读取输入和输出（I/O)值。<u><em><strong>服务接口功能块</strong></em></u>是一种特殊形式的块，提供与物理设备或通信系统的各种接口，在第四章中讨论。</p>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230523114211924.png" alt="image-20230523114211924" style="zoom:80%;">
<p>图 3.9b 显示了 <code>TempControl</code> 子程序如何在一个简单的控制器中运行，为一个使用蒸汽加热的容器提供闭环温度控制。<code>TempControl</code> 子程序的输入是一个从热电偶等传感器上读取的温度值；子程序的输出驱动某种形式的执行器，如蒸汽阀，以改变加热。</p>
<blockquote>
<p>注意 ⚠️</p>
<p>在这个例子中，<code>TempControl</code> 子程序实际上是 <code>Single_Vessel_Control</code> 程序的一部分，该程序已在单一的 IEC 61499 资源中声明，即其所有功能块都在同一资源中运行。</p>
</blockquote>
<p>这个子程序有两个事件输入，<code>E_Ini</code>t 和 <code>E_Run</code>。</p>
<ul>
<li><code>E_Init</code> 是用来初始化内部组件块的。它触发了 PID块的执行并读取其输入变量，也就是说，<code>Setpoint</code> 输入的值被读取并存储在 <code>PID 1</code> 中。这定义了控制环路将稳定的预期温度。一般来说，PID 算法将需要大量的参数，如积分和导数动作的定时常数。为了保持例子的简单性，这些参数没有显示出来，但将以与设定值相同的方式进行初始化。</li>
<li><code>E_Run</code> 事件在子程序中传播，导致控制环路根据 PID 算法计算的值更新其外部输出。在这个例子中，我们可以假设应用程序中的另一个定时功能块提供一个定期的事件流，例如在 <code>E_Run</code> 事件输入处以 <code>100毫秒</code> 的间隔，以确保 <code>TempControl</code> 块被定期调用。这将确保以给定的扫描速率测量温度，并将其值传播给 <code>PID 1</code>，而<code>PID 1</code>又 会创建一个新的输出值来调节热量输出。</li>
</ul>
</blockquote>
<h3 id="子应用类型规范的规则"><a class="markdownIt-Anchor" href="#子应用类型规范的规则"></a> 子应用类型规范的规则</h3>
<p>子应用构建的规则如下：</p>
<ol>
<li>一个子应用的实例只能在其他子应用类型定义中或在一个应用程序中被声明。</li>
<li>在子应用类型定义中不使用 <code>WITH</code> 构造，因为事件和数据之间的关联将取决于子应用如何在资源之间分配。</li>
<li>在文本语法中，子应用的输入和输出变量使用 <code>VAR_INPUT</code> 和 <code>VAR_OUTPUT</code> 构造来声明，但与复合功能块一样，这并不意味着为这些变量创建存储。子应用程序的所有输入和输出值都存储在组件块的内部接口。</li>
</ol>
<h3 id="子应用的执行规则"><a class="markdownIt-Anchor" href="#子应用的执行规则"></a> 子应用的执行规则</h3>
<p>子应用的实例可以在应用程序中声明，也可以在其他子应用中声明。然而，子应用程序的实例与复合功能块的实例相当不同，因为它真正代表了一组功能块及其连接的副本。在这方面，一个子应用可以被比作一个软件宏或一个图形模式。</p>
<p>该标准为子应用的执行方式定义了以下规则：</p>
<ol>
<li>事件可以直接通过子应用程序路由，因此到达事件输入的事件将立即触发事件输出的事件。</li>
<li>每个没有直接路由的事件输入必须连接到一个内部组件块的事件输入。在这种情况下，当事件到达子应用程序的事件输入时，内部组件块将收到一个事件并被安排执行。</li>
<li>当一个组件块执行时，它将产生一个或多个输出事件。这些将反过来触发在子应用中与之相连的其他组件块的执行。</li>
<li>没有直接通过事件输入的子应用程序的事件输出必须连接到一个组件块的输出事件。当相关的组件块执行并产生一个输出事件时，该事件被传播到子应用程序的事件输出。</li>
</ol>
<h3 id="分布式子应用实例"><a class="markdownIt-Anchor" href="#分布式子应用实例"></a> 分布式子应用实例</h3>
<p>到目前为止，我们已经考虑了在单一资源上运行的子应用。IEC 61499 的一个重要特点是能够重新安排应用程序和子应用程序，使它们能够提供相同的功能，但在不同的资源上以不同的分布安排运行。子应用，如图3.9中描述的 <code>TempControl</code>，可以被分解成更小的功能块网络片段，在不同的资源中运行。在 <code>TempControl</code> 的情况下，可以考虑以下安排：</p>
<ol>
<li>所有块都在一个资源上运行，即非分布式配置</li>
<li><code>Input 1</code>、<code>PID 1</code> 和 <code>Output 1</code> 块在不同的资源上运行，即完全分布式配置。即完全分布式配置</li>
<li><code>Input 1</code> 在一个资源上运行，而<code>PID 1</code> 和 <code>Output 1</code> 块在第二个资源上运行，即分割配置。资源上运行，即一个分离式资源配置</li>
<li><code>Input 1</code>、<code>PID 1</code> 块在一个资源上运行，而 <code>Output 1</code> 在第二个资源上运行，即另一种分割资源配置。</li>
</ol>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230523121624897.png" alt="image-20230523121624897" style="zoom:80%;">
<p>图 3.10 显示了第四种分布安排，其中模拟输入（Analog Input）和 PID 算法的块 <code>Input 1</code>、<code>PID 1</code> 在一个资源 <code>Resource1</code> 上运行，模拟输出（Analog Output）在第二个资源 <code>Output1</code> 上运行。</p>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230523122646643.png" alt="image-20230523122646643" style="zoom:80%;">
<p>在实践中，这种安排意味着子程序 <code>TempControl</code> 可以在位于不同控制器的两个独立资源中运行。图 3.11 显示了可以考虑的一种可能的物理系统配置。它显示了两个控制器 <code>Controller_A</code> 和 <code>Controller_B</code>  通过某种形式的通信系统连接，例如使用现场总线或以太网的网络。模拟输入被连接到 <code>Controller_A</code> ，而执行器现在由另一个 <code>Controller_B</code>  驱动。子应用现在分布在两个控制器上，但内部功能仍然由原始 <code>TempControl</code> 子应用类型定义的功能块来确定。</p>
<p>我们设想，系统设计者可以根据系统设计要求，为子程序自由选择适当的分布安排。设计者选择的分布安排将取决于许多因素，包括：</p>
<ol>
<li>资源是否能够支持特定类型的功能块，</li>
<li>特定资源的负载和性能，</li>
<li>以及资源之间通信服务的延迟和可靠性。</li>
</ol>
<p>可以注意到，如图 3.10 所示，一些额外的功能块 <code>Pub1</code> 和 <code>Sub1</code> 已经被添加到分布式 <code>TempControl</code> 子程序中。这些是服务接口功能块的进一步例子，在第4章有更详细的讨论，它们在资源内的功能块和资源的通信系统之间提供一个接口：</p>
<ul>
<li><code>PUB1</code> 是一个发布者功能块，用于通过通信链路向其他控制器内的一个或多个外部资源发送一个或多个数据值。它只是使用一个给定的识别地址来发送数值。</li>
<li><code>SUB1</code> 是一个订户功能块，在第二个资源中用来接收 <code>PUB1</code> 发出的值。在这种情况下，只有一个用户，但也可能有多个用户的配置。</li>
</ul>
<p>这个例子使用了<u><em><strong>发布者/订阅者服务接口块</strong></em></u>，但标准中也讨论了提供不同类型通信模型的其他块，如请求者和响应者。在这个特定的例子中，使用了发布者/订阅者模型，因为在这个简单的设计中，没有要求向 <code>PID1</code> 块提供任何反馈，以确定向模拟输出的值的传输是否成功。<code>PID1</code> 模块将继续向其输出新的数值，而不管下游的通信问题。显然，在一个完整的设计中，需要监控通信并检查整个控制回路是否正常工作。这可以通过使用，例如，请求和响应通信模型或通过从 <code>Output1</code> 块反馈信号来实现。</p>
<blockquote>
<p>注意 ⚠️</p>
<p>当一个子程序被重新安排在不同的资源上运行时，通常需要为通信系统增加参数。这通常包括诸如资源地址和网络路由参数等细节。这些信息通常将作为参数传递给处理资源间通信的服务接口功能块。</p>
<p>应该强调的是，IEC 61499 没有定义通信协议，也没有对通信相关的地址或参数进行标准化。但它确实提供了一个框架和架构，用于定义服务，如使用服务接口功能块的通信。</p>
</blockquote>
<h2 id="36-总结"><a class="markdownIt-Anchor" href="#36-总结"></a> 3.6 总结</h2>
<p>在本章中，我们已经涵盖了功能块类型定义的最重要方面。我们回顾了类型定义如何被用来创建功能块实例。反过来，我们也看到了功能块实例是如何在新的类型定义中被用来分层建立功能更强的功能块的。尽管设计可以用图形来创建，但我们注意到，标准也定义了一种正式的文本语法，可以作为一种替代的表示方法。</p>
<p>总结一下：</p>
<ul>
<li>
<p>有三类功能块：基本功能块，复合功能块 和 子应用功能块。</p>
</li>
<li>
<p>基本功能块的行为是以执行控制图（ECC）和一个或多个算法来定义的。</p>
</li>
<li>
<p>复合功能块是以一个组件功能块的网络来定义的。</p>
</li>
<li>
<p>子应用块与复合功能块类似，但也有一个灵活的特点，即它们可以分布在多个资源上运行。</p>
</li>
<li>
<p>服务接口功能块提供了一种方法来模拟资源与底层硬件和通信系统之间的互动。</p>
<p>所有的功能块类型定义都可以用图形或文字来定义。图形和文本的表述是可以互换的。</p>
</li>
</ul>
<h1 id="4-服务接口service-interface功能块"><a class="markdownIt-Anchor" href="#4-服务接口service-interface功能块"></a> 4. 服务接口（Service Interface）功能块</h1>
<p>到目前为止，我们主要关注的是用于模拟资源内部行为的功能块。在第三章末尾，我们回顾了一个简单的分布式应用的创建，并表明只有在提供额外的服务接口（SI）功能块以在资源之间通信数据值和事件的情况下，这才可能实现。</p>
<p>事实上，只要资源内的功能块和外部世界之间需要任何形式的交互，就需要 SI 功能块。IEC 61499没有为特定类型的 SI 功能块设定标准，但确实规定这些形式的功能块应使用一套标准的输入和输出变量以及输入和输出事件来定义。还有一种特殊的符号用于描述在执行 SI 功能块期间外部发生的互动序列，如发送请求和等待响应。</p>
<p>现在我们考虑可能需要 SI 功能块的地方。在一个工业控制器中，显然需要读取物理输入值，如来自压力和温度传感器的输入值，也需要将输出值写入执行器，例如，用于驱动阀门、泵、电机等设备。还有要求通过串行通信链路传输数值，向外部控制器发送数据副本，驱动显示器，以及从显示面板和其他 HMI 设备读取输入。事实上，这些都是与资源进行外部交互的例子，可以使用不同类型的 SI 功能块进行建模。下表中列出了一些可能用于工业控制系统建模的 SI 功能块的例子。</p>
<table>
<thead>
<tr>
<th>Type name</th>
<th>Service provided</th>
<th>Application example</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>IO_Writer</code></td>
<td>允许一个资源向本地连接的I/O设备传输一个或多个值。<br>注：IEC 61499假定控制器I/O子系统位于资源之外，但可以使用服务接口块进行访问。</td>
<td>用于更新驱动物理设备的执行器的值，如阀门、加热器或泵。</td>
</tr>
<tr>
<td><code>IO_Reader</code></td>
<td>允许一个资源接收从一个或多个设备读入的最新值。</td>
<td>读取输入设备的位置的最新值，例如机器人放置机构上的微动开关。</td>
</tr>
<tr>
<td><code>Publisher</code></td>
<td>将一个或多个变量的值传输给一个或多个变量。将一个或多个变量的值传送给一个或多个支持 &quot;订阅者 &quot;服务的外部资源。</td>
<td>不断向一些远程控制器传输输出值，以驱动执行器。</td>
</tr>
<tr>
<td><code>Subscriber</code></td>
<td>从提供发布者服务的外部资源接收一个或多个值。<br>注意：发布者和订阅者将通过网络特定的唯一地址或服务标识符来识别一组特定的值。可以有许多用户从一个发布者那里接收数据。</td>
<td>定期从给定的外部资源接收数值流，例如，更新一组HMI显示器。</td>
</tr>
</tbody>
</table>
<p>这些只是可能需要的 SI 功能块种类的几个典型例子。应该注意的是，该标准并不试图定义具体的 SI 块，因为很明显，每个系统都会有自己的特殊要求。然而，我们将看到，IEC 61499 确实对 SI 功能块接口的一些重要方面进行了标准化，包括主要的输入和输出参数。</p>
<h2 id="41-类型定义"><a class="markdownIt-Anchor" href="#41-类型定义"></a> 4.1 类型定义</h2>
<p>IEC 61499 一般性地规定了定义 SI 功能块接口的方式。每个 SI 功能块都提供某种服务，如读取I/O、通过网络发布（Publish）数值等。</p>
<p>应该注意的是，一个 SI 功能块可以响应应用程序的调用而启动一个服务。另外，SI 块可以响应外部请求，如来自 HMI 的信号，从应用程序中获得一个值。SI 功能块可以被建模以支持这两种类型的行为。</p>
<h3 id="si-功能块的标准输入和输出"><a class="markdownIt-Anchor" href="#si-功能块的标准输入和输出"></a> SI 功能块的标准输入和输出</h3>
<p>每个 SI 功能块都应该使用以下标准输入和输出，尽管不是每个 SI 类型的定义都必须使用所有这些输入和输出：</p>
<h4 id="事件输入"><a class="markdownIt-Anchor" href="#事件输入"></a> 事件输入</h4>
<h5 id="init"><a class="markdownIt-Anchor" href="#init"></a> <code>INIT</code></h5>
<p>这个输入事件被用来初始化一个由块提供的特定服务。例如，它可以启动一个服务，通过串行链路提供数据传输。该事件通常与一些输入参数一起发送，以描述服务的类型，如网络地址和波特率。</p>
<h5 id="req"><a class="markdownIt-Anchor" href="#req"></a> <code>REQ</code></h5>
<p>该事件启动一个请求，以从外部代理获得数据。例如，该事件可用于启动一个从外部设备获取数据的请求的传输。</p>
<h5 id="rsp"><a class="markdownIt-Anchor" href="#rsp"></a> <code>RSP</code></h5>
<p>该事件启动了对外部代理的响应的传输。例如，它可以向一个远程HMI设备发送数据，以响应对数据的请求。</p>
<h4 id="事件输出"><a class="markdownIt-Anchor" href="#事件输出"></a> 事件输出</h4>
<h5 id="inito"><a class="markdownIt-Anchor" href="#inito"></a> <code>INITO</code></h5>
<p>这个输出事件表明 SI 功能块已经完成了它的初始化，即作为接收 <code>INIT</code> 事件的一个结果。它不一定意味着服务已经成功初始化；为此提供了一个状态输出。</p>
<h5 id="cnf"><a class="markdownIt-Anchor" href="#cnf"></a> <code>CNF</code></h5>
<p>当区块完成了对外部代理的请求的传输时，“确认（confirmation）”事件被输出。例如，它应该被用来表明一个读取特定物理 I/O 点的请求已经被控制器的 I/O 子系统处理。</p>
<h5 id="ind"><a class="markdownIt-Anchor" href="#ind"></a> <code>IND</code></h5>
<p>当服务接口块收到来自外部代理的响应时，“指示（indication）”事件被输出。例如，当从控制器的 I/O 子系统读取的 I/O 已经获得所选传感器的值时，就会产生一个 <code>IND</code> 事件。</p>
<h4 id="数据输入"><a class="markdownIt-Anchor" href="#数据输入"></a> 数据输入</h4>
<h5 id="qi-bool"><a class="markdownIt-Anchor" href="#qi-bool"></a> <code>QI: BOOL</code></h5>
<p><code>QI</code> 数据输入与 <code>INIT</code> 输入事件一起使用，作为一个简单的限定符。当 <code>true</code> 时，它表示应该启动该块所提供的服务。当它的值为 <code>false</code> 时，与 <code>INIT</code> 事件一起使用，表示服务应被终止。</p>
<h5 id="params-any"><a class="markdownIt-Anchor" href="#params-any"></a> <code>PARAMS： ANY</code></h5>
<p>这个输入表示一个数据结构，它持有一组与 SI 服务相关的值，并定义其特定的特征。该结构中的数据类型和数值数量将具体到功能块提供的服务类型。SI功能块类型定义将定义 <code>PARAMS</code> 结构和其中的默认参数值。该输入仅与 <code>INIT</code> 事件一起使用，用于服务的初始化。</p>
<p>例如，一个通信 SI 功能块的 <code>PARAMS</code> 输入将包含网络寻址信息和其他通信特性。</p>
<h5 id="sd_1-sd_n-any"><a class="markdownIt-Anchor" href="#sd_1-sd_n-any"></a> <code>SD_1, ... SD_N: ANY</code></h5>
<p>这些数据输入被用来发送带有请求和响应的数据。输入的数量和它们的数据类型将特定于功能块提供的服务类型；这由符号 <code>SD_1, ..., SD_N</code> 表示。</p>
<p>例如，当向输出设备写值时，这些参数将包含硬件地址（如机架、模块、通道）和输出值。</p>
<h4 id="数据输出"><a class="markdownIt-Anchor" href="#数据输出"></a> 数据输出</h4>
<h5 id="qo-bool"><a class="markdownIt-Anchor" href="#qo-bool"></a> <code>QO: BOOL</code></h5>
<p>这个限定符输出用于指示任何输入事件的服务是否已经成功完成。例如，在初始化 <code>INIT</code> 事件之后，<code>true</code> 值表示成功启动；<code>false</code> 则表示服务未能初始化。</p>
<h5 id="status-any"><a class="markdownIt-Anchor" href="#status-any"></a> <code>STATUS： ANY</code></h5>
<p>这个输出可以与任何输入事件一起设置，用于提供处理最后一个输入事件的状态。例如，当使用 <code>INIT</code> 事件初始化一个服务并且不成功时，将设置 Status。同样，当一个用于向远程设备传输数值的 <code>REQ</code> 事件被处理并随后失败时，Status 被用来保持失败的原因。</p>
<h5 id="rd_1-rd_n-any"><a class="markdownIt-Anchor" href="#rd_1-rd_n-any"></a> <code>RD_1, ..., RD_N: ANY</code></h5>
<p>这些输出用于传达从 <code>CNF</code> 和 <code>IND</code> 中收到的数据。与 <code>SD_1 ... SD_N</code> 输入，这些输出的数量和它们的数据类型将具体到正在提供的服务类型。</p>
<p>例如，考虑当一个请求被提出来时，例如，从一组 10 个输入点中读取数值–当服务从 I/O 子系统中收到数值时，将发生一个 <code>IND</code> 指示事件；它们的数值将在一组 <code>RD_1...RD_10</code> 输出上提供。</p>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230525095900342.png" alt="image-20230525095900342" style="zoom:80%;">
<p>图4.1描述了两个 SI 功能块，在 IEC 61499 标准中被作为例子给出。这些块仍然是 &quot;通用 &quot;的，因为它们没有被赋予特定数量的输入和输出。输入和输出的数据类型也是用关键字 <code>ANY</code> 来定义的。换句话说，这些是类型定义的大纲模板。要在特定的应用领域使用这些，还需要进一步的具体细节和数据类型。<br>
请求者 SI 功能块提供了一个通信服务，以从远程资源获取数据。</p>
<ul>
<li><code>PARAMS</code> 输入用于指定通信地址和其他细节；</li>
<li><code>SD_1</code> 到 <code>SD_m</code> 输入为一个请求提供参数，例如通过发送请求命令字符串和参数。</li>
<li><code>RD_1</code> 到 <code>RD_n</code> 输出用于从远程资源收到的响应数据，并将在该块发出确认 <code>CNF</code> 输出事件时到达。</li>
</ul>
<p>响应者 SI 功能块，实际上是提供了通信的另一端。它接收来自远程资源的请求，并在 <code>RD_1</code> 至 <code>RD_n</code> 上创建一个指示 <code>IND</code> 事件和输出数据，以表明已经收到了一个远程数据请求。通过将数据写入应答器输入 <code>SD_1</code> 到 <code>SD_m</code>，并在应答器 <code>RSP</code> 事件输入端触发一个事件，可以返回对请求的响应。然后，该数据将被通信系统送回原请求者块，在那里它将被接收，并反过来触发一个带有数据的确认 <code>CNF</code> 输出事件，如前所述。</p>
<p>请求者和响应者 SI 功能块一起可用于在由某种形式的通信或网络设施连接的两个资源之间交换数据。</p>
<ul>
<li>请求者块为 IEC 61499 所提到的 &quot;应用程序发起的互动（application-initiated interation） &quot;提供服务；换句话说，对外部数据的请求是由应用程序内产生的事件触发的。</li>
<li>相反，响应者块为 &quot;资源发起的交互（resource-initiated interaction）&quot;提供服务。对数据的请求来自于外部资源，并导致指示 <code>IND</code> 事件的产生。在这种情况下，应用程序将需要对可能在任何时候发生的事件做出反应。</li>
</ul>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230525100152044.png" alt="image-20230525100152044" style="zoom:80%;">
<p>图4.2显示了 SI 功能块的另外两个例子；<code>IO_Writer</code> 用于向物理输出写值，而 <code>IO_Reader</code> 用于从选定的物理输入读值。两者的功能都是类似的。</p>
<ul>
<li>
<p>让我们考虑如何使用 <code>IO_Writer</code> 块：</p>
<p>一个应用程序将需要至少一个这个块的实例来向物理输出写值。为了设置服务，应用程序必须首先发送一个 <code>INIT</code> 事件，<code>QI</code> 输入设置为 “<code>true</code>”，<code>PARAMS</code> 输入设置为识别服务的特征。<code>PARAMS</code> 输入可以包含一些细节，如“写的更新率”、“失败时重试的次数”等等。此后，通过将输入 <code>SD_1</code> 设置为输出地址，如机架、通道和 I/O 点，并将新值设置为输入 <code>SD_2</code>，可以将数据发送到选定的输出。写入是由事件输入端 <code>REQ</code> 的一个事件启动的。</p>
<p>一段时间后，当硬件I/O系统完成写操作后，将发生一个输出事件 <code>CNF</code>，以确认 &quot;写 &quot;已经完成。输出 <code>STATUS</code> 提供了一个操作是否成功的指示。如果操作失败，<code>STATUS</code> 将包含一个适当的错误代码。输出 <code>RD_1</code> 提供了从输出设备读出的数值的反馈。这可以用来确认写操作已经成功。</p>
</li>
<li>
<p><code>IO_Reader</code> 块以非常类似的方式执行。在使用 <code>INIT</code> 事件初始化服务后，通过 <code>QI</code> 和 <code>PARAMS</code> 输入，可以通过设置输入 <code>SD_1</code> 的 IO 地址并向事件输入 <code>REQ</code> 发送一个事件来读取任何物理输入的值。</p>
<p>一段时间后，当数据从输入传感器中读出后，在输出事件 <code>CNF</code> 中会发生一个确认事件。读取操作的成功将由输出 <code>STATUS</code> 的值表示，如果成功，从输入端读取的值将在输出 <code>RD_1</code>上提供。</p>
</li>
</ul>
<p><code>IO_WRITER</code> 和 <code>IO_READER</code> 是访问硬件 I/O 的 SI 块的相当简单的形式。然而，可以考虑用更复杂的块来模拟读和写的设施，例如，在一次操作中为许多I/O点读出多个值。</p>
<blockquote>
<p>注意 ⚠️</p>
<p>从触发 <code>REQ</code> 事件发出请求到收到确认事件 <code>CNF</code> 之间的时间将取决于许多因素，例如：</p>
<ul>
<li>资源调度系统的负载</li>
<li>设备操作系统响应来自资源调度系统的请求的速度</li>
<li>向物理 I/O 点传输请求的时间。</li>
</ul>
</blockquote>
<h2 id="42-si-功能块的行为"><a class="markdownIt-Anchor" href="#42-si-功能块的行为"></a> 4.2 SI 功能块的行为</h2>
<p>与其他形式的功能块一样，SI 功能块的行为是由功能块类型规范定义的。然而，由于 SI 功能块主要与外部事务有关，该标准规定了一个额外的符号，称为 <em>ISO Technical Report 8509</em> 中的时间顺序图。这些可以用来显示与功能块的各种交互之间的时间和顺序关系。事实上，时间顺序图在通信标准中普遍使用，它提供了一种有效的方法来显示各种信息或事件发生的顺序。</p>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230525103433974.png" alt="image-20230525103433974" style="zoom:80%;">
<p>图4.3显示了时间顺序图的一部分，用来描述图4.1中所显示的请求者功能块的行为。时间顺序图描述了三个事务：</p>
<ol>
<li><em><strong>Normal_initialisation</strong></em>，适用于应用程序启动Requester服务时；</li>
<li><em><strong>Normal_data_transfer</strong></em>，描述了向远程资源发送请求；</li>
<li><em><strong>Normal_termination</strong></em>，描述了应用程序终止服务。</li>
</ol>
<p>让我们更仔细地看一下时间序列图的特点。首先，该图显示时间是向下递增的。例如，在图4.3中，<code>INIT+</code> 事件发生在 <code>INITO+</code> 之前，因为 <code>INTIO</code> 是一个输出事件，它是作为对输入事件 <code>INIT</code> 的响应而产生的，但发生在一段时间之后。此外，密切相关的事件，如 <code>INIT</code> 和 <code>INTIO</code>，总是由竖条内的垂直连接线显示。请注意，在时序图上描述了与事务有关的功能块输入和输出事件的名称。</p>
<p>每个时间序列图中描述的两个垂直条将发生操作的两个不同领域分开。图4.3显示了应用程序发起的事务的例子，在这种情况下，惯例是将功能块类型的名称放在两个垂直条的左边，资源放在右边。发生在功能块领域的事件总是被描述在有功能块类型名称的一侧。</p>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230525103350859.png" alt="image-20230525103350859" style="zoom:80%;">
<p>图4.4显示了响应者功能块的一些事务实例，本章前面也介绍过。在这种情况下，由于主要的交互是由资源而不是应用程序发起的，所以惯例是将资源描绘在垂直条的左侧。</p>
<p>注意，只有 <em><strong>Normal_data_transfer</strong></em> 事务是由资源通过 <code>IND</code> 事件的到达指示启动的。在这个例子中，应用程序处理指示数据并返回一个积极的响应 <code>RSP+</code>。建立和关闭服务的 <em><strong>Normal_initialisation</strong></em> 和 <em><strong>Normal_termination</strong></em> 事务都是由应用程序发起的。</p>
<p>事件名称的后缀 &quot;+“表示该事件是否与成功（或正常）事务有关，而后缀”-&quot;则与不成功（或异常）事务有关。对于输入事件，后缀’+‘表示与该事件一起设置的输入 <code>QI</code> 的值将是 <code>TRUE</code>。反之，后缀’-'意味着输入 <code>QI</code> 将被设置为 <code>FALSE</code>。</p>
<blockquote>
<p>例如，事件 <code>INIT+</code> 表示它将在 <code>QI</code> 设置为 <code>TRUE</code> 的情况下被发送，并意味着服务将被初始化。相反，<code>INIT-</code> 表示该事件将在 <code>QI</code> 设置为 <code>FALSE</code> 的情况下被发送，并表明服务应该被终止。</p>
</blockquote>
<p>与输出事件类似，后缀’+‘表示成功或积极的事务，而后缀’-‘表示该事件与不成功或消极的事务。对于输出事件，后缀’+‘表示输出 <code>QO</code> 的值将被设置为 <code>TRUE</code>，而后缀’-'表示 <code>QO</code> 将被设置为 <code>FALSE</code>。</p>
<blockquote>
<p>例如，<code>IND-</code> 将是一个负面的指示，意味着交易在某种程度上是不成功的。如果这种情况发生在响应者功能块上，它可能意味着从远程资源发送的数据不正确–可能是数据的格式不正确。应用程序应该发出一个否定的响应，即 <code>RSP</code>，如图 4.5 所示。</p>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230525104228690.png" alt="image-20230525104228690" style="zoom:80%;">
</blockquote>
<p>显然，对于复杂的 SI 功能块，应该考虑正常和异常事务的所有不同组合和形式。</p>
<h3 id="si-标准事件的语义"><a class="markdownIt-Anchor" href="#si-标准事件的语义"></a> SI 标准事件的语义</h3>
<p>对于 SI 功能支持的所有标准事件的积极和消极形式的意义（即语义）都有定义。IEC 61499 将这些不同的事件形式定义为服务原语。表 4.2 有两列，分别对应于通信服务和通用服务，并提供了标准服务原语的定义。</p>
<table>
<thead>
<tr>
<th>服务原语</th>
<th>在通信服务中的语义</th>
<th>在一般性服务中的语义</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>INIT+</code></td>
<td>请求<u><em><strong>初始化</strong></em></u>通信服务</td>
<td>请求初始化服务</td>
</tr>
<tr>
<td><code>INIT-</code></td>
<td>请求<u><em><strong>结束</strong></em></u>通信服务</td>
<td>请求结束服务</td>
</tr>
<tr>
<td><code>INITO+</code></td>
<td>表示通信服务<u><em><strong>已被初始化</strong></em></u></td>
<td>表示服务<u><em><strong>已被初始化</strong></em></u></td>
</tr>
<tr>
<td><code>INITO-</code></td>
<td>表示通信服务<u><em><strong>不能被初始化</strong></em></u>或<u><em><strong>已被成功终止</strong></em></u></td>
<td>表示服务<u><em><strong>不能被初始化</strong></em></u>或<u><em><strong>已被成功终止</strong></em></u></td>
</tr>
<tr>
<td><code>REQ+</code></td>
<td><u><em><strong>正常请求</strong></em></u>传输数据</td>
<td><u><em><strong>正常请求</strong></em></u>服务</td>
</tr>
<tr>
<td><code>REQ-</code></td>
<td><u><em><strong>禁用请求</strong></em></u>传输数据</td>
<td><u><em><strong>禁用请求</strong></em></u>服务</td>
</tr>
<tr>
<td><code>CNF+</code></td>
<td>确认数据<u><em><strong>传输成功</strong></em></u></td>
<td>服务的<u><em><strong>正常确认</strong></em></u></td>
</tr>
<tr>
<td><code>CNF-</code></td>
<td>确认数据<u><em><strong>传输不成功</strong></em></u></td>
<td>确认<u><em><strong>服务请求不成功</strong></em></u></td>
</tr>
<tr>
<td><code>IND+</code></td>
<td>数据<u><em><strong>成功到达</strong></em></u>的指示</td>
<td><u><em><strong>正常服务到达</strong></em></u>的指示</td>
</tr>
<tr>
<td><code>IND-</code></td>
<td>数据<u><em><strong>到达不成功</strong></em></u>的指示</td>
<td><u><em><strong>正常未成功到达</strong></em></u>的指示</td>
</tr>
<tr>
<td><code>RSP+</code></td>
<td>应用对数据<u><em><strong>成功到达的响应</strong></em></u></td>
<td>应用对<u><em><strong>成功服务的响应</strong></em></u></td>
</tr>
<tr>
<td><code>RSP-</code></td>
<td>应用对数据<u><em><strong>不成功的到达的响应</strong></em></u></td>
<td>应用对<u><em><strong>不正常或不成功服务的响应</strong></em></u></td>
</tr>
</tbody>
</table>
<h3 id="文本语法-si功能块示例"><a class="markdownIt-Anchor" href="#文本语法-si功能块示例"></a> 文本语法 - SI功能块示例</h3>
<p>IEC 61499 为 SI 功能块类型指定了一个额外的文本语法，允许定义各种服务事务。通过回顾本章前面描述的 <code>IO_Writer</code> 功能块的文本类型定义，可以最好地证明这一点，如图4.2所示。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">FUNCTION_BLOCK IO_WRITER</span><br><span class="line">(* IO_Writer Service Interface *)</span><br><span class="line"></span><br><span class="line">	EVENT_INPUT</span><br><span class="line">		INIT WITH QI, PARAMS;</span><br><span class="line">		REQ WITH QI, SD_1, SD_2;</span><br><span class="line"> 	END_EVENT</span><br><span class="line"> 	</span><br><span class="line">	EVENT_OUTPUT</span><br><span class="line">		INIT0 WITH QO, STATUS;</span><br><span class="line">		CNF WITH QO, STATUS, RD_1;</span><br><span class="line">	END_EVENT</span><br><span class="line">	</span><br><span class="line">	VAR_INPUT</span><br><span class="line">		QI : BOOL; (* Event input qualifier *)</span><br><span class="line">		PARAMS : IO_PARAMS; (* Service parameters *)</span><br><span class="line">		SD_1 : IO_ADDR; (* Output address *)</span><br><span class="line">		SD_2 : IO_VALUE; (* Output value *)</span><br><span class="line">	END_VAR</span><br><span class="line">	</span><br><span class="line">	VAR_OUTPUT</span><br><span class="line">		QO : BOOL; (* Event output qualifier *)</span><br><span class="line">		STATUS : ANY; (* Service status *)</span><br><span class="line">		RD_1 : IO_VALUE (* Returned value *)</span><br><span class="line">	END_VAR</span><br><span class="line">	</span><br><span class="line">	SERVICE REQUESTER/RESOURCE</span><br><span class="line">	</span><br><span class="line">		SEQUENCE normal_initialisation</span><br><span class="line">			REQUESTER.INIT+(PARAMS)-&gt;REQUESTER.INITO+();</span><br><span class="line">		END_SEQUENCE</span><br><span class="line">		</span><br><span class="line">		SEQUENCE abnormal_initialisation</span><br><span class="line">			REQUESTER.INIT+(PARAMS)-&gt;REQUESTER.INITO-();</span><br><span class="line">		END_SEQUENCE</span><br><span class="line">		</span><br><span class="line">		SEQUENCE normal_data_transfer</span><br><span class="line">			REQUESTER.REQ+(SD_1,SD_2)-&gt;REQUESTER.CNF+(RD_1);</span><br><span class="line">		END_SEQUENCE</span><br><span class="line">		</span><br><span class="line">		SEQUENCE abnormal_data_transfer</span><br><span class="line">			REQUESTER.REQ+(SD_1,SD_2)-&gt;REQUESTER.CNF-(STATUS);</span><br><span class="line">		END_SEQUENCE</span><br><span class="line">		</span><br><span class="line">		SEQUENCE normal_termination</span><br><span class="line">			REQUESTER.INIT-()-&gt;REQUESTER.INITO-();</span><br><span class="line">		END_SEQUENCE</span><br><span class="line">		</span><br><span class="line">		SEQUENCE abnormal_termination</span><br><span class="line">			REQUESTER.INIT-()-&gt;REQUESTER.INITO-(STATUS);</span><br><span class="line">		END_SEQUENCE</span><br><span class="line">		</span><br><span class="line">		SEQUENCE resource_initiated_termination</span><br><span class="line">			-&gt; REQUESTER.INITO-(STATUS)</span><br><span class="line">		END_SEQUENCE</span><br><span class="line">		</span><br><span class="line">	END_SERVICE</span><br><span class="line">END_FUNCTION_BLOCK</span><br></pre></td></tr></table></figure>
<ul>
<li>提供了新的关键字 <code>SERVICE</code> 和 <code>END_SERVICE</code> 来包含服务序列的定义。</li>
<li>每个服务序列都用关键词 <code>SEQUENCE</code> 引入，用关键词 <code>END_SEQUENCE</code> 结束。序列定义定义了启动事务的服务原语和相关参数。<code>-&gt;</code> 操作符意味着两件事：
<ol>
<li>由于外部处理或通信延迟，可能会有时间延迟；</li>
<li>由此产生的服务基元，如该操作符右边所述，将作为左边的服务基元的结果而发生。序列的名称必须与“时间-序列图”上给出的名称一一对应。</li>
</ol>
</li>
</ul>
<p>服务启动时应该有效的输入的名称被括在服务基元之后的括号里。同样地，为所产生的服务基元设置的输出名称也显示在右边。</p>
<blockquote>
<p>注意 ⚠️</p>
<p>在资源发起的终止的最后一个序列定义中，在 <code>-&gt;</code> 符号的左边没有给出事务的组件。这是因为，在这种情况下，事务是由资源之外的某个未知代理产生的。例如，这可能发生在即将发生电源故障的情况下，因此设备正在通过资源接口发送一个未经请求的事务以终止 <code>IO_WRITER</code> 服务。</p>
</blockquote>
<p>SI 功能块的任何额外行为，例如在启动服务之前检查特定输入的有效性，可以通过将 SI 块封装在一个复合块中来建模，如第三章所讨论的。然后可以添加额外的功能块来过滤输入数据和验证响应数据。</p>
<p>应该注意的是，SI 功能块类型定义只包含在功能块域内发生的行为的定义，即在资源内。它没有定义资源外的行为，这些行为是由设备操作系统、硬件或通信系统提供的。这都不在 IEC 61499 的范围内。</p>
<h2 id="43-伙伴式partnered服务接口功能块"><a class="markdownIt-Anchor" href="#43-伙伴式partnered服务接口功能块"></a> 4.3 伙伴式（Partnered）服务接口功能块</h2>
<p>在有些情况下，SI 功能块被用来在不同资源之间提供和交换信息。例如，一个应用程序可能分布在两个资源 A 和 B 之间，需要从 A 发送请求数据并从 B 接收响应。然而，驻扎在 A 和 B 的应用程序的两个部分必须能够检测数据交换是否成功。这方面的一个解决方案是提供客户端和服务器 SI 功能块，能够进行双向数据传输。资源 A 中的客户端块向资源 B 中的服务器块发出请求；服务器响应并将响应数据发回给 A 中的客户端块。</p>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230525140256492.png" alt="image-20230525140256492" style="zoom:80%;">
<p>为了对此进行建模，该标准规定时间序列图可以显示双方的交易。考虑图 4.6 所示的客户端和服务器功能块，并假设这些功能块提供一个互锁的数据交换服务。当客户端发出一个请求时，服务器会做出响应。图 4.7 显示了部分时间序列图；在这种情况下，两个竖条代表了在客户端和服务器之间传输消息的处理和时间延迟。</p>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230525140535542.png" alt="image-20230525140535542" style="zoom:80%;">
<p>服务序列的文本语法可以包括事务两端的定义。例如，Server 的类型定义可以包括来自另一个 Client 的预期响应。为了说明这一点，下面的文本语法将把双向数据传输服务序列定义为服务器类型定义的一部分，也就是说，它描述了图 4.7 中的时间序列图。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SEQUENCE normal_data_transfer</span><br><span class="line">	CLIENT.REQ+(SD_1,...,SD_m) -&gt;SERVER.IND+(RD_1,...,RD_m);</span><br><span class="line">	SERVER.RSP+(SD_1,...,SD_n) -&gt;CLIENT.CNF+(RD_1,...,RD_n);</span><br><span class="line">END_SEQUENCE</span><br></pre></td></tr></table></figure>
<p>请注意，客户端的定义将简单地引用服务器的完整事务定义。还要注意的是，在这个例子中，符号 <code>...,SD_n</code> 是表示客户端/服务器块是通用的，可以根据特定的应用进行调整。在一个真实的系统中，每个客户端/服务器对将被指定为发送和接收一个特定数据类型的固定数量的数据项。</p>
<p>客户端和服务器对实际上提供了一种机制来创建一个远程功能块的本地 “代理”。他们可以提供一组本地的输入和输出，模仿远程块上的输入和输出。根据设想，当一个应用程序在资源之间分割时，工程支持工具将能够自动插入客户/服务器对。</p>
<h2 id="44-管理功能块"><a class="markdownIt-Anchor" href="#44-管理功能块"></a> 4.4 管理功能块</h2>
<p>标准中定义的 SI 功能块的最后一种形式涉及到加载、启动和启动功能块执行的服务。该标准定义了一个通用形式的管理功能块，如图4.8所示，可以使用不同的命令定义来启动一系列的服务功能。这些服务的描述和它们的工作方式在标准中只给出了一个概要。这是一个特别难以建模的领域，因为系统将倾向于有完全不同的机制来加载和创建功能块网络，并开始执行加载的应用程序。在未来，关于这些服务的进一步细节可能会被包括在标准的其他部分，但这是一个很大的话题，很难以一般的方式来建模。</p>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230525144502464.png" alt="image-20230525144502464" style="zoom:80%;">
<p>一个极端是，为了启动一个应用程序，一个系统可能需要将所有的功能块和支持的资源库编译成二进制格式，并向下加载到单独的设备中。在另一个极端，设备可能有大量的预装功能块库；例如，功能块的定义可能都是设备固件的一部分。在这种情况下，可以通过简单地下载在不同设备中创建应用的功能块网络所需的连接定义，来创建一个应用。也可能有混合系统，其中一些功能块在固件中，而另一些则被下载。</p>
<p>如下表 4.3、4.4 所示，管理功能块支持的服务在资源和设备层面都适用。</p>
<p><em>(表 4.3，资源层面的管理服务功能)</em></p>
<table>
<thead>
<tr>
<th>Service Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Create</code></td>
<td>创建数据类型定义、功能块类型和实例以及功能块之间的连接。这将涉及到从源头下载定义，例如，通过网络复制，从存储智能卡中复制进来。</td>
</tr>
<tr>
<td><code>Initialise</code></td>
<td>初始化数据类型、功能块类型和实例以及连接。这涉及到将功能块和连接设置为可运行状态，并包括将变量重置为其默认的初始值。</td>
</tr>
<tr>
<td><code>Start</code></td>
<td>启动函数触发了一个资源内功能块网络的执行。通常，它将启动资源调度功能并开始运行产生定时事件的 SI 功能块。这些反过来又会触发导致功能块执行的事件链。</td>
</tr>
<tr>
<td><code>Stop</code></td>
<td>停止服务通过暂停资源调度功能使所有执行停止。</td>
</tr>
<tr>
<td><code>Delete</code></td>
<td>删除服务可用于删除任何数据类型、功能块或连接的定义。</td>
</tr>
<tr>
<td><code>Query</code></td>
<td>查询服务提供了一种方法来访问关于数据类型、功能块和连接的状态、属性和存在的信息。</td>
</tr>
</tbody>
</table>
<p><em>(表 4.4，设备层面的管理服务功能)</em></p>
<table>
<thead>
<tr>
<th>Service Function</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>Create</code></td>
<td>在一个设备中创建和建立一个资源。这设置了一个设备中资源的特征和属性。</td>
</tr>
<tr>
<td><code>Initialise</code></td>
<td>初始化资源，使其准备好加载和执行功能块。</td>
</tr>
<tr>
<td><code>Start</code></td>
<td>启动资源以允许功能块执行。</td>
</tr>
<tr>
<td><code>Stop</code></td>
<td>停止资源执行功能块。</td>
</tr>
<tr>
<td><code>Delete</code></td>
<td>从设备中删除资源，使其不能再被访问以加载和执行功能块。</td>
</tr>
<tr>
<td><code>Query</code></td>
<td>查询设备以获得有关设备中资源的状态、属性和存在的信息。</td>
</tr>
</tbody>
</table>
<p>管理功能块可以通过为 <code>CMD</code> 输入指定不同的值来启动各种服务功能。对每种形式的服务功能的响应是由 Status 输出中返回的值给出的。服务功能由输入 <code>CMD_PARAMS</code> 的值进一步描述。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CMD = CREATE</span><br><span class="line">CMD_PARAMS = fb_instance_definition</span><br><span class="line">PARAMS = fb instance definition data</span><br><span class="line">RESULT = fb instance reference</span><br></pre></td></tr></table></figure>
<p>这启动了服务功能，以创建功能块实例定义。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CMD = QUERY</span><br><span class="line">CMD_PARAMS = connection_start_point</span><br><span class="line">PARAMS = connection start point definition</span><br><span class="line">RESULT = connection end point definition</span><br></pre></td></tr></table></figure>
<p>这显示了一个查询管理服务功能的例子，为一个给定的开始连接找到对结束连接的引用。</p>
<p>作为一个一般性的评论，功能块在建模系统时非常有效，其行为主要与数据和事件流有关。对于加载和创建功能块以形成分布在各个设备上的应用的管理操作，是否可以用同一个模型来描述，这是一个问题。这种类型的行为可能需要一个不同类型的模型，因为它主要涉及到数据管理问题。</p>
<h3 id="被管理的功能块"><a class="markdownIt-Anchor" href="#被管理的功能块"></a> 被管理的功能块</h3>
<p>可以被管理功能块加载和访问的功能块被称为 “被管理功能块”。这与非管理功能块形成对比；这些功能块包括属于设备固件的一部分，因此有一定程度的固定功能。</p>
<p><em>(表 4.5，被管理功能块的主要状态)</em></p>
<table>
<thead>
<tr>
<th>State</th>
<th>Meaning</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>THAWED</code></td>
<td>功能块实例内部状态信息可用，功能块准备开始执行。当功能块的包含设备正在通电时，该状态存在。</td>
</tr>
<tr>
<td><code>RETAINED</code></td>
<td>当一个功能块的包含设备完全断电时，该功能块被认为处于该状态。</td>
</tr>
<tr>
<td><code>IDLE</code></td>
<td>该功能块处于初始化状态。该块的执行控制图处于初始状态；输入和输出变量有其初始值。</td>
</tr>
<tr>
<td><code>RUNNING</code></td>
<td>在这种状态下，功能块被认为可用于接收输入事件。任何输入事件都会被资源调度功能所处理。</td>
</tr>
<tr>
<td><code>STOPPED</code></td>
<td>所有算法和输入事件的处理都由调度函数终止。</td>
</tr>
<tr>
<td><code>KILLED</code></td>
<td>所有输入事件和算法进程的操作被抑制。</td>
</tr>
</tbody>
</table>
<p>管理功能块可以有一些状态，如表 4.5 所定义。如果一个被管理的功能块与一个管理器功能块相关联，那么它的状态可以被改变。这个概念是，一个资源可以通过向管理功能块发出请求来动态地改变功能块的配置。在标准中，这种实际发生的方式还很粗略，但在 IEC 61499 的第二部分中可能会有更详细的处理。</p>
<blockquote>
<p>注意 ⚠️</p>
<p>这只是对管理功能块的主要状态的概述。对于进一步的细节，读者应该参考 IEC 61499 第一部分 &quot;受管功能块的行为 &quot;一节，其中有关于受管功能块的状态机的细节，也有关于不同状态之间的相关转换的描述。</p>
</blockquote>
<h2 id="45-总结"><a class="markdownIt-Anchor" href="#45-总结"></a> 4.5 总结</h2>
<p>我们现在已经介绍了 IEC 61499 服务接口功能的重要特征。重新总结一下，服务接口（SI）功能块的提供是为了在资源中运行的功能块和资源外提供的服务之间提供一个接口。一个 SI 功能块类型的定义只定义了进入服务的接口和它的响应；它并不定义资源外的服务行为。一个特殊的符号，即时间序列图，被用来显示 SI 块的输入和输出侧的事件之间的时间关系。</p>
<p>SI 功能块可用于：</p>
<ul>
<li>对通过设备的I/O子系统访问的I/O点进行读和写</li>
<li>从外部资源请求数据或响应外部资源的数据请求</li>
<li>设置与外部资源的互锁数据交换，例如，使用客户端和服务器块</li>
<li>管理资源中功能块的创建和执行</li>
</ul>
<h1 id="5-事件event功能块"><a class="markdownIt-Anchor" href="#5-事件event功能块"></a> 5. 事件（Event）功能块</h1>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://lostnfound.top">Guohao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lostnfound.top/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/">https://lostnfound.top/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lostnfound.top" target="_blank">Lost N Found</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/">自动化</a></div><div class="post_share"><div class="social-share" data-image="/linear-gradient(45deg,%20#8EC3B0,%20#9ED5C5,%20#F8C4B4,%20#FF8787)" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Guohao</div><div class="author-info__description">L’existence précède l‘essence</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Dave0126" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:dave980126@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D"><span class="toc-text"> 1. 介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-text"> 背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iec-61499-function-block-standard"><span class="toc-text"> IEC 61499 function block standard</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%8A%9F%E8%83%BD%E5%9D%97"><span class="toc-text"> 为什么使用功能块？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E5%9D%97%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB"><span class="toc-text"> 功能块与对象的联系与区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-iec-61499%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%A6%82%E5%BF%B5"><span class="toc-text"> 2. IEC 61499中的模型与概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B"><span class="toc-text"> 2.1 系统模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B"><span class="toc-text"> 2.2 设备模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E8%B5%84%E6%BA%90%E6%A8%A1%E5%9E%8B"><span class="toc-text"> 2.3 资源模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-%E5%BA%94%E7%94%A8%E6%A8%A1%E5%9E%8B"><span class="toc-text"> 2.4 应用模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-%E5%8A%9F%E8%83%BD%E5%9D%97%E6%A8%A1%E5%9E%8B"><span class="toc-text"> 2.5 功能块模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-%E5%8A%9F%E8%83%BD%E5%9D%97%E7%B1%BB%E5%9E%8B"><span class="toc-text"> 2.6 功能块类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E5%9D%97%E7%B1%BB%E5%9E%8B"><span class="toc-text"> 基本功能块类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E5%9D%97%E7%9A%84%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B"><span class="toc-text"> 基本功能块的执行模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E5%8A%9F%E8%83%BD%E5%9D%97%E7%B1%BB%E5%9E%8B"><span class="toc-text"> 复合功能块类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E5%8A%9F%E8%83%BD%E5%9D%97%E7%B1%BB%E5%9E%8B"><span class="toc-text"> 服务接口功能块类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-%E5%88%86%E5%B8%83%E5%BC%8F%E6%A8%A1%E5%9E%8B"><span class="toc-text"> 2.7 分布式模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9E%8B"><span class="toc-text"> 2.8 管理模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B"><span class="toc-text"> 2.9 运行状态模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#210-%E4%BD%BF%E7%94%A8%E9%80%82%E9%85%8D%E5%99%A8%E7%9A%84%E9%80%9A%E7%94%A8%E6%8E%A5%E5%8F%A3"><span class="toc-text"> 2.10 使用适配器的通用接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#211-iec-61499-%E5%AE%9E%E4%BD%93%E7%9A%84%E6%96%87%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text"> 2.11 IEC 61499 实体的文本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-3%E9%80%892%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95"><span class="toc-text"> 【示例】- 3选2投票算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#212-%E6%80%BB%E7%BB%93"><span class="toc-text"> 2.12 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%AE%9A%E4%B9%89%E5%8A%9F%E8%83%BD%E5%9D%97%E5%92%8C%E5%AD%90%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%B1%BB%E5%9E%8B"><span class="toc-text"> 3. 定义功能块和子应用程序类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#31-%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%AE%9E%E4%BE%8B"><span class="toc-text"> 3.1 类型与实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-%E4%B8%8D%E5%90%8C%E5%BD%A2%E5%BC%8F%E7%9A%84%E5%8A%9F%E8%83%BD%E5%9D%97"><span class="toc-text"> 3.2 不同形式的功能块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E5%9D%97%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text"> 3.3 基本功能块的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E5%A4%96%E6%8E%A5%E5%8F%A3%E5%A3%B0%E6%98%8E"><span class="toc-text"> 对外接口声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E8%A1%8C%E4%B8%BA"><span class="toc-text"> 内部行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%8E%A7%E5%88%B6%E5%9B%BEecc%E5%8A%9F%E8%83%BD"><span class="toc-text"> 执行控制图（ECC）功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E8%AF%AD%E6%B3%95textual-syntax%E7%A4%BA%E4%BE%8B"><span class="toc-text"> 文本语法（Textual syntax）示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E5%9D%97%E5%AE%9E%E4%BE%8B%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-text"> 基础功能块实例的行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="toc-text"> 算法的执行</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-%E5%A4%8D%E5%90%88%E5%8A%9F%E8%83%BD%E5%9D%97%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text"> 3.4 复合功能块的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E5%9D%97%E7%B1%BB%E5%9E%8B%E8%A7%84%E8%8C%83%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-text"> 复合块类型规范的规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-text"> 事件连接的规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-text"> 数据连接的规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E5%9D%97%E7%A4%BA%E4%BE%8B"><span class="toc-text"> 复合块示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#with-%E7%BB%93%E6%9E%84%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text"> WITH 结构的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E5%8A%9F%E8%83%BD%E5%9D%97%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="toc-text"> 复合功能块的执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E5%8A%9F%E8%83%BD%E5%9D%97%E7%9A%84%E6%96%87%E6%9C%AC%E8%AF%AD%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="toc-text"> 复合功能块的文本语法示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-%E5%AD%90%E5%BA%94%E7%94%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text"> 3.5 子应用的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E5%BA%94%E7%94%A8%E7%B1%BB%E5%9E%8B%E8%A7%84%E8%8C%83%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-text"> 子应用类型规范的规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E8%A7%84%E5%88%99"><span class="toc-text"> 子应用的执行规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%90%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="toc-text"> 分布式子应用实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36-%E6%80%BB%E7%BB%93"><span class="toc-text"> 3.6 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3service-interface%E5%8A%9F%E8%83%BD%E5%9D%97"><span class="toc-text"> 4. 服务接口（Service Interface）功能块</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#41-%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="toc-text"> 4.1 类型定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#si-%E5%8A%9F%E8%83%BD%E5%9D%97%E7%9A%84%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA"><span class="toc-text"> SI 功能块的标准输入和输出</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E8%BE%93%E5%85%A5"><span class="toc-text"> 事件输入</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#init"><span class="toc-text"> INIT</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#req"><span class="toc-text"> REQ</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rsp"><span class="toc-text"> RSP</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E8%BE%93%E5%87%BA"><span class="toc-text"> 事件输出</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#inito"><span class="toc-text"> INITO</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#cnf"><span class="toc-text"> CNF</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#ind"><span class="toc-text"> IND</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5"><span class="toc-text"> 数据输入</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#qi-bool"><span class="toc-text"> QI: BOOL</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#params-any"><span class="toc-text"> PARAMS： ANY</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sd_1-sd_n-any"><span class="toc-text"> SD_1, ... SD_N: ANY</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%BE%93%E5%87%BA"><span class="toc-text"> 数据输出</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#qo-bool"><span class="toc-text"> QO: BOOL</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#status-any"><span class="toc-text"> STATUS： ANY</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#rd_1-rd_n-any"><span class="toc-text"> RD_1, ..., RD_N: ANY</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-si-%E5%8A%9F%E8%83%BD%E5%9D%97%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-text"> 4.2 SI 功能块的行为</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#si-%E6%A0%87%E5%87%86%E4%BA%8B%E4%BB%B6%E7%9A%84%E8%AF%AD%E4%B9%89"><span class="toc-text"> SI 标准事件的语义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E8%AF%AD%E6%B3%95-si%E5%8A%9F%E8%83%BD%E5%9D%97%E7%A4%BA%E4%BE%8B"><span class="toc-text"> 文本语法 - SI功能块示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43-%E4%BC%99%E4%BC%B4%E5%BC%8Fpartnered%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E5%8A%9F%E8%83%BD%E5%9D%97"><span class="toc-text"> 4.3 伙伴式（Partnered）服务接口功能块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44-%E7%AE%A1%E7%90%86%E5%8A%9F%E8%83%BD%E5%9D%97"><span class="toc-text"> 4.4 管理功能块</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A2%AB%E7%AE%A1%E7%90%86%E7%9A%84%E5%8A%9F%E8%83%BD%E5%9D%97"><span class="toc-text"> 被管理的功能块</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45-%E6%80%BB%E7%BB%93"><span class="toc-text"> 4.5 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E4%BA%8B%E4%BB%B6event%E5%8A%9F%E8%83%BD%E5%9D%97"><span class="toc-text"> 5. 事件（Event）功能块</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background: #8EC3B0"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By Guohao</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: 'ea138c6f176d57705144',
      clientSecret: 'c999d74b366c68c80bc3b704c716a8ff8d67af6d',
      repo: 'Dave0126.github.io',
      owner: 'Dave0126',
      admin: ['Dave0126'],
      id: '0977791134aa8ed5f5410207f933517e',
      updateCountCallback: commentCount
    },))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !true) {
  if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div></div></body></html>