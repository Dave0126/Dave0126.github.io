<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>【笔记】Modelling Control Systeme Using IEC61499 | Lost N Found</title><meta name="author" content="Guohao"><meta name="copyright" content="Guohao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="关于《Modelling Control Systeme Using IEC61499》的读书笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="【笔记】Modelling Control Systeme Using IEC61499">
<meta property="og:url" content="https://lostnfound.top/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/index.html">
<meta property="og:site_name" content="Lost N Found">
<meta property="og:description" content="关于《Modelling Control Systeme Using IEC61499》的读书笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lostnfound.top/linear-gradient(45deg,%20#8EC3B0,%20#9ED5C5,%20#F8C4B4,%20#FF8787)">
<meta property="article:published_time" content="2023-05-16T02:46:01.000Z">
<meta property="article:modified_time" content="2023-05-23T09:10:16.690Z">
<meta property="article:author" content="Guohao">
<meta property="article:tag" content="自动化">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lostnfound.top/linear-gradient(45deg,%20#8EC3B0,%20#9ED5C5,%20#F8C4B4,%20#FF8787)"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://lostnfound.top/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":100,"languages":{"author":"作者: Guohao","link":"链接: ","source":"来源: Lost N Found","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '【笔记】Modelling Control Systeme Using IEC61499',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-05-23 17:10:16'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/atom.xml" title="Lost N Found" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-battery-full"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-calendar-check"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-hashtag"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user-circle"></i><span> 关于我</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/Dave0126"><i class="fa-fw fab fa-github"></i><span> Github</span></a></li><li><a class="site-page child" href="mailto:dave980126@outlook.com"><i class="fa-fw fas fa-envelope"></i><span> Mail</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: linear-gradient(45deg, #8EC3B0, #9ED5C5, #F8C4B4, #FF8787)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Lost N Found</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-battery-full"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-calendar-check"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-hashtag"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user-circle"></i><span> 关于我</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/Dave0126"><i class="fa-fw fab fa-github"></i><span> Github</span></a></li><li><a class="site-page child" href="mailto:dave980126@outlook.com"><i class="fa-fw fas fa-envelope"></i><span> Mail</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">【笔记】Modelling Control Systeme Using IEC61499</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2023-05-16T02:46:01.000Z" title="发表于 2023-05-16 10:46:01">2023-05-16</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-05-23T09:10:16.690Z" title="更新于 2023-05-23 17:10:16">2023-05-23</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%87%AA%E5%8A%A8%E5%8C%96/">自动化</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">21.3k</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>写在前面：</p>
<p>本文章是根据 Robert Lewis 所著《Modelling Control Systems Using IEC 61499》翻译、整理而来。碍于本人学识有限，同时并非本专业人士，部分叙述难免存在纰漏，请读者注意甄别。</p>
<p>参考资料：</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://books.google.com/books?id=m3LaTv7VefwC&amp;lpg=PR5&amp;ots=bygTVzfRst&amp;dq=Modelling%20Control%20Systems%20Using%20IEC%2061499">《Modelling Control Systems Using IEC 61499》, Lewis R. W., ISBN:978-0-85296-796-6 </a></li>
</ul>
<hr>
<h1 id="1-介绍"><a class="markdownIt-Anchor" href="#1-介绍"></a> 1. 介绍</h1>
<h2 id="背景"><a class="markdownIt-Anchor" href="#背景"></a> 背景</h2>
<p>目前为止，工业控制系统分成了两大阵营。一类是基于传统的分布式控制系统(DCS)，另一类是基于可编程逻辑控制器（PLC）。</p>
<ul>
<li>
<p>现行的DCS 主要应用于化工厂和炼油厂。它们是由少量的大型中央处理器构成，提供监控和数据采集。通过本地网络和部署在工厂中的众多控制器，仪表，传感器和执行部件相联。</p>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230516105230518.png" alt="image-20230516105230518" style="zoom:80%;">
<p>系统可以具有分立的仪表和超级工作站。超级工作站由本地控制器和一串仪表构成。在一个DCS 中，许多的监控来自于一个或者多个中心处理器。工厂中的仪表提供本地的闭环控制，例如PID 控制。</p>
</li>
<li>
<p>在许多机器控制和生产过程控制中（特别是自动化生产线中），控制系统是使用PLC来设计的。</p>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230516105952159.png" alt="image-20230516105952159" style="zoom:80%;">
<p>大型PLC 系统通常由多个PLC ，它们通过一个或者多个特定的高速网络相互通信。PLC 一般连接大量的输入输出（I/O) 信号，由它们处理传感器和执行部件。在这种场合，分立仪表，比如温度，压力传感器也连接到PLC 上。</p>
</li>
</ul>
<p>使用这两种设计方法，系统都倾向编写一个大型单一的软件包。这种软件通常很难在新的应用中重复使用，相互之间集成也非常困难。DCS和PLC 两种系统<u><em><strong>难以修改和扩展，不能提供高度的灵活性</strong></em></u>。而这一点却是先进，灵活的控制系统所期望的。</p>
<h2 id="iec-61499-function-block-standard"><a class="markdownIt-Anchor" href="#iec-61499-function-block-standard"></a> IEC 61499 function block standard</h2>
<p>IEC 已经开发了一个专门的标准 IEC61499 ，它定义了如何将功能块（<u><em><strong>function block</strong></em></u>）用于分布式工业过程，测量和控制系统。这项工作有助于解决语义集成的问题。</p>
<blockquote>
<p>&quot;In industrial systems, function blocks are an established concept for defining robust, re-usable software components. A function block can provide a software solution to a small problem, such as the control of a valve, or control a major unit of plant, such as a complete production line.</p>
<p>Function blocks allow industrial algorithms to be encapsulated in a form that can be readily understood and applied by people who are not software specialists. Each block has a defined set of input parameters, which are read by the internal algorithm when it executes. The results from the algorithm are written to the block’s outputs. Complete applications can be built from networks of function blocks formed by interconnecting block inputs and outputs.&quot;</p>
<p>在工业系统中，功能块建立了定义鲁棒性，可重用软件组件的概念。一个功能块能够提供解决小问题的软件解决方法，比如控制阀门。也可以解决一个工厂的主要部件，例如完整的生产线。</p>
<p>功能块允许工业算法封装在一种可理解的形式中，使非软件专家的人士可以使用。每个功能块都有数据输入，供算法执行时读取。算法的结果写入功能块的输出。完整的应用由功能块输入输出互联的功能块网络组成。</p>
</blockquote>
<p>现场总线是连接智能现场设备和自动化系统的数字式、双向传输、多分支结构的通讯网络。也就是说基于现场总线的系统是以单个分散的，数字化，智能化的测量和控制设备作为网络的节点，用总线相连，实现信息的相互交换，使得不同网络，不同现场设备之间可以信息共享。</p>
<h3 id="为什么使用功能块"><a class="markdownIt-Anchor" href="#为什么使用功能块"></a> 为什么使用功能块？</h3>
<p>在面向对象程序设计中的<u><em><strong>对象</strong></em></u>在某种程度上类似于<u><em><strong>功能块</strong></em></u>。对象的概念之所以成功，是因为它们能够为在真实世界的概念和项目建立行为建模。</p>
<blockquote>
<p>使用对象带来的好处：</p>
<ol>
<li>对象反映现实世界。将与应用程序关联的现实世界实体表示为对象，更为自然和直观</li>
<li>对象是稳定的。通常，对象是经过验证的软件元素，不会发生重大变化</li>
<li>对象降低了复杂性。开发人员可以在不真正理解对象内部如何工作的情况下使用对象。可以通过创建和链接对象来开发应用程序通常不需要了解对象的内部结构</li>
<li>对象是可重用的。一旦一个对象被开发和测试，它就可以成为开发人员的一部分（类库）。</li>
</ol>
</blockquote>
<p>功能块也具有这些特性中的大部分，由此所带来的好处有：</p>
<ul>
<li>减少了为应用程序开发的控制软件的数量</li>
<li>减少了开发控制系统所需的时间</li>
<li>使用相同类型功能块的控制系统将具有更一致的行为</li>
<li>使得控制系统更易于测试</li>
</ul>
<h3 id="功能块与对象的联系与区别"><a class="markdownIt-Anchor" href="#功能块与对象的联系与区别"></a> 功能块与对象的联系与区别</h3>
<table>
<thead>
<tr>
<th>Feature</th>
<th>Objects</th>
<th>FBs</th>
<th>Comment</th>
</tr>
</thead>
<tbody>
<tr>
<td>封装数据</td>
<td>✅</td>
<td>✅</td>
<td>对象可能包含同时也是其他对象实例的数据；<br>功能块可能包含其他功能块的实例。</td>
</tr>
<tr>
<td>外部接口</td>
<td>✅</td>
<td>✅</td>
<td>在 IEC 61499 中，私有接口和公共接口之间没有区别和事件</td>
</tr>
<tr>
<td>调用</td>
<td>对象有含参方法和返回值</td>
<td>FB输入输出变量和事件</td>
<td>在FB中，数据可以与事件同步</td>
</tr>
<tr>
<td>继承</td>
<td>✅</td>
<td>❌</td>
<td>目前在 IEC 61499 中没有功能块继承行为的机制</td>
</tr>
<tr>
<td>多态</td>
<td>✅</td>
<td>✅</td>
<td>IEC 61499 引入了一个“Adaptor”概念，允许功能块共享公共接口</td>
</tr>
<tr>
<td>实例化</td>
<td>对象类和功能块类型是同义的</td>
<td>功能块实例是由功能块类型定义的</td>
<td></td>
</tr>
</tbody>
</table>
<h1 id="2-iec-61499中的模型与概念"><a class="markdownIt-Anchor" href="#2-iec-61499中的模型与概念"></a> 2. IEC 61499中的模型与概念</h1>
<p>本章将回顾 IEC 61499 中定义的主要模型和概念，以全面了解功能块标准。IEC 61499 的主要目的不是作为一种编程方法，而是作为分布式系统的架构和模型。按照定义，该标准无意直接由编程工具使用。相反，IEC 61499 提供了一组模型来描述使用功能块编程的分布式系统。</p>
<p>本章涵盖的主题包括：</p>
<ul>
<li>分布式控制系统的系统、设备和资源模型</li>
<li>表示分布式应用程序的模型</li>
<li>功能块的特性及其执行</li>
<li>不同形式的功能块的类型规范</li>
<li>服务接口功能块提供硬件和操作系统的接口</li>
<li>适配器（Adaptor）用于共享块接口</li>
<li>用于定义 IEC 61499 实体的文本语法。</li>
</ul>
<h2 id="21-系统模型"><a class="markdownIt-Anchor" href="#21-系统模型"></a> 2.1 系统模型</h2>
<p>我们将从IEC 61499 中定义的顶层系统模型开始，这定义了通信设备和应用程序之间的关系。</p>
<p>分布式应用程序将被设计为连接功能块的网络。但是，当应用程序加载到系统上时，它通常会作为<br>
一系列功能块网络片段加载到不同的设备中。由各个设备提供的通行服务确保构成应用程序一部分的功能块维护其数据和事件连接。</p>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230518144157171.png" alt="image-20230518144157171" style="zoom:60%;">
<blockquote>
<p>IEC 61499 系统模型允许设备支持多个应用程序的执行。该标准定义了一种设备模型，可以在不干扰现有应用程序的情况下加载和卸载分布式应用程序；这是通过使用设备内的管理服务来实现的这些将在第 4 章后面进行介绍</p>
</blockquote>
<h2 id="22-设备模型"><a class="markdownIt-Anchor" href="#22-设备模型"></a> 2.2 设备模型</h2>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230518151147145.png" alt="image-20230518151147145" style="zoom:70%;">
<p>一个设备能够支持一个或多个资源。 IEC 61499 中的资源具有与 PLC 编程语言标准 IEC 61131‑3 中定义的资源概念类似的属性。资源提供功能块网络的独立执行和控制。</p>
<p>设备模型有一个“进程接口”，它提供使资源能够与物理设备上的输入和输出 (I/O) 点交换数据的服务。还有一个通信接口，为资源提供通信服务，通过外部网络与远程设备中的资源交换数据。</p>
<p>过程和通信接口的内部结构和行为不在 IEC 61499 的范围内，但它们有望提供一系列服务以支持资源内功能块的执行。</p>
<p>该设备的目的是提供一种基础设施来维持一种或多种资源。功能块网络的片段分布在本地设备或远程设备资源中的资源之间。</p>
<h2 id="23-资源模型"><a class="markdownIt-Anchor" href="#23-资源模型"></a> 2.3 资源模型</h2>
<p>该资源提供设施和服务以支持一个或多个功能块应用程序片段的执行。IEC 61499 的主要重点是对每个资源内功能块的行为进行建模。该资源为通信系统和“设备特定进程”提供接口，即与设备紧密相连的外部服务和子系统，例如设备 I/O 子系统。</p>
<blockquote>
<p>例如，每个资源都将有一个到通信系统的接口，以允许功能块与远程资源中的块交换数据，以及一个接口来读取和写入本地设备输入和输出（I/O）。</p>
</blockquote>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230519093741295.png" alt="image-20230519093741295" style="zoom:80%;">
<p>图 2.3 描述了 IEC 61499 资源的主要特征，它显示了一个由数据和事件流链接的互连功能块网络。资源提供的调度功能确保功能块内的算法以正确的顺序执行，即按照事件到达每个功能块的要求。</p>
<ul>
<li>其中，“服务接口” (Service Interface) 功能块是一种特殊形式的功能块，它提供功能块和资源接口之间的链接。例如，通信 SI 块可用于读取数据或将数据发送到远程资源中的功能块。</li>
</ul>
<p>资源的一个重要特征是它支持独立操作，不会影响同一设备或网络中的其他资源。</p>
<blockquote>
<p>注意 ⚠️：</p>
<p>分布式应用程序的管理可能需要协调控制加载功能块网络片段的许多资源。实现这种协调所需的设施是 IEC 61499 <u><em><strong>尚未完全解决</strong></em></u>的问题。</p>
</blockquote>
<h2 id="24-应用模型"><a class="markdownIt-Anchor" href="#24-应用模型"></a> 2.4 应用模型</h2>
<p>在IEC 61499中，应用被定义为由事件和数据流链接的互连功能块网络。</p>
<ul>
<li>应用程序可以分散并分布在许多资源上。</li>
<li>在应用程序中，可以使用子应用程序进一步分解。</li>
<li>子应用程序具有功能块的外部特征，但可以包含功能块网络，这些功能块本身可以分布在其他资源上。该标准定义了应用程序分解的“分形”形式，允许在需要时将子应用程序进一步分解为更小的子应用程序。</li>
</ul>
<p>该应用程序定义了各个块之间所需的事件和数据流之间的关系。分布块的各种资源必须确保事件用于在正确的优先级和时间安排块内的适当算法。</p>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230519100703886.png" alt="image-20230519100703886" style="zoom:80%;">
<blockquote>
<p>注意，IEC 61499 功能块包含用于定义其完整行为的所有算法和初始化值。</p>
</blockquote>
<p>实际上，应用程序是解决特定自动化控制问题的一整套功能块和互连（interconnection）。应用程序由功能块实例和互连定义组成，在某些情况下，它们包括特定块类型的功能块的多个实例。 IEC 61499 的原则是所有行为都根据功能块定义。结果，我们将看到应用程序中没有可以存在于功能块之外的全局或局部变量。这是为基于<br>
IEC 61131‑3 的 PLC 创建的应用程序与 IEC 61499 应用程序之间的重要区别。</p>
<h2 id="25-功能块模型"><a class="markdownIt-Anchor" href="#25-功能块模型"></a> 2.5 功能块模型</h2>
<p>功能块（Function Block）是支持整个 IEC 61499 的核心，其具有自己的数据结构，并且由一个或者多个算法来处理它们。功能块类型（function block  type）提供了数据结构和算法的形式化描述。</p>
<p>功能块可以有多个实例（instance）。从形式上看，功能块和面向对象中的对象非常类似。</p>
<ul>
<li>
<p>每个功能块有一个类型名称和一个实例名称。</p>
</li>
<li>
<p>每一个功能块都有一系列事件输入（<code>Evnet Input</code>）。它们能够接收其它功能块通过事件连接传递的事件。</p>
</li>
<li>
<p>每个功能块都能有事件输出（<code>Evnet Output</code>）。它们向其它功能块传递事件。</p>
</li>
<li>
<p>每个功能块会有数据输入（<code>Data Input</code>）。传递给它其它功能块内部产生的数据。</p>
</li>
<li>
<p>每个功能块会有数据输出（<code>Data Output</code>）。将该功能块内部产生的数据传递该其它功能块。</p>
</li>
<li>
<p>每个区块都会有一组内部变量，用来保存算法调用之间保留的数值。</p>
</li>
<li>
<p>事件可以使用 “<code>WITH</code>” 修饰词与数据关联。在图形表示中，将事件和相关联的数据连接线交叉点画一个小方块。</p>
</li>
<li>
<p>功能块的行为定义为一系列的算法和状态信息。利用块的状态和状态的变化，可以建立各种策略的模型，以定义哪些算法将在响应特定事件时执行。</p>
</li>
</ul>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230519103529416.png" alt="image-20230519103529416" style="zoom:80%;">
<p>上图描述了 IEC 61499 功能块的主要特性：</p>
<ul>
<li>功能块的顶部，称为“执行控制（Execution Control）”部分，在某些情况下包含一个定义，以状态机的形式给出，用于将事件映射到算法；即它定义了下半部分定义的哪些算法在各种事件到达“执行控制”时被触发，以及输出事件何时被触发标准称之为“事件输入、事件输出和算法执行之间的因果关系”。该标准定义了映射到达事件输入的事件、内部算法的执行和输出事件的触发之间的关系的方法，这将在本章后面的部分中讨论。</li>
<li>功能块的下半部分包含算法和内部数据，它们都隐藏在功能块中。功能块是一种软件组件，如果设计得当，<br>
则不需要用户详细了解其内部设计。</li>
</ul>
<p>功能块依赖于其包含资源的支持来提供设施来调度算法并将请求映射到通信和处理接口。</p>
<p>该标准规定资源可以选择性地提供附加功能以允许访问功能块的内部。显然，在现场总线设备中，能够检查块内的内部变量对于维护或调试目的总是有用的。所以可能有“后门”方法来访问功能块内部；然而，从 IEC 61499 体系结构的角度来看，控制变量和事件仅通过外部公开接口传递。</p>
<h2 id="26-功能块类型"><a class="markdownIt-Anchor" href="#26-功能块类型"></a> 2.6 功能块类型</h2>
<p>IEC 61499 中的一个重要概念是定义功能块类型的能力，该类型定义了可以从该类型创建的功能块实例的行为和接口。这与面向对象软件中对象实例的行为由关联对象的类定义定义的方式同义。<br>
复合功能块和子应用程序类型的内部行为由功能块实例网络定义。因此，该定义包括需要存在于内部功能块实例之间的数据和事件连接。<br>
功能块类型由<u><em><strong>类型名称</strong></em></u>、块的<u><em><strong>输入和输出事件</strong></em></u>的正式定义以及<u><em><strong>输入和输出变量</strong></em></u>的定义定义。</p>
<h3 id="基本功能块类型"><a class="markdownIt-Anchor" href="#基本功能块类型"></a> 基本功能块类型</h3>
<p>基本功能块的行为是根据响应输入事件而调用的算法来定义的。当算法执行时，它们会触发输出事件，以表示块内发生了某些状态变化。事件到算法的映射使用称为执行控制图 (ECC)的特殊状态转换符号来表示。</p>
<h4 id="基本功能块的执行模型"><a class="markdownIt-Anchor" href="#基本功能块的执行模型"></a> 基本功能块的执行模型</h4>
<p>借助下图对基本功能块进行描述，功能块上的编号特征显示了块的不同部分由底层“调度功能”处理的顺序。该模型假设功能块所在的资源提供了一个调度功能，确保功能块执行的每个阶段以正确的顺序和正确的优先级发生。</p>
<p>在下图中有许多离散的时序阶段，每个时序阶段可能需要一段时间才能过去，这是基本功能块执行所必需的；每个阶段都取决于功能块和底层调度功能之间定义的交互。下图描述了基本功能块运行必须顺序出现的8个时序点；每个阶段的结束由特定编号的时间点定义：</p>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230519110753009.png" alt="image-20230519110753009" style="zoom:80%;">
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">T</mi><mi mathvariant="bold">i</mi><mi mathvariant="bold">m</mi><msub><mi mathvariant="bold">e</mi><mn mathvariant="bold">1</mn></msub></mrow><annotation encoding="application/x-tex">\mathbf{Time_1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbf">T</span><span class="mord mathbf">i</span><span class="mord mathbf">m</span><span class="mord"><span class="mord mathbf">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>：来自外部功能块的值（Data）在功能块输入处稳定</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">T</mi><mi mathvariant="bold">i</mi><mi mathvariant="bold">m</mi><msub><mi mathvariant="bold">e</mi><mn mathvariant="bold">2</mn></msub></mrow><annotation encoding="application/x-tex">\mathbf{Time_2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbf">T</span><span class="mord mathbf">i</span><span class="mord mathbf">m</span><span class="mord"><span class="mord mathbf">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>：与输入值（Data）关联的事件（Event）到达事件输入</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">T</mi><mi mathvariant="bold">i</mi><mi mathvariant="bold">m</mi><msub><mi mathvariant="bold">e</mi><mn mathvariant="bold">3</mn></msub></mrow><annotation encoding="application/x-tex">\mathbf{Time_3}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbf">T</span><span class="mord mathbf">i</span><span class="mord mathbf">m</span><span class="mord"><span class="mord mathbf">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>：功能块执行控制向调度功能发送信号，表明它具有输入值并准备好执行其算法</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">T</mi><mi mathvariant="bold">i</mi><mi mathvariant="bold">m</mi><msub><mi mathvariant="bold">e</mi><mn mathvariant="bold">4</mn></msub></mrow><annotation encoding="application/x-tex">\mathbf{Time_4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbf">T</span><span class="mord mathbf">i</span><span class="mord mathbf">m</span><span class="mord"><span class="mord mathbf">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>​：在资源的加载和性能特征确定的一段时间后，调度功能开始执行功能块的算法</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">T</mi><mi mathvariant="bold">i</mi><mi mathvariant="bold">m</mi><msub><mi mathvariant="bold">e</mi><mn mathvariant="bold">5</mn></msub></mrow><annotation encoding="application/x-tex">\mathbf{Time_5}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbf">T</span><span class="mord mathbf">i</span><span class="mord mathbf">m</span><span class="mord"><span class="mord mathbf">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>​：该算法处理输入值，在某些情况下，还处理内部存储的值以创建写入功能块输出的新输出值</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">T</mi><mi mathvariant="bold">i</mi><mi mathvariant="bold">m</mi><msub><mi mathvariant="bold">e</mi><mn mathvariant="bold">6</mn></msub></mrow><annotation encoding="application/x-tex">\mathbf{Time_6}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbf">T</span><span class="mord mathbf">i</span><span class="mord mathbf">m</span><span class="mord"><span class="mord mathbf">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>：算法完成其执行，并向调度函数发出信号以指示输出值稳定并准备就绪</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">T</mi><mi mathvariant="bold">i</mi><mi mathvariant="bold">m</mi><msub><mi mathvariant="bold">e</mi><mn mathvariant="bold">7</mn></msub></mrow><annotation encoding="application/x-tex">\mathbf{Time_7}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbf">T</span><span class="mord mathbf">i</span><span class="mord mathbf">m</span><span class="mord"><span class="mord mathbf">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">7</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>​：调度功能调用功能块的执行控制以生成输出事件。根据到达的输入事件和执行控制的内部状态，可能会产生不同的输出事件</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">T</mi><mi mathvariant="bold">i</mi><mi mathvariant="bold">m</mi><msub><mi mathvariant="bold">e</mi><mn mathvariant="bold">8</mn></msub></mrow><annotation encoding="application/x-tex">\mathbf{Time_8}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbf">T</span><span class="mord mathbf">i</span><span class="mord mathbf">m</span><span class="mord"><span class="mord mathbf">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>​：执行控制依次在功能块的输出事件接口上创建适当的输出事件。下游功能块使用输出事件表示它们现在可以使用此块生成的输出值</li>
</ul>
<blockquote>
<p>注意 ⚠️：</p>
<p>这些时序阶段不能重叠，并且必须按功能块正确执行的规定顺序发生。</p>
</blockquote>
<p>该标准定义了以下在构建应用程序时非常重要的持续时间：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="bold">T</mi><mrow><mi mathvariant="bold">s</mi><mi mathvariant="bold">e</mi><mi mathvariant="bold">t</mi><mi mathvariant="bold">u</mi><mi mathvariant="bold">p</mi></mrow></msub><mo>=</mo><mrow><mi mathvariant="bold">T</mi><mi mathvariant="bold">i</mi><mi mathvariant="bold">m</mi><msub><mi mathvariant="bold">e</mi><mn mathvariant="bold">2</mn></msub></mrow><mi mathvariant="normal">–</mi><mrow><mi mathvariant="bold">T</mi><mi mathvariant="bold">i</mi><mi mathvariant="bold">m</mi><msub><mi mathvariant="bold">e</mi><mn mathvariant="bold">1</mn></msub></mrow></mrow><annotation encoding="application/x-tex">\mathbf{T_{setup}}= \mathbf{Time_2} – \mathbf{Time_1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.972218em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.294444em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathbf mtight">s</span><span class="mord mathbf mtight">e</span><span class="mord mathbf mtight">t</span><span class="mord mathbf mtight">u</span><span class="mord mathbf mtight">p</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbf">T</span><span class="mord mathbf">i</span><span class="mord mathbf">m</span><span class="mord"><span class="mord mathbf">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mord" style="margin-right:0.02778em;">–</span><span class="mord"><span class="mord mathbf">T</span><span class="mord mathbf">i</span><span class="mord mathbf">m</span><span class="mord"><span class="mord mathbf">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>：接收输入值与其关联的输入事件到达之间的时间</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="bold">T</mi><mrow><mi mathvariant="bold">s</mi><mi mathvariant="bold">t</mi><mi mathvariant="bold">a</mi><mi mathvariant="bold">r</mi><mi mathvariant="bold">t</mi></mrow></msub><mo>=</mo><mrow><mi mathvariant="bold">T</mi><mi mathvariant="bold">i</mi><mi mathvariant="bold">m</mi><msub><mi mathvariant="bold">e</mi><mn mathvariant="bold">4</mn></msub></mrow><mi mathvariant="normal">–</mi><mrow><mi mathvariant="bold">T</mi><mi mathvariant="bold">i</mi><mi mathvariant="bold">m</mi><msub><mi mathvariant="bold">e</mi><mn mathvariant="bold">2</mn></msub></mrow></mrow><annotation encoding="application/x-tex">\mathbf{T_{start}}= \mathbf{Time_4} – \mathbf{Time_2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83611em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.29444400000000004em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathbf mtight">s</span><span class="mord mathbf mtight">t</span><span class="mord mathbf mtight">a</span><span class="mord mathbf mtight">r</span><span class="mord mathbf mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbf">T</span><span class="mord mathbf">i</span><span class="mord mathbf">m</span><span class="mord"><span class="mord mathbf">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mord" style="margin-right:0.02778em;">–</span><span class="mord"><span class="mord mathbf">T</span><span class="mord mathbf">i</span><span class="mord mathbf">m</span><span class="mord"><span class="mord mathbf">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>：收输入事件和执行算法之间的时间； 这个持续时间可能取决于资源加载，即调度函数的待处理队列中还有多少其他功能块</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="bold">T</mi><mrow><mi mathvariant="bold">a</mi><mi mathvariant="bold">l</mi><mi mathvariant="bold">g</mi><mi mathvariant="bold">o</mi></mrow></msub><mo>=</mo><mrow><mi mathvariant="bold">T</mi><mi mathvariant="bold">i</mi><mi mathvariant="bold">m</mi><msub><mi mathvariant="bold">e</mi><mn mathvariant="bold">6</mn></msub></mrow><mi mathvariant="normal">–</mi><mrow><mi mathvariant="bold">T</mi><mi mathvariant="bold">i</mi><mi mathvariant="bold">m</mi><msub><mi mathvariant="bold">e</mi><mn mathvariant="bold">4</mn></msub></mrow></mrow><annotation encoding="application/x-tex">\mathbf{T_{algo}}= \mathbf{Time_6} – \mathbf{Time_4}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.972218em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathbf mtight">a</span><span class="mord mathbf mtight">l</span><span class="mord mathbf mtight" style="margin-right:0.01597em;">g</span><span class="mord mathbf mtight">o</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbf">T</span><span class="mord mathbf">i</span><span class="mord mathbf">m</span><span class="mord"><span class="mord mathbf">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mord" style="margin-right:0.02778em;">–</span><span class="mord"><span class="mord mathbf">T</span><span class="mord mathbf">i</span><span class="mord mathbf">m</span><span class="mord"><span class="mord mathbf">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>：功能块算法开始和完成之间的时间</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi mathvariant="bold">T</mi><mrow><mi mathvariant="bold">f</mi><mi mathvariant="bold">i</mi><mi mathvariant="bold">n</mi></mrow></msub><mo>=</mo><mrow><mi mathvariant="bold">T</mi><mi mathvariant="bold">i</mi><mi mathvariant="bold">m</mi><msub><mi mathvariant="bold">e</mi><mn mathvariant="bold">8</mn></msub></mrow><mi mathvariant="normal">–</mi><mrow><mi mathvariant="bold">T</mi><mi mathvariant="bold">i</mi><mi mathvariant="bold">m</mi><msub><mi mathvariant="bold">e</mi><mn mathvariant="bold">6</mn></msub></mrow></mrow><annotation encoding="application/x-tex">\mathbf{T_{fin}}= \mathbf{Time_8} – \mathbf{Time_6}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83611em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">T</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathbf mtight" style="margin-right:0.10903em;">f</span><span class="mord mathbf mtight">i</span><span class="mord mathbf mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.84444em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathbf">T</span><span class="mord mathbf">i</span><span class="mord mathbf">m</span><span class="mord"><span class="mord mathbf">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">8</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span><span class="mord" style="margin-right:0.02778em;">–</span><span class="mord"><span class="mord mathbf">T</span><span class="mord mathbf">i</span><span class="mord mathbf">m</span><span class="mord"><span class="mord mathbf">e</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathbf mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>：从完成算法到引发输出事件的时间</li>
</ul>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230519134256803.png" alt="image-20230519134256803" style="zoom:80%;">
<p>在不同的实现中，可能需要多种机制来确保功能块能够使用一致的数据来执行。例如，重要的是输入数据值在算法执行时保持稳定。该算法应该只使用在输入事件到达时存在的输入值，即输入事件可用于快照准备算法执行的输入值。</p>
<h3 id="复合功能块类型"><a class="markdownIt-Anchor" href="#复合功能块类型"></a> 复合功能块类型</h3>
<p>复合功能块和子应用程序类型的内部行为由功能块实例网络定义。因此，该定义包括需要存在于内部功能块实例之间的数据和事件连接。</p>
<h3 id="服务接口功能块类型"><a class="markdownIt-Anchor" href="#服务接口功能块类型"></a> 服务接口功能块类型</h3>
<p>服务接口 (SI) 功能块提供功能块域和外部服务之间的接口，例如与远程设备中的功能块通信或读取硬件实时时钟的值。因为 SI 功能块类型主要与数据事务有关，所以它是使用<u><em><strong>时序图定</strong></em></u>义的。这种形式的图更常用于定义跨通信接口的事务。时序图将在本章后面的服务接口块部分进行描述。</p>
<h2 id="27-分布式模型"><a class="markdownIt-Anchor" href="#27-分布式模型"></a> 2.7 分布式模型</h2>
<p>应用程序和子应用程序都可以“分布式”，即配置为在多个资源上运行。分布式应用程序将由功能块网络组成，功能块的片段在指定资源上运行。请注意，IEC 61499 认为分布涉及不同资源上功能块的排列。因为一个设备可以支持多种资源，所以分布式应用程序可以在单个设备上运行，即使用同一设备内的资源。子应用程序是一种较小的应用程序形式，可以复制，但在其他方面具有与应用程序相同的分布特征。</p>
<p>功能块和应用程序之间存在重要区别。</p>
<ul>
<li>应用程序或子应用程序的时间和性能将取决于它所分布的资源以及连接它们的通信网络。如果两个网络的通信数据速率差异很大，因此两个子应用程序显然会由于网络延迟而具有不同的性能和响应时间，尽管它们的内部软件算法是相同的。</li>
<li>相反，功能块被假定为“原子的”并且仅在单个资源中运行。在这方面，功能块的性能不受通信网络特性的影响。但是，性能可能会在较小程度上受到实例化块的资源和设备的行为和特性的影响。下表总结了这些分布特征。</li>
</ul>
<table>
<thead>
<tr>
<th></th>
<th>Distributable</th>
<th>Timing</th>
<th>Reliability</th>
<th>Replication</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Function Block</strong></td>
<td>❌</td>
<td>只依赖于设备</td>
<td>只依赖于设备</td>
<td>FB类型的实例</td>
</tr>
<tr>
<td><strong>Sub-Application</strong></td>
<td>✅</td>
<td>依赖于设备和通讯</td>
<td>依赖于设备和通讯</td>
<td>子应用类型的副本</td>
</tr>
<tr>
<td><strong>Application</strong></td>
<td>✅</td>
<td>依赖于设备和通讯</td>
<td>依赖于设备和通讯</td>
<td>无</td>
</tr>
</tbody>
</table>
<h2 id="28-管理模型"><a class="markdownIt-Anchor" href="#28-管理模型"></a> 2.8 管理模型</h2>
<p>在上面我们说到，资源可以支持构成分布式应用程序或子应用程序的一部分的功能块网络片段。但这些应用程序分段如何被创建和管理？</p>
<p>为此，IEC 61499 还定义了一种特殊形式的应用程序，称为“管理应用程序（Management Application）” ，负责在资源内创建功能块网络。管理应用程序具有比普通应用程序更高的特权功能，可以通过创建功能块和连接来构造其他应用程序的一部分。它通常会通过通信链路与远程编程站等外部代理进行交互。</p>
<p>管理应用程序的功能将包括：</p>
<ul>
<li>在一个资源中创建功能块实例</li>
<li>将功能块片段与一个特定的应用程序联系起来</li>
<li>在功能块和服务接口块之间建立数据和事件连接</li>
<li>作为分布式应用的一部分启动功能块的执行</li>
<li>提供服务以支持从通信链路上查询功能块实例的状态功能块实例的查询</li>
<li>删除功能块实例以及它们的数据和事件连接。</li>
</ul>
<p>一个重要的约束是管理应用程序应该能够为不同的应用程序加载功能块网络片段，而不会干扰其他正<br>
在运行的应用程序的执行。</p>
<p>管理应用程序的一部分可能将以非易失性形式存在于设备中，并且总是能够在设备加电时加载应用程序。</p>
<p>该标准提出了两种提供管理应用程序的方案：</p>
<ul>
<li>
<p>下图描绘了一个具有特殊“管理资源”的设备，该资源包含管理应用程序，这些应用程序提供在设备中提供的相邻资源中建立和维护功能块网络的功能。</p>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230519152240514.png" alt="image-20230519152240514" style="zoom:90%;">
</li>
<li>
<p>在图2.9中，定义了另一种方案，即每个资源包含一个管理应用程序，负责在同一资源中加载功能块网络。<br>
管理应用程序的建模方式与其他使用功能块网络和服务接口功能块的应用程序的建模方式完全相同。一个管理应用程序很可能需要一些服务接口功能块来处理与外部通信链路的接口，例如，处理创建功能块实例的请求。</p>
</li>
</ul>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230519153022606.png" alt="image-20230519153022606" style="zoom:80%;">
<p>管理应用程序的功能尚未在IEC 61499中详细定义，但显然这是一个需要标准化的重要领域，然后才能以一致的方式加载和配置符合IEC 61499的设备。统一的方式加载和配置IEC 61499兼容的设备。</p>
<h2 id="29-运行状态模型"><a class="markdownIt-Anchor" href="#29-运行状态模型"></a> 2.9 运行状态模型</h2>
<p>基于 IEC 61499 功能块网络的大型系统通常会分几个阶段进行开发、调试和投产。因此，在功能块网络中，IEC 61499 提出“生命周期”的概念被建模并应用于功能单元，例如设备、资源和应用程序。</p>
<p>操作状态模型尚未在标准中完全定义，但建议每个功能单元都有明确定义的状态，例如：</p>
<ul>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">S</mi><mi mathvariant="bold">T</mi><mi mathvariant="bold">O</mi><mi mathvariant="bold">P</mi><mi mathvariant="bold">P</mi><mi mathvariant="bold">E</mi><mi mathvariant="bold">D</mi></mrow><annotation encoding="application/x-tex">\mathbf{STOPPED}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">S</span><span class="mord mathbf">T</span><span class="mord mathbf">O</span><span class="mord mathbf">P</span><span class="mord mathbf">P</span><span class="mord mathbf">E</span><span class="mord mathbf">D</span></span></span></span></span>：单元未运行</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">L</mi><mi mathvariant="bold">O</mi><mi mathvariant="bold">A</mi><mi mathvariant="bold">D</mi><mi mathvariant="bold">E</mi><mi mathvariant="bold">D</mi></mrow><annotation encoding="application/x-tex">\mathbf{LOADED}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">L</span><span class="mord mathbf">O</span><span class="mord mathbf">A</span><span class="mord mathbf">D</span><span class="mord mathbf">E</span><span class="mord mathbf">D</span></span></span></span></span>：单元已加载，例如，当应用程序的所有功能块定义和相关功能块实例已加载到设备中时，设备可能处于“已加载”状态</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">C</mi><mi mathvariant="bold">O</mi><mi mathvariant="bold">N</mi><mi mathvariant="bold">F</mi><mi mathvariant="bold">I</mi><mi mathvariant="bold">G</mi><mi mathvariant="bold">U</mi><mi mathvariant="bold">R</mi><mi mathvariant="bold">A</mi><mi mathvariant="bold">B</mi><mi mathvariant="bold">L</mi><mi mathvariant="bold">E</mi></mrow><annotation encoding="application/x-tex">\mathbf{CONFIGURABLE}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">C</span><span class="mord mathbf">O</span><span class="mord mathbf">N</span><span class="mord mathbf">F</span><span class="mord mathbf">I</span><span class="mord mathbf">G</span><span class="mord mathbf">U</span><span class="mord mathbf">R</span><span class="mord mathbf">A</span><span class="mord mathbf">B</span><span class="mord mathbf">L</span><span class="mord mathbf">E</span></span></span></span></span>：单元已加载并准备好在开始运行之前进行配置；当功能块实例已加载但仍<br>
等待功能块连接详细信息时，设备将处于“可配置”状态</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">O</mi><mi mathvariant="bold">P</mi><mi mathvariant="bold">E</mi><mi mathvariant="bold">R</mi><mi mathvariant="bold">A</mi><mi mathvariant="bold">T</mi><mi mathvariant="bold">I</mi><mi mathvariant="bold">O</mi><mi mathvariant="bold">N</mi><mi mathvariant="bold">A</mi><mi mathvariant="bold">L</mi></mrow><annotation encoding="application/x-tex">\mathbf{OPERATIONAL}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">O</span><span class="mord mathbf">P</span><span class="mord mathbf">E</span><span class="mord mathbf">R</span><span class="mord mathbf">A</span><span class="mord mathbf">T</span><span class="mord mathbf">I</span><span class="mord mathbf">O</span><span class="mord mathbf">N</span><span class="mord mathbf">A</span><span class="mord mathbf">L</span></span></span></span></span>：单元已加载和配置并准备好开始执行或支持执行部分加载的应用程序</li>
<li><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="bold">R</mi><mi mathvariant="bold">U</mi><mi mathvariant="bold">N</mi><mi mathvariant="bold">N</mi><mi mathvariant="bold">I</mi><mi mathvariant="bold">N</mi><mi mathvariant="bold">G</mi></mrow><annotation encoding="application/x-tex">\mathbf{RUNNING}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68611em;vertical-align:0em;"></span><span class="mord"><span class="mord mathbf">R</span><span class="mord mathbf">U</span><span class="mord mathbf">N</span><span class="mord mathbf">N</span><span class="mord mathbf">I</span><span class="mord mathbf">N</span><span class="mord mathbf">G</span></span></span></span></span>：装置完全可操作并正在运行</li>
</ul>
<p>为了控制和同步分布式应用程序的加载，该标准建议制定策略以确保“跨组件的一致操作状态”。</p>
<p>例如，分布式应用程序可能需要将功能块网络的片段加载到位于各种不同的（在某些情况下）远程设备中的许多不同资源上。驻留在不同设备中的功能块的加载和配置可能发生在不同时间；但是，可能需要同步所有关联设备和资源从“运行”状态到“运行”状态的切换，才能使应用程序正确启动。</p>
<p>该标准还预见到某些特权功能单元可能会控制其他功能单元的情况。</p>
<blockquote>
<p>例如，设备 A 中的“作业加载器”功能块可用于在远程设备 B 和 C 中加载新的功能块定义，以便为特定类型的批处理配置文件修改应用程序。在这种情况下，需要能够赋予某些块加载、配置和更改其<br>
他块状态的权限。本章已经介绍的管理应用程序功能块显然需要具有特殊权限才能加载和启动完整的应用程序。</p>
</blockquote>
<p>应用程序管理和应用程序操作状态的控制是 IEC 61499 中仍有待开发的领域，可能会在该标准的其他部分中解决。</p>
<h2 id="210-使用适配器的通用接口"><a class="markdownIt-Anchor" href="#210-使用适配器的通用接口"></a> 2.10 使用适配器的通用接口</h2>
<p>面向对象软件的一大优势是能够让不同的对象共享相同的接口。在面向对象软件中，表示具有相似基本特征的实体的对象具有共同的外部接口部分是一种普遍的做法。例如，在设计图形用户界面 (GUI) 时，具有相似特征的图形实体（例如表示圆和正方形的对象）通常具有通用的接口方法（表示正方形和圆形等项目的对象可能有许多共同的方法，例如用于调整大小、移动、复制和颜色填充）。</p>
<p>面相对象软件中的行为共享是通过一种称为“继承”的技术实现的。这允许新的专用对象“继承”，即共享来自另一个更通用类型的对象的相同接口和基本行为。拥有具有通用接口的不同类型的对象在软件设计中具有显着的优势。</p>
<blockquote>
<p>一个很好的例子是处理具有相似特性的传感器的功能块。我们可以设想块处理模拟传感器，比如温度和压差，在它们的接口中有一些共同的特征。例如，两者都需要能够设置高低警报级别，并检测超出范围的情况。能够使用相同的软件来处理不同类型传感器的功能块的共同方面显然是有用的。</p>
</blockquote>
<p>为了促进对通用接口的支持，IEC 61499 定义了一个称为“<u><em><strong>适配器接口</strong></em></u>”的特殊概念。这允许具有相似行为的功能块通过附加特殊类型的功能块来共享相同的接口。</p>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230519165313119.png" alt="image-20230519165313119" style="zoom:80%;">
<p>这种类型的功能块称为“适配器”。它类似于可以连接到其他设备的电子设备，这些设备使用插头和插座布置提供专门的行为。图 2.10 以图形方式描述了这个概念；该图的左侧显示了能够与其上方的专用块紧密连接的适配器块；在右侧，我们看到两个块连接在一起形成适配器连接。</p>
<blockquote>
<p>为了进一步阐明使用适配器的好处，考虑功能块的设计来处理各种形式的模拟输入。</p>
<p>让我们考虑一个块来处理温度输入，另一个块来处理差压输入。显然，每个块都需要自己专门的接口输入和输出。温度块将需要输入来定义热电偶范围、校准偏移、缩放等，而差压输入将需要专门的输入和输出来定义压力滞后和压力传感器特性。</p>
<p>但是，这两个块也将具有一系列通用的输入和输出。只需考虑警报定义和创建的要求； 将报警处理的标准实现封装在一个块中显然会更加高效和一致。 图 2.11 描述了如何使用适配器概念为警报管理提供一个公共块，该公共块可以连接到具有特定行为和不同类型传感器接口的专用块。</p>
<p>在 IEC 61499 中，功能块可以配置为适配器“提供者（Provider）”或“接受者（Acceptor）”。在我们的示例中，警报块 <code>Alarm</code> 被描述为适配器“提供者”，而传感器专用块“<code>Temperature</code>”和“<code>Diff_Pressure</code>”是适配器“接受者”。</p>
<p>请注意，可以用不同的方式对常见行为进行建模。在此示例中，也可以将通用传感器块作为具有所有共享行为的适配器接受器，然后将专用块附加为适配器提供者以提供传感器专业化。</p>
</blockquote>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230519165655643.png" alt="image-20230519165655643" style="zoom:80%;">
<h2 id="211-iec-61499-实体的文本语法"><a class="markdownIt-Anchor" href="#211-iec-61499-实体的文本语法"></a> 2.11 IEC 61499 实体的文本语法</h2>
<p>IEC 61499 标准的一个显着特征是丰富的文本语法（textual syntax），允许以文本语言描述应用程序和功能块等实体模型。文本定义可用于明确定义模型，以便可以自动且一致地创建图形表示。</p>
<blockquote>
<p>例如，一个复合功能块可以由几个具有适当数据和事件连接的较小块组成的网络构成。复合块内部设计的所有方面都可以使用 IEC 61499 文本句法表示。</p>
</blockquote>
<p>可以设想，编译文本定义作为检查特定模型有效性的手段是可能的。文本形式对于将模型设计从一个工作站平台移植到另一个工作站平台当然很有用。它定义了模型的语义方面，但没有完全描述图形细节。</p>
<blockquote>
<p>注意 ⚠️：</p>
<p>在 IEC 61499 标准的第 2 部分中，可以使用基于 XML 的文件交换格式来传输图形属性。这在第 7 章中进行了回顾。</p>
</blockquote>
<blockquote>
<p>例如，可能已经开发了一个特定的模型，显示位于网络图中某些位置的功能块。实际位置和更精细的图形细节（例如颜色和字体）不是此语法的一部分。但是，块之间的逻辑连接是精确定义的。</p>
<p>该标准包含一个详尽的附件，描述了文本句法所有特征的生成规则。请注意，此语法的某些方面将在本书中进行描述，但对于完整和准确的定义，建议参阅 IEC 61499标准第 1 部分中的附录 B</p>
</blockquote>
<h3 id="示例-3选2投票算法"><a class="markdownIt-Anchor" href="#示例-3选2投票算法"></a> 【示例】- 3选2投票算法</h3>
<p>这里使用一个简单的功能块来说明文本语法的一些特性。语法的许多特性将在后面的章节中进行更详细的讨论。</p>
<p>考虑一个功能块，它在三个输入 <code>A</code>、<code>B</code> 和 <code>C</code> 上应用“3 选 2 投票”算法。这可以建模为“基本”功能块，如下所示：</p>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230519170644887.png" alt="image-20230519170644887" style="zoom:80%;">
<p>该块有两个事件输入，<code>Reset</code> 和 <code>Vote</code>。</p>
<ul>
<li><code>Reset</code> 事件会触发一种算法来重置存储的选民内部状态。当 <code>Reset</code> 算法成功完成后，在 <code>Ready</code> 输出端产生一个事件。</li>
<li><code>Vote</code> 事件用于触发主投票算法，该算法检查三个布尔输入 <code>A</code>、<code>B</code> 和 <code>C</code> 的状态。如果两个或多个输入为真，则输出状态设置为真并保持为真，直到执行 <code>Reset</code> 算法。当选举算法完成后，将在 <code>Voted</code> 事件输出中生成一个事件。</li>
</ul>
<p>描述 <code>Voter</code> 功能块的文本语法（textual syntax）如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">FUNCTION_BLOCK VOTER (* Voter FB *)</span><br><span class="line"></span><br><span class="line">EVENT_INPUT</span><br><span class="line">	Reset; (* Reset event *)</span><br><span class="line">	Vote WITH A,B,C; (* Trigger Voter *)</span><br><span class="line">END_EVENT</span><br><span class="line"></span><br><span class="line">EVENT_OUTPUT</span><br><span class="line">	Ready;</span><br><span class="line">	Voted WITH State;</span><br><span class="line">END_EVENT</span><br><span class="line"></span><br><span class="line">VAR_INPUT</span><br><span class="line">	A : BOOL;</span><br><span class="line">	B : BOOL;</span><br><span class="line">	C : BOOL;</span><br><span class="line">END_VAR</span><br><span class="line"></span><br><span class="line">VAR_OUTPUT</span><br><span class="line">	State : BOOL;</span><br><span class="line">END_VAR</span><br><span class="line"></span><br><span class="line">EC_STATES</span><br><span class="line">	Ready : ResetAlg -&gt; Ready;</span><br><span class="line">	Voted : VoteAlg -&gt; Voted;</span><br><span class="line">END_STATES</span><br><span class="line"></span><br><span class="line">EC_TRANSITIONS</span><br><span class="line">	Ready TO Voted := Vote;</span><br><span class="line">	Voted TO Voted := Vote;</span><br><span class="line">	Voted TO Ready := Reset;</span><br><span class="line">END_TRANSITIONS</span><br><span class="line"></span><br><span class="line">ALGORITHM ResetAlg IN ST; (* Reset Algorithm *)</span><br><span class="line">	State := 0; (* Reset the state output *)</span><br><span class="line">END_ALGORITHM</span><br><span class="line"></span><br><span class="line">ALGORITHM VoteAlg IN ST; (* Voter algorithm *)</span><br><span class="line">	IF State = 0 THEN</span><br><span class="line">		State := (A AND B) OR (A AND C) OR (B AND C);</span><br><span class="line">	END_IF;</span><br><span class="line">END_ALGORITHM</span><br><span class="line"></span><br><span class="line">END_FUNCTION_BLOCK</span><br></pre></td></tr></table></figure>
<p>从这个例子中可以看出以下几点：</p>
<ul>
<li>文本定义包括 <code>EVENT_</code> 和 <code>VAR_</code> 部分，用于声明块的输入和输出接口的所有事件和数据</li>
<li>块的内部状态被定义并与触发状态转换的事件相关联；这是在 <code>EC_STATES</code> 和 <code>EC_TRANSITIONS</code> 部分中声明的</li>
<li>当块处于块定义的 <code>EC_STATES</code> 部分中定义的特定状态时，算法由事件触发</li>
<li>每个算法都可以用特定的文本语言定义。在本例中，<code>ResetAlg</code> 和 <code>VoteAlg</code> 算法都是使用结构化文本 (ST) 语言定义的；这是 PLC 编程语言标准 IEC 61131‑3 中定义的高级语言。但请注意，IEC 61499 并不排除使用其他语言（例如 JAVA 或 C）来定义算法内容。事实上，IEC 61499 并没有定义算法定义的文本语法，而是允许使用任何现有的标准文本语言。</li>
</ul>
<h2 id="212-总结"><a class="markdownIt-Anchor" href="#212-总结"></a> 2.12 总结</h2>
<p>我们现在已经回顾了 IEC 61499 引入的主要概念，这些概念提供了一个框架和体系结构来为面向功能块的分布式系统建模。</p>
<p>总结一下：</p>
<ul>
<li>系统模型定义了一组可以通过网络连接进行通信的互连设备。</li>
<li>设备模型支持一种或多种资源，这些资源为功能块网络的加载、配置和执行提供支持。</li>
<li>应用程序可以驻留在一个或多个资源上。 每个资源可以支持应用程序的一部分的管理和执行，每个部分作为功能块网络的一个片段分布。</li>
<li>有基本功能块和复合功能块，用于处理不同形式的块构造和块层次结构。</li>
<li>服务接口块提供网络通信和硬件接口设施。</li>
<li>适配器概念允许功能块共享通用接口。</li>
<li>IEC 61499 文本句法为移植和创建功能块和应用程序等实体的定义提供了一种简洁且可编译的形式。</li>
</ul>
<h1 id="3-定义功能块和子应用程序类型"><a class="markdownIt-Anchor" href="#3-定义功能块和子应用程序类型"></a> 3. 定义功能块和子应用程序类型</h1>
<p>在本章中，我们将回顾如何为功能块和子应用程序创建类型定义，并展示如何使用这些定义来创建功能块实例和子应用程序的副本。</p>
<p>具体我们会：</p>
<ul>
<li>查看不同形式的功能块定义</li>
<li>显示如何定义事件和数据接口</li>
<li>检查算法是如何构建的以及如何与事件执行相关联</li>
<li>考虑功能块实例的行为方式</li>
<li>查看可以使用子应用程序的位置，并将它们的行为和属性与复合功能块进行比较。</li>
</ul>
<h2 id="31-类型与实例"><a class="markdownIt-Anchor" href="#31-类型与实例"></a> 3.1 类型与实例</h2>
<p>在继续定义 IEC 61499 中提供的机制以更详细地定义功能块类型之前，让我们回顾一下功能块类型和实例的作用。</p>
<ul>
<li>功能块类型定义描述了特定类型功能块的外部接口和内部行为。</li>
<li>然而，功能块实例实际上是使用功能块类型定义创建的功能块的工作副本。</li>
</ul>
<p>在大型系统中，功能块类型定义很可能保存在各种库中，用于“控制算法”、“警报管理”、“输入传感器”等目的。基于大型功能块的系统的配置将需要选择合适的功能块类型库，然后根据所选功能块类型声明功能块实例。因此，功能块类型的清晰、精确和明确的定义与有效使用 IEC 61499 密切相关。</p>
<h2 id="32-不同形式的功能块"><a class="markdownIt-Anchor" href="#32-不同形式的功能块"></a> 3.2 不同形式的功能块</h2>
<p>该标准为三种不同形式的功能块提供了类型定义；每种形式都有自己特定的属性和用途，如下表中所列。</p>
<table>
<thead>
<tr>
<th>形式</th>
<th>是否可分布化</th>
<th>定义</th>
<th>注释</th>
</tr>
</thead>
<tbody>
<tr>
<td>基本功能块<br>Basic FB</td>
<td>❌</td>
<td>使用执行控制图 (ECC) 定义的状态。<br>使用适当语言定义的算法，<br>例如 结构化文本，Java。</td>
<td>基本功能块不能分布化； <br>它只能在单个资源上运行。 <br>基本功能块定义了可以构建大型复合块的基本块。</td>
</tr>
<tr>
<td>复合功能块<br>Composite FB</td>
<td>❌</td>
<td>由基本功能块和复合功能块组成的网络构成。<br>定义是根据功能块之间的数据和事件连接给出的。</td>
<td>复合功能块是从较低级别功能块的网络构建的。<br>这些可以是基本的或较低级别的复合块。</td>
</tr>
<tr>
<td>子应用<br>Sub-App</td>
<td>✅</td>
<td>由基本功能块和复合功能块组成的网络构成。<br>一个子应用程序又可以包含更小的子应用程序的副本。</td>
<td>这种类型的块旨在提供可以<br>分布在许多资源上的应用程序的可重用部分。</td>
</tr>
</tbody>
</table>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230520142126665.png" alt="image-20230520142126665" style="zoom:80%;">
<p>这三种形式的主要特征如上图 3.1 所示。应该注意的是，</p>
<ul>
<li>基本功能块和复合功能块始终驻留在单个资源上，并在其输入和输出处提供变量以保存数据值。</li>
<li>基本块还需要用于执行控制状态机的内部存储。</li>
<li>然而，相比之下，子应用程序并没有专门存储输入、输出和事件。对于子应用程序，此类存储由存在于子应用程序主体中的内部功能块提供。</li>
</ul>
<h2 id="33-基本功能块的定义"><a class="markdownIt-Anchor" href="#33-基本功能块的定义"></a> 3.3 基本功能块的定义</h2>
<p>基本功能块（Basic FB）可以使用 IEC 61499 文本句法以文本方式或图形方式进行描述。</p>
<p>有两种图形表示形式共同描述了基本功能块的属性和行为：(i) 外部接口声明和 (ii) 定义事件、状态和算法执行之间关系的执行控制图 (ECC)。</p>
<h3 id="对外接口声明"><a class="markdownIt-Anchor" href="#对外接口声明"></a> 对外接口声明</h3>
<p>如图3.2所示的对外接口声明具有以下特点：</p>
<ul>
<li>功能块类型名称应位于主块的中心，如图3.2 中的“<code>Ramp</code>”所示。</li>
<li>块的<u><em><strong>输入</strong></em></u>始终显示在块的左侧；***输出***显示为来自块的右侧。</li>
<li><u><em><strong>输入事件</strong></em></u>被描述为进入块上部的左侧，<u><em><strong>输出事件</strong></em></u>显示为来自右侧。</li>
<li>输入和输出变量的名称显示在块内与其关联的图形连接器旁边。</li>
<li>输入和输出的数据类型显示分别在图形连接器的左侧和右侧</li>
</ul>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230520151944945.png" alt="image-20230520151944945" style="zoom:80%;">
<p>图形表示提供了足够的信息以用作正式的类型声明。事实上，IEC 61499 的主要目标是图形表示始终具有精确的文本表示。设想图形建模工具将始终能够将图形形式转换为文本表示，反之亦然。</p>
<ul>
<li>
<p>【<u><em><strong>输入事件</strong></em></u>】：例如图 3.2 中描绘的 <code>E_Init</code> 事件，显示为进入功能块标题，如果需要，可以与一个或多个输入相关联。如果模块需要在运行内部算法之前对输入值进行采样，这通常是必需的。在 <code>Ramp</code> 功能块示例中，无论何时发生 <code>E_Init</code> 事件，即在块初始化的瞬间，输入<code>X0</code>、<code>X1</code>、<code>Cycle</code> 和 <code>Duration</code> 都需要保持稳定。同样，当 <code>E_Run</code> 事件发生时，<code>PV</code> 输入值将被采样。</p>
</li>
<li>
<p>【<u><em><strong>输入事件与输入数据的关联</strong></em></u>】使用 IEC 61499 表示为 <code>WITH</code> 限定符的构造。在图形表示中，这使用将事件与其关联数据链接的小正方形显示。</p>
<p>也可以将输出事件与某些输出变量相关联。这用于表示那些已由内部算法更新并在触发输出事件时准备就绪的输出变量。在图 3.2 的基本功能示例中，当内部斜坡算法更新输出 <code>Out</code> 和 <code>Hold</code> 时，会发生 <code>E_Ex0</code> 输出事件。</p>
</li>
<li>
<p>【<u><em><strong>事件</strong></em></u>】可以定义为具有可选的事件类型。这是为了让功能块可以设计为仅在其事件输入处接受特定类型的事件。事件类型提高了设计的鲁棒性。这是对数据类型用于提高设计完整性的方式的逻辑扩展，仅允许连接携带兼容数据的输入和输出。</p>
</li>
<li>
<p>【<u><em><strong>初始化事件</strong></em></u>】：例如，不可能将 <code>E_stop</code> 类型的关闭事件连接到此事件输入。</p>
</li>
<li>
<p>如果未给块事件输入或输出指定事件类型，则应用默认类型 <code>EVENT</code>。这种通用类型 <code>EVENT</code> 的事件可以连接到 <code>EVENT</code> 类型的任何其他事件输入。相反，<code>EVENT</code> 类型的事件输入可以接收任何事件类型的事件。</p>
</li>
</ul>
<blockquote>
<p>注意 ⚠️：</p>
<p>基本功能块的每个输入和输出必须分别与至少一个事件输入或输出相关联。</p>
<p>这是因为，当输入值被采样或输出值发生变化时，总是需要至少一个事件来发出信号。另一种查看方式是将事件及其关联数据视为一种消息类型，允许事件及其数据作为连贯集在块之间传递。</p>
</blockquote>
<p>基本功能块行为的一个重要方面涉及对事件和算法执行之间的关系进行建模。这是使用称为执行控制图(ECC)的概念实现的。与块的其他功能一样，ECC 可以图形方式或文本方式定义。此功能的一个结果是暗示块必须具有存储空间来保存事件样本之间的输入值。同样，它有存储空间来保存输出事件触发之间的输出值。当然总是有这样的可能性，一个块可能以比块可以存储然后处理更快的速率接收带有数据的事件。该标准规定，在这种情况下，底层调度功能应优先考虑功能块算法的执行，以确保此类过载情况不会发生。</p>
<h3 id="内部行为"><a class="markdownIt-Anchor" href="#内部行为"></a> 内部行为</h3>
<p>基本功能块内部行为的描述有两个方面：<u><em><strong>算法体</strong></em></u>和<u><em><strong>算法执行控制</strong></em></u>。</p>
<p>基本块通常包含一种或多种算法。每个算法都由资源调度功能调用，以响应到达块接口的特定输入事件。</p>
<ol>
<li>当算法执行时，它处理来自输入和内部变量的数据，为内部和输出变量创建新值。</li>
<li>当算法完成其执行的某些阶段时，它可能会触发输出事件以表示输出数据已准备就绪并且可以被其他块“使用”。</li>
</ol>
<p>每种算法都<u><em><strong>必须</strong></em></u>触发至少<u><em><strong>一个输出事件</strong></em></u>，以表明它已完成执行。</p>
<p>IEC 61499 没有定义应该用于算法定义的语言。只要可以在输入和输出数据变量及其数据类型和算法语言内的变量之间定义映射，就可以使用任何高级语言。</p>
<p>基本功能块行为的一个重要方面涉及对事件和算法执行之间的关系进行建模。这是使用称为<u><em><strong>执行控制图</strong></em></u>(ECC)的概念实现的。与块的其他功能一样，ECC 可以图形方式或文本方式定义。ECC 是一种<u><em><strong>状态转换图</strong></em></u>，与 IEC 61131‑3 中的图形顺序功能图有许多相似之处。然而，作为一种状态建模技术，它的目的非常不同，不应与 SFC1 等图形编程语言混淆。</p>
<p>每个基本功能块都需要一个 ECC 来定义以下内容：</p>
<ul>
<li>块的主要内部状态；</li>
<li>块将如何响应每种类型的输入事件；</li>
<li>响应输入事件激活哪些算法；</li>
<li>执行算法时触发哪些输出事件。</li>
</ul>
<blockquote>
<p>下图3.3是一个执行控制图（ECC），其描述了我们之前讨论过的 “Ramp” 功能块。在该 ECC 中描述了三个状态 <code>START</code>、<code>INIT</code> 和 <code>RAMP</code>，他们对应功能块中的三个主要状态：</p>
<ul>
<li>“<code>START</code>”状态表示块在等待接收事件时的静止状态。</li>
<li>当模块运行初始化算法“<code>ALG_INIT</code>”时，会出现“<code>INIT</code>”状态。</li>
<li>在“ramping”算法运行时存在“<code>RAMP</code>”状态，即“<code>ALG_RAMP</code>“</li>
</ul>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230522142130287.png" alt="image-20230522142130287" style="zoom:80%;">
<p>状态之间的转换由布尔表达式描述，涉及事件变量和在功能块主体内声明的布尔变量。事件变量提供输入事件的内部表示，并用于描述状态之间的转换。表 3.2 列出了此示例 ECC 的转换条件。</p>
<table>
<thead>
<tr>
<th>FROM state</th>
<th>TO state</th>
<th>Transiton</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>START</code></td>
<td><code>INIT</code></td>
<td><code>E_Init</code> (event)</td>
</tr>
<tr>
<td><code>INIT</code></td>
<td><code>START</code></td>
<td><code>1</code> (always true)</td>
</tr>
<tr>
<td><code>START</code></td>
<td><code>RAMP</code></td>
<td><code>E_Run</code> (event)</td>
</tr>
<tr>
<td><code>RAMP</code></td>
<td><code>START</code></td>
<td><code>1</code> (always true)</td>
</tr>
</tbody>
</table>
<p>在此示例中，“<code>INIT</code>”和“<code>RAMP</code>”是仅在算法执行时存在的瞬态。在更复杂的块中，状态可以表示块的基本状态或模式。</p>
</blockquote>
<h3 id="执行控制图ecc功能"><a class="markdownIt-Anchor" href="#执行控制图ecc功能"></a> 执行控制图（ECC）功能</h3>
<p>该标准定义了一系列适用于执行控制图（ECC）的规则和功能，总结如下：</p>
<ul>
<li>
<p>一个基本功能块只有一个执行控制图，它是使用功能块类型定义的执行控制块部分中的文本句法定义的；</p>
</li>
<li>
<p>每个 ECC 必须有一个初始状态，在图中使用两个同心圆表示；</p>
</li>
<li>
<p>圆形和矩形都可以用来表示 ECC 内的状态（本书中用矩形表示）；</p>
</li>
<li>
<p>ECC 可以使用事件变量作为事件输入。通常，状态之间的转换由使用事件输入变量的逻辑表达式来定义；</p>
</li>
<li>
<p>ECC 还可以测试或修改事件输出，同样在ECC内部表示为布尔事件输出变量；</p>
</li>
<li>
<p>ECC 也可以测试但不修改在功能块体内声明的布尔变量。这使得ECC的行为可以根据功能块主体的内部状态来修改。</p>
<blockquote>
<p>例如，一个功能块可能有两种主要模式，如 &quot;手动 &quot;和 “自动”，由一个内部布尔变量 “<code>ManualFlag</code>” 定义。在一个特定的输入事件到来时，ECC 可以测试 “<code>ManualFlag</code>” 并进入适当的状态以调用手动或自动算法。</p>
</blockquote>
</li>
<li>
<p>触发 ECC 内部状态变化的过渡表达式通常涉及输入事件变量。然而，这些表达式也可以包括代表输出事件的变量、功能块内部状态，以及基于块的主要输入和输出变量值的条件表达式。</p>
</li>
<li>
<p>每个 ECC 状态可以有零个或多个动作。作为一个例子，图 3.4 描述了一个状态 “<code>MAIN</code>”，它有两个动作来调用算法 “<code>CALC</code>” 和 “<code>FILTER</code>”；当它们完成执行时，分别触发输出事件 “<code>ExO_1</code>” 和 “<code>ExO_2</code>”。每个动作通常与一个算法和一个输出事件相关。</p>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230522145717158.png" alt="image-20230522145717158" style="zoom:80%;">
<p>当状态被激活时，为该状态定义的所有动作都会被执行。然而，一个动作可以有一个空的算法，它只需要触发一个输出事件。也有可能出现没有输出事件的动作。通常情况下，一个状态至少会有一个具有输出事件的动作，以向外部世界发出信号，表明某些输出已经被更新。</p>
</li>
</ul>
<blockquote>
<p>注意 ⚠️</p>
<p>只有在转换之前的状态处于活动状态时，才会测试 ECC 内的转换条件。因此，即使一个功能块可能有一个非常复杂的 ECC，在状态之间有大量的转换，测试转换所涉及的开销可能很小，因为在任何时候只有一个状态是活动的。</p>
<p>ECC 主要用于表示输入事件、算法执行和输出事件触发之间的关系。它不应用于对应用程序状态行为进行建模，例如对各种控制模式进行建模。应用程序状态和相关行为应在功能块算法本身中定义。对于大多数相当复杂的功能块，ECC 应该相对简单，只有四五个状态。</p>
</blockquote>
<h3 id="文本语法textual-syntax示例"><a class="markdownIt-Anchor" href="#文本语法textual-syntax示例"></a> 文本语法（Textual syntax）示例</h3>
<p>我们依旧以之前讨论的 “Ramp” 功能块为例，考虑其行为，使用 IEC 61499 标准对其进行建模。</p>
<ul>
<li>该功能块将输出“<code>OUT</code>”从输入“<code>X0</code>”给出的初始值“ramp”到目标值在“<code>Duration</code>”输入给定的时间内为“<code>X1</code>”。</li>
<li>“<code>Cycle</code>”输入定义了&quot;ramp&quot;输出更新之间的经过时间。</li>
<li>该块还检查输出是否超过输入“<code>PV</code>”，在这种情况下，“<code>Hold</code>”输出设置为真。假设 “ramp” 块以“<code>Cycle</code>”时间给定的更新速率重复调用；例如，它可能被配置为每 <code>200 ms</code> 执行一次。</li>
</ul>
<p>我们已经回顾了这个基本功能块的两个图形视图：（i）图形功能块类型声明（见图3.2）和（ii）执行控制图 ECC（见图3.3）。这两个图中给出的信息也可以用 IEC 61499 文本语法来表示，它与使用 IEC 61131-3 结构化文本语言（ST）表达的算法一起提供了“Ramp”块的完整文本定义，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">FUNCTION_BLOCK Ramp</span><br><span class="line">	(* Ramp function block type definition *)</span><br><span class="line">	</span><br><span class="line">EVENT_INPUT</span><br><span class="line">	E_Init WITH X0,X1,Cycle,Duration;</span><br><span class="line">	E_Run WITH PV;</span><br><span class="line">END_EVENT</span><br><span class="line"></span><br><span class="line">EVENT_OUTPUT</span><br><span class="line">	E_Rdy;</span><br><span class="line">	E_Ex0 WITH Out,Hold;</span><br><span class="line">END_EVENT</span><br><span class="line"></span><br><span class="line">EC_STATE</span><br><span class="line">	START; (* Initial state *)</span><br><span class="line">	INIT: ALG_INIT -&gt; E_Rdy;</span><br><span class="line">	RAMP: ALG_RAMP -&gt; E_Ex0;</span><br><span class="line">END_STATES</span><br><span class="line"></span><br><span class="line">EC_TRANSITIONS</span><br><span class="line">	START TO INIT := E_Init;</span><br><span class="line">	INIT TO START := 1;</span><br><span class="line">	START TO RAMP := E_Run;</span><br><span class="line">	RAMP TO START := 1;</span><br><span class="line">END_TRANSITIONS</span><br><span class="line"></span><br><span class="line">VAR_INPUT</span><br><span class="line">	X0 : REAL;</span><br><span class="line">	X1 : REAL;</span><br><span class="line">	Cycle : TIME;</span><br><span class="line">	Duration : TIME;</span><br><span class="line">	PV : REAL;</span><br><span class="line">END_VAR</span><br><span class="line"></span><br><span class="line">VAR_OUTPUT</span><br><span class="line">	Out : REAL;</span><br><span class="line">	Hold : BOOL;</span><br><span class="line">END_VAR</span><br><span class="line"></span><br><span class="line">VAR</span><br><span class="line">	T : TIME; (* Time into Ramp *)</span><br><span class="line">END_VAR</span><br><span class="line"></span><br><span class="line">(* Algorithm definitions *)</span><br><span class="line">ALGORITHM ALG_INIT IN ST:</span><br><span class="line">	T := T#0s;</span><br><span class="line">END_ALGORITHM</span><br><span class="line"></span><br><span class="line">ALGORITHM ALG_RAMP IN ST:</span><br><span class="line">	IF T &lt; Duration THEN</span><br><span class="line">		OUT := X0 + (X1-X0) * TIME_TO_REAL(T) / TIME_TO_REAL(Duration);</span><br><span class="line">		T := T + Cycle;</span><br><span class="line">		Hold := PV &gt; Out;</span><br><span class="line">	END_IF;</span><br><span class="line">END_ALGORITHM</span><br><span class="line"></span><br><span class="line">END_FUNCTION_BLOCK</span><br></pre></td></tr></table></figure>
<p>“Ramp”功能块在上述类型声明中被完全定义。在初始化事件 “<code>E_Init</code>”到来时，描述“ramp”行为的输入值，即 <code>X0</code>，<code>X1</code> ，<code>Duration</code> 和 <code>Cycle</code>。<br>
“<code>INIT</code>”状态被激活，导致初始化算法“<code>ALG_INIT</code>”被调用。这就重置了内部定时器变量 “<code>T</code>”。当初始化算法结束时，输出事件“<code>E_rdy</code>”被触发，如 <code>EC_STATE</code> 声明中所定义。<br>
同样，当收到运行事件“<code>E_Run</code>”时，会发生向状态“<code>RAMP</code>”的转换，导致“<code>ALG_RAMP</code>”算法运行。这个算法根据<code>X0</code>、<code>X1</code>、<code>Cycle</code> 和 <code>Duration</code> 的值以及进入 <code>RAMP</code> 的时间 <code>T</code> 来计算 <code>OUT</code> 的新输出值。该算法还检查输出是否超过了“<code>PV</code>”的输入值，在这种情况下，输出“<code>Hold</code>”被设置为真。</p>
<h3 id="基础功能块实例的行为"><a class="markdownIt-Anchor" href="#基础功能块实例的行为"></a> 基础功能块实例的行为</h3>
<p>使用文本或图形声明，都可以定义从基本功能块类型定义中创建的实例。一个基本功能块类型的实例将具有由其类型定义所定义的行为，但它将有自己的输入和输出变量、事件变量和保持其 ECC 状态的存储。换句话说，每个基本函数实例的状态是完全独立于其他实例的。<br>
声明了基本功能块的资源，将在第一次激活该功能块之前初始化每个基本功能实例。这种初始化包括以下内容：</p>
<ul>
<li>每个输入、输出和内部变量的值被设置为在块类型定义中给出的声明中定义的初始值。如果没有给出初始化值，将采用特定数据类型的默认值。例如，没有定义初始值的布尔输入将总是被初始化为 “<code>FALSE</code>”，这是布尔变量的默认初始值。</li>
<li>在 ECC 中使用的所有事件输入和输出变量将被初始化为 “<code>FALSE</code>”。</li>
<li>算法的内部状态将被初始化。例如，如果一个算法是用 IEC 61131-3 顺序功能图（SFC）语言定义的，那么该算法将被重置，以便它在 SFC 初始步骤中开始。</li>
<li>实例 ECC 的初始状态将被设置为激活；ECC 内的所有其他状态将不激活。</li>
</ul>
<h3 id="算法的执行"><a class="markdownIt-Anchor" href="#算法的执行"></a> 算法的执行</h3>
<p>该标准非常精确地定义了到达功能块事件输入的事件触发 ECC 内状态变化的方式，然后反过来引起资源对功能块算法的调度。这一行为的主要方面总结如下：</p>
<ul>
<li>该资源存储和更新事件变量，以记录输入事件在功能块实例接口处的到达；</li>
<li>然后，该资源只允许在 ECC 内改变状态，如果： (a) 已收到输入事件，(b) 从当前活动状态（即从过渡的前身状态）开始的过渡条件得到满足，© 当前状态下的行动所调用的所有算法已停止执行。</li>
</ul>
<p>这种 IEC 61499算法执行模型的一个后果是，<u><em><strong>如果在算法执行之前或期间，一个输入事件有多次出现，该事件可能会丢失</strong></em></u>。由于这个原因，在标准中指出，资源应该提供检测这种过载条件存在时的手段，并采取适当的行动来恢复错误。</p>
<blockquote>
<p>注意 ⚠️</p>
<p>通过各种手段，应该总是可以创建一个避免事件过载的模型；例如，通过创建块来提供事件和数据队列，或者通过将加载信息反馈给上游块来修改事件输出生成率。</p>
</blockquote>
<p>基本功能块实例的执行控制图（ECC）在任何时候都可以处于<u><em><strong>与资源调度功能有关的三种主要状态</strong></em></u>（<code>Idle</code>、<code>Scheduling_algo</code> 和 <code>Waiting_for_algo_complete</code>）之一。这些状态形成了一个简单的状态机，如下图 3.5 所示，并在下表中描述。</p>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230522153731924.png" alt="image-20230522153731924" style="zoom:80%;">
<table>
<thead>
<tr>
<th>State</th>
<th>Condition</th>
<th>Notes</th>
</tr>
</thead>
<tbody>
<tr>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">S_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td>
<td>Idle</td>
<td>在这种状态下，区块中没有任何东西正在执行或待执行。该区块正在等待输入事件的到来。</td>
</tr>
<tr>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">S_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td>
<td>Scheduling algorithms</td>
<td>当处于状态 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">S_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 时，资源已经检测到一个输入事件的到来，并将在其他当前活动的或其他区块的更高优先级的算法结束后安排该区块的算法。</td>
</tr>
<tr>
<td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">S_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></td>
<td>Waiting for algorithms to complete</td>
<td>该资源已经开始执行该区块所选择的算法，现在正在等待，直到该算法结束。</td>
</tr>
</tbody>
</table>
<p>资源调度功能对与这些状态之间的变化相关的转换进行以下操作：</p>
<ul>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">S_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">S_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 与到达的输入事件相关的输入事件变量被设置为真，任何与使用’<code>WITH</code>'结构的事件相关的输入变量被采样并存储在块内。</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">S_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">S_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 资源安排块的算法运行，即资源开始执行与新的活动 ECC 状态相关的算法。在算法执行期间，各种输出事件变量可能被设置为 “<code>TRUE</code>”。在这段时间内，算法通常会更新各种输出变量的值。</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">S_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">S_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 该资源检测到算法已经完成执行。</p>
</li>
<li>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">S_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 至 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">S_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 该资源触发与算法执行期间设置的输出事件变量相关的输出事件。所有被定义为 &quot;<code>WITH</code> &quot;特定输出事件的输出变量现在都可以被外部连接的块采样。</p>
<p>当回到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">S_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 空闲状态时，输入事件变量也会被清空。<br>
返回到 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><msub><mi>S</mi><mn>0</mn></msub></mrow><annotation encoding="application/x-tex">S_0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathdefault" style="margin-right:0.05764em;">S</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.05764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">0</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 空闲状态时，输入事件变量也被清除，为新事件的到来做好准备。</p>
</li>
</ul>
<p>一个资源实际执行一个基本功能块的特定算法的方式在某种程度上是 “取决于实现（implementation-dependent）”的。如前所述，一个算法可以用各种语言来表达，因此它的行为不被认为是在 IEC 61499的范围内。然而，算法的实现应具有以下特点：</p>
<ul>
<li><u>输入</u>和<u>输出变量</u>以及<u>事件变量</u>应准确无误地<u>映射到算法中的变量</u>。</li>
<li><u>算法应该被封装</u>，以至于它只能在功能块体内读写变量。</li>
<li>相对于将触发其执行的事件的预期到达率而言，<u>算法的执行时间应该很短</u>。显然，如果一个算法被设计为每 100 毫秒执行一次，并且要使用 100 毫秒的时钟事件来触发，那么它最坏的情况下的执行时间应该远远低于 100 毫秒，以便让其他算法执行。</li>
<li>该<u>算法应该有一个明确的初始状态</u>，当该块第一次被资源准备好执行时，它可以进入这个状态。</li>
</ul>
<h2 id="34-复合功能块的定义"><a class="markdownIt-Anchor" href="#34-复合功能块的定义"></a> 3.4 复合功能块的定义</h2>
<p>复合功能块提供了一种方法，可以从基本功能块和其他较小的复合功能块中分层次地建立起更复杂的功能块。</p>
<blockquote>
<p><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">复</mi><mi mathvariant="normal">合</mi><mi mathvariant="normal">功</mi><mi mathvariant="normal">能</mi><mi mathvariant="normal">块</mi><mo>=</mo><mi mathvariant="normal">基</mi><mi mathvariant="normal">本</mi><mi mathvariant="normal">功</mi><mi mathvariant="normal">能</mi><mi mathvariant="normal">块</mi><mi mathvariant="normal">之</mi><mi mathvariant="normal">间</mi><mi mathvariant="normal">/</mi><mi mathvariant="normal">或</mi><mi mathvariant="normal">与</mi><mi mathvariant="normal">其</mi><mi mathvariant="normal">他</mi><mi mathvariant="normal">复</mi><mi mathvariant="normal">合</mi><mi mathvariant="normal">功</mi><mi mathvariant="normal">能</mi><mi mathvariant="normal">块</mi><mi mathvariant="normal">之</mi><mi mathvariant="normal">间</mi><mi mathvariant="normal">的</mi><mi mathvariant="normal">组</mi><mi mathvariant="normal">合</mi></mrow><annotation encoding="application/x-tex">复合功能块 = 基本功能块之间/或与其他复合功能块之间的组合</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mord cjk_fallback">复</span><span class="mord cjk_fallback">合</span><span class="mord cjk_fallback">功</span><span class="mord cjk_fallback">能</span><span class="mord cjk_fallback">块</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord cjk_fallback">基</span><span class="mord cjk_fallback">本</span><span class="mord cjk_fallback">功</span><span class="mord cjk_fallback">能</span><span class="mord cjk_fallback">块</span><span class="mord cjk_fallback">之</span><span class="mord cjk_fallback">间</span><span class="mord">/</span><span class="mord cjk_fallback">或</span><span class="mord cjk_fallback">与</span><span class="mord cjk_fallback">其</span><span class="mord cjk_fallback">他</span><span class="mord cjk_fallback">复</span><span class="mord cjk_fallback">合</span><span class="mord cjk_fallback">功</span><span class="mord cjk_fallback">能</span><span class="mord cjk_fallback">块</span><span class="mord cjk_fallback">之</span><span class="mord cjk_fallback">间</span><span class="mord cjk_fallback">的</span><span class="mord cjk_fallback">组</span><span class="mord cjk_fallback">合</span></span></span></span></p>
</blockquote>
<p>复合功能块的类型定义包含对选定类型的功能块实例的声明，这些实例通过数据和事件连接被连接起来。该标准将在复合块中使用的块视为组件功能块。组件块之间的数据连接定义了块输出到输入之间的数据值传输，而事件连接定义了块内算法的执行顺序。</p>
<h3 id="复合块类型规范的规则"><a class="markdownIt-Anchor" href="#复合块类型规范的规则"></a> 复合块类型规范的规则</h3>
<p>关于复合功能块类型定义的规范有一些规则和限制，特别是关于外部事件和数据输入和输出与内部组件块的连接。</p>
<p>这些规则的产生是因为事件不能直接被扇出<span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow></mrow><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span>（fanned-out）；也就是说，在事件输出和事件输入之间必须有<u><em><strong>一对一的连接</strong></em></u>。通过使用 <code>E_SPLIT</code> 功能块可以使一个事件产生多个并发的事件；这是第五章中讨论的IEC 61499的特殊事件功能块之一。相比之下，数据输入可以是扇形的，即允许一个数据输出来驱动许多不同的数据输入。</p>
<blockquote>
<p><strong>扇出系数</strong><span class="katex"><span class="katex-mathml"><math><semantics><mrow><msup><mrow></mrow><mo>∗</mo></msup></mrow><annotation encoding="application/x-tex">^*</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.688696em;vertical-align:0em;"></span><span class="mord"><span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.688696em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span></span></span></span></span></span></span></span>（英语：Fan-out）是电子技术中表明逻辑门带负载能力的一个量度，其定义为一个逻辑门电路能驱动与之同类逻辑门的个数。大多数晶体管—晶体管逻辑（TTL）门能够为10个其他数字门或设备提供信号。因而，一个典型的晶体管—晶体管逻辑门有10个扇出。</p>
<p>（资料来源<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%89%87%E5%87%BA">维基百科</a>）</p>
</blockquote>
<h3 id="事件连接的规则"><a class="markdownIt-Anchor" href="#事件连接的规则"></a> 事件连接的规则</h3>
<ol>
<li><u><em><strong>每个复合事件输入</strong></em></u>必须正好<u><em><strong>连接到内部组件功能块的一个输入事件</strong></em></u>，或者必须“通过路由（through routed）”到复合块的事件输出。也就是说，事件输入不可能直接连接到不同组件块的多个事件输入。</li>
</ol>
<p>如果需要，<code>E_SPLIT</code> 等事件功能块可用于从单个输入事件中创建扇出事件，见第5章。</p>
<ol start="2">
<li>
<p>每个<u><em><strong>组件的事件输入端</strong></em></u>必须准确地<u><em><strong>连接到</strong></em></u><u><em><strong>一个组件输出事件</strong></em></u>或<u><em><strong>一个复合块事件输入端</strong></em></u>。</p>
</li>
<li>
<p>类似地，<u><em><strong>组件功能块的每个事件输出</strong></em></u>只能精确地<u><em><strong>连接到一个组件输入事件</strong></em></u>或<u><em><strong>一个复合事件输出</strong></em></u>。</p>
</li>
<li>
<p>每个<u><em><strong>复合块的输出事件</strong></em></u>必须正好与<u><em><strong>一个组件的输出事件</strong></em></u>相连接，或者直接<u><em><strong>来自一个复合输入事件</strong></em></u>。</p>
</li>
</ol>
<blockquote>
<p>注意 ⚠️</p>
<p>一些组件块的输入和输出事件可能保持不连接。在这种情况下，仅与未连接的输入事件相关的算法将不会被执行。</p>
</blockquote>
<h3 id="数据连接的规则"><a class="markdownIt-Anchor" href="#数据连接的规则"></a> 数据连接的规则</h3>
<p>以下规则适用于复合块<u><em><strong>数据</strong></em></u>输入和输出与组件输入和输出之间的连接。</p>
<ol>
<li>
<p>复合块的每个数据输入可以</p>
<ul>
<li>连接到内部组件块的一个或多个数据输入，</li>
<li>或直接连接到一个或多个复合功能块的输出，</li>
<li>或同时连接。</li>
</ul>
</li>
<li>
<p>每个组件块的数据输入可以是</p>
<ul>
<li>不连接，</li>
<li>或连接到一个其他组件块的输出，</li>
<li>或连接到复合块的数据输入。</li>
</ul>
<p>显然，该标准不允许一个成分块输入连接到多个输出，因为这样输入就会有一个不确定的值。</p>
</li>
<li>
<p>每个组件块数据输出可以</p>
<ul>
<li>不连接，</li>
<li>或连接到一个或多个组件数据输入，</li>
<li>也可以连接到一个或多个复合数据输出。</li>
</ul>
</li>
<li>
<p>每个复合块数据输出必须连接到</p>
<ul>
<li>一个组件数据输出，</li>
<li>或从一个复合数据通过通过路由（through routed）的方式输入 。</li>
</ul>
</li>
</ol>
<h3 id="复合块示例"><a class="markdownIt-Anchor" href="#复合块示例"></a> 复合块示例</h3>
<p>考虑一下图 3.6 中描述的功能块例子，它被选来演示复合功能块的许多特性。</p>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230522162322847.png" alt="image-20230522162322847" style="zoom:80%;">
<p>该图显示了一个复合块的图形主体，它被描绘成一个连接在一起的功能块网络，形成一个新的块。在这个例子中，一个额外的比较类型的组件功能块和事件功能块 <code>E_MERGE</code> 被用来扩展“Ramp”功能块的功能，形成一个“Sawtooth”发生器。</p>
<blockquote>
<p>注意 ⚠️</p>
<p><code>Ramp1</code> 是 <code>Ramp</code> 基本块的一个实例，如本章前一节所述。每个组件块的实例名称就显示在图形主体中每个块的轮廓上方。</p>
</blockquote>
<p>这个新块的外部接口如图 3.7 所示。</p>
<blockquote>
<p>注意 ⚠️</p>
<p>它的外观与基本功能块相同。事实上，从外部角度来看，仅仅从一个块的外部接口是不可能区分出基本块和复合块的。</p>
</blockquote>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230522162608842.png" alt="image-20230522162608842" style="zoom:80%;">
<p>现在我们将回顾这个块的行为，并说明它是如何被模拟成一个复合功能块的。</p>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230522163306494.png" alt="image-20230522163306494" style="zoom:80%;">
<p>这个块的目的是提供一个输出值，如图 3.8 所示，遵循一个 “sawtooth”曲线，即重复地将输出从 <code>0.0</code> “ramp”到一个目标值，然后复位并从 <code>0.0</code> 重新开始“ramp”。</p>
<ol>
<li>该模块通过输入事件 <code>E_Init</code> 的初始化事件进行初始化。此时，输入<code>X0</code>、<code>X1</code>、<code>Cycle</code> 和 <code>Duration</code> 的输入值被存储在 “<code>Ramp1</code>”输入变量中。
<ul>
<li>在这个例子中，<code>X0</code> 和 <code>X1</code> 被固定在 <code>0.0</code> 和 <code>1000.0</code> 的值上，由复合块主体中定义的常数有效地设置了 ramp 输出 <code>Out</code> 的限制。</li>
<li><code>Cycle</code> 和 <code>Duration</code> 的值来自于块的外部接口提供的值，并定义了“sawtooth”波形的时间特征。</li>
</ul>
</li>
<li>在初始化之后，该块已经准备好在事件输入端 <code>E_Run</code> 接收定期的事件流。<code>E_Run</code>输入的每个事件都会触发<code>Ramp1</code> 块向 <code>X1</code> 设定的上限递增其输出 <code>Out</code>。</li>
<li>每次 <code>Ramp1</code> 内部算法完成其执行，一个输出事件 <code>E_ExO</code> 被传递给 <code>Compare1</code> 块，然后它将 <code>Out</code> 的值与 <code>Target</code> 的值进行检查，即它比较输入<code>X</code> 和 <code>Y</code>。</li>
<li>最终，当 <code>Ramp1.Out</code> 值达到目标值时，比较块检测到输入 <code>X</code> 大于输入 <code>Y</code> 并触发其输出事件 <code>E_GT</code>。</li>
<li>这个事件被反馈给 <code>Merge1</code> 块，它为 <code>Ramp1</code> 块产生一个新的初始化事件。<code>Ramp1</code> 块被重新初始化，输出被重置为 <code>0.0</code>。</li>
<li>只要该块继续在其事件输入 <code>E_Run</code> 接收事件，它将继续产生锯齿形的波形。</li>
</ol>
<p>锯齿（sawtooth）形曲线的斜率可以通过在事件输入端 <code>E_Init</code> 发出不同的持续时间值的初始化事件来改变该块。<code>Merge1</code>是第 5 章中描述的标准事件功能块的一个实例，它提供了一个将多个事件合并为一个新的事件流的方法。在这种情况下，<code>Merge</code> 被用来允许 <code>Ramp</code> 块由外部事件输入 <code>E_Init</code> 或由内部产生的来自比较块的事件来初始化。</p>
<h3 id="with-结构的使用"><a class="markdownIt-Anchor" href="#with-结构的使用"></a> <code>WITH</code> 结构的使用</h3>
<p>通过使用 <code>WITH</code> 结构，可以用图形显示哪些数据输入和输出分别与特定的输入和输出事件相关。</p>
<blockquote>
<p>例如，在图 3.7 中，初始化事件 <code>E_Init</code> 与输入 <code>Cycle</code> 和 <code>Duration</code> 有关。</p>
</blockquote>
<p>然而，与基本功能块的行为不同，<code>WITH</code> 构造并<u><em><strong>不表示输入被存储在属于该块界面的变量中</strong></em></u>。</p>
<p>对于复合块来说，<code>WITH</code> 是一种手段，用来显示<u><em><strong>当一个特定的输入事件发生时，哪些输入需要准备好</strong></em></u>。输入值实际上被采样并存储在内部组件块的输入变量中。同样地，对于输出事件，使用 <code>WITH</code> 构造可以显示当某个特定事件发生时哪些输出值是准备好的，例如在图 3.7 中，当输出事件 <code>E_Ex0</code> 发生时，数据输出 <code>Out</code> 是准备好的。</p>
<blockquote>
<p>注意 ⚠️</p>
<p>标准规定复合功能块声明中的<u><em><strong>每个数据输入和数据输出</strong></em></u>都<u><em><strong>必须与至少一个</strong></em></u> <code>WITH</code> <u><em><strong>构造相关联</strong></em></u>。</p>
<ul>
<li>对于输入来说，这可以确保它们的值至少被一个事件所采样；</li>
<li>对于输出来说，这可以确保有一个明确的时间点来更新输出。</li>
</ul>
</blockquote>
<h3 id="复合功能块的执行"><a class="markdownIt-Anchor" href="#复合功能块的执行"></a> 复合功能块的执行</h3>
<p>复合功能块的实例可以作为资源中存在的功能块网络的一部分来创建，可以存在于顶层，也可以在其他更大的复合功能块的定义中使用。在所有情况下，复合块的执行都是由<u><em><strong>其事件输入的到来</strong></em></u>决定的。该标准定义了以下简单的规则，决定了事件的处理方式：</p>
<ol>
<li>
<p>如果一个复合块的输入事件被直接路由（thought route）到一个复合块的事件输出，那么在事件输入端发生的事件将在该块的事件输出端产生一个事件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">复合块A:OUTPUT --&quot;直接路由&quot;--&gt; 复合块B:INPUT</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果一个输入事件被连接到一个内部组件功能块，那么输入事件的发生将导致一个事件到达组件的输入事件。然后，该组件块将被资源的调度功能安排执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line"></span><br><span class="line">input_evt1([输入事件]) -.-&gt; componentA</span><br><span class="line"></span><br><span class="line">subgraph 复合块A</span><br><span class="line">	componentA[[组件A]]</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>同样，如果一个组件块的输出事件与另一个组件块的输入事件相连，那么第一个组件块的输出事件将导致第二个组件块被安排执行。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">flowchart TB</span><br><span class="line">componentA ---&gt; componentB</span><br><span class="line"></span><br><span class="line">subgraph 复合块A</span><br><span class="line">	componentA[[组件A]]</span><br><span class="line">	componentB[[组件B]]</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>如果一个复合输出事件与一个组件块的输出事件相连，那么当组件块产生一个输出事件时，复合输出事件就会产生。</p>
</li>
</ol>
  <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">flowchart LR</span><br><span class="line"></span><br><span class="line">componentA -.-&gt; output_evt1([输出事件])</span><br><span class="line"></span><br><span class="line">subgraph 复合块A</span><br><span class="line">	componentA[[组件A:OUTPUT]]</span><br><span class="line">end</span><br></pre></td></tr></table></figure>
<p>这些简单的规则在事件和块的执行之间提供了一个直观和逻辑的联系。从本质上讲，事件通过复合功能块的网络传播，从输入端到复合块的输出端进行传播。</p>
<h3 id="复合功能块的文本语法示例"><a class="markdownIt-Anchor" href="#复合功能块的文本语法示例"></a> 复合功能块的文本语法示例</h3>
<p>到目前为止，我们集中讨论了复合功能块的图形表示。与基本功能块一样，IEC 61499文本语法也可以用来描述构成复合功能块的结构和内部网络。例如，图3.6中描述的锯齿形块可以用以下文字描述来表示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">FUNCTION_BLOCK SAWTOOTH</span><br><span class="line">(* Event definitions *)</span><br><span class="line"></span><br><span class="line">EVENT_INPUT</span><br><span class="line">	E_RUN WITH TARGET;</span><br><span class="line">	E_INIT WITH CYCLE, DURATION;</span><br><span class="line">END_EVENT</span><br><span class="line"></span><br><span class="line">EVENT_OUTPUT</span><br><span class="line">	E_RDY;</span><br><span class="line"> 	E_ExO WITH OUT;</span><br><span class="line">END_EVENT</span><br><span class="line"></span><br><span class="line">(* Variable definitions *)</span><br><span class="line">VAR_INPUT</span><br><span class="line">	CYCLE : TIME;</span><br><span class="line">	DURATION : TIME;</span><br><span class="line">	TARGET : REAL;</span><br><span class="line">END_VAR</span><br><span class="line"></span><br><span class="line">VAR_OUTPUT</span><br><span class="line">	OUT : REAL;</span><br><span class="line">END_VAR</span><br><span class="line"></span><br><span class="line">(* Function blocks *)</span><br><span class="line">FBS</span><br><span class="line">	RAMP1 : RAMP;</span><br><span class="line">	COMPARE1 : COMPARE;</span><br><span class="line">	MERGE1 : E_MERGE;</span><br><span class="line">END_FBS</span><br><span class="line"></span><br><span class="line">(* Event connections *)</span><br><span class="line">EVENT_CONNECTIONS</span><br><span class="line">	E_RUN TO RAMP1.E_RUN;</span><br><span class="line">	E_INIT TO MERGE1.EI1;</span><br><span class="line">	MERGE1.EO TO RAMP1.E_INIT;</span><br><span class="line">	RAMP1.E_Rdy TO E_Rdy;</span><br><span class="line">	RAMP1.E_ExO TO E_ExO;</span><br><span class="line">	COMPARE.E_GT TO MERGE1.EI2;</span><br><span class="line">END_CONNECTIONS</span><br><span class="line"></span><br><span class="line">(* Data connections *)</span><br><span class="line">DATA_CONNECTIONS</span><br><span class="line">	0.0 TO RAMP1.X0;</span><br><span class="line">	1000.0 TO RAMP1.X1;</span><br><span class="line">	CYCLE TO RAMP1.CYCLE;</span><br><span class="line">	DURATION TO RAMP1.DURATION;</span><br><span class="line">	RAMP1.OUT TO COMPARE1.X;</span><br><span class="line">	TARGET TO COMPARE1.Y;</span><br><span class="line">	Compare1.X0 TO OUT;</span><br><span class="line">END_CONNECTIONS</span><br><span class="line"></span><br><span class="line">END_FUNCTION_BLOCK;</span><br></pre></td></tr></table></figure>
<p>文本形式比较像电子电路的构建清单。它描述了所有的<u><em><strong>事件和数据输入和输出</strong></em></u>、<u><em><strong>内部功能块</strong></em></u>以及<u><em><strong>事件和数据连接</strong></em></u>。</p>
<p>定义的每一部分都由一个块的关键字引入，例如，<code>EVENT_INPUT</code> … <code>END_EVENT</code> 定义了该块的所有输入事件，同样，<code>DATA_CONNECTIONS</code> … <code>END_CONNECTIONS</code> 定义了外部接口和内部块之间的所有数据连接。</p>
<p>文本语法的开发是为了形成一种通用和可移植的格式，可以用来表达复合块的结构。它并不直接表达块的行为的算法方面，但它确实<u><em><strong>明确地定义了块是如何构建的</strong></em></u>，从中可以推导出它的行为。事实上，目前正在开发的软件工具可以自动在图形和文本表示之间进行转换。</p>
<h2 id="35-子应用的定义"><a class="markdownIt-Anchor" href="#35-子应用的定义"></a> 3.5 子应用的定义</h2>
<p>一个子应用可以被看作是一种特殊形式的复合功能块，它被设计为 “分布式”。也就是说，它可以在一个以上的资源上运行。它的结构与复合功能块相似，但关于数据和事件的使用的一些规则被放松了。一个子应用功能块类型只能在其他较大的子应用的主体中和完整的应用中使用。然而，一个子应用类型本身可以使用复合、基本和其他子应用功能块来定义。</p>
<p>与复合功能块相比，子应用的主要对比特征是它可以选择在多个资源上运行。请注意，基本功能块和复合功能块只能在同一资源上运行，也就是说，不可能将它们分解成可以在不同资源上运行的部分。然而，一个子应用可以在一个资源上运行，也可以分布在不同的资源上运行；换句话说，它是可分布的。</p>
<p>关于子应用的一种方式是，它代表一个可重复使用的部分功能块网络。它通常被用来定义功能块和连接的安排，可以在不同的网络配置中重复使用。在许多方面，子应用类型的定义类似于软件的宏，因为它允许一个特定的解决方案以功能块网络的形式被轻易地复制。</p>
<blockquote>
<p>例如，考虑一个提供温度控制回路的子应用块，如图 3.9a 所示。</p>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230523113657703.png" alt="image-20230523113657703" style="zoom:80%;">
<p>它由一个模拟输入块 <code>Input 1</code>、一个PID控制块 <code>PID 1</code> 和一个模拟输出块 <code>Output 1</code> 组成。通常，这将用于控制一个设备的温度，例如，一个加热容器或炉子。这个控制回路的主要功能是：(i)测量当前温度，(ii)将其值与设定值或期望温度进行比较，然后(iii)调整一个输出值，驱动加热设备来校正温度。</p>
<p>这三个功能被映射到构成子程序的三个组件功能块上。<code>Input 1</code> 模块读取外部传感器的电流值。<code>PID 1</code> 块提供一个 ***PID 算法***来比较测量值（过程值）和设定值并创建输出值。<code>Input 1</code> 模块获取 <code>PID 1</code> 模块创建的值，并将其传输给外部执行器。<br>
<code>Input 1</code> 和 <code>Output 1</code> 将被构造成复合功能块，每个功能块都需要至少一个服务接口功能块来提供与底层控制器的接口，以便从控制器硬件读取输入和输出（I/O)值。<u><em><strong>服务接口功能块</strong></em></u>是一种特殊形式的块，提供与物理设备或通信系统的各种接口，在第四章中讨论。</p>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230523114211924.png" alt="image-20230523114211924" style="zoom:80%;">
<p>图 3.9b 显示了 <code>TempControl</code> 子程序如何在一个简单的控制器中运行，为一个使用蒸汽加热的容器提供闭环温度控制。<code>TempControl</code> 子程序的输入是一个从热电偶等传感器上读取的温度值；子程序的输出驱动某种形式的执行器，如蒸汽阀，以改变加热。</p>
<blockquote>
<p>注意 ⚠️</p>
<p>在这个例子中，<code>TempControl</code> 子程序实际上是 <code>Single_Vessel_Control</code> 程序的一部分，该程序已在单一的 IEC 61499 资源中声明，即其所有功能块都在同一资源中运行。</p>
</blockquote>
<p>这个子程序有两个事件输入，<code>E_Ini</code>t 和 <code>E_Run</code>。</p>
<ul>
<li><code>E_Init</code> 是用来初始化内部组件块的。它触发了 PID块的执行并读取其输入变量，也就是说，<code>Setpoint</code> 输入的值被读取并存储在 <code>PID 1</code> 中。这定义了控制环路将稳定的预期温度。一般来说，PID 算法将需要大量的参数，如积分和导数动作的定时常数。为了保持例子的简单性，这些参数没有显示出来，但将以与设定值相同的方式进行初始化。</li>
<li><code>E_Run</code> 事件在子程序中传播，导致控制环路根据 PID 算法计算的值更新其外部输出。在这个例子中，我们可以假设应用程序中的另一个定时功能块提供一个定期的事件流，例如在 <code>E_Run</code> 事件输入处以 <code>100毫秒</code> 的间隔，以确保 <code>TempControl</code> 块被定期调用。这将确保以给定的扫描速率测量温度，并将其值传播给 <code>PID 1</code>，而<code>PID 1</code>又 会创建一个新的输出值来调节热量输出。</li>
</ul>
</blockquote>
<h3 id="子应用类型规范的规则"><a class="markdownIt-Anchor" href="#子应用类型规范的规则"></a> 子应用类型规范的规则</h3>
<p>子应用构建的规则如下：</p>
<ol>
<li>一个子应用的实例只能在其他子应用类型定义中或在一个应用程序中被声明。</li>
<li>在子应用类型定义中不使用 <code>WITH</code> 构造，因为事件和数据之间的关联将取决于子应用如何在资源之间分配。</li>
<li>在文本语法中，子应用的输入和输出变量使用 <code>VAR_INPUT</code> 和 <code>VAR_OUTPUT</code> 构造来声明，但与复合功能块一样，这并不意味着为这些变量创建存储。子应用程序的所有输入和输出值都存储在组件块的内部接口。</li>
</ol>
<h3 id="子应用的执行规则"><a class="markdownIt-Anchor" href="#子应用的执行规则"></a> 子应用的执行规则</h3>
<p>子应用的实例可以在应用程序中声明，也可以在其他子应用中声明。然而，子应用程序的实例与复合功能块的实例相当不同，因为它真正代表了一组功能块及其连接的副本。在这方面，一个子应用可以被比作一个软件宏或一个图形模式。</p>
<p>该标准为子应用的执行方式定义了以下规则：</p>
<ol>
<li>事件可以直接通过子应用程序路由，因此到达事件输入的事件将立即触发事件输出的事件。</li>
<li>每个没有直接路由的事件输入必须连接到一个内部组件块的事件输入。在这种情况下，当事件到达子应用程序的事件输入时，内部组件块将收到一个事件并被安排执行。</li>
<li>当一个组件块执行时，它将产生一个或多个输出事件。这些将反过来触发在子应用中与之相连的其他组件块的执行。</li>
<li>没有直接通过事件输入的子应用程序的事件输出必须连接到一个组件块的输出事件。当相关的组件块执行并产生一个输出事件时，该事件被传播到子应用程序的事件输出。</li>
</ol>
<h3 id="分布式子应用实例"><a class="markdownIt-Anchor" href="#分布式子应用实例"></a> 分布式子应用实例</h3>
<p>到目前为止，我们已经考虑了在单一资源上运行的子应用。IEC 61499 的一个重要特点是能够重新安排应用程序和子应用程序，使它们能够提供相同的功能，但在不同的资源上以不同的分布安排运行。子应用，如图3.9中描述的 <code>TempControl</code>，可以被分解成更小的功能块网络片段，在不同的资源中运行。在 <code>TempControl</code> 的情况下，可以考虑以下安排：</p>
<ol>
<li>所有块都在一个资源上运行，即非分布式配置</li>
<li><code>Input 1</code>、<code>PID 1</code> 和 <code>Output 1</code> 块在不同的资源上运行，即完全分布式配置。即完全分布式配置</li>
<li><code>Input 1</code> 在一个资源上运行，而<code>PID 1</code> 和 <code>Output 1</code> 块在第二个资源上运行，即分割配置。资源上运行，即一个分离式资源配置</li>
<li><code>Input 1</code>、<code>PID 1</code> 块在一个资源上运行，而 <code>Output 1</code> 在第二个资源上运行，即另一种分割资源配置。</li>
</ol>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230523121624897.png" alt="image-20230523121624897" style="zoom:80%;">
<p>图 3.10 显示了第四种分布安排，其中模拟输入（Analog Input）和 PID 算法的块 <code>Input 1</code>、<code>PID 1</code> 在一个资源 <code>Resource1</code> 上运行，模拟输出（Analog Output）在第二个资源 <code>Output1</code> 上运行。</p>
<img src="/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/image-20230523122646643.png" alt="image-20230523122646643" style="zoom:80%;">
<p>在实践中，这种安排意味着子程序 <code>TempControl</code> 可以在位于不同控制器的两个独立资源中运行。图 3.11 显示了可以考虑的一种可能的物理系统配置。它显示了两个控制器 <code>Controller_A</code> 和 <code>Controller_B</code>  通过某种形式的通信系统连接，例如使用现场总线或以太网的网络。模拟输入被连接到 <code>Controller_A</code> ，而执行器现在由另一个 <code>Controller_B</code>  驱动。子应用现在分布在两个控制器上，但内部功能仍然由原始 <code>TempControl</code> 子应用类型定义的功能块来确定。</p>
<p>我们设想，系统设计者可以根据系统设计要求，为子程序自由选择适当的分布安排。设计者选择的分布安排将取决于许多因素，包括：</p>
<ol>
<li>资源是否能够支持特定类型的功能块，</li>
<li>特定资源的负载和性能，</li>
<li>以及资源之间通信服务的延迟和可靠性。</li>
</ol>
<p>可以注意到，如图 3.10 所示，一些额外的功能块 <code>Pub1</code> 和 <code>Sub1</code> 已经被添加到分布式 <code>TempControl</code> 子程序中。这些是服务接口功能块的进一步例子，在第4章有更详细的讨论，它们在资源内的功能块和资源的通信系统之间提供一个接口：</p>
<ul>
<li><code>PUB1</code> 是一个发布者功能块，用于通过通信链路向其他控制器内的一个或多个外部资源发送一个或多个数据值。它只是使用一个给定的识别地址来发送数值。</li>
<li><code>SUB1</code> 是一个订户功能块，在第二个资源中用来接收 <code>PUB1</code> 发出的值。在这种情况下，只有一个用户，但也可能有多个用户的配置。</li>
</ul>
<p>这个例子使用了<u><em><strong>发布者/订阅者服务接口块</strong></em></u>，但标准中也讨论了提供不同类型通信模型的其他块，如请求者和响应者。在这个特定的例子中，使用了发布者/订阅者模型，因为在这个简单的设计中，没有要求向 <code>PID1</code> 块提供任何反馈，以确定向模拟输出的值的传输是否成功。<code>PID1</code> 模块将继续向其输出新的数值，而不管下游的通信问题。显然，在一个完整的设计中，需要监控通信并检查整个控制回路是否正常工作。这可以通过使用，例如，请求和响应通信模型或通过从 <code>Output1</code> 块反馈信号来实现。</p>
<blockquote>
<p>注意 ⚠️</p>
<p>当一个子程序被重新安排在不同的资源上运行时，通常需要为通信系统增加参数。这通常包括诸如资源地址和网络路由参数等细节。这些信息通常将作为参数传递给处理资源间通信的服务接口功能块。</p>
<p>应该强调的是，IEC 61499 没有定义通信协议，也没有对通信相关的地址或参数进行标准化。但它确实提供了一个框架和架构，用于定义服务，如使用服务接口功能块的通信。</p>
</blockquote>
<h2 id="36-总结"><a class="markdownIt-Anchor" href="#36-总结"></a> 3.6 总结</h2>
<p>在本章中，我们已经涵盖了功能块类型定义的最重要方面。我们回顾了类型定义如何被用来创建功能块实例。反过来，我们也看到了功能块实例是如何在新的类型定义中被用来分层建立功能更强的功能块的。尽管设计可以用图形来创建，但我们注意到，标准也定义了一种正式的文本语法，可以作为一种替代的表示方法。</p>
<p>总结一下：</p>
<ul>
<li>
<p>有三类功能块：基本功能块，复合功能块 和 子应用功能块。</p>
</li>
<li>
<p>基本功能块的行为是以执行控制图（ECC）和一个或多个算法来定义的。</p>
</li>
<li>
<p>复合功能块是以一个组件功能块的网络来定义的。</p>
</li>
<li>
<p>子应用块与复合功能块类似，但也有一个灵活的特点，即它们可以分布在多个资源上运行。</p>
</li>
<li>
<p>服务接口功能块提供了一种方法来模拟资源与底层硬件和通信系统之间的互动。</p>
<p>所有的功能块类型定义都可以用图形或文字来定义。图形和文本的表述是可以互换的。</p>
</li>
</ul>
<h1 id="4-服务接口service-interface功能块"><a class="markdownIt-Anchor" href="#4-服务接口service-interface功能块"></a> 4. 服务接口（Service Interface）功能块</h1>
<p>到目前为止，我们主要关注的是用于模拟资源内部行为的功能块。在第三章末尾，我们回顾了一个简单的分布式应用的创建，并表明只有在提供额外的服务接口（SI）功能块以在资源之间通信数据值和事件的情况下，这才可能实现。</p>
<p>事实上，只要资源内的功能块和外部世界之间需要任何形式的交互，就需要 SI 功能块。IEC 61499没有为特定类型的 SI 功能块设定标准，但确实规定这些形式的功能块应使用一套标准的输入和输出变量以及输入和输出事件来定义。还有一种特殊的符号用于描述在执行 SI 功能块期间外部发生的互动序列，如发送请求和等待响应。</p>
<p>现在我们考虑可能需要 SI 功能块的地方。在一个工业控制器中，显然需要读取物理输入值，如来自压力和温度传感器的输入值，也需要将输出值写入执行器，例如，用于驱动阀门、泵、电机等设备。还有要求通过串行通信链路传输数值，向外部控制器发送数据副本，驱动显示器，以及从显示面板和其他 HMI 设备读取输入。事实上，这些都是与资源进行外部交互的例子，可以使用不同类型的 SI 功能块进行建模。下表中列出了一些可能用于工业控制系统建模的 SI 功能块的例子。</p>
<table>
<thead>
<tr>
<th>Type name</th>
<th>Service provided</th>
<th>Application example</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>IO_Writer</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>IO_Reader</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>Publisher</code></td>
<td></td>
<td></td>
</tr>
<tr>
<td><code>Subscriber</code></td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>这些只是可能需要的 SI 功能块种类的几个典型例子。应该注意的是，该标准并不试图定义具体的 SI 块，因为很明显，每个系统都会有自己的特殊要求。然而，我们将看到，IEC 61499 确实对 SI 功能块接口的一些重要方面进行了标准化，包括主要的输入和输出参数。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://lostnfound.top">Guohao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lostnfound.top/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/">https://lostnfound.top/2023/05/16/NOTE-Modelling-Control-Sys-IEC61499/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lostnfound.top" target="_blank">Lost N Found</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/">自动化</a></div><div class="post_share"><div class="social-share" data-image="/linear-gradient(45deg,%20#8EC3B0,%20#9ED5C5,%20#F8C4B4,%20#FF8787)" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Guohao</div><div class="author-info__description">L’existence précède l‘essence</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">36</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">20</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">8</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Dave0126" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:dave980126@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E4%BB%8B%E7%BB%8D"><span class="toc-text"> 1. 介绍</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%83%8C%E6%99%AF"><span class="toc-text"> 背景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#iec-61499-function-block-standard"><span class="toc-text"> IEC 61499 function block standard</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E5%8A%9F%E8%83%BD%E5%9D%97"><span class="toc-text"> 为什么使用功能块？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%9F%E8%83%BD%E5%9D%97%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E8%81%94%E7%B3%BB%E4%B8%8E%E5%8C%BA%E5%88%AB"><span class="toc-text"> 功能块与对象的联系与区别</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-iec-61499%E4%B8%AD%E7%9A%84%E6%A8%A1%E5%9E%8B%E4%B8%8E%E6%A6%82%E5%BF%B5"><span class="toc-text"> 2. IEC 61499中的模型与概念</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E7%B3%BB%E7%BB%9F%E6%A8%A1%E5%9E%8B"><span class="toc-text"> 2.1 系统模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E8%AE%BE%E5%A4%87%E6%A8%A1%E5%9E%8B"><span class="toc-text"> 2.2 设备模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E8%B5%84%E6%BA%90%E6%A8%A1%E5%9E%8B"><span class="toc-text"> 2.3 资源模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-%E5%BA%94%E7%94%A8%E6%A8%A1%E5%9E%8B"><span class="toc-text"> 2.4 应用模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-%E5%8A%9F%E8%83%BD%E5%9D%97%E6%A8%A1%E5%9E%8B"><span class="toc-text"> 2.5 功能块模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-%E5%8A%9F%E8%83%BD%E5%9D%97%E7%B1%BB%E5%9E%8B"><span class="toc-text"> 2.6 功能块类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E5%9D%97%E7%B1%BB%E5%9E%8B"><span class="toc-text"> 基本功能块类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E5%9D%97%E7%9A%84%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B"><span class="toc-text"> 基本功能块的执行模型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E5%8A%9F%E8%83%BD%E5%9D%97%E7%B1%BB%E5%9E%8B"><span class="toc-text"> 复合功能块类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E5%8A%9F%E8%83%BD%E5%9D%97%E7%B1%BB%E5%9E%8B"><span class="toc-text"> 服务接口功能块类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-%E5%88%86%E5%B8%83%E5%BC%8F%E6%A8%A1%E5%9E%8B"><span class="toc-text"> 2.7 分布式模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-%E7%AE%A1%E7%90%86%E6%A8%A1%E5%9E%8B"><span class="toc-text"> 2.8 管理模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-%E8%BF%90%E8%A1%8C%E7%8A%B6%E6%80%81%E6%A8%A1%E5%9E%8B"><span class="toc-text"> 2.9 运行状态模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#210-%E4%BD%BF%E7%94%A8%E9%80%82%E9%85%8D%E5%99%A8%E7%9A%84%E9%80%9A%E7%94%A8%E6%8E%A5%E5%8F%A3"><span class="toc-text"> 2.10 使用适配器的通用接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#211-iec-61499-%E5%AE%9E%E4%BD%93%E7%9A%84%E6%96%87%E6%9C%AC%E8%AF%AD%E6%B3%95"><span class="toc-text"> 2.11 IEC 61499 实体的文本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B-3%E9%80%892%E6%8A%95%E7%A5%A8%E7%AE%97%E6%B3%95"><span class="toc-text"> 【示例】- 3选2投票算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#212-%E6%80%BB%E7%BB%93"><span class="toc-text"> 2.12 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E5%AE%9A%E4%B9%89%E5%8A%9F%E8%83%BD%E5%9D%97%E5%92%8C%E5%AD%90%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%B1%BB%E5%9E%8B"><span class="toc-text"> 3. 定义功能块和子应用程序类型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#31-%E7%B1%BB%E5%9E%8B%E4%B8%8E%E5%AE%9E%E4%BE%8B"><span class="toc-text"> 3.1 类型与实例</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-%E4%B8%8D%E5%90%8C%E5%BD%A2%E5%BC%8F%E7%9A%84%E5%8A%9F%E8%83%BD%E5%9D%97"><span class="toc-text"> 3.2 不同形式的功能块</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-%E5%9F%BA%E6%9C%AC%E5%8A%9F%E8%83%BD%E5%9D%97%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text"> 3.3 基本功能块的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AF%B9%E5%A4%96%E6%8E%A5%E5%8F%A3%E5%A3%B0%E6%98%8E"><span class="toc-text"> 对外接口声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%85%E9%83%A8%E8%A1%8C%E4%B8%BA"><span class="toc-text"> 内部行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A7%E8%A1%8C%E6%8E%A7%E5%88%B6%E5%9B%BEecc%E5%8A%9F%E8%83%BD"><span class="toc-text"> 执行控制图（ECC）功能</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E8%AF%AD%E6%B3%95textual-syntax%E7%A4%BA%E4%BE%8B"><span class="toc-text"> 文本语法（Textual syntax）示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E5%9D%97%E5%AE%9E%E4%BE%8B%E7%9A%84%E8%A1%8C%E4%B8%BA"><span class="toc-text"> 基础功能块实例的行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="toc-text"> 算法的执行</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-%E5%A4%8D%E5%90%88%E5%8A%9F%E8%83%BD%E5%9D%97%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text"> 3.4 复合功能块的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E5%9D%97%E7%B1%BB%E5%9E%8B%E8%A7%84%E8%8C%83%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-text"> 复合块类型规范的规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8B%E4%BB%B6%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-text"> 事件连接的规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%BF%9E%E6%8E%A5%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-text"> 数据连接的规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E5%9D%97%E7%A4%BA%E4%BE%8B"><span class="toc-text"> 复合块示例</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#with-%E7%BB%93%E6%9E%84%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-text"> WITH 结构的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E5%8A%9F%E8%83%BD%E5%9D%97%E7%9A%84%E6%89%A7%E8%A1%8C"><span class="toc-text"> 复合功能块的执行</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%8D%E5%90%88%E5%8A%9F%E8%83%BD%E5%9D%97%E7%9A%84%E6%96%87%E6%9C%AC%E8%AF%AD%E6%B3%95%E7%A4%BA%E4%BE%8B"><span class="toc-text"> 复合功能块的文本语法示例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-%E5%AD%90%E5%BA%94%E7%94%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text"> 3.5 子应用的定义</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E5%BA%94%E7%94%A8%E7%B1%BB%E5%9E%8B%E8%A7%84%E8%8C%83%E7%9A%84%E8%A7%84%E5%88%99"><span class="toc-text"> 子应用类型规范的规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%90%E5%BA%94%E7%94%A8%E7%9A%84%E6%89%A7%E8%A1%8C%E8%A7%84%E5%88%99"><span class="toc-text"> 子应用的执行规则</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E5%AD%90%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B"><span class="toc-text"> 分布式子应用实例</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36-%E6%80%BB%E7%BB%93"><span class="toc-text"> 3.6 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3service-interface%E5%8A%9F%E8%83%BD%E5%9D%97"><span class="toc-text"> 4. 服务接口（Service Interface）功能块</span></a></li></ol></div></div></div></div></main><footer id="footer" style="background: #8EC3B0"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2023 By Guohao</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: 'ea138c6f176d57705144',
      clientSecret: 'c999d74b366c68c80bc3b704c716a8ff8d67af6d',
      repo: 'Dave0126.github.io',
      owner: 'Dave0126',
      admin: ['Dave0126'],
      id: '0977791134aa8ed5f5410207f933517e',
      updateCountCallback: commentCount
    },))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !true) {
  if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div></div></body></html>