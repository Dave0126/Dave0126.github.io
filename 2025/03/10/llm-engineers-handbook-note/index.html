<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>《LLM Engineers Handbook》读书笔记 | Lost N Found</title><meta name="author" content="Guohao"><meta name="copyright" content="Guohao"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="《LLM Engineer’s Handbook》本书的个人学习笔记">
<meta property="og:type" content="article">
<meta property="og:title" content="《LLM Engineers Handbook》读书笔记">
<meta property="og:url" content="https://lostnfound.top/2025/03/10/llm-engineers-handbook-note/index.html">
<meta property="og:site_name" content="Lost N Found">
<meta property="og:description" content="《LLM Engineer’s Handbook》本书的个人学习笔记">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://lostnfound.top/linear-gradient(45deg,%20#8EC3B0,%20#9ED5C5,%20#F8C4B4,%20#FF8787)">
<meta property="article:published_time" content="2025-03-10T05:04:09.000Z">
<meta property="article:modified_time" content="2025-03-13T05:06:44.807Z">
<meta property="article:author" content="Guohao">
<meta property="article:tag" content="LLM">
<meta property="article:tag" content="DeepLearning">
<meta property="article:tag" content="Engineering">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://lostnfound.top/linear-gradient(45deg,%20#8EC3B0,%20#9ED5C5,%20#F8C4B4,%20#FF8787)"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="canonical" href="https://lostnfound.top/2025/03/10/llm-engineers-handbook-note/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"limitCount":100,"languages":{"author":"作者: Guohao","link":"链接: ","source":"来源: Lost N Found","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"}},
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《LLM Engineers Handbook》读书笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-03-13 13:06:44'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.1.0"><link rel="alternate" href="/atom.xml" title="Lost N Found" type="application/atom+xml">
</head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">27</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-battery-full"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-calendar-check"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-hashtag"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user-circle"></i><span> 关于我</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/Dave0126"><i class="fa-fw fab fa-github"></i><span> Github</span></a></li><li><a class="site-page child" href="mailto:dave980126@outlook.com"><i class="fa-fw fas fa-envelope"></i><span> Mail</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background: linear-gradient(45deg, #8EC3B0, #9ED5C5, #F8C4B4, #FF8787)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Lost N Found</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-battery-full"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-calendar-check"></i><span> 时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-hashtag"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-user-circle"></i><span> 关于我</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" target="_blank" rel="noopener" href="https://github.com/Dave0126"><i class="fa-fw fab fa-github"></i><span> Github</span></a></li><li><a class="site-page child" href="mailto:dave980126@outlook.com"><i class="fa-fw fas fa-envelope"></i><span> Mail</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">《LLM Engineers Handbook》读书笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-03-10T05:04:09.000Z" title="发表于 2025-03-10 13:04:09">2025-03-10</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-03-13T05:06:44.807Z" title="更新于 2025-03-13 13:06:44">2025-03-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/LLM/">LLM</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">29.9k</span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><p>写在前面：</p>
<p>本文章是关于《LLM Engineer’s Handbook》的部分学习笔记。原书以开发一个名为 <code>LLM Twin</code> 的、模仿某人的写作风格的端到端项目，展示如何运用 LLM 工程和 MLOps ，构建一个最小可行产品以解决特定问题。其中，作者使用较多笔墨来介绍 LLM 在工程化中的开发方法论，对于原理的探讨着墨较少。所以在以原书为主线的前提下会添加部分对于原理的介绍，作为对于方法论的补充说明。碍于本人学识有限，部分叙述难免存在纰漏，请读者注意甄别。感谢所有学者、工程师的开源帮助。</p>
<p>参考资料：</p>
<ul>
<li>《LLM Engineer’s Handbook》书中示例代码：[<code>Github</code>]( <a target="_blank" rel="noopener" href="https://github.com/PacktPublishing/">https://github.com/PacktPublishing/</a> LLM-Engineers-Handbook)</li>
<li>张奇、桂韬、郑锐、黄萱菁，大语言模型理论与实践，<a target="_blank" rel="noopener" href="https://intro-llm.github.io/">https://intro-llm.github.io/</a>, 2023.</li>
</ul>
<hr>
<h1 id="零-前言"><a class="markdownIt-Anchor" href="#零-前言"></a> 零、前言</h1>
<p>大型语言模型（Large Language Model, LLM）工程领域迅速崛起，已成为人工智能和机器学习中的关键领域。随着 LLM 持续革新自然语言处理和生成技术，能够在实际场景中有效实施、优化和部署这些模型的专业人士需求呈指数级增长。LLM 工程涵盖从<u><em>数据准备</em></u>、<u><em>模型微调</em></u>到<u><em>推理优化</em></u>和<u><em>生产部署</em></u>等广泛学科，要求软件工程、机器学习专业知识和领域知识的独特融合。</p>
<p>机器学习运维（Machine Learning Operations, MLOps）在成功实施 LLM 于生产环境中起着至关重要的作用。MLOps 将 DevOps 的原则扩展至机器学习项目，专注于自动化和简化整个 ML 生命周期。对于 LLM 而言，由于其模型的复杂性和规模，MLOps 尤为重要。它解决了诸如管理大型数据集、处理模型版本控制、确保可重复性以及维持模型性能等挑战。通过融入 MLOps 实践，LLM 项目可以实现更高的效率、可靠性和可扩展性，最终促成更成功和有影响力的部署。</p>
<p>《LLM Engineer’s Handbook》是一本全面指南（以下简称“手册”），旨在将最佳实践应用于 LLM 工程领域。手册中涵盖数据工程、监督微调、模型评估、推理优化和检索增强生成（Retrieval-Augmented Generation, RAG）管道开发等主题。</p>
<p>为直观展示这些概念，手册中将开发一个名为 <code>LLM Twin</code> 的端到端项目，目标是模仿某人的写作风格和个性。该用例将展示如何运用 LLM 工程和 MLOps ，构建一个最小可行产品以解决特定问题。我们读者将了解：</p>
<ul>
<li>如何为 LLM 收集和准备数据、针对特定任务微调模型、优化推理性能以及实施RAG管道；</li>
<li>如何评估LLM性能、使模型与人类偏好对齐；</li>
<li>部署基于LLM的应用程序。</li>
</ul>
<p>本笔记与手册结构保持一致，主要分为以下几个内容：</p>
<ul>
<li><strong>第1章 理解 <code>LLM Twin</code> 的概念和架构</strong>：介绍了贯穿全手册的 <code>LLM Twin</code> 项目，作为生产级 LLM 应用的端到端示例。定义了构建可扩展机器学习系统的 FTI 架构，并将其应用于 <code>LLM Twin</code> 的用例；</li>
<li><strong>第2章 工具和安装</strong>：介绍用于构建实际 LLM 应用的 Python、MLOps 和云工具，如编排器、实验跟踪器、提示监控和 LLM 评估工具。展示了如何在本地安装和使用这些工具以进行测试和开发；</li>
<li><strong>第3章 数据工程</strong>：介绍一个数据收集管道的实现，该管道从 <a target="_blank" rel="noopener" href="https://medium.com">Medium</a>、<a target="_blank" rel="noopener" href="https://github.com">GitHub</a> 和 <a target="_blank" rel="noopener" href="https://substack.com/home-i">Substack</a> 等多个网站抓取数据，并将原始数据存储在数据仓库中。强调了在实际机器学习应用中，从动态来源收集原始数据的重要性，而非依赖静态数据集；</li>
<li><strong>第4章 RAG 特征管道</strong>：介绍了检索增强生成（Retrieval-Augmented Generation, RAG）的基本概念，如 Embeddings、基础 RAG 框架、向量数据库，以及如何优化 RAG 应用。通过使用软件最佳实践，设计并实现了 LLM Twin 的 RAG 特征管道，以应用 RAG 理论；</li>
<li><strong>第5章 监督微调（Supervised Fine-Tuning, SFT）</strong>：探讨了使用**指令（instruction）-回答（answer）**对来优化预训练语言模型以执行特定任务的过程。涵盖了创建高质量数据集、实施全量微调（full fine-tuning）、LoRA 和 QLoRA 等微调技术，并提供了在自定义数据集上微调 <a href><code>Llama 3.1 8B</code></a> 模型的实践示范；</li>
<li><strong>第6章 带偏好对齐的微调</strong>：介绍了将语言模型与人类偏好对齐的技术，重点关注直接偏好优化（Direct Preference Optimization, DPO）。涵盖了创建自定义偏好数据集、实施 DPO，并提供了使用 <code>Unsloth</code> 库对 <code>TwinLlama-3.1-8B</code> 模型进行对齐的实践示范；</li>
<li><strong>第7章 评估LLM</strong>：详细描述了评估语言模型和 LLM 系统性能的各种方法。介绍通用和特定领域的评估，讨论流行的基准测试。本章包括对 <code>TwinLlama-3.1-8B</code> 模型的多标准实践评估；</li>
<li><strong>第8章 推理优化</strong>：涵盖了关键的优化策略，如推测解码、模型并行和权重量化。将讨论如何提高推理速度、降低延迟和最小化内存使用，介绍流行的推理引擎并比较其特性；</li>
<li><strong>第9章 RAG推理管道</strong>：通过从头开始实施自查询、重排序和过滤向量搜索等方法，探索高级 RAG 技术。涵盖了设计和实现 <code>LLM Twin</code> 的 RAG 推理管道，以及类似于 <code>LangChain</code> 等流行框架的自定义检索模块；</li>
<li><strong>第10章 推理管道部署</strong>：介绍了在线、异步和批量推理等机器学习部署策略，有助于将微调后的 <code>LLM Twin</code> 模型架构并部署到AWS SageMaker，并构建 FastAPI 微服务，将 RAG 推理管道作为 RESTful API 公开；</li>
<li><strong>第11章 MLOps和LLMOps</strong>：介绍了 LLMOps 的概念，从其在 DevOps 和 MLOps 中的根源开始。本章解释了如何将 <code>LLM Twin</code> 项目部署到云端，如将机器学习管道部署到 AWS，并展示了如何使用 Docker 容器化代码和构建 CI/CD/CT 管道。还在 <code>LLM Twin</code> 的推理管道上添加了提示监控层；</li>
<li><strong>附录 MLOps原则</strong>：涵盖了用于构建可扩展、可重复和健壮的机器学习应用的六项 MLOps 原则。</li>
</ul>
<h1 id="一-理解-llm-twin-的概念和架构"><a class="markdownIt-Anchor" href="#一-理解-llm-twin-的概念和架构"></a> 一、理解 <code>LLM Twin</code> 的概念和架构</h1>
<p>手册将教我们如何构建一个 <code>LLM Twin</code>，即一个通过将特定个人的写作风格、语气和个性融入 LLM 的 AI 角色。通过这个示例，我们将经历完整的 ML 生命周期，从数据收集到部署和监控。在实现 <code>LLM Twin</code> 的过程中学到的大多数概念都可以应用于其他基于 LLM 或 ML 的应用程序。</p>
<blockquote>
<p>The best way to learn about LLMs and production machine learning (ML) is to get your hands dirty and build systems.</p>
<p>学习LLM和生产级机器学习（ML）的最佳方式是亲自动手构建系统。</p>
</blockquote>
<p>在开始实施新产品时，从工程的角度来看，我们必须在开始构建之前经过三个规划步骤：</p>
<ul>
<li>首先，了解我们试图解决的问题以及我们想要构建的内容至关重要。在我们的案例中，<code>LLM Twin</code> 究竟是什么？为什么要构建它？这一步是我们必须思考并专注于**“WHY”**的地方。</li>
<li>其次，为了反映现实世界的场景，我们将设计一个具有最小功能的产品的初级版本。在这里，我们必须清楚地定义产品所具有的核心功能。这些选择是基于时间表、资源和团队知识做出的。这是我们在构思阶段和实际实施之间架起桥梁，并最终回答以下问题：“我们要构建什么（<strong>WHAT</strong>）？”。</li>
<li>最后，我们将进行系统设计步骤，列出用于构建 LLM 系统的核心架构和设计选型。前两个步主要与产品的设计相关，而最后一个是技术性的，专注于“<strong>HOW</strong>”。</li>
</ul>
<p>这三个步骤是在构建现实世界产品时自然发生的。虽然前两个不需要太多的 ML 知识，但是这对于产品的开发而言同样至关重要。简而言之，本章涵盖以下主题：</p>
<ul>
<li>理解 <code>LLM Twin</code> 概念</li>
<li>规划 <code>LLM Twin</code> 产品的最小可行产品（Minimum Viable Product, MVP）</li>
<li>使用特征/训练/推理管道构建 ML 系统</li>
<li>设计 <code>LLM Twin</code> 的系统架构</li>
</ul>
<h2 id="什么是-llm-twin"><a class="markdownIt-Anchor" href="#什么是-llm-twin"></a> 什么是 <code>LLM Twin</code></h2>
<p><code>LLM Twin</code> 是一个将个性化的写作风格、语气融入大型语言模型（LLM）中的 AI 角色。与在整个互联网数据上训练的通用 LLM 不同，<code>LLM Twin</code> 是在个人数据上进行微调的，将这些个人数据“<em>投射（projected）</em>”到大语言模型中。</p>
<blockquote>
<p>[!NOTE]</p>
<p>这里有意使用了“<em>投射（projected）</em>”一词。正如其他投射一样，在此过程中丢失大量信息，<strong>大模型只能反映出训练数据中信息</strong>。</p>
</blockquote>
<p>如果我们用鲁迅的文学作品微调 LLM，LLM 将会模仿鲁迅的写作风格，这也被称为风格迁移。我们将利用风格迁移策略，使 LLM 模仿我们个人的风格。</p>
<p>为了将 LLM 调整为特定的风格和语气，除了微调外，我们还将利用各种高级的检索增强生成（RAG）技术，以使用我们先前的 Embedding 来调节自回归过程。我们将在后续章节中详细探讨这些内容。</p>
<blockquote>
<p>[!TIP]</p>
<p><strong>什么是嵌入 Embedding ？</strong></p>
<p>在 LLM 的开发领域中，向量 Embedding 在获取文本信息的本质方面起着关键作用。向量 Embedding 的核心是指在数学空间中将单词、句子甚至整个文档表示为密集的低维向量的过程。与依赖于稀疏表示（如one-hot编码）的传统方法不同，向量 Embeddings封装了单词之间的语义关系，并使算法能够理解它们的上下文含义。</p>
<p>通过使用词 Embeddings、句子 Embeddings 或上下文 Embedding 等技术，向量 Embeddings 提供了文本数据的紧凑而有意义的表示。例如，单词 Embeddings 将单词映射到固定长度的向量，其中具有相似含义的单词在向量空间中的位置更接近。这允许高效的语义搜索、信息检索和语言理解任务。</p>
<p>向量 Embedding 的重要性在于它能够将原始文本转换为算法可以理解和推理的数字表示。这种转换过程不仅促进了各种自然语言处理（NLP）任务，而且还作为大型语言模型的基本构建块。向量 Embeddings 使这些模型能够利用嵌入在文本数据中的丰富语义信息，使它们能够生成更连贯和上下文更合适的响应。</p>
</blockquote>
<p>我们可以想象这样一个可以对 LLM 进行微调的场景：</p>
<ul>
<li>小红书、知乎等社交平台：使 LLM 仿照我们自己的风格来编写社交媒体内容；</li>
<li>学术论文和文章：微调 LLM 以撰写正式和学术性的内容；</li>
<li>代码：微调 LLM 使其以特定的代码规范来编写代码。</li>
</ul>
<p>所有上述场景都可以归结为一个核心策略：收集个人数据集（或其中的一部分），使用不同的算法将其输入到 LLM 中。最终，LLM 将反映所收集数据的语气和风格。</p>
<h3 id="为什么不用-qwen-这些通用大模型"><a class="markdownIt-Anchor" href="#为什么不用-qwen-这些通用大模型"></a> 为什么不用 <code>Qwen</code> 这些通用大模型？</h3>
<p><code>Qwen</code> 这些通用大模型非常通用、缺乏独特表达，且往往冗长。盲目使用通用大模型可能会导致以下问题：</p>
<ul>
<li><strong>幻觉导致的错误信息</strong>：需要手动检查生成内容是否存在幻觉，或使用第三方工具进行验证，是一项繁琐且低效的任务。</li>
<li><strong>繁琐的手动提示工程</strong>：需要手动编写提示词并注入外部信息，这个过程既耗时又麻烦。此外，由于无法完全控制提示词和输入数据，在不同会话中生成一致的答案也十分困难。虽然可以通过 API 和 <code>LangChain</code> 等工具部分解决此问题，但这需要一定的编程经验。</li>
</ul>
<p>如果想要高质量且真正有价值的内容时，我们可能会花比直接写作更多的时间去调试 AI 生成的文本。</p>
<p>由此可见，构建私人的大语言模型的关键点在于：</p>
<ul>
<li>我们收集哪些数据</li>
<li>如何预处理这些数据</li>
<li>如何将数据输入 LLM</li>
<li>如何链接多个提示以获得理想结果</li>
<li>如何评估生成的内容</li>
</ul>
<h3 id="规划产品的-mvp"><a class="markdownIt-Anchor" href="#规划产品的-mvp"></a> 规划产品的 MVP</h3>
<p>既然我们已经了解了什么是 LLM Twin 以及为什么要构建它，那么我们需要明确定义产品的功能。手册中重点关注 <code>LLM Twin</code> 的第一版，即<strong>最小可行产品（Minimum Viable Product, MVP）</strong>，以遵循大多数产品的自然发展周期。</p>
<h4 id="什么是-mvp"><a class="markdownIt-Anchor" href="#什么是-mvp"></a> 什么是 MVP?</h4>
<p>MVP 指的是产品的<strong>最小可行版本</strong>，即仅包含足够功能来吸引早期用户，并在开发的初始阶段验证产品概念的可行性。通常，MVP 的目标是以最小的投入<strong>从市场中收集反馈</strong>。</p>
<p>MVP 是一种产品策略，主要有以下优势：</p>
<ul>
<li><strong>加速产品上市（Accelerated time-to-market）</strong>：快速推出产品，以获得早期用户并建立市场影响力。</li>
<li><strong>验证产品理念（Idea validation）</strong>：在全面开发产品之前，通过真实用户进行测试，以验证产品是否符合需求。</li>
<li><strong>市场调研（Market research）</strong>：深入了解目标用户的偏好，收集有价值的市场反馈。</li>
<li><strong>降低风险（Risk minimization）</strong>：减少因产品市场表现不佳而浪费的时间和资源。</li>
</ul>
<p>在 MVP 中，必须严格<strong>遵循 “V”（Viable，可行性）</strong> 的原则，即产品必须是可行的。即使产品功能最小化，它也必须提供<strong>完整的用户体验</strong>，而不是半成品。MVP 需要是一个真正可用的产品，提供流畅的使用体验，让用户愿意持续使用，并随着产品的发展而发展。</p>
<h4 id="llm-twin-的-mvp-的核心功能"><a class="markdownIt-Anchor" href="#llm-twin-的-mvp-的核心功能"></a> <code>LLM Twin</code> 的 MVP 的核心功能</h4>
<p>为了保持简单性，我们的 LLM Twin MVP 将具备以下核心功能：</p>
<ol>
<li><strong>数据收集</strong>
<ul>
<li>从 <strong>小红书、知乎、微信 和 GitHub</strong> 账户收集用户的数据。</li>
</ul>
</li>
<li><strong>LLM 训练微调</strong>
<ul>
<li>使用<strong>开源 LLM</strong>，结合收集的数据进行微调（fine-tuning）。</li>
</ul>
</li>
<li><strong>RAG（检索增强生成）</strong>
<ul>
<li>将收集的数字数据存入<strong>向量数据库（vector database）</strong>，以支持 RAG 机制。</li>
</ul>
</li>
<li><strong>社交媒体内容生成</strong>（例如小红书文章）
<ul>
<li><strong>用户输入的提示（prompts）</strong></li>
<li><strong>RAG 检索</strong>，复用并引用用户过往内容</li>
<li><strong>新内容</strong>（如文章、论文等）作为 LLM 额外的知识输入</li>
</ul>
</li>
<li><strong>简单的 Web 界面</strong>，提供交互能力：
<ul>
<li><strong>配置社交媒体链接</strong>，并触发数据收集流程</li>
<li><strong>输入提示词（prompts）或外部资源链接</strong>，让 LLM Twin 生成内容</li>
</ul>
</li>
</ol>
<h4 id="mvp-的关键挑战"><a class="markdownIt-Anchor" href="#mvp-的关键挑战"></a> MVP 的关键挑战</h4>
<p>尽管上述 MVP 可能看起来功能不多，但我们必须确保<strong>系统具备以下特性</strong>：</p>
<ul>
<li><strong>成本可控</strong>（Cost-effective）：优化计算资源，避免不必要的开销。</li>
<li><strong>可扩展</strong>（Scalable）：随着用户增长，系统仍能稳定运行。</li>
<li><strong>模块化</strong>（Modular）：方便未来扩展和优化。</li>
</ul>
<p>至此，我们已经从<strong>用户和商业角度</strong>探讨了<code>LLM Twin</code> 的价值。<strong>最后一步</strong>，我们需要<strong>从工程实现的角度</strong>进行分析，并制定开发计划，明确<strong>如何在技术层面实现这个系统</strong>。</p>
<blockquote>
<p>[!NOTE]</p>
<p>从现在开始，重点将<strong>转向 <code>LLM Twin</code> 的具体实现</strong>。即使我们专注于上述<strong>核心功能</strong>，我们仍会基于<strong>最新的 LLM 研究成果</strong>，并结合<strong>最佳的软件工程与 MLOps 实践</strong>，构建<strong>一个成本可控、可扩展的 LLM 应用</strong>。</p>
</blockquote>
<h2 id="构建具有特征训练推理流水线的-ml-系统"><a class="markdownIt-Anchor" href="#构建具有特征训练推理流水线的-ml-系统"></a> 构建具有<code>特征/训练/推理流水线</code>的 ML 系统</h2>
<p>在深入探讨 <code>LLM Twin</code> 架构的具体细节之前，我们需要先理解其核心 ML 体系结构模式——<strong>特征/训练/推理（Feature/Training/Inference , FTI）架构</strong>。本节将概述 <strong>FTI 流水线</strong> 的设计，以及它如何帮助我们构建一个结构化的 ML 应用。</p>
<h3 id="ml-系统开发的挑战"><a class="markdownIt-Anchor" href="#ml-系统开发的挑战"></a> ML 系统开发的挑战</h3>
<p>构建生产级 ML 系统不仅仅是训练一个模型。从工程角度来看，训练模型通常是最简单的一步。然而，决定正确的架构和超参数，才是让模型真正发挥作用的挑战——这更像是一个研究问题，而不是纯粹的工程问题。</p>
<p>当前，我们关注的重点是<strong>如何设计一个可用于生产的架构</strong>。<strong>即使训练出了高准确率的模型，仅仅基于静态数据集训练它，距离真正的部署仍然很遥远。</strong> 我们需要考虑以下问题：</p>
<ul>
<li><strong>数据处理</strong>：如何**摄取（ingest）、清理（clean）和验证（validate）**新的数据？</li>
<li><strong>训练 vs 推理环境</strong>：训练和推理（Inference）环境是否需要<strong>分开部署</strong>？<strong>计算资源</strong> 如何分配？</li>
<li><strong>特征存储与计算</strong>：如何在<strong>正确的环境</strong>下<strong>计算并提供</strong>模型所需的特征？</li>
<li><strong>模型部署与服务</strong>：如何<strong>高效、低成本</strong>地提供推理服务？如何<strong>版本化、追踪并共享</strong>数据集和模型？</li>
<li><strong>监控与维护</strong>：如何<strong>监控</strong> ML 基础设施和模型的表现？<strong>模型如何扩展并持续更新</strong>？</li>
<li><strong>自动化</strong>：如何<strong>自动化</strong>模型的部署和训练流程？</li>
</ul>
<blockquote>
<p>[!TIP]</p>
<p>这些问题通常由 <strong>ML 或 MLOps 工程师</strong> 负责解决，而 <strong>研究团队或数据科学团队</strong> 主要关注<strong>模型训练</strong>本身。</p>
</blockquote>
<p>Google Cloud 团队提出的 <strong>成熟 ML &amp; MLOps 系统</strong> 需要包括的组件如下：</p>
<p><img src="/2025/03/10/llm-engineers-handbook-note/screenshot_2025-03-10_15.43.53.png" alt="screenshot_2025-03-10_15.43.53"></p>
<ul>
<li><strong>ML 代码</strong>（核心模型开发）</li>
<li><strong>数据收集</strong>（Data Collection）</li>
<li><strong>数据验证</strong>（Data Verification）</li>
<li><strong>测试与调试</strong>（Testing &amp; Debugging）</li>
<li><strong>资源管理</strong>（Resource Management）</li>
<li><strong>模型分析</strong>（Model Analysis）</li>
<li><strong>流程 &amp; 元数据管理</strong>（Process &amp; Metadata Management）</li>
<li><strong>服务基础设施</strong>（Serving Infrastructure）</li>
<li><strong>监控系统</strong>（Monitoring）</li>
</ul>
<p>可见，<strong>生产化 ML 模型远远不只是写好训练代码这么简单</strong>，它涉及多个环节和工程实践。</p>
<h3 id="如何构建一个统一的-ml-系统"><a class="markdownIt-Anchor" href="#如何构建一个统一的-ml-系统"></a> 如何构建一个统一的 ML 系统？</h3>
<p><strong>关键问题</strong>：如何将所有这些组件连接成<strong>一个统一的 ML 系统</strong>？我们需要设计一个标准化的架构，使 ML 系统的搭建更加高效、可复用和可扩展。</p>
<p>在传统软件工程中，很多应用可以拆分为 <strong>数据库（DB）、业务逻辑（Business Logic）和用户界面（UI）</strong> 三大部分。尽管每个部分的实现可能<strong>非常复杂</strong>，但在<strong>高层次的架构设计</strong>上，它们仍然可以归纳为这三大模块。</p>
<p>那么，ML 应用是否也能有类似的通用架构呢？</p>
<p>我们需要先回顾一些现有方案，看看它们为什么<strong>不适合构建可扩展的 ML 系统</strong>，然后再探索更优的解决方案。</p>
<h4 id="以往解决方案的问题"><a class="markdownIt-Anchor" href="#以往解决方案的问题"></a> 以往解决方案的问题</h4>
<p><img src="/2025/03/10/llm-engineers-handbook-note/screenshot_2025-03-10_15.47.41.png" alt="screenshot_2025-03-10_15.47.41"></p>
<p>在上图中，我们可以看到大多数 ML 应用程序中常见的架构。这种架构基于<strong>单体批处理（monolithic batch）<strong>模式，将</strong>特征创建（Create Features）</strong>、**模型训练（Train Model）<strong>和</strong>推理（Make Predictions）**紧密耦合在同一个组件中。</p>
<p>采用这种方法可以快速解决 ML 领域中的一个关键问题——<strong>训练-推理偏差（training-serving skew）</strong>。</p>
<ul>
<li><strong>训练-推理偏差</strong> 发生在<strong>训练时和推理时使用的特征计算方式不同</strong>，导致模型在生产环境中的表现不如预期。</li>
<li>在这种单体架构中，训练和推理阶段的特征是用<strong>相同的代码</strong>生成的，因此<strong>避免了训练-推理偏差</strong>。</li>
</ul>
<p><strong>单体批处理架构适用于小数据集</strong>，因为：</p>
<ul>
<li>训练、推理使用相同的特征计算代码，避免了训练-推理偏差</li>
<li>通过**批处理（batch mode）**定期运行流水线</li>
<li>预测结果通常被**第三方应用（如 dashboard）**消费</li>
</ul>
<p>然而，<strong>这种架构在面对更大规模的数据时，会引发许多问题</strong>：</p>
<ul>
<li><strong>特征无法复用</strong>（既不能在系统内部复用，也不能被其他系统使用）</li>
<li><strong>扩展性差</strong>，如果数据规模增加，必须重构代码以支持 <strong>PySpark</strong> 或 <strong>Ray</strong></li>
<li><strong>性能优化困难</strong>，如果想用 <strong>C++、Java 或 Rust</strong> 重写推理模块，会变得极为复杂</li>
<li><strong>团队协作受限</strong>，由于<strong>特征计算、训练和推理紧耦合在一起</strong>，难以拆分给不同的团队</li>
<li><strong>不支持流式计算</strong>，如果需要<strong>实时训练</strong>，无法切换到流式架构</li>
</ul>
<h5 id="单体架构在实时推理系统中的问题"><a class="markdownIt-Anchor" href="#单体架构在实时推理系统中的问题"></a> 单体架构在实时推理系统中的问题</h5>
<p><img src="/2025/03/10/llm-engineers-handbook-note/screenshot_2025-03-10_15.57.35.png" alt="screenshot_2025-03-10_15.57.35"></p>
<p>在上图中，我们可以看到类似的架构被应用于<strong>实时推理系统</strong>时会带来的额外问题。</p>
<p>在实时推理中，<strong>为了生成预测，我们必须通过客户端请求传输整个状态</strong>，以便计算特征并输入模型。例如，在电影推荐系统中，理想情况下，我们<strong>只需传递 userID</strong> 给模型，模型可以基于存储的用户数据计算推荐结果。但在单体架构中，我们必须传递<strong>整个用户状态</strong>，包括姓名、年龄、性别、观影历史等，使得客户端必须理解如何访问这些状态数据。</p>
<p><strong>这种方法极易出错</strong>，因为：</p>
<ul>
<li><strong>客户端和模型服务</strong> 强耦合，客户端必须知道如何查询和构造数据</li>
<li><strong>状态传输成本高</strong>，尤其在高并发情况下，传输大量状态信息会影响性能</li>
</ul>
<p>另一个例子是 <strong>LLM + RAG（检索增强生成）</strong> 的实现：</p>
<ul>
<li>在 <strong>RAG 模型</strong> 中，我们希望能基于<strong>外部知识库</strong>增强 LLM 的推理能力。</li>
<li>如果<strong>没有向量数据库（vector DB）</strong>，我们必须在每次查询时<strong>手动附带所有文档</strong>，否则模型无法参考这些外部知识。</li>
<li>这样就导致客户端需要<strong>手动查询和管理文档</strong>，这不仅<strong>不现实</strong>，而且是<strong>一种反模式（antipattern）</strong>。</li>
</ul>
<p>客户端不应负责查询和计算特征，而应交由服务端处理。</p>
<blockquote>
<p>我们将在<strong>第 8 章和第 9 章</strong>详细介绍 <strong>RAG</strong> 这一技术。</p>
</blockquote>
<p>综上所述，我们的<strong>核心问题是如何在不依赖客户端传递完整特征的情况下进行预测</strong>。</p>
<p>在<strong>另一端的极端案例</strong>，Google Cloud提供了一种**生产就绪（production-ready）**的、自动化流水线的 <a target="_blank" rel="noopener" href="https://cloud.google.com/architecture/mlops-continuous-delivery-and-automation-pipelines-in-machine-learning?hl=zh-cn">ML 架构</a>（见下图）。</p>
<p><img src="/2025/03/10/llm-engineers-handbook-note/screenshot_2025-03-10_16.10.48.png" alt="screenshot_2025-03-10_16.10.48"></p>
<p>这种架构确实<strong>能够解决生产环境中的 ML 部署问题</strong>，但它存在以下挑战：</p>
<ul>
<li><strong>复杂度高</strong>，不够直观，非 ML 生产专家很难理解</li>
<li><strong>上手难度大</strong>，如果你没有丰富的 ML 生产部署经验，可能会被架构的复杂性劝退</li>
<li><strong>不易渐进式扩展</strong>，难以理解如何从<strong>小型系统</strong>开始并随着需求增长逐步扩展</li>
</ul>
<p>在接下来的章节，我们将介绍 <strong>特征/训练/推理（Feature/Training/Inference , FTI）架构</strong>，它是一种直观的 ML 设计，能够有效<strong>解决前述的核心问题</strong>。</p>
<h3 id="特征训练推理fti-架构"><a class="markdownIt-Anchor" href="#特征训练推理fti-架构"></a> 特征/训练/推理（FTI） 架构</h3>
<blockquote>
<p>[!TIP]</p>
<p>想了解更多关于 FTI 模式的信息，可以参考*“From MLOps to ML Systems with Feature/Training/Inference Pipelines”* by Jim Dowling, CEO and co-founder of Hopsworks：<a target="_blank" rel="noopener" href="https://www.hopsworks.ai/post/mlops-to-ml-systems-with-fti-pipelines">https://www.hopsworks.ai/post/mlops-to-ml-systems-with-fti-pipelines</a></p>
</blockquote>
<p><strong>特征/训练/推理（Feature/Training/Inference , FTI）架构</strong>提出了一个清晰直接的思维框架，任何团队或个人都可以遵循它，来完成特征计算、模型训练以及推理管道的部署。该模式表明，任何机器学习系统都可以归结为三个管道：</p>
<ul>
<li>计算特征*（Feature）*</li>
<li>训练模型*（Training）*</li>
<li>进行推理*（Inference）*</li>
</ul>
<p>这种架构强大之处在于，我们可以清晰地定义每个管道的职责和接口。最终，系统只有三个核心模块，而不是像 Google Cloud 方案中展示的那种拥有二十个模块的复杂结构，这大大简化了操作和定义的难度。下图展示了特征、训练和推理管道架构。</p>
<p><img src="/2025/03/10/llm-engineers-handbook-note/screenshot_2025-03-10_16.11.00.png" alt="screenshot_2025-03-10_16.11.00"></p>
<p><strong>FTI 架构的核心特点</strong>：</p>
<ul>
<li><strong>每个管道都是独立的组件</strong>，可以<strong>在不同进程或硬件上运行</strong>。</li>
<li><strong>每个管道可以使用不同的技术实现</strong>，甚至可以由<strong>不同的团队开发和维护</strong>。</li>
<li><strong>可扩展性强</strong>，允许团队根据实际需求对不同管道<strong>独立扩展</strong>。</li>
<li><strong>提供清晰的思维导图</strong>，帮助团队<strong>高效组织 ML 系统架构</strong>。</li>
</ul>
<h4 id="特征管道feature-pipeline"><a class="markdownIt-Anchor" href="#特征管道feature-pipeline"></a> 特征管道（Feature Pipeline）</h4>
<p><strong>作用</strong>：<br>
特征管道的主要任务是<strong>从原始数据中提取特征</strong>，并生成用于<strong>模型训练或推理的特征和标签</strong>。但这些特征不会直接传递给模型，而是**存储在特征库（Feature Store）**中。</p>
<p><strong>主要职责</strong>：</p>
<ul>
<li><strong>存储、版本管理、追踪、共享</strong> 训练和推理所需的特征。</li>
<li><strong>保持特征的状态</strong>，确保训练和推理阶段使用的特征一致，从而<strong>避免训练-推理偏差（Training-Serving Skew）</strong>。</li>
<li><strong>让训练和推理管道轻松获取数据</strong>，保证系统的<strong>稳定性和可复现性</strong>。</li>
</ul>
<h4 id="训练管道training-pipeline"><a class="markdownIt-Anchor" href="#训练管道training-pipeline"></a> 训练管道（Training Pipeline）</h4>
<p><strong>作用</strong>：<br>
训练管道的任务是**从特征库中提取特征和标签，训练模型，并将训练好的模型存储在模型仓库（Model Registry）**中。</p>
<p><strong>主要职责</strong>：</p>
<ul>
<li>
<p>训练一个或多个模型，并<strong>存储、版本管理、追踪和共享</strong> 这些模型。</p>
</li>
<li>
<p><strong>模型仓库（Model Registry）</strong> 的角色类似于<strong>特征库</strong>，但重点是管理模型，而不是特征。</p>
</li>
<li>
<p>记录元数据（Metadata Store）</p>
<p>，包括：</p>
<ul>
<li>训练使用的<strong>特征、标签及其版本</strong>，确保模型的可追溯性。</li>
<li>确保团队可以随时知道<strong>模型的训练数据</strong>，方便调试和迭代。</li>
</ul>
</li>
</ul>
<h4 id="推理管道inference-pipeline"><a class="markdownIt-Anchor" href="#推理管道inference-pipeline"></a> 推理管道（Inference Pipeline）</h4>
<p><strong>作用</strong>：<br>
推理管道的任务是<strong>使用特征库中的特征数据和模型仓库中的训练模型进行推理</strong>，并生成最终的预测结果。</p>
<p><strong>主要职责</strong>：</p>
<ul>
<li>支持批量（Batch）或实时（Real-time）推理：
<ul>
<li><strong>批量模式</strong>：预测结果存入数据库（DB）。</li>
<li><strong>实时模式</strong>：预测结果直接返回给客户端。</li>
</ul>
</li>
<li><strong>版本管理</strong>：特征、标签、模型的版本都是可追踪的，这意味着可以<strong>灵活地升级或回滚模型部署</strong>。</li>
<li>动态调整模型与特征的连接关系：
<ul>
<li>例如，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">模</mi><mi mathvariant="normal">型</mi><msub><mi>M</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">模型M_{1}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback">模</span><span class="mord cjk_fallback">型</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 可能使用<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">特</mi><mi mathvariant="normal">征</mi><msub><mi>f</mi><mn>1</mn></msub></mrow><annotation encoding="application/x-tex">特征f_1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord cjk_fallback">特</span><span class="mord cjk_fallback">征</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">特</mi><mi mathvariant="normal">征</mi><msub><mi>f</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">特征f_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord cjk_fallback">特</span><span class="mord cjk_fallback">征</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">特</mi><mi mathvariant="normal">征</mi><msub><mi>f</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">特征f_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord cjk_fallback">特</span><span class="mord cjk_fallback">征</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>，而 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">模</mi><mi mathvariant="normal">型</mi><msub><mi>M</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">模型M_{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.83333em;vertical-align:-0.15em;"></span><span class="mord cjk_fallback">模</span><span class="mord cjk_fallback">型</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10903em;">M</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10903em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 可能使用 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">特</mi><mi mathvariant="normal">征</mi><msub><mi>f</mi><mn>2</mn></msub></mrow><annotation encoding="application/x-tex">特征f_2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord cjk_fallback">特</span><span class="mord cjk_fallback">征</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span>、<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">特</mi><mi mathvariant="normal">征</mi><msub><mi>f</mi><mn>3</mn></msub></mrow><annotation encoding="application/x-tex">特征f_3</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord cjk_fallback">特</span><span class="mord cjk_fallback">征</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">特</mi><mi mathvariant="normal">征</mi><msub><mi>f</mi><mn>4</mn></msub></mrow><annotation encoding="application/x-tex">特征f_4</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord cjk_fallback">特</span><span class="mord cjk_fallback">征</span><span class="mord"><span class="mord mathdefault" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.30110799999999993em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></li>
<li>通过版本管理，我们可以<strong>快速切换或调整特征与模型的映射关系</strong>。</li>
</ul>
</li>
</ul>
<h2 id="设计-llm-twin-的系统结构"><a class="markdownIt-Anchor" href="#设计-llm-twin-的系统结构"></a> 设计 <code>LLM Twin</code> 的系统结构</h2>
<h3 id="需求分析"><a class="markdownIt-Anchor" href="#需求分析"></a> 需求分析</h3>
<p>系统需要具备以下数据处理能力：</p>
<ul>
<li><strong>数据采集</strong>：自动化并<strong>定期</strong> 从 <strong>小红书、知乎 和 GitHub</strong>（如果可行） 抓取数据。</li>
<li><strong>数据存储与标准化</strong>：统一格式化爬取的数据，并存入<strong>数据仓库（Data Warehouse）</strong>。</li>
<li><strong>数据清理</strong>：处理 <strong>噪声数据、重复数据和异常数据</strong>，确保数据质量。</li>
<li><strong>指令数据集（Instruction Dataset）构建</strong>：生成 <strong>用于微调 LLM 的训练数据集</strong>。</li>
<li><strong>数据向量化与存储</strong>：<strong>切分（Chunking）和嵌入（Embedding）</strong> 清理后的数据。<strong>存储向量化数据到向量数据库（Vector DB）</strong>，以支持 <strong>RAG</strong>。</li>
</ul>
<h4 id="训练training需求"><a class="markdownIt-Anchor" href="#训练training需求"></a> 训练（Training）需求</h4>
<ul>
<li>
<p><strong>支持多种 LLM 微调</strong>：</p>
<ul>
<li>支持 <strong>不同规模的 LLM（7B、14B、30B、70B 参数）</strong>；</li>
<li>能够基于 <strong>不同规模的指令数据集</strong> 进行微调。</li>
<li>支持不同 LLM 模型类型（如 <strong>Mistral、Llama、GPT</strong> 之间切换）。</li>
</ul>
</li>
<li>
<p><strong>实验管理</strong>：<strong>跟踪和比较</strong> 训练实验结果，优化模型效果。</p>
</li>
<li>
<p><strong>自动化训练</strong>：<strong>自动启动</strong> 训练任务，当新的 <strong>指令数据集可用</strong> 时触发训练流程。<strong>在部署前</strong> 测试潜在的 <strong>生产 LLM 候选模型</strong>，确保高质量推理能力。</p>
</li>
</ul>
<h4 id="推理inference需求"><a class="markdownIt-Anchor" href="#推理inference需求"></a> 推理（Inference）需求</h4>
<ul>
<li>
<p><strong>REST API 接口</strong>：提供 <strong>REST API</strong>，允许客户端与 <strong>LLM Twin</strong> 交互。</p>
</li>
<li>
<p><strong>实时访问向量数据库（Vector DB）</strong>：<strong>支持 RAG</strong>，确保推理时可以实时检索相关知识数据。</p>
</li>
<li>
<p><strong>多模型推理能力</strong>：<strong>支持不同规模的 LLM 进行推理</strong>，适应不同业务场景。</p>
</li>
<li>
<p><strong>自动扩展（Auto-Scaling）</strong>：<strong>根据用户请求负载自动扩展推理服务</strong>，优化计算资源分配。</p>
</li>
<li>
<p><strong>自动化部署</strong>：<strong>通过评估机制</strong>，自动部署 <strong>通过测试的 LLM</strong> 版本，减少手动干预。</p>
</li>
</ul>
<h4 id="llmops-需求"><a class="markdownIt-Anchor" href="#llmops-需求"></a> LLMOps 需求</h4>
<ul>
<li>
<p><strong>指令数据集管理</strong>：<strong>支持版本控制</strong>、<strong>数据 lineage 追踪</strong> 和 <strong>数据集复用</strong>，提高数据可管理性。</p>
</li>
<li>
<p><strong>模型管理</strong>：<strong>支持模型版本控制</strong>、<strong>模型 lineage 追踪</strong> 和 <strong>模型复用</strong>，便于模型管理和回溯。</p>
</li>
<li>
<p><strong>实验追踪</strong>：<strong>记录所有实验配置、结果和性能指标</strong>，确保可重复性和优化。</p>
</li>
<li>
<p><strong>CI/CD + 持续训练（Continuous Training）</strong>：<strong>支持 CT/CI/CD</strong>，即持续训练（CT）、持续集成（CI）和持续部署（CD）。</p>
</li>
<li>
<p><strong>提示词和系统监控</strong>：监控**提示词（Prompt）**的表现，防止偏差。<strong>系统监控</strong>，确保 LLM 服务稳定运行。</p>
</li>
</ul>
<h3 id="如何使用-fti-管道设计-llm-twin-架构"><a class="markdownIt-Anchor" href="#如何使用-fti-管道设计-llm-twin-架构"></a> 如何使用 FTI 管道设计 LLM Twin 架构</h3>
<p>我们将系统拆分为<strong>四个核心组件</strong>。除了 FTI 的三大核心管道（<strong>特征、训练、推理</strong>）外，我们还必须实现<strong>数据管道</strong>。</p>
<p>但在我们的场景下，我们的目标是<strong>在小团队中构建一个 MVP（最小可行产品）</strong>，因此：我们必须<strong>同时实现数据收集和 FTI 管道</strong>。这种 <strong>端到端开发模式</strong> 在初创公司中非常常见，因为资源有限，无法分配独立团队。工程师需要 <strong>跨多个角色</strong>，视项目进度调整工作内容。即使未来团队扩展，<strong>理解端到端 ML 系统的架构仍然至关重要</strong>，有助于协同开发与优化。</p>
<p><img src="/2025/03/10/llm-engineers-handbook-note/screenshot_2025-03-11_10.13.07.png" alt="screenshot_2025-03-11_10.13.07"></p>
<h4 id="数据收集管道data-collection-pipeline"><a class="markdownIt-Anchor" href="#数据收集管道data-collection-pipeline"></a> 数据收集管道（Data Collection Pipeline）</h4>
<p>数据收集管道的任务是<strong>爬取你的个人数据</strong>，包括：<strong>小红书</strong>、<strong>知乎</strong>（帖子、文章），<strong>GitHub</strong>（代码）</p>
<p>在架构上，该管道遵循<strong>ETL（提取-加载-转换）模式</strong>，即：</p>
<ul>
<li><strong>提取（Extract）</strong>：从社交媒体平台爬取数据；</li>
<li><strong>转换（Transform）</strong>：对数据进行标准化处理；</li>
<li><strong>加载（Load）</strong>：将数据存入<strong>数据仓库（NoSQL 数据库）</strong>。</li>
</ul>
<blockquote>
<p>[!NOTE]</p>
<p><strong>为什么使用 NoSQL 作为数据仓库？</strong></p>
<p>由于我们处理的是<strong>文本数据</strong>，它<strong>天然是非结构化的</strong>，因此 <strong>NoSQL 数据库（如 MongoDB）是最佳选择</strong>。尽管 <strong>MongoDB 不是传统的关系型数据库</strong>，但在我们的架构中，它将充当<strong>数据库的角色</strong>，因为：</p>
<ul>
<li>它存储了<strong>标准化的原始数据</strong>，这些数据由 <strong>ETL 管道收集</strong>并可以<strong>直接用于 ML 训练</strong>。</li>
<li>它适合<strong>灵活存储和查询非结构化文本数据</strong>，便于下游管道访问和处理。</li>
</ul>
</blockquote>
<p>为了更好地处理数据，我们将爬取的数据分为<strong>三类</strong>：</p>
<ul>
<li><strong>文章（Articles）</strong> → 知乎</li>
<li><strong>帖子（Posts）</strong> → 小红书</li>
<li><strong>代码（Code）</strong> → GitHub</li>
</ul>
<p>我们希望<strong>抽象化数据来源</strong>，即：在 LLM 训练或推理时，<strong>数据的来源不重要</strong>；但为了<strong>溯源和引用</strong>，我们会将**原始 URL 作为元数据（metadata）**存储。</p>
<p>从 <strong>数据处理、微调训练（Fine-tuning）和 RAG（检索增强生成）</strong> 的角度来看，<strong>知道数据类别比知道来源更重要</strong>。</p>
<ul>
<li>例如，不同数据类型的切分（chunking）策略会有所不同：
<ul>
<li><strong>帖子（Post）</strong> 和 <strong>文章（Article）</strong> 的分割方式不同。</li>
<li><strong>代码（Code）</strong> 需要额外的解析和上下文理解。</li>
</ul>
</li>
</ul>
<p>按<strong>类别</strong>（category）而非来源（source）组织数据，能提高系统的扩展性：</p>
<ul>
<li>例如： 小红书的数据可以直接纳入<strong>Posts 类别</strong>，无须改动处理逻辑；而<strong>GitLab</strong> 的代码数据可以无缝集成到 <strong>Code 类别</strong>。</li>
</ul>
<h4 id="特征管道feature-pipeline-2"><a class="markdownIt-Anchor" href="#特征管道feature-pipeline-2"></a> 特征管道（Feature Pipeline）</h4>
<p>特征管道的核心作用是<strong>从数据仓库获取原始数据</strong>（文章、帖子、代码），<strong>进行处理后存入特征存储（Feature Store）</strong>。<strong>FTI 设计模式的核心特点在此体现</strong>，但 LLM Twin 的特征管道有一些<strong>自定义特性</strong>：</p>
<ul>
<li>针对三种数据类型（文章、帖子、代码）分别进行不同的处理</li>
<li>包含三大核心步骤（<strong>清洗、切分、嵌入</strong>），用于微调 LLM 和 RAG（检索增强生成）</li>
<li>创建两种数据快照：
<ul>
<li><strong>清洗后数据</strong>（用于 LLM 微调）</li>
<li><strong>嵌入（Embedding）后数据</strong>（用于 RAG）：使用逻辑特征存储（Logical Feature Store），而非传统的专用特征存储。</li>
</ul>
</li>
</ul>
<p><strong>逻辑特征存储：向量数据库（Vector DB）</strong></p>
<p>在 RAG 系统中，向量数据库（Vector DB）是关键基础设施。向量数据库本质上是 <strong>NoSQL 数据库</strong>，可以按 <strong>ID 和集合名称（collection name）</strong> 访问数据点（datapoints）。我们可以<strong>查询 Vector DB 中的新数据</strong>，而不需要<strong>执行向量搜索（Vector Search）</strong>。处理后的数据会被封装为<strong>版本化、可追踪、可共享的处理后的数据（artifact）</strong>（关于 artifact 的细节将在第 2 章讨论）。</p>
<blockquote>
<p>[!TIP]</p>
<p>What is an <strong>artifact</strong> in computer science?</p>
<p>To put it simply, an artifact is a by-product of software development. It’s anything that is created so a piece of software can be developed. This might include things like data models, diagrams, setup scripts — the list goes on.</p>
<p>（简单来说，Artifact 指的是一种软件开发的副产品。它指的是任何创建出来用以开发一套软件的一类东西，这其中也许包含了数据模型，图表，启动脚本等等。）</p>
</blockquote>
<p>系统的其余部分将如何访问逻辑特征存储？**训练管道（Training Pipeline）**将指令数据集（Instruction Datasets）视为 artifact。<strong>推理管道（Inference Pipeline）</strong> 通过 <strong>向量搜索（Vector Search）</strong> 查询 <strong>Vector DB</strong> 以获取额外上下文信息。</p>
<p>对于我们的用例 <code>LLM Twin</code>，这已经足够了，因为：指令数据集（artifact）非常适合用于离线训练，而向量数据库是为在线访问而构建的，这是我们进行推理所需要的。</p>
<p>不过，在后续章节中，我们将解释如何**清理（cleaned）、分块（chunked）和嵌入（embedded）**这三个数据类别（文章、帖子和代码）。</p>
<h4 id="训练管道training-pipeline-2"><a class="markdownIt-Anchor" href="#训练管道training-pipeline-2"></a> 训练管道（Training Pipeline）</h4>
<p>训练管道的核心职责是 <strong>从特征存储（Feature Store）获取指令数据集（Instruct Dataset），微调 LLM，并将训练好的 LLM 权重存入模型注册表（Model Registry）</strong>。更具体地说：</p>
<ol>
<li>触发训练：当逻辑特征存储中有新的指令数据集（artifact）可用时，我们将触发训练管道，使用工件并微调 LLM。</li>
<li>超参数优化：
<ul>
<li>在初始阶段，数据科学团队负责这一步。他们通过自动或手动进行多次实验，以找到最适合的模型和超参数。</li>
<li>为了比较和挑选最佳超参数集，记录所有有价值的东西，并在实验之间进行比较。</li>
<li>最终，他们将挑选最佳超参数和微调后的 LLM，并将其作为 LLM 生产候选方案提出。然后将提议的 LLM 存储在模型注册表中。实验阶段结束后，我们存储并重复使用找到的最佳超参数。</li>
</ul>
</li>
<li>如今，我们可以完全自动化训练过程，即持续训练（Continuous Training, CT）。我们的模块化设计使我们能够快速利用 ML 编排器来安排和触发不同的系统部分。例如，我们可以安排数据收集管道每周抓取数据。然后，当数据仓库中有新数据可用时，我们可以触发特征管道，当有新的指令数据集可用时，我们可以触发训练管道。</li>
</ol>
<p>在将新模型推向生产之前，根据更严格的测试集对其进行评估至关重要，以确保最新候选模型比当前生产模型更好。如果此步骤通过，模型最终将被标记为已接受并部署到生产推理管道。即使在完全自动化的 ML 系统中，也建议在接受新的生产模型之前进行手动步骤。因此，在此阶段，专家会查看测试组件生成的报告。如果一切看起来都很好，它就会批准该模型，自动化可以继续。</p>
<p><strong>关键技术问题</strong></p>
<ul>
<li>如何设计一个 LLM 无关的训练管道？</li>
<li>应该使用哪些微调技术？</li>
<li>如何扩展微调算法，使其适用于不同规模的 LLM 和数据集？</li>
<li>如何从多个实验中选取最优 LLM 作为生产候选？</li>
<li>如何测试 LLM，以决定是否推送到生产环境？</li>
</ul>
<p>在后面的章节中，我们将一一介绍解决方案。</p>
<h4 id="推理管道inference-pipeline-2"><a class="markdownIt-Anchor" href="#推理管道inference-pipeline-2"></a> 推理管道（Inference Pipeline）</h4>
<p>推理管道是 <strong>LLM 系统的最后一个核心组件</strong>，负责处理用户查询并返回答案。它连接 <strong>模型注册表（Model Registry）</strong> 和 <strong>逻辑特征存储（Logical Feature Store）</strong>，用于加载微调后的 LLM 并执行 RAG（检索增强生成，Retrieval-Augmented Generation）。</p>
<p><strong>推理流程</strong></p>
<ol>
<li><strong>加载模型</strong>：从模型注册表加载已微调的 LLM；从逻辑特征存储访问向量数据库（Vector DB），用于 RAG 查询。</li>
<li><strong>接收客户端请求</strong>：通过 <strong>REST API</strong> 接收用户查询；解析查询并生成 RAG 任务。</li>
<li><strong>执行 RAG 以增强 LLM 生成能力</strong>：使用 <strong>向量数据库进行检索（Vector Search）</strong>，找到相关外部信息；结合 LLM 进行答案生成，返回最终响应。</li>
<li><strong>监控与分析</strong>：所有用户查询、RAG 处理的增强提示（Enriched Prompts）和生成结果，都会发送至<strong>提示监控系统（Prompt Monitoring System）</strong>。监控系统 <strong>分析、调试</strong> 模型输出，优化 LLM 行为。可根据 <strong>特定需求</strong> 触发警报，执行手动或自动调整。</li>
</ol>
<h3 id="fti-设计与-llm-twin-架构的最终思考"><a class="markdownIt-Anchor" href="#fti-设计与-llm-twin-架构的最终思考"></a> FTI 设计与 <code>LLM Twin</code> 架构的最终思考</h3>
<p>FTI（Feature-Training-Inference）模式 <strong>并不需要严格遵循</strong>，它的核心作用是<strong>帮助清晰地设计 ML（机器学习）系统</strong>。例如，我们的系统并没有使用传统的特征存储（Feature Store），而是选择了 <strong>基于向量数据库（Vector DB）和指令数据集（Artifacts）</strong> 的<strong>逻辑特征存储（Logical Feature Store）</strong>，因为这样更简单且成本更低。重点是提供一个<strong>可版本化（Versioned）且可复用（Reusable）</strong> 的训练数据集，而不是形式上的标准化存储。</p>
<p><strong>计算资源需求及可扩展性</strong></p>
<ul>
<li><strong>数据收集管道 &amp; 特征管道</strong>：
<ul>
<li>主要依赖 <strong>CPU 计算</strong>，对计算资源需求较低。</li>
<li>基于 <strong>CPU &amp; RAM 负载</strong> <strong>水平扩展（Horizontal Scaling）</strong></li>
</ul>
</li>
<li><strong>训练管道</strong>：
<ul>
<li>需要 <strong>强大的 GPU 计算能力</strong> 来加载和微调 LLM。</li>
<li>通过 <strong>增加 GPU 资源</strong> <strong>垂直扩展（Vertical Scaling）</strong></li>
</ul>
</li>
<li><strong>推理管道</strong>：
<ul>
<li>计算需求介于数据管道和训练管道之间，需要 <strong>较强计算能力</strong> 以确保低延迟。</li>
<li>基于 <strong>客户端请求数量</strong> <strong>水平扩展（Horizontal Scaling）</strong>。</li>
</ul>
</li>
</ul>
<p>推理管道直接面向用户，因此<strong>必须严格测试</strong>，确保<strong>延迟符合预期</strong>，从而提供良好的用户体验。FTI 设计使得计算资源的分配变得灵活，我们可以为不同的组件选择最合适的计算架构。</p>
<h2 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h2>
<ol>
<li>Dowling, J. (2024a, July 11). <em>From MLOps to ML Systems with Feature/Training/Inference Pipelines</em>. <em>Hopsworks</em>. <a target="_blank" rel="noopener" href="https://www.hopsworks.ai/post/mlops-to-ml-systems-with-fti-pipelines">https://www.hopsworks.ai/post/mlops-to-ml-systems-with-fti-pipelines</a></li>
<li>Dowling, J. (2024b, August 5). <em>Modularity and Composability for AI Systems with AI Pipelines and Shared Storage</em>. <em>Hopsworks</em>. <a target="_blank" rel="noopener" href="https://www.hopsworks.ai/post/modularity-and-composability-for-ai-systems-with-ai-pipelines-and-shared-storage">https://www.hopsworks.ai/post/modularity-and-composability-for-ai-systems-with-ai-pipelines-and-shared-storage</a></li>
<li>Joseph, M. (2024, August 23). <em>The Taxonomy for Data Transformations in AI Systems</em>. <em>Hop- sworks</em>. <a target="_blank" rel="noopener" href="https://www.hopsworks.ai/post/a-taxonomy-for-data-transformations-in-ai-systems">https://www.hopsworks.ai/post/a-taxonomy-for-data-transformations-in-ai-systems</a></li>
<li><em>MLOps: Continuous delivery and automation pipelines in machine learning</em>. (2024, August 28). Google Cloud. <a target="_blank" rel="noopener" href="https://cloud.google.com/architecture/mlops-continuous-delivery-and-automation-pipelines-in-machine-learning">https://cloud.google.com/architecture/mlops-continuous-delivery-and-automation-pipelines-in-machine-learning</a></li>
<li>Qwak. (2024a, June 2). <em>CI/CD for Machine Learning in 2024: Best Practices to build, test, and Deploy</em> | Infer. <em>Medium</em>. <a target="_blank" rel="noopener" href="https://medium.com/infer-qwak/ci-cd-for-machine-learning-in-2024-best-practices-to-build-test-and-deploy-c4ad869824d2">https://medium.com/infer-qwak/ci-cd-for-machine-learning-in-2024-best-practices-to-build-test-and-deploy-c4ad869824d2</a></li>
<li>Qwak. (2024b, July 23). <em>5 Best Open Source Tools to build End-to-End MLOPs Pipeline</em> in 2024. <em>Medium</em>. <a target="_blank" rel="noopener" href="https://medium.com/infer-qwak/building-an-end-to-end-mlops-pipeline-with-open-source-tools-d8bacbf4184f">https://medium.com/infer-qwak/building-an-end-to-end-mlops-pipeline-with-open-source-tools-d8bacbf4184f</a></li>
<li>Salama, K., Kazmierczak, J., &amp; Schut, D. (2021). <em>Practitioners guide to MLOPs: A framework for continuous delivery and automation of machine learning</em> (1st ed.) [PDF]. Google Cloud. <a target="_blank" rel="noopener" href="https://services.google.com/fh/files/misc/practitioners_guide_to_mlops_whitepaper.pdf">https://services.google.com/fh/files/misc/practitioners_guide_to_mlops_whitepaper.pdf</a></li>
</ol>
<h1 id="二-工具链与安装"><a class="markdownIt-Anchor" href="#二-工具链与安装"></a> 二、工具链与安装</h1>
<blockquote>
<p>[!CAUTION]</p>
<p>在手册中的对应章节介绍了使用的所有<strong>核心工具</strong>，特别是 <strong>LLM Twin 项目</strong> 的实现和部署所需的工具。因为个人偏好不同、对于工具链的选择亦有不同，所以在这里不做详细介绍，只会简要介绍手册作者推荐的工具链。</p>
<p>如果你<strong>熟悉这些工具</strong>，可以<strong>直接跳过</strong>本章。</p>
</blockquote>
<p>在本章，我们不会深入讲解 LLM、RAG、MLOps 或 LLMOps 的概念，而是快速概览我们的技术栈和前置要求，避免后续章节重复讲解工具安装和选择原因。从 <strong>第 3 章开始</strong>，我们将正式进入 <code>LLM Twin</code> 的应用场景，并<strong>实现一个 ETL 数据收集流程</strong>，用于从互联网爬取数据。</p>
<p><strong>本章内容概览</strong></p>
<ul>
<li><strong>Python 生态工具</strong>：
<ul>
<li>如何管理多个 Python 版本</li>
<li>创建虚拟环境</li>
<li>安装固定版本的依赖项</li>
<li>如何在本地安装 <code>LLM-Engineers-Handbook</code> 代码库（如果你想尝试代码，地址如下）：<a target="_blank" rel="noopener" href="https://github.com/PacktPublishing/LLM-Engineers-Handbook">GitHub Repo</a></li>
</ul>
</li>
<li><strong>MLOps &amp; LLMOps 工具链</strong>：
<ul>
<li>介绍<strong>通用 MLOps 工具</strong>（如模型注册表）</li>
<li>深入了解<strong>LLM 相关工具</strong>（如 LLM 评估和 Prompt 监控工具）</li>
<li>使用 <strong>ZenML</strong> 进行 ML 管道管理（ML 与 MLOps 的桥梁）</li>
</ul>
</li>
<li><strong>数据库管理</strong>：
<ul>
<li>介绍 <strong>NoSQL 和向量数据库</strong> 的使用</li>
<li>如何使用 <strong>Docker</strong> 在本地运行所有组件</li>
</ul>
</li>
<li><strong>云端环境准备（AWS）</strong>：
<ul>
<li>创建 AWS 账户并获取访问密钥</li>
<li>安装 &amp; 配置 <strong>AWS CLI</strong>，以便程序化管理云资源</li>
<li>了解 <strong>SageMaker</strong> 及其在开源 LLM 训练和部署中的作用</li>
</ul>
</li>
</ul>
<h2 id="python-生态工具链安装"><a class="markdownIt-Anchor" href="#python-生态工具链安装"></a> Python 生态工具链安装</h2>
<p>任何 Python 项目都需要三个基本工具：<strong><code>python</code> 解释器</strong>、<strong>依赖项管理</strong>和<strong>任务执行工具</strong>。Python 解释器会按预期执行您的 Python 项目。手册中的所有代码都使用 <code>python 3.11.8</code> 进行了测试。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python --version</span><br><span class="line"><span class="comment"># Python 3.11.8</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>[!TIP]</p>
<p>我们可以从此处下载 <code>python 解释器</code>：<a target="_blank" rel="noopener" href="https://www.python.org/downloads/"><code>python.org</code></a></p>
</blockquote>
<p>手册中推荐使用 <strong><code>poetry</code> 工具</strong>来管理 <code>python</code>的依赖和虚拟环境，<code>poethepoet</code> 是 <code>Poetry</code> 插件，用于<strong>管理 CLI 任务</strong>，替代 <code>Makefile</code>、<code>shell</code> 脚本等；当然也可以使用其他的工具的组合替代，比如 <code>conda(mini-conda)</code> 和 <code>pip</code>。</p>
<ul>
<li><code>poetry</code> 官网：<a target="_blank" rel="noopener" href="https://python-poetry.org/docs/">https://python-poetry.org/docs/</a></li>
<li><code>mini-conda</code> 官网：<a target="_blank" rel="noopener" href="https://www.anaconda.com/docs/getting-started/miniconda/main">https://www.anaconda.com/docs/getting-started/miniconda/main</a></li>
</ul>
<h2 id="mlops-llmops-工具概览"><a class="markdownIt-Anchor" href="#mlops-llmops-工具概览"></a> MLOps &amp; LLMOps 工具概览</h2>
<p>本节简要介绍 <strong>MLOps</strong>（机器学习运维）和 <strong>LLMOps</strong>（大模型运维）工具，以及它们在 <code>LLM Twin</code> 项目中的作用。理论部分将在第 11 章深入讲解，而手册主要通过<strong>实战</strong>来展示这些工具的使用方式。</p>
<h3 id="hugging-face模型注册库model-registry"><a class="markdownIt-Anchor" href="#hugging-face模型注册库model-registry"></a> Hugging Face：模型注册库（Model Registry）</h3>
<p><strong>模型注册库</strong> 是一个 <strong>集中式存储</strong>，用于管理 <strong>ML 模型</strong> 的<strong>版本、元数据和性能指标</strong>。它在 MLOps 中起到关键作用：</p>
<ul>
<li>版本控制（Versioning）</li>
<li>模型共享（Sharing）</li>
<li>模型可追溯性（Traceability）</li>
<li>集成 CI/CD 流水线（Continuous Deployment）</li>
</ul>
<p>以下是一些常见的模型库：</p>
<ul>
<li><strong>Hugging Face Model Hub</strong>
<ul>
<li>社区丰富，但中国大陆境内无法直接访问 ❌</li>
<li><strong>适用于</strong>：开源社区、NLP、大模型（LLMs）</li>
<li><strong>官网</strong>：<a target="_blank" rel="noopener" href="https://huggingface.co">https://huggingface.co</a></li>
<li><strong>特点</strong>：
<ol>
<li><strong>大模型（LLM）生态支持</strong>，可存储 Transformer、Diffusion 等 AI 模型。</li>
<li>提供 <strong>可视化 UI</strong>，可管理模型版本、推理 demo（Spaces）。</li>
<li>易于与 <strong>PyTorch、TensorFlow、JAX</strong> 等框架集成。</li>
<li>适用于 <strong>团队协作</strong> 和 <strong>社区共享</strong>，支持 <strong>私有模型库</strong>。</li>
</ol>
</li>
</ul>
</li>
<li><strong>AWS SageMaker Model Registry</strong>
<ul>
<li><strong>适用于：</strong> 企业级云端 MLOps，<strong>企业、金融、医疗</strong>等对安全性要求高的 MLOps 场景。</li>
<li><strong>官网：</strong> <a target="_blank" rel="noopener" href="https://aws.amazon.com/sagemaker/">aws.amazon.com/sagemaker/</a></li>
<li><strong>特点：</strong>
<ol>
<li>与 <strong>AWS SageMaker</strong> 生态完美结合，支持 <strong>训练-注册-部署-监控</strong> 整套流程。</li>
<li>提供 <strong>自动化 CI/CD</strong>，模型更新后可自动部署。</li>
<li><strong>高安全性</strong>，支持 <strong>IAM 权限管理</strong>，适用于企业级 ML 部署。</li>
</ol>
</li>
</ul>
</li>
<li><strong>ModelScope</strong>
<ul>
<li>阿里云推出的开源 AI 模型平台</li>
<li><strong>适用于</strong>：适用于 <strong>大模型（LLM）、计算机视觉（CV）、自然语言处理（NLP）</strong> 等 AI 任务</li>
<li><strong>官网</strong>：<a target="_blank" rel="noopener" href="https://modelscope.cn/">https://modelscope.cn/</a></li>
<li><strong>特点</strong>：
<ol>
<li>支持 1,000+ 预训练模型，包括大语言模型（LLM）、计算机视觉（CV）、语音处理（Speech）、多模态（Multimodal）等</li>
<li>一键调用 AI 工作流（Pipelines），快速搭建 AI 任务</li>
<li>免费在线体验，支持<strong>模型下载、本地部署、API 调用</strong></li>
</ol>
</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th><strong>对比项</strong></th>
<th><strong>魔搭 ModelScope</strong></th>
<th><strong>Hugging Face Model Hub</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>适用地区</strong></td>
<td>✅ <strong>中国大陆境内可用</strong></td>
<td>🚫 <strong>需科学上网</strong></td>
</tr>
<tr>
<td><strong>模型数量</strong></td>
<td>⭐ 1,000+</td>
<td>⭐ 10,000+</td>
</tr>
<tr>
<td><strong>大模型支持</strong></td>
<td>✅ 通义千问、ChatGLM、Qwen</td>
<td>✅ LLaMA、GPT-3、Falcon</td>
</tr>
<tr>
<td><strong>微调（Fine-tuning）</strong></td>
<td>✅ LoRA, QLoRA, P-Tuning</td>
<td>✅ LoRA, PEFT, DPO, Unsloth</td>
</tr>
<tr>
<td><strong>推理服务（API）</strong></td>
<td>✅ 免费调用</td>
<td>✅ 需付费</td>
</tr>
<tr>
<td><strong>工作流（Pipelines）</strong></td>
<td>✅ 一键执行</td>
<td>🚫 需手写代码，可与 <code>LLMOps</code> 集成</td>
</tr>
<tr>
<td><strong>私有化部署</strong></td>
<td>✅ 企业可自建</td>
<td>✅ 需自建服务器</td>
</tr>
</tbody>
</table>
<blockquote>
<p>[!NOTE]</p>
<p>手册中使用的 Hugging Face 模型：</p>
<ul>
<li><code>TwinLlama 3.1-8B</code>（微调后）<a target="_blank" rel="noopener" href="https://huggingface.co/mlabonne/TwinLlama-3.1-8B">https://huggingface.co/mlabonne/TwinLlama-3.1-8B</a></li>
<li><code>TwinLlama 3.1-8B-DPO</code>（偏好对齐后）<a target="_blank" rel="noopener" href="https://huggingface.co/mlabonne/TwinLlama-3.1-8B-DPO">https://huggingface.co/mlabonne/TwinLlama-3.1-8B-DPO</a></li>
</ul>
</blockquote>
<h3 id="zenmlmlops-工作流编排器"><a class="markdownIt-Anchor" href="#zenmlmlops-工作流编排器"></a> ZenML：MLOps 工作流编排器</h3>
<blockquote>
<p>[!NOTE]</p>
<p>TODO</p>
</blockquote>
<h3 id="cometml可视化实验跟踪"><a class="markdownIt-Anchor" href="#cometml可视化实验跟踪"></a> CometML：可视化实验跟踪</h3>
<blockquote>
<p>[!NOTE]</p>
<p>TODO</p>
</blockquote>
<h3 id="opik评估-测试和监控大型语言模型"><a class="markdownIt-Anchor" href="#opik评估-测试和监控大型语言模型"></a> Opik：评估、测试和监控大型语言模型</h3>
<blockquote>
<p>[!NOTE]</p>
<p>TODO</p>
</blockquote>
<h2 id="非结构化数据库与向量数据库"><a class="markdownIt-Anchor" href="#非结构化数据库与向量数据库"></a> 非结构化数据库与向量数据库</h2>
<h3 id="mongodbnosql"><a class="markdownIt-Anchor" href="#mongodbnosql"></a> MongoDB：NoSQL</h3>
<blockquote>
<p>[!NOTE]</p>
<p>TODO</p>
</blockquote>
<h3 id="qdrant向量数据库"><a class="markdownIt-Anchor" href="#qdrant向量数据库"></a> Qdrant：向量数据库</h3>
<blockquote>
<p>[!NOTE]</p>
<p>TODO</p>
</blockquote>
<h2 id="云端环境准备aws"><a class="markdownIt-Anchor" href="#云端环境准备aws"></a> 云端环境准备（AWS）</h2>
<blockquote>
<p>[!NOTE]</p>
<p>TODO</p>
</blockquote>
<h1 id="三-数据工程"><a class="markdownIt-Anchor" href="#三-数据工程"></a> 三、数据工程</h1>
<p>本章将深入探讨 <code>LLM Twin</code> 项目，学习如何设计和实现数据收集流水线，以获取用于 LLM 任务（如微调或推理）的原始数据。由于本书并非专门介绍数据工程，因此本章内容将保持精简，仅关注收集必要原始数据的关键部分。从第 4 章开始，我们将重点讨论 <strong>LLM 和生成式 AI</strong>，深入研究其理论和具体实现细节。</p>
<p>在处理项目或研究时，我们通常会使用一个<strong>静态数据集</strong>。但在 <code>LLM Twin</code> 项目中，我们希望模拟真实世界的场景，在其中<strong>主动收集和整理数据</strong>。因此，构建<strong>数据流水线</strong>将帮助我们了解端到端机器学习项目的工作方式。本章将讲解如何设计和实现 <strong>ETL（提取、转换、加载）流水线</strong>，从 社交平台爬取数据，并将其存储到 <strong>MongoDB 数据库</strong>。我们将介绍各种爬取方法，标准化数据，并将其加载到数据仓库中。</p>
<p>本章的主要内容包括：</p>
<ol>
<li><strong>设计数据收集流水线</strong>
<ul>
<li>介绍 <strong>LLM Twin</strong> 的数据收集架构</li>
<li>解析 <strong>ETL</strong> 流水线的设计</li>
</ul>
</li>
<li><strong>实现数据收集流水线</strong>
<ul>
<li>使用 <strong>ZenML</strong> 作为流程编排工具</li>
<li>构建爬虫，并实现 <strong>调度层</strong>（根据 URL 域名实例化对应爬虫类）</li>
<li>按最佳软件开发实践，开发每个爬虫模块</li>
</ul>
</li>
<li><strong>数据仓库管理</strong>
<ul>
<li>在 <strong>MongoDB</strong> 之上构建数据层，统一管理文档结构</li>
<li>查询并交互数据</li>
</ul>
</li>
</ol>
<p>最后，我们将学习如何使用 <strong>ZenML 运行数据收集流水线</strong>，并<strong>查询 MongoDB 中的数据</strong>。</p>
<h2 id="设计数据收集管道"><a class="markdownIt-Anchor" href="#设计数据收集管道"></a> 设计数据收集管道</h2>
<p>在深入实施之前，我们必须了解 <code>LLM Twin</code> 的数据收集 ETL 架构，如下图所示。我们需要探究从哪些平台抓取数据，以及如何设计数据结构和流程。但是，第一步是了解我们的数据收集管道如何映射到 ETL 流程。</p>
<p><img src="/2025/03/10/llm-engineers-handbook-note/screenshot_2025-03-11_15.25.00.png" alt="screenshot_2025-03-11_15.25.00"></p>
<p>ETL 管道涉及三个基本步骤：</p>
<ol>
<li>我们从各种来源<strong>提取数据</strong>。我们将从内容平台抓取数据以收集原始数据。</li>
<li>我们通过<strong>清理和标准化这些数据</strong>，将其转换为适合存储和分析的一致格式。</li>
<li>我们将转换后的数据<strong>加载到数据仓库</strong>或数据库中。</li>
</ol>
<p>对于我们的项目，我们使用 MongoDB 作为我们的 NoSQL 数据仓库。虽然这不是标准方法，但我们很快就会解释这种选择背后的原因。<br>
我们想要设计一个 ETL 管道，输入一个用户和一个链接列表作为输入。之后，它会单独抓取每个链接，标准化收集到的内容，并将其保存在 MongoDB 数据仓库中该特定作者下。</p>
<p><strong>数据收集流水线的输入和输出</strong></p>
<ul>
<li><strong>输入</strong>：用户（作者）及其提供的一组链接。</li>
<li><strong>输出</strong>：存储在 <strong>MongoDB</strong> 数据仓库中的原始文档列表。</li>
</ul>
<blockquote>
<p>[!NOTE]</p>
<p>我们将交替使用<strong>用户</strong>和<strong>作者</strong>，因为在 ETL 管道的大多数情况下，用户是提取内容的作者。但是，在数据仓库中，我们只有一个用户集合。</p>
</blockquote>
<p><img src="/2025/03/10/llm-engineers-handbook-note/screenshot_2025-03-11_15.38.12.png" alt="screenshot_2025-03-11_15.38.12">ETL 管道将检测每个链接的域名，并根据该域调用专门的爬虫。我们为三个不同的数据类别实现了四个不同的爬虫，如上图所示。首先，我们收集的所有文档都可以归结为文章、存储库（或代码)和帖子。数据来自哪里并不重要。我们主要对文档的格式感兴趣。在大多数情况下，我们必须以不同的方式处理这些数据类别。因此，我们为每个实体创建了一个不同的域实体，每个实体在 MongoDB 中都有自己的类和集合。当我们将源 URL 保存在文档的元数据中时，我们仍然会知道它的来源，并可以在 GenAI 用例中引用它。</p>
<table>
<thead>
<tr>
<th>爬虫类型</th>
<th>目标数据源</th>
<th>输出文档类型</th>
<th>主要步骤</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Medium 爬虫</strong></td>
<td>Medium 文章</td>
<td>文章（Article）</td>
<td>登录 Medium → 爬取 HTML → 解析并清理文本 → 存入数据库</td>
</tr>
<tr>
<td><strong>通用文章爬虫</strong></td>
<td>Substack / 个人博客等</td>
<td>文章（Article）</td>
<td>爬取 HTML → 解析并清理文本 → 存入数据库</td>
</tr>
<tr>
<td><strong>GitHub 爬虫</strong></td>
<td>GitHub 仓库</td>
<td>代码仓库（Repository）</td>
<td>克隆代码仓库 → 解析文件树 → 处理代码文件 → 存入数据库</td>
</tr>
<tr>
<td><strong>LinkedIn 爬虫</strong></td>
<td>LinkedIn 个人动态</td>
<td>帖子（Post）</td>
<td>登录 LinkedIn → 爬取用户动态 → 解析 HTML → 存入数据库</td>
</tr>
</tbody>
</table>
<p>在下一节中，我们将详细研究每个爬虫的实现。现在，请注意，每个爬虫都以特定方式访问特定平台或站点并从中提取 HTML。之后，所有爬虫都会解析 HTML，从中提取文本，并对其进行清理和规范化，以便可以将其存储在同一个接口下的数据仓库中。</p>
<p>通过将所有收集的数据减少到三种数据类别，<strong>文章（Article）</strong>、<strong>代码仓库（Repository）<strong>和</strong>帖子（Post）</strong>，而不是为每个新数据源创建新的数据类别，我们可以轻松地将此架构扩展到多个数据源，而无需付出太多重复适配工作。例如，如果我们想开始从 X 收集数据，我们只需要实现一个输出帖子文档的新爬虫，仅此而已。其余代码将保持不变。否则，如果我们在类和文档结构中引入源维度，我们将不得不向所有下游层添加代码以支持任何新数据源。例如，我们必须为每个新源实现一个新的文档类，并调整功能管道以支持它。</p>
<p>对于我们的概念验证，抓取几百个文档就足够了，但如果我们想将其扩展到实际产品，我们可能需要更多数据源来抓取。LLM 需要大量数据，通常需要数千个文档才能获得理想的结果，而不仅仅是几百个文档。但在许多项目中，实现一个不是最准确的端到端项目版本并在以后对其进行迭代是一种很好的策略。因此，通过使用这种架构，可以在未来的迭代中轻松添加更多数据源以收集更大的数据集。下一章将介绍有关 LLM 微调和数据集大小的更多信息。</p>
<p>ETL 过程如何连接到特征管道？特征管道从 MongoDB 数据仓库中提取原始数据，进一步清理，将其处理为特征，并将其存储在 Qdrant 向量数据库中，以使 LLM 训练和推理管道可以访问它。第 4 章提供了有关特征管道的更多信息。ETL 过程独立于特征管道。这两个管道严格通过 MongoDB 数据仓库相互通信。因此，数据收集管道可以为 MongoDB 写入数据，而功能管道可以独立地按照不同的时间表从中读取数据。</p>
<p><strong>为什么我们使用 MongoDB 作为数据仓库？</strong></p>
<ul>
<li><strong>适用于小规模数据</strong>：本项目的文档量较小，MongoDB 能够很好地处理。</li>
<li><strong>适合非结构化文本</strong>：爬取的数据主要是<strong>非结构化文本</strong>，MongoDB 不强制模式（Schema），使开发更灵活。</li>
<li><strong>易用性</strong>：MongoDB 提供直观的 <strong>Python SDK</strong>，官方提供 <strong>Docker 镜像</strong> 和 <strong>云端免费层</strong>，适合本项目的 PoC（概念验证）。</li>
<li><strong>未来可扩展性</strong>：如果数据量增大（如达到百万级别），可以切换到 <strong>Snowflake</strong> 或 <strong>BigQuery</strong> 这样的专用数据仓库。</li>
</ul>
<h2 id="实现-llm-twin-的数据收集流水线"><a class="markdownIt-Anchor" href="#实现-llm-twin-的数据收集流水线"></a> 实现 <code>LLM Twin</code> 的数据收集流水线</h2>
<p><code>LLM Twin</code> 项目的每个流水线的入口都是一个 <strong>ZenML</strong> 流水线，且可以通过 YAML 文件在运行时进行配置，并通过 <strong>ZenML</strong> 生态系统执行。因此，我们从 <strong>ZenML</strong> 的 <code>digital_data_etl</code> 流水线开始，仔细分析其实现方式。你会注意到，这正是我们在第 2 章中用来演示 <strong>ZenML</strong> 的示例流水线。不过，这次我们将深入探讨其实现，并解释数据收集的具体细节。理解流水线的工作原理后，我们将探讨每个爬虫的实现，它们分别用于从不同网站收集数据并存储到 MongoDB 数据仓库中。</p>
<blockquote>
<p>[!CAUTION]</p>
<p>这里手册的作者使用 <code>ZenML</code> 作为 LLMOps 的整体框架，使用 <code>zenml.pipeline</code> 作为流水线管道的具体实现。这里我们将重点放在流水线的<strong>工程方法</strong>，而非具体的实现中（<strong>框架无关</strong>）。如果读者需要了解 <code>ZenML</code> 框架内的相关实现，请在手册中第 65 页查找详情。</p>
</blockquote>
<h3 id="流水线与步骤"><a class="markdownIt-Anchor" href="#流水线与步骤"></a> 流水线与步骤</h3>
<p>在流水线的实现中，它的输入是用户的全名和一组链接，这些链接将由该用户（即该链接的内容作者）进行爬取。在函数内，我们调用了两个步骤：首先，我们根据全名查找用户。接着，我们遍历所有链接并逐个爬取。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@pipeline</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">digital_data_etl</span>(<span class="params">user_full_name: <span class="built_in">str</span>, links: <span class="built_in">list</span>[<span class="built_in">str</span>]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    user = get_or_create_user(user_full_name)				<span class="comment"># step1</span></span><br><span class="line">    last_step = crawl_links(user=user, links=links)	<span class="comment"># step2</span></span><br><span class="line">    <span class="keyword">return</span> last_step.invocation_id</span><br></pre></td></tr></table></figure>
<p>接下来，我们将分别探讨 <code>get_or_create_user</code> 和 <code>crawl_links</code> 这两个步骤：</p>
<ol>
<li>
<p>以用户的全名作为输入，并尝试从 MongoDB 数据库中查找该用户，如果用户不存在，则创建一个新的用户；</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@step</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">get_or_create_user</span>(<span class="params">user_full_name: <span class="built_in">str</span></span>) -&gt; Annotated[UserDocument, <span class="string">&quot;user&quot;</span>]:</span><br><span class="line">    logger.info(<span class="string">f&quot;Getting or creating user: <span class="subst">&#123;user_full_name&#125;</span>&quot;</span>)</span><br><span class="line">    first_name, last_name = utils.split_user_full_name(user_full_name)</span><br><span class="line">    user = UserDocument.get_or_create(first_name=first_name, last_name=last_name)</span><br><span class="line">    step_context = get_step_context()</span><br><span class="line">    step_context.add_output_metadata(output_name=<span class="string">&quot;user&quot;</span>, metadata=_get_metadata(user_full_name, user))	<span class="comment"># matadata</span></span><br><span class="line">    <span class="keyword">return</span> user</span><br></pre></td></tr></table></figure>
<p>在这里，我们还定义了一个辅助函数 <code>_get_metadata()</code>，它构建了一个包含查询参数和检索到的用户信息的字典，这些信息将作为元数据添加到用户输出 artifact ：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_get_metadata</span>(<span class="params">user_full_name: <span class="built_in">str</span>, user: UserDocument</span>) -&gt; <span class="built_in">dict</span>:</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="string">&quot;query&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;user_full_name&quot;</span>: user_full_name,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">&quot;retrieved&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;user_id&quot;</span>: <span class="built_in">str</span>(user.<span class="built_in">id</span>),</span><br><span class="line">            <span class="string">&quot;first_name&quot;</span>: user.first_name,</span><br><span class="line">            <span class="string">&quot;last_name&quot;</span>: user.last_name,</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>接下来是 <code>crawl_links</code> 步骤，它用于收集提供的链接中的数据。在此函数中，我们初始化了一个爬虫分发器 <code>CrawlerDispatcher</code>，并配置它以处理特定的域名，如 <code>GitHub</code> 等：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@step</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">crawl_links</span>(<span class="params">user: UserDocument, links: <span class="built_in">list</span>[<span class="built_in">str</span>]</span>) -&gt; Annotated[<span class="built_in">list</span>[<span class="built_in">str</span>], <span class="string">&quot;crawled_links&quot;</span>]:</span><br><span class="line">    dispatcher = CrawlerDispatcher.build().register_github()</span><br><span class="line">    logger.info(<span class="string">f&quot;Starting to crawl <span class="subst">&#123;<span class="built_in">len</span>(links)&#125;</span> link(s).&quot;</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>然后，该函数初始化了存储输出元数据的变量，并计数成功的爬取次数。它遍历每个链接，尝试爬取并提取数据，并更新成功的爬取次数和链接的元数据：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">metadata = &#123;&#125;</span><br><span class="line">successfull_crawls = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> link <span class="keyword">in</span> tqdm(links):</span><br><span class="line">    successfull_crawl, crawled_domain = _crawl_link(dispatcher, link, user)</span><br><span class="line">    successfull_crawls += successfull_crawl</span><br><span class="line">    metadata = _add_to_metadata(metadata, crawled_domain, successfull_crawl)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>处理完所有链接后，函数将累积的元数据添加到输出 artifact 中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">step_context = get_step_context()</span><br><span class="line">step_context.add_output_metadata(output_name=<span class="string">&quot;crawled_links&quot;</span>, metadata=metadata)</span><br><span class="line">logger.info(<span class="string">f&quot;Successfully crawled <span class="subst">&#123;successfull_crawls&#125;</span> / <span class="subst">&#123;<span class="built_in">len</span>(links)&#125;</span> links.&quot;</span>)</span><br><span class="line"><span class="keyword">return</span> links</span><br></pre></td></tr></table></figure>
<p>在上述的函数中有两个辅助函数 <code>_crawl_link</code> 和<code>_add_to_metadata</code>。<code>_crawl_link</code> 尝试使用合适的爬虫来提取每个链接的信息，处理任何可能发生的异常，并返回一个元组，表示爬取是否成功以及链接的域名：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_crawl_link</span>(<span class="params">dispatcher: CrawlerDispatcher, link: <span class="built_in">str</span>, user: UserDocument</span>) -&gt; <span class="built_in">tuple</span>[<span class="built_in">bool</span>, <span class="built_in">str</span>]:</span><br><span class="line">    crawler = dispatcher.get_crawler(link)</span><br><span class="line">    crawler_domain = urlparse(link).netloc</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        crawler.extract(link=link, user=user)</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">True</span>, crawler_domain)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        logger.error(<span class="string">f&quot;An error occurred while crawling: <span class="subst">&#123;e!s&#125;</span>&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> (<span class="literal">False</span>, crawler_domain)</span><br></pre></td></tr></table></figure>
<p><code>_add_to_metadata</code> 用于更新元数据字典，记录每个域名的爬取成功与总数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">_add_to_metadata</span>(<span class="params">metadata: <span class="built_in">dict</span>, domain: <span class="built_in">str</span>, successfull_crawl: <span class="built_in">bool</span></span>) -&gt; <span class="built_in">dict</span>:</span><br><span class="line">    <span class="keyword">if</span> domain <span class="keyword">not</span> <span class="keyword">in</span> metadata:</span><br><span class="line">        metadata[domain] = &#123;&#125;</span><br><span class="line">    metadata[domain][<span class="string">&quot;successful&quot;</span>] = metadata.get(domain, &#123;&#125;).get(<span class="string">&quot;successful&quot;</span>, <span class="number">0</span>) + successfull_crawl</span><br><span class="line">    metadata[domain][<span class="string">&quot;total&quot;</span>] = metadata.get(domain, &#123;&#125;).get(<span class="string">&quot;total&quot;</span>, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> metadata</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="爬虫分发器-crawlerdispatcher-的实现"><a class="markdownIt-Anchor" href="#爬虫分发器-crawlerdispatcher-的实现"></a> 爬虫分发器 <code>CrawlerDispatcher</code> 的实现</h3>
<p>正如上面提到的，<code>CrawlerDispatcher</code> 类会根据每个链接的域名来确定该使用哪个爬虫。</p>
<p><img src="/2025/03/10/llm-engineers-handbook-note/screenshot_2025-03-12_11.12.34.png" alt="screenshot_2025-03-12_11.12.34"></p>
<p>爬虫的提取逻辑被封装在 <code>extract()</code> 方法中。例如，如果提供的链接属于 <code>https://github.com</code>，它会创建一个 <code>GithubCrawler</code> 实例来爬取该平台的数据。接下来，我们深入探讨 <code>CrawlerDispatcher</code> 的实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> BaseCrawler, GithubCrawler, CustomArticleCrawler</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CrawlerDispatcher</span>:</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="comment"># 存储域名（如 guthub.com）到 爬虫类（如 GithubCrawler）的映射关系。</span></span><br><span class="line">    self._crawlers = <span class="type">Dict</span>[<span class="built_in">str</span>, <span class="type">Type</span>[BaseCrawler]] = &#123;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="meta">	@classmethod</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">build</span>(<span class="params">cls</span>) -&gt; <span class="string">&quot;CrawlerDispatcher&quot;</span>:</span><br><span class="line">    dispatcher = cls()</span><br><span class="line">    <span class="keyword">return</span> dispatcher</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">register_github</span>(<span class="params">self</span>) -&gt; <span class="string">&quot;CrawlerDispatcher&quot;</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 注册一个新的爬虫类型 &quot;&quot;&quot;</span></span><br><span class="line">    self.register(<span class="string">&quot;https://github.com&quot;</span>, GithubCrawler)</span><br><span class="line">    <span class="keyword">return</span> self</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">register</span>(<span class="params">self, domain:<span class="built_in">str</span>, crawler:<span class="built_in">type</span>[BaseCrawler]</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    parsed_domain = urlparse(domain)</span><br><span class="line">    domain = parsed_domain.netloc</span><br><span class="line">    self._crawlers[<span class="string">r&quot;https://(www\.?&#123;&#125;/*)&quot;</span>.<span class="built_in">format</span>(re.eacape(domain))] = crawler</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">get_crawler</span>(<span class="params">self, url:<span class="built_in">str</span></span>) -&gt; BaseCrawler:</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 根据 URL 解析出域名，并实例化正确的爬虫 &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">for</span> pattern, crawler <span class="keyword">in</span> self._crawlers.items():</span><br><span class="line">      <span class="keyword">if</span> re.match(pattern, url):</span><br><span class="line">        <span class="keyword">return</span> crawler()</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        logger.warning(<span class="string">f&quot;No crawler found for <span class="subst">&#123;url&#125;</span>. Defaulting to CustomArticleCrawler&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> CustomArticleCrawler()</span><br><span class="line">        </span><br></pre></td></tr></table></figure>
<h3 id="爬虫crawlers"><a class="markdownIt-Anchor" href="#爬虫crawlers"></a> 爬虫（Crawlers）</h3>
<p>在深入探讨各个爬虫的具体实现之前，我们需要先介绍它们的 基类 <code>BaseCrawler</code>。</p>
<p>基类定义了一个统一的接口，使得所有爬虫都遵循相同的结构。我们之所以能够实现<strong>分发层（Dispatcher Layer）</strong>，正是因为所有爬虫都遵循相同的方法签名。</p>
<h4 id="基类-basecrawler"><a class="markdownIt-Anchor" href="#基类-basecrawler"></a> 基类 <code>BaseCrawler</code></h4>
<p>现在，我们来看 <code>BaseCrawler</code> 的实现，它定义了所有爬虫必须实现的方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC, abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseCrawler</span>(<span class="title class_ inherited__">ABC</span>):</span><br><span class="line">  <span class="string">&quot;&quot;&quot; 所有爬虫的基类，定义了通用接口 &quot;&quot;&quot;</span></span><br><span class="line">  model: <span class="built_in">type</span>[NoSQLBaseDocument]</span><br><span class="line">  </span><br><span class="line"><span class="meta">  @abstractmethod</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">extract</span>(<span class="params">self, link: <span class="built_in">str</span>, **kwargs</span>):</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 爬取数据并存入数据库 &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>
<p><strong>解析</strong>：</p>
<ol>
<li><code>BaseCrawler</code> 继承 <code>ABC</code>（抽象基类），确保不能直接实例化它。</li>
<li><code>extract()</code> 是一个 <strong>抽象方法</strong>，所有具体爬虫都必须实现它。</li>
</ol>
<p>这样，我们可以在不更改 <code>CrawlerDispatcher</code> 代码的情况下，轻松 <strong>扩展新爬虫</strong>。</p>
<h4 id="拓展爬虫基于-selenium-的爬虫基类"><a class="markdownIt-Anchor" href="#拓展爬虫基于-selenium-的爬虫基类"></a> 拓展爬虫：基于 <code>Selenium</code> 的爬虫基类</h4>
<p>在 <code>BaseCrawler</code> 基础上，我们进一步扩展出了 <strong><code>BaseSeleniumCrawler</code></strong>，用于 <strong>自动化浏览器操作</strong>，以便爬取需要动态加载或需要登录的网站（如 Medium、LinkedIn）。</p>
<blockquote>
<p>[!NOTE]</p>
<p><strong>为什么使用 Selenium？</strong></p>
<ol>
<li><strong>支持动态内容加载</strong>：许多现代网站使用 JavaScript 加载内容，普通的 HTTP 请求（如 <code>requests</code>）无法抓取完整数据，而 Selenium <strong>可以模拟用户操作，触发 JavaScript 代码</strong>。</li>
<li><strong>支持登录</strong>：对于 <strong>需要用户认证</strong> 的网站（如 LinkedIn），Selenium <strong>可以模拟用户输入账号密码并自动登录</strong>。</li>
<li><strong>支持交互</strong>：Selenium <strong>可以执行点击、滚动、表单填写等操作</strong>，使其更适用于复杂网页的爬取。</li>
<li>使用 <code>Selenium-based</code> 的爬虫，必须先在本机安装 Chrome （或者其他基于 <code>chromium</code> 内核的浏览器）</li>
</ol>
</blockquote>
<p><strong>简述</strong></p>
<ul>
<li>代码使用 <code>Selenium</code> 和 <code>ChromeDriver</code> 初始化程序设置 Web 爬取所需的导入和配置</li>
<li><code>chromedriver_autoinstaller</code> 确保安装适当版本的 <code>ChromeDriver</code> 并将其添加到系统路径，从而与已安装的 Google Chrome 浏览器版本（或其他基于 Chromium 的浏览器）保持兼容性。</li>
<li><code>Selenium</code> 将使用 <code>ChromeDriver</code> 与浏览器通信并打开无头会话模式，我们可以在其中以编程方式操作浏览器以访问各种 URL、单击特定元素（例如按钮）或滚动浏览新闻源。</li>
<li>使用 <code>chromedriver_autoinstaller</code>，我们确保始终安装与我们机器的 Chrome 浏览器版本匹配的正确 <code>ChromeDriver</code> 版本。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> tempfile <span class="keyword">import</span> mkdtemp</span><br><span class="line"><span class="keyword">import</span> chromedriver_autoinstaller</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options</span><br><span class="line"><span class="keyword">from</span> llm_engineering.domain.documents <span class="keyword">import</span> NoSQLBaseDocument</span><br><span class="line"><span class="comment"># Check if the current version of chromedriver exists</span></span><br><span class="line"><span class="comment"># and if it doesn&#x27;t exist, download it automatically,</span></span><br><span class="line"><span class="comment"># then add chromedriver to path</span></span><br><span class="line">chromedriver_autoinstaller.install()</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BaseSeleniumCrawler</span>(BaseCrawler, ABC):</span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, scroll_limit:<span class="built_in">int</span>=<span class="number">5</span></span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    chromedriver_autoinstaller.install()		<span class="comment"># 自动安装 ChromeDriver 并初始化</span></span><br><span class="line">    </span><br><span class="line">    options = webdriver.ChromeOptions()</span><br><span class="line">		options.add_argument(<span class="string">&quot;--no-sandbox&quot;</span>)</span><br><span class="line">		options.add_argument(<span class="string">&quot;--headless=new&quot;</span>)	<span class="comment"># 无头模式，浏览器界面不可见</span></span><br><span class="line">    options.add_argument(<span class="string">&quot;--disable-dev-shm-usage&quot;</span>)</span><br><span class="line">    options.add_argument(<span class="string">&quot;--log-level=3&quot;</span>)</span><br><span class="line">    options.add_argument(<span class="string">&quot;--disable-popup-blocking&quot;</span>)</span><br><span class="line">    options.add_argument(<span class="string">&quot;--disable-notifications&quot;</span>)</span><br><span class="line">    options.add_argument(<span class="string">&quot;--disable-extensions&quot;</span>)</span><br><span class="line">		options.add_argument(<span class="string">&quot;--disable-background-networking&quot;</span>)</span><br><span class="line">		options.add_argument(<span class="string">&quot;--ignore-certificate-errors&quot;</span>)</span><br><span class="line">		options.add_argument(<span class="string">f&quot;--user-data-dir=<span class="subst">&#123;mkdtemp()&#125;</span>&quot;</span>)</span><br><span class="line">		options.add_argument(<span class="string">f&quot;--data-path=<span class="subst">&#123;mkdtemp()&#125;</span>&quot;</span>)</span><br><span class="line">		options.add_argument(<span class="string">f&quot;--disk-cache-dir=<span class="subst">&#123;mkdtemp()&#125;</span>&quot;</span>)</span><br><span class="line">		options.add_argument(<span class="string">&quot;--remote-debugging-port=9226&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    self.set_extra_driver_options(options)	<span class="comment"># 子类可以自定义额外的选项</span></span><br><span class="line">		self.scroll_limit = scroll_limit</span><br><span class="line">		self.driver = webdriver.Chrome(options=options)</span><br><span class="line">    </span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">set_extra_driver_options</span>(<span class="params">self, options: Options</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 子类可以重写此方法，添加额外的浏览器选项 &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">login</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 子类可以重写此方法，实现登录逻辑 &quot;&quot;&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">scroll_page</span>(<span class="params">self</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&quot;&quot;&quot; 滚动页面，直到达到滚动限制 &quot;&quot;&quot;</span></span><br><span class="line">    current_scroll = <span class="number">0</span></span><br><span class="line">    last_height = self.driver.execute_script(<span class="string">&quot;return document.body.scrollHeight&quot;</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">      self.driver.execute_script(<span class="string">&quot;window.scrollTo(0, document.body.scrollHeight);&quot;</span>)</span><br><span class="line">      time.sleep(<span class="number">5</span>)</span><br><span class="line">      new_height = self.driver.execute_script(<span class="string">&quot;return document.body.scrollHeight&quot;</span>)</span><br><span class="line">      <span class="keyword">if</span> new_height == last_height <span class="keyword">or</span> (self.scroll_limit <span class="keyword">and</span> current_scroll &gt;= self.scroll_limit):</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">        last_height = new_height</span><br><span class="line">        current_scroll += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>至此，我们已经定义了两个爬虫基类：<code>BaseCrawler</code> 和 <code>BaseSeleniumCrawler</code>。下一步我们将通过继承这两个基类，从而实现具体的爬虫：</p>
<ul>
<li><code>GithubCrawler(BaseCrawler)</code></li>
<li><code>CustomArticleCrawler(BaseCrawler)</code></li>
<li><code>MediumCrawler(BaseSeleniumCrawler)</code></li>
</ul>
<h4 id="github-爬虫类-githubcrawler"><a class="markdownIt-Anchor" href="#github-爬虫类-githubcrawler"></a> Github 爬虫类 <code>GithubCrawler</code></h4>
<p><code>GitHubCrawler</code> 类继承自 <code>BaseCrawler</code>，旨在爬取 GitHub 仓库的内容。与其他需要 Selenium 的爬虫不同，由于 GitHub 支持 Git 的 <code>clone</code> 功能，爬虫无需通过浏览器模拟登录或操作，而是直接利用 Git 将仓库克隆到本地进行内容提取。下面是这个类的详细实现。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">GithubCrawler</span>(<span class="title class_ inherited__">BaseCrawler</span>):</span><br><span class="line">  model = RepositoryDocument	<span class="comment"># MongoDB 中定义的代码仓库类型的内容</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, ignore=(<span class="params"><span class="string">&quot;.git&quot;</span>, <span class="string">&quot;.toml&quot;</span>, <span class="string">&quot;.lock&quot;</span>, <span class="string">&quot;.png&quot;</span></span>)</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;ignore 参数定义了要忽略的标准文件和目录类型。例如 .git, .toml, .lock, .png 等。这样可以确保爬虫在处理 GitHub 仓库时不会抓取这些不需要的文件。&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="built_in">super</span>().__init__()</span><br><span class="line">    self._ignore = ignore		<span class="comment"># 文件过滤规则，忽略标准文件和目录</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">	@override</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">extract</span>(<span class="params">self, link: <span class="built_in">str</span>, **kwargs</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="comment"># 检查仓库是否已经在数据库中存在，避免重复存储</span></span><br><span class="line">    old_model = self.model.find(link=link)</span><br><span class="line">    <span class="keyword">if</span> old_model <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">      logger.info(<span class="string">f&quot;Repository already exists in the database: <span class="subst">&#123;link&#125;</span>&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      logger.info(<span class="string">f&quot;Starting scrapping GitHub repository: <span class="subst">&#123;link&#125;</span>&quot;</span>)</span><br><span class="line">      repo_name = link.rstrip(<span class="string">&quot;/&quot;</span>).split(<span class="string">&quot;/&quot;</span>)[-<span class="number">1</span>]</span><br><span class="line">      local_temp = tempfile.mkdtemp()</span><br><span class="line">      os.chdir(local_temp)</span><br><span class="line">      </span><br><span class="line">      <span class="comment"># 自进程执行克隆 GitHub 仓库</span></span><br><span class="line">      subprocess.run([<span class="string">&quot;git&quot;</span>, <span class="string">&quot;clone&quot;</span>, link])</span><br><span class="line">      </span><br><span class="line">      <span class="comment"># 获取克隆后的仓库路径</span></span><br><span class="line">      repo_path = os.path.join(local_temp, os.listdir(local_temp)[<span class="number">0</span>])  <span class="comment"># 获取仓库目录路径</span></span><br><span class="line">      tree = &#123;&#125;  <span class="comment"># 用于存储仓库文件内容的字典</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment"># 遍历仓库目录，跳过忽略的文件和目录</span></span><br><span class="line">      <span class="keyword">for</span> root, _, files <span class="keyword">in</span> os.walk(repo_path):</span><br><span class="line">      	<span class="built_in">dir</span> = root.replace(repo_path, <span class="string">&quot;&quot;</span>).lstrip(<span class="string">&quot;/&quot;</span>)</span><br><span class="line">      	<span class="keyword">if</span> <span class="built_in">dir</span>.startswith(self._ignore):</span><br><span class="line">      		<span class="keyword">continue</span></span><br><span class="line">      	</span><br><span class="line">      	<span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line">      		<span class="keyword">if</span> file.endswith(self._ignore):</span><br><span class="line">      			<span class="keyword">continue</span></span><br><span class="line">      		file_path = os.path.join(<span class="built_in">dir</span>, file)</span><br><span class="line">      		<span class="comment"># 读取文件内容，去除空格并存储</span></span><br><span class="line">      		<span class="keyword">with</span> <span class="built_in">open</span>(os.path.join(root, file), <span class="string">&quot;r&quot;</span>, errors=<span class="string">&quot;ignore&quot;</span>) <span class="keyword">as</span> f:</span><br><span class="line">      			tree[file_path] = f.read().replace(<span class="string">&quot; &quot;</span>, <span class="string">&quot;&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 创建 RepositoryDocument 实例并保存到 MongoDB</span></span><br><span class="line">    	user = kwargs[<span class="string">&quot;user&quot;</span>]</span><br><span class="line">    	instance = self.model(</span><br><span class="line">        content=tree,</span><br><span class="line">        name=repo_name,</span><br><span class="line">        link=link,</span><br><span class="line">        platform=<span class="string">&quot;github&quot;</span>,</span><br><span class="line">        author_id=user.<span class="built_in">id</span>,</span><br><span class="line">        author_full_name=user.full_name,</span><br><span class="line">      )</span><br><span class="line">      instance.save()</span><br><span class="line">      </span><br><span class="line">		<span class="keyword">except</span> Exception:</span><br><span class="line">      <span class="keyword">raise</span>  <span class="comment"># 若发生错误，抛出异常</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">finally</span>:</span><br><span class="line">      <span class="comment"># 确保删除临时目录以释放资源</span></span><br><span class="line">      shutil.rmtree(local_temp)</span><br><span class="line">      logger.info(<span class="string">f&quot;Finished scraping GitHub repository: <span class="subst">&#123;link&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<h4 id="customarticlecrawler-类"><a class="markdownIt-Anchor" href="#customarticlecrawler-类"></a> <code>CustomArticleCrawler</code> 类</h4>
<p><code>CustomArticleCrawler</code> 类采用不同的方法来从互联网上收集数据。它利用 <code>AsyncHtmlLoader</code> 类来加载链接的完整 HTML 内容，再通过 <code>Html2TextTransformer</code> 类提取该 HTML 中的文本内容。这两个类由 <code>langchain_community</code>Python 包提供，以下是相关模块的导入：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.parse <span class="keyword">import</span> urlparse</span><br><span class="line"><span class="keyword">from</span> langchain_community.document_loaders <span class="keyword">import</span> AsyncHtmlLoader</span><br><span class="line"><span class="keyword">from</span> langchain_community.document_transformers.html2text <span class="keyword">import</span> Html2TextTransformer</span><br><span class="line"><span class="keyword">from</span> loguru <span class="keyword">import</span> logger</span><br><span class="line"><span class="keyword">from</span> domain.documents <span class="keyword">import</span> ArticleDocument</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> BaseCrawler</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">CustomArticleCrawler</span>(<span class="title class_ inherited__">BaseCrawler</span>):</span><br><span class="line">  model = ArticleDocument	<span class="comment"># MongoDB 中定义的文章类型的内容</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">extract</span>(<span class="params">self, link: <span class="built_in">str</span>, **kwargs</span>) -&gt; <span class="literal">None</span>:</span><br><span class="line">    <span class="comment"># 检查文章是否已经存在于数据库中，避免重复爬取</span></span><br><span class="line">    old_model = self.model.find(link=link)</span><br><span class="line">    <span class="keyword">if</span> old_model <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">      logger.info(<span class="string">f&quot;Article already exists in the database: <span class="subst">&#123;link&#125;</span>&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 如果文章不存在，进行爬取</span></span><br><span class="line">    logger.info(<span class="string">f&quot;Starting scraping article: <span class="subst">&#123;link&#125;</span>&quot;</span>)</span><br><span class="line">    loader = AsyncHtmlLoader([link])  <span class="comment"># 使用 AsyncHtmlLoader 加载 HTML 内容</span></span><br><span class="line">    docs = loader.load()  <span class="comment"># 加载 HTML</span></span><br><span class="line">    html2text = Html2TextTransformer()  <span class="comment"># 使用 Html2TextTransformer 提取文本</span></span><br><span class="line">    docs_transformed = html2text.transform_documents(docs)  <span class="comment"># 转换为文本</span></span><br><span class="line">    doc_transformed = docs_transformed[<span class="number">0</span>]  <span class="comment"># 获取第一个转换后的文档</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 提取文章内容和相关元数据</span></span><br><span class="line">    content = &#123;</span><br><span class="line">      <span class="string">&quot;Title&quot;</span>: doc_transformed.metadata.get(<span class="string">&quot;title&quot;</span>),</span><br><span class="line">      <span class="string">&quot;Subtitle&quot;</span>: doc_transformed.metadata.get(<span class="string">&quot;description&quot;</span>),</span><br><span class="line">      <span class="string">&quot;Content&quot;</span>: doc_transformed.page_content,</span><br><span class="line">      <span class="string">&quot;language&quot;</span>: doc_transformed.metadata.get(<span class="string">&quot;language&quot;</span>),</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 解析 URL 来确定平台（或域名）</span></span><br><span class="line">    parsed_url = urlparse(link)</span><br><span class="line">    platform = parsed_url.netloc</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 创建文章模型实例，并保存到 MongoDB 数据库</span></span><br><span class="line">    user = kwargs[<span class="string">&quot;user&quot;</span>]</span><br><span class="line">    instance = self.model(</span><br><span class="line">      content=content,</span><br><span class="line">      link=link,</span><br><span class="line">			platform=platform,</span><br><span class="line">			author_id=user.<span class="built_in">id</span>,</span><br><span class="line">      author_full_name=user.full_name,</span><br><span class="line">    )</span><br><span class="line">    instance.save()</span><br><span class="line">    logger.info(<span class="string">f&quot;Finished scraping custom article: <span class="subst">&#123;link&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><strong>解析</strong></p>
<ol>
<li><strong>初始化方法</strong>:
<ul>
<li><code>CustomArticleCrawler</code> 类继承自 <code>BaseCrawler</code>，并使用 <code>ArticleDocument</code> 作为数据模型来存储爬取的文章信息。</li>
</ul>
</li>
<li><strong><code>extract()</code> 方法</strong>:
<ul>
<li><strong>检查重复</strong>：首先检查文章是否已经存在于数据库中，如果存在，则不再重复爬取该文章。</li>
<li><strong>加载 HTML</strong>：如果文章不存在，使用 <code>AsyncHtmlLoader</code> 类加载提供的链接的 HTML 内容。</li>
<li><strong>提取文本</strong>：使用 <code>Html2TextTransformer</code> 类将 HTML 转换为纯文本，并返回一个包含文档内容的列表。我们只关心列表中的第一个文档。</li>
<li><strong>提取内容</strong>：从转换后的文档中提取标题、子标题、正文和语言等元数据。</li>
<li><strong>解析平台</strong>：通过解析 URL 来确定文章所属的平台或域名。</li>
<li><strong>保存数据</strong>：使用 <code>ArticleDocument</code> 类创建一个文章实例，并将提取的内容保存到 MongoDB 数据库中。</li>
</ul>
</li>
<li><strong><code>LangChain</code> 的应用</strong>：
<ul>
<li><code>AsyncHtmlLoader</code> 和 <code>Html2TextTransformer</code> 类遵循 LangChain 的范式，这使得我们能够快速实现爬取和转换功能。虽然它们非常适用于大多数场景，但由于灵活性较差，难以进行深度定制，因此在生产环境中可能不适合所有情况，无法对某些特定网站或内容结构进行精细化控制。</li>
</ul>
</li>
</ol>
<h2 id="nosql-数据仓库文档"><a class="markdownIt-Anchor" href="#nosql-数据仓库文档"></a> NoSQL 数据仓库文档</h2>
<p>我们之前设计了三个文档类来结构化我们的数据类别。这些类定义了文档所需的具体属性，例如内容、作者和来源链接。最佳实践是将数据结构化为类，而不是字典，因为我们对每个项目期望的属性更为详尽，从而减少运行时错误。例如，当从 Python 字典中访问值时，我们无法确保它存在或其类型是否正确。通过将数据项封装在类中，我们可以确保每个属性都符合预期。</p>
<p>通过利用像 <code>Pydantic</code> 这样的 Python 包，我们可以获得开箱即用的类型验证，确保数据集的一致性。因此，我们将数据类别建模为以下文档类，这些类已经在代码中使用过：</p>
<ul>
<li><code>ArticleDocument</code> 类</li>
<li><code>PostDocument</code> 类</li>
<li><code>RepositoryDocument</code> 类</li>
</ul>
<p>这些不仅仅是简单的 Python 数据类或 <code>Pydantic</code> 模型。它们支持在 MongoDB 数据仓库上进行读写操作。为了将读写功能注入到所有文档类中，并避免重复代码，我们使用了对象-文档映射（ODM）软件模式，它基于对象关系映射（ORM）模式。因此，接下来我们将首先探讨 ORM，然后转向 ODM，最后深入研究我们的自定义 ODM 实现和文档类。</p>
<h3 id="odm-中间件"><a class="markdownIt-Anchor" href="#odm-中间件"></a> ODM 中间件</h3>
<p>在讨论软件模式之前，让我们了解一下 ORM。ORM 是一种技术，允许您使用面向对象的范式查询和操作数据库中的数据。无需编写 SQL 或特定 API 的查询，您可以将所有复杂性封装到一个 ORM 类中，该类知道如何处理所有数据库操作，通常是 CRUD 操作。因此，使用 ORM 可以避免手动处理数据库操作，并减少手动编写样板代码的需要。ORM 与 SQL 数据库（如 PostgreSQL 或 MySQL）交互。</p>
<p>大多数现代 Python 应用程序在与数据库交互时都会使用 ORM。尽管 SQL 在数据领域仍然是一种流行的选择，但在 Python 后端组件中，您很少看到原始的 SQL 查询。最流行的 Python ORM 是 SQLAlchemy（<a target="_blank" rel="noopener" href="https://www.sqlalchemy.org/%EF%BC%89%E3%80%82%E6%AD%A4%E5%A4%96%EF%BC%8C%E9%9A%8F%E7%9D%80">https://www.sqlalchemy.org/）。此外，随着</a> FastAPI 的兴起，SQLModel（<a target="_blank" rel="noopener" href="https://github.com/fastapi/sqlmodel%EF%BC%89%E6%88%90%E4%B8%BA%E4%BA%86%E4%B8%80%E4%B8%AA%E5%B8%B8%E8%A7%81%E9%80%89%E6%8B%A9%EF%BC%8C%E5%AE%83%E6%98%AF">https://github.com/fastapi/sqlmodel）成为了一个常见选择，它是</a> SQLAlchemy 的一个封装，使其与 FastAPI 的集成更加简便。</p>
<p>ODM 模式与 ORM 非常相似，但它是针对 NoSQL 数据库（如 MongoDB）和无结构的集合操作，而不是 SQL 数据库和表。当我们使用 NoSQL 数据库时，数据结构主要集中在集合中，存储的是类似 JSON 的文档，而不是表中的行。</p>
<p>总之，ODM 简化了与基于文档的 NoSQL 数据库的交互，并将面向对象的代码映射到类似 JSON 的文档。接下来，我们将实现一个轻量级的 ODM 模块，基于 <code>MongoDB</code>，帮助我们深入理解 ODM 的工作原理。</p>
<p>接下来，我们定义了一个类型变量 <code>T</code>，它绑定到 <code>NoSQLBaseDocument</code> 类。该变量利用 Python 的泛型模块，允许我们将类的类型进行泛化。例如，在实现 <code>ArticleDocument</code> 类时，<code>T</code> 所有使用的地方都会被替换为 <code>ArticleDocument</code> 类型。</p>
<p><code>NoSQLBaseDocument</code> 类继承了 Pydantic 的 <code>BaseModel</code>、Python 的 <code>Generic</code> 和 <code>ABC</code> 类（使其成为抽象基类），它是我们的基础 ODM 类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> uuid</span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC</span><br><span class="line"><span class="keyword">from</span> typing <span class="keyword">import</span> <span class="type">Generic</span>, <span class="type">Type</span>, TypeVar</span><br><span class="line"><span class="keyword">from</span> loguru <span class="keyword">import</span> logger</span><br><span class="line"><span class="keyword">from</span> pydantic <span class="keyword">import</span> UUID4, BaseModel, Field</span><br><span class="line"><span class="keyword">from</span> pymongo <span class="keyword">import</span> errors</span><br><span class="line"><span class="keyword">from</span> llm_engineering.domain.exceptions <span class="keyword">import</span> ImproperlyConfigured</span><br><span class="line"><span class="keyword">from</span> llm_engineering.infrastructure.db.mongo <span class="keyword">import</span> connection</span><br><span class="line"><span class="keyword">from</span> llm_engineering.settings <span class="keyword">import</span> settings</span><br><span class="line">_database = connection.get_database(settings.DATABASE_NAME)</span><br><span class="line"></span><br><span class="line">T = TypeVar(<span class="string">&quot;T&quot;</span>, bound=<span class="string">&quot;NoSQLBaseDocument&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NoSQLBaseDocument</span>(BaseModel, <span class="type">Generic</span>[T], ABC):</span><br><span class="line">  <span class="string">&#x27;&#x27;&#x27;实现了 __eq__ 和 __hash__ 方法，允许比较实例并将其用于散列集合（如集合）或基于其唯一 id 属性作为字典键&#x27;&#x27;&#x27;</span></span><br><span class="line">  <span class="built_in">id</span>: UUID4 = Field(default_factory=uuid.uuid4)</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__eq__</span>(<span class="params">self, value: <span class="built_in">object</span></span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, self.__class__):</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> self.<span class="built_in">id</span> == value.<span class="built_in">id</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">__hash__</span>(<span class="params">self</span>) -&gt; <span class="built_in">int</span>:</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">hash</span>(self.<span class="built_in">id</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">  @classmethod</span></span><br><span class="line">  <span class="string">&#x27;&#x27;&#x27;将从 MongoDB 获取的字典转换为类实例&#x27;&#x27;&#x27;</span></span><br><span class="line">	<span class="keyword">def</span> <span class="title function_">from_mongo</span>(<span class="params">cls: <span class="type">Type</span>[T], data: <span class="built_in">dict</span></span>) -&gt; T:</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> data:</span><br><span class="line">      <span class="keyword">raise</span> ValueError(<span class="string">&quot;Data is empty.&quot;</span>)</span><br><span class="line">		<span class="built_in">id</span> = data.pop(<span class="string">&quot;_id&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> cls(**<span class="built_in">dict</span>(data, <span class="built_in">id</span>=<span class="built_in">id</span>))</span><br><span class="line">    </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">to_mongo</span>(<span class="params">self: T, **kwargs</span>) -&gt; <span class="built_in">dict</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;将模型实例转换为适合 MongoDB 插入的字典&#x27;&#x27;&#x27;</span></span><br><span class="line">    exclude_unset = kwargs.pop(<span class="string">&quot;exclude_unset&quot;</span>, <span class="literal">False</span>)</span><br><span class="line">    by_alias = kwargs.pop(<span class="string">&quot;by_alias&quot;</span>, <span class="literal">True</span>)</span><br><span class="line">    parsed = self.model_dump(exclude_unset=exclude_unset, by_alias=by_alias, **kwargs)</span><br><span class="line">    <span class="keyword">if</span> <span class="string">&quot;_id&quot;</span> <span class="keyword">not</span> <span class="keyword">in</span> parsed <span class="keyword">and</span> <span class="string">&quot;id&quot;</span> <span class="keyword">in</span> parsed:</span><br><span class="line">      parsed[<span class="string">&quot;_id&quot;</span>] = <span class="built_in">str</span>(parsed.pop(<span class="string">&quot;id&quot;</span>))</span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> parsed.items():</span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">isinstance</span>(value, uuid.UUID):</span><br><span class="line">        parsed[key] = <span class="built_in">str</span>(value)</span><br><span class="line">    <span class="keyword">return</span> parsed</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">save</span>(<span class="params">self: T, **kwargs</span>) -&gt; T | <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;利用上面描述的 to_mongo() 方法将实例转换为与 MongoDB 兼容的文档，并尝试将其插入数据库，处理可能发生的任何写入错误&#x27;&#x27;&#x27;</span></span><br><span class="line">    collection = _database[self.get_collection_name()]</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      collection.insert_one(self.to_mongo(**kwargs))</span><br><span class="line">      <span class="keyword">return</span> self</span><br><span class="line">    <span class="keyword">except</span> errors.WriteError:</span><br><span class="line">      logger.exception(<span class="string">&quot;Failed to insert document.&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">	@classmethod</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">get_or_create</span>(<span class="params">cls: <span class="type">Type</span>[T], **filter_options</span>) -&gt; T:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;如果找到匹配的文档，则将其转换为类的实例。如果没有找到，则创建一个新实例，并使用过滤选项作为其初始数据并保存到数据库&#x27;&#x27;&#x27;</span></span><br><span class="line">    collection = _database[cls.get_collection_name()]</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      instance = collection.find_one(filter_options)</span><br><span class="line">      <span class="keyword">if</span> instance:</span><br><span class="line">        <span class="keyword">return</span> cls.from_mongo(instance)</span><br><span class="line">      new_instance = cls(**filter_options)</span><br><span class="line">      new_instance = new_instance.save()</span><br><span class="line">      <span class="keyword">return</span> new_instance</span><br><span class="line">    <span class="keyword">except</span> errors.OperationFailure:</span><br><span class="line">      logger.exception(<span class="string">f&quot;Failed to retrieve document with filter options: <span class="subst">&#123;filter_options&#125;</span>&quot;</span>)</span><br><span class="line">      <span class="keyword">raise</span></span><br><span class="line">      </span><br><span class="line"><span class="meta">	@classmethod</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">bulk_insert</span>(<span class="params">cls: <span class="type">Type</span>[T], documents: <span class="built_in">list</span>[T], **kwargs</span>) -&gt; <span class="built_in">bool</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;批量写入文档以提高效率&#x27;&#x27;&#x27;</span></span><br><span class="line">    collection = _database[cls.get_collection_name()]</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      collection.insert_many([doc.to_mongo(**kwargs) <span class="keyword">for</span> doc <span class="keyword">in</span> documents])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">except</span> (errors.WriteError, errors.BulkWriteError):</span><br><span class="line">      logger.error(<span class="string">f&quot;Failed to insert documents of type <span class="subst">&#123;cls.__name__&#125;</span>&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">	@classmethod</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">find</span>(<span class="params">cls: <span class="type">Type</span>[T], **filter_options</span>) -&gt; T | <span class="literal">None</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;根据filter_options来查找数据库中的文档&#x27;&#x27;&#x27;</span></span><br><span class="line">    collection = _database[cls.get_collection_name()]</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      instance = collection.find_one(filter_options)</span><br><span class="line">      <span class="keyword">if</span> instance:</span><br><span class="line">        <span class="keyword">return</span> cls.from_mongo(instance)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    <span class="keyword">except</span> errors.OperationFailure:</span><br><span class="line">      logger.error(<span class="string">&quot;Failed to retrieve document.&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">	@classmethod</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">bulk_find</span>(<span class="params">cls: <span class="type">Type</span>[T], **filter_options</span>) -&gt; <span class="built_in">list</span>[T]:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;检索与过滤选项匹配的多个文档。将每个检索到的 MongoDB 文档转换为模型实例，并将它们收集到列表中&#x27;&#x27;&#x27;</span></span><br><span class="line">    collection = _database[cls.get_collection_name()]</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">      instances = collection.find(filter_options)</span><br><span class="line">      <span class="keyword">return</span> [document <span class="keyword">for</span> instance <span class="keyword">in</span> instances <span class="keyword">if</span> (document := cls.from_mongo(instance)) <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>]</span><br><span class="line">    <span class="keyword">except</span> errors.OperationFailure:</span><br><span class="line">      logger.error(<span class="string">&quot;Failed to retrieve document.&quot;</span>)</span><br><span class="line">      <span class="keyword">return</span> []</span><br><span class="line">    </span><br><span class="line"><span class="meta">	@classmethod</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">get_collection_name</span>(<span class="params">cls: <span class="type">Type</span>[T]</span>) -&gt; <span class="built_in">str</span>:</span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;确定与该类关联的 MongoDB 集合的名称。它期望该类具有嵌套的 Settings 类，该类具有指定集合名称的 name 属性&#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(cls, <span class="string">&quot;Settings&quot;</span>) <span class="keyword">or</span> <span class="keyword">not</span> <span class="built_in">hasattr</span>(cls.Settings, <span class="string">&quot;name&quot;</span>):</span><br><span class="line">      <span class="keyword">raise</span> ImproperlyConfigured(</span><br><span class="line">        <span class="string">&quot;Document should define an Settings configuration class with the name of the collection.&quot;</span>)</span><br><span class="line">    <span class="keyword">return</span> cls.Settings.name</span><br></pre></td></tr></table></figure>
<h3 id="数据类别和用户文档类"><a class="markdownIt-Anchor" href="#数据类别和用户文档类"></a> 数据类别和用户文档类</h3>
<p>最后，我们看一下继承自 <code>NoSQLBaseDocument</code> 基类的子类的实现。这些是定义我们数据类别的具体类。你已经在本章中看到这些类，它们用于爬虫类中的文章、仓库和帖子。</p>
<p>首先定义了一个 <code>enum</code> 类，将所有数据类别类型集中管理。这些变量将作为常量，用于配置本书中的所有 ODM 类。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> StrEnum</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DataCategory</span>(<span class="title class_ inherited__">StrEnum</span>):</span><br><span class="line">  PROMPT = <span class="string">&quot;prompt&quot;</span></span><br><span class="line">  QUERIES = <span class="string">&quot;queries&quot;</span></span><br><span class="line">  INSTRUCT_DATASET_SAMPLES = <span class="string">&quot;instruct_dataset_samples&quot;</span></span><br><span class="line">  INSTRUCT_DATASET = <span class="string">&quot;instruct_dataset&quot;</span></span><br><span class="line">	PREFERENCE_DATASET_SAMPLES = <span class="string">&quot;preference_dataset_samples&quot;</span></span><br><span class="line">	PREFERENCE_DATASET = <span class="string">&quot;preference_dataset&quot;</span></span><br><span class="line">	POSTS = <span class="string">&quot;posts&quot;</span></span><br><span class="line">	ARTICLES = <span class="string">&quot;articles&quot;</span></span><br><span class="line">	REPOSITORIES = <span class="string">&quot;repositories&quot;</span></span><br><span class="line">  USERS = <span class="string">&quot;users&quot;</span></span><br></pre></td></tr></table></figure>
<p><code>Document</code> 类被引入作为其他文档类的抽象基类，基于 <code>NoSQLBaseDocument</code> ODM 类。它包括通用的属性，如内容、平台和作者信息，为所有继承自它的文档提供了标准化结构：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Document</span>(NoSQLBaseDocument, ABC):</span><br><span class="line">	content: <span class="built_in">dict</span></span><br><span class="line">	platform: <span class="built_in">str</span></span><br><span class="line">	author_id: UUID4 = Field(alias=<span class="string">&quot;author_id&quot;</span>)</span><br><span class="line">	author_full_name: <span class="built_in">str</span> = Field(alias=<span class="string">&quot;author_full_name&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>具体的文档类型通过继承 <code>Document</code> 类来定义。<code>RepositoryDocument</code>、<code>PostDocument</code> 和 <code>ArticleDocument</code> 类分别代表不同的数据类别，每个类别都有独特的字段和设置，指定它们在数据库中的集合名称。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">RepositoryDocument</span>(<span class="title class_ inherited__">Document</span>):</span><br><span class="line">  name: <span class="built_in">str</span></span><br><span class="line">  link: <span class="built_in">str</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Settings</span>:</span><br><span class="line">    name = DataCategory.REPOSITORIES</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PostDocument</span>(<span class="title class_ inherited__">Document</span>):</span><br><span class="line">  image: <span class="type">Optional</span>[<span class="built_in">str</span>] = <span class="literal">None</span></span><br><span class="line">  link: <span class="built_in">str</span> | <span class="literal">None</span> = <span class="literal">None</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Settings</span>:</span><br><span class="line">    name = DataCategory.POSTS</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ArticleDocument</span>(<span class="title class_ inherited__">Document</span>):</span><br><span class="line">  link: <span class="built_in">str</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Settings</span>:</span><br><span class="line">    name = DataCategory.ARTICLES</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>最后，我们定义了 <code>UserDocument</code> 类，用于存储和查询所有来自 LLM Twin 项目的用户：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">UserDocument</span>(<span class="title class_ inherited__">NoSQLBaseDocument</span>):</span><br><span class="line">  first_name: <span class="built_in">str</span></span><br><span class="line">  last_name: <span class="built_in">str</span></span><br><span class="line">  <span class="keyword">class</span> <span class="title class_">Settings</span>:</span><br><span class="line">    name = DataCategory.USERS</span><br><span class="line">    </span><br><span class="line"><span class="meta">	@property</span></span><br><span class="line">  <span class="keyword">def</span> <span class="title function_">full_name</span>(<span class="params">self</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="string">f&quot;<span class="subst">&#123;self.first_name&#125;</span> <span class="subst">&#123;self.last_name&#125;</span>&quot;</span></span><br></pre></td></tr></table></figure>
<p>通过实现 <code>NoSQLBaseDocument</code> ODM 类，我们将重点放在了每个文档或领域实体的字段和特定功能上。所有 CRUD 功能都委托给了父类。通过利用 Pydantic 定义字段，我们还获得了开箱即用的类型验证。例如，当创建 <code>ArticleDocument</code> 类的实例时，如果提供的链接为 <code>None</code> 或不是字符串，系统将抛出一个错误，提示数据无效。</p>
<p>到此为止，我们已经完成了数据采集管道的实现，首先是 ZenML 组件，然后是爬虫的实现，最后封装成 ODM 类和数据类别文档。接下来的步骤是运行数据采集管道并将原始数据导入 MongoDB 数据仓库。</p>
<h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2>
<p>最后，我们用一个 <code>UML</code> 来直观的总结这一章节中关于数据收集的代码设计结构：</p>
<pre class="mermaid">classDiagram
    class NoSQLBaseDocument {
    	+UUID4 id
    	+__eq__(value: object) bool
    	+__hash__() int
    	+from_mongo(data: dict) NoSQLBaseDocument
    	+to_mongo(**kwargs) dict
    	+save(**kwargs) NoSQLBaseDocument
    	+get_or_create(**filter_options) NoSQLBaseDocument
    	+bulk_insert(documents: list) bool
    	+find(**filter_options) NoSQLBaseDocument
    	+bulk_find(**filter_options) list
    	+get_collection_name() str
    }

    class Document {
    	+dict content
    	+str platform
    	+UUID4 author_id
    	+str author_full_name
    }

    class RepositoryDocument {
    	+str name
    	+str link
    	+Settings
    }

    class PostDocument {
    	+Optional[str] image
    	+Optional[str] link
    	+Settings
    }

    class ArticleDocument {
    	+str link
    	+Settings
    }

    class UserDocument {
    	+str first_name
    	+str last_name
    	+Settings
    	+full_name()
    }

    class DataCategory {
    	<<enumeration>>
    	+PROMPT
    	+QUERIES
    	+INSTRUCT_DATASET_SAMPLES
    	+INSTRUCT_DATASET
    	+PREFERENCE_DATASET_SAMPLES
    	+PREFERENCE_DATASET
    	+POSTS
    	+ARTICLES
    	+REPOSITORIES
    }
    
    class CrawlerDispatcher {
    	-Dict[str, Type[BaseCrawler]] _crawlers
    	+build() CrawlerDispatcher
    	+register_xxx() CrawlerDispatcher
    	-register(domin:str, crawler:Type[BaseCrawler])
    	+get_crawler(url:str) BaseCrawler
    }
    
    class BaseCrawler {
    	<<abstract>>
    	+NoSQLBaseDocument model
    	+extract(link:str, **kwargs) Any
    }
    
    class BaseSeleniumCrawler {
    	<<abstract>>
    	+int scroll_limit
    	+driver
    	+set_extra_driver_options(op:Options)
    	+login()
    	+scroll_page()
    }
    
    class GithubCrawler
    class CustomArticleCrawler
    class MediumCrawler
    
    class MongoDB

    NoSQLBaseDocument <|-- document : 继承自 <|-- repositorydocument postdocument articledocument nosqlbasedocument userdocument --> DataCategory : 引用
    PostDocument --> DataCategory : 引用
    ArticleDocument --> DataCategory : 引用
    UserDocument --> DataCategory : 引用
    
    CrawlerDispatcher --> BaseCrawler : 引用
    BaseCrawler --> NoSQLBaseDocument : 引用
    BaseCrawler <|-- baseseleniumcrawler : 继承自 githubcrawler --|> BaseCrawler : 继承自
    CustomArticleCrawler --|> BaseCrawler : 继承自
    MediumCrawler --|> BaseSeleniumCrawler : 继承自
    
    NoSQLBaseDocument ..> MongoDB : 操作数据库</|--></|--></abstract></abstract></enumeration></pre>
<h1 id="四-检索增强生成rag管道"><a class="markdownIt-Anchor" href="#四-检索增强生成rag管道"></a> 四、检索增强生成（RAG）管道</h1>
<p>检索增强生成（RAG）在大多数生成式 AI 应用中是非常重要的。RAG 的核心职责是将自定义数据注入到大型语言模型（LLM）中，以执行给定的操作（例如总结、重述和提取注入的数据）。通常希望在 LLM 中使用它没有训练过的数据（例如私有数据或新数据），由于微调 LLM 是一项非常昂贵的操作，因此 RAG 成为了一种非常有吸引力的策略，可以绕过不断微调的需求来访问这些新数据。</p>
<p>我们将从理论部分开始，重点介绍 RAG 的基础和它如何工作。接着，我们将逐步引导你了解一个简单的 RAG 系统的所有组件：<strong>分块、嵌入和向量数据库</strong>。最终，我们将介绍用于高级 RAG 系统的各种优化。然后，我们将继续探索 LLM Twin 的 RAG 特性管道架构。在这一步，我们将应用章节开头讨论的所有理论内容。最后，我们将通过实现 LLM Twin 的 RAG 特性管道来演示实践中的应用。</p>
<p>本章的主要内容如下：</p>
<ul>
<li>理解 RAG</li>
<li>高级 RAG 概述</li>
<li>探索 <code>LLM Twin</code> 的 RAG 特性管道架构</li>
<li>实现 <code>LLM Twin</code> 的 RAG 特性管道</li>
</ul>
<h2 id="理解-rag"><a class="markdownIt-Anchor" href="#理解-rag"></a> 理解 RAG</h2>
<p>RAG 通过从外部数据源检索信息来增强生成式 AI 模型的准确性和可靠性。它是一种与 LLM 内部知识互补的技术。在深入细节之前，我们先来理解 RAG 的含义：</p>
<ul>
<li><strong>检索（Retrieval）</strong>：搜索相关数据</li>
<li><strong>增强（Augmented）</strong>：将数据作为上下文添加到提示中</li>
<li><strong>生成（Generation）</strong>：使用增强后的提示与 LLM 进行生成</li>
</ul>
<p>任何 LLM 都只能理解它所训练过的数据，这通常被称为参数化知识。因此，即使 LLM 能够完美地回答过去发生的事情，但对于最新的数据或它未曾训练过的任何外部资源，它也无法得知。另一种情况是，它可能会自信地“幻想”并提供错误的答案。</p>
<p>要理解 RAG，首先你需要知道，在使用 RAG 时，我们<strong>将必要的信息注入到提示中，将增强后的提示传递给 LLM，进行最终回答</strong>。此时，LLM 会利用额外的上下文来回答用户问题。</p>
<p>RAG 解决了两个根本问题：</p>
<ul>
<li><strong>幻觉（Hallucinations）</strong></li>
<li><strong>过时或私有信息（Old or private information）</strong></li>
</ul>
<h3 id="幻觉hallucinations"><a class="markdownIt-Anchor" href="#幻觉hallucinations"></a> 幻觉（Hallucinations）</h3>
<p>如果一个没有使用 RAG 的聊天机器人被问到它没有训练过的问题，它很可能会”自信“地给出一个错误答案，让人难以分辨真假。即使 LLM 并不总是产生幻觉，这种情况仍然会引发对其答案可信度的担忧。因此，就带来了两个问题：</p>
<ul>
<li>什么时候可以信任 LLM 的回答？</li>
<li>如何评估答案是否正确？</li>
</ul>
<p>通过引入 RAG，我们强制 LLM 仅根据提供的上下文进行回答。LLM 作为推理引擎，而 RAG 提供的额外信息则充当生成答案的唯一真实来源。这样，我们可以快速评估 LLM 的答案是否基于外部数据。</p>
<h3 id="过时信息old-information"><a class="markdownIt-Anchor" href="#过时信息old-information"></a> 过时信息（Old Information）</h3>
<p>任何 LLM 都只能在某个特定时间点上的全世界知识的子集上进行训练或微调，主要有以下三个原因：</p>
<ul>
<li><strong>私有数据（Private data）</strong>：你无法在没有所有权或使用权的数据上训练模型。</li>
<li><strong>新数据（New data）</strong>：新数据每时每刻都在产生，因此必须不断训练 LLM 以跟上更新。</li>
<li><strong>成本（Costs）</strong>：训练或微调 LLM 是一项极其昂贵的操作，因此无法频繁进行。</li>
</ul>
<p>RAG 解决了这些问题，因为你不再需要不断微调 LLM 以适应新数据（甚至是私有数据）。只需<strong>将必要的数据直接注入</strong>到 LLM 处理的<strong>提示（prompt）中</strong>，就能生成正确且有价值的答案。</p>
<h2 id="简单-rag-框架"><a class="markdownIt-Anchor" href="#简单-rag-框架"></a> 简单 RAG 框架</h2>
<p>RAG 系统的基本结构都非常相似。我们将首先集中了解最简单形式的 RAG。请注意，我们将简单的 RAG（Vanilla RAG） 和原始 RAG（Naive RAG） 交替使用，以避免重复。</p>
<p>RAG 系统由三个主要模块组成，彼此独立：</p>
<ul>
<li><strong>数据输入管道（Ingestion pipeline）</strong>：一个用于填充向量数据库的批处理或流式管道。</li>
<li><strong>检索管道（Retrieval pipeline）</strong>：一个查询向量数据库并检索与用户输入相关的条目的模块。</li>
<li><strong>生成管道（Generation pipeline）</strong>：使用检索到的数据来增强提示并与 LLM 一起生成答案。</li>
</ul>
<p>由于这三个组件是独立的类或服务，我们将分别深入了解它们。但目前，让我们尝试回答“这三个模块如何连接？”的问题。以下是一个非常简单的概述：</p>
<ol>
<li>在后台，数据输入管道根据计划或持续运行，将外部数据填充到向量数据库中；</li>
<li>在客户端，用户提出一个问题；</li>
<li>问题传递给检索模块，检索模块对用户输入进行预处理并查询向量数据库；</li>
<li>生成管道使用提示模板、用户输入和检索到的上下文来创建提示；</li>
<li>提示传递给 LLM 以生成答案；</li>
<li>答案显示给用户。</li>
</ol>
<p><img src="/2025/03/10/llm-engineers-handbook-note/screenshot_2025-03-12_16.04.00.jpg" alt="screenshot_2025-03-12_16.04.00"></p>
<p>当你需要访问任何类型的外部信息时，就必须在你的生成式 AI 应用中实现 RAG。例如，在实现一个财务助手时，你很可能需要访问最新的新闻、报告和价格，才能提供有价值的答案。或者，如果你构建一个旅行推荐系统，你必须检索并解析一份潜在景点、餐馆和活动的列表。在训练时，LLM 并没有访问你的特定数据，因此你将经常需要在生成式 AI 项目中实现 RAG 策略。</p>
<p>现在，让我们深入探讨数据输入、检索和生成管道。</p>
<h3 id="数据输入管道ingestion-pipeline"><a class="markdownIt-Anchor" href="#数据输入管道ingestion-pipeline"></a> 数据输入管道（Ingestion pipeline）</h3>
<p>RAG 摄取管道从各种数据源（例如数据仓库、数据湖、网页等）提取原始文档。然后，它会清理、分块并嵌入文档。最后，它会将嵌入的块加载到向量数据库（或其他类似的向量存储）中。</p>
<p>因此，RAG 数据输入管道进一步分为以下几个模块：</p>
<ol>
<li><strong>数据提取模块（data extraction）</strong><br>
该模块负责从各种数据源（如数据库、API 或网页）中收集所需的数据。这个模块高度依赖于你的数据。它可以简单地通过查询数据仓库来完成，也可以是更复杂的操作，例如爬取维基百科等网站。</li>
<li><strong>清洗层（cleaning）</strong><br>
清洗层对提取的数据进行标准化处理，并移除不需要的字符。这样可以确保数据质量，提高后续处理的准确性。</li>
<li><strong>切分模块（chunking）</strong><br>
该模块将清洗后的文档拆分成较小的部分。由于我们希望将文档的内容传递给嵌入模型，因此必须确保内容不超过模型的最大输入大小。切分还需要确保将语义上相关的区域分开。例如，在切分一本书的章节时，最优的方式是将相似的段落分到同一个切片中。这样做可以确保在检索时，只将必要的数据添加到提示中。</li>
<li><strong>嵌入组件（embedding）</strong><br>
嵌入组件使用嵌入模型将切片内容（如文本、图片、音频等）映射到一个密集的向量中，这个向量承载了语义信息。在本章的后续部分，我们将深入讨论嵌入模型。</li>
<li><strong>加载模块（loading）</strong><br>
加载模块负责将嵌入后的切片及其元数据文档存储到数据库中。元数据将包含一些关键信息，例如嵌入的内容、该切片的源 URL、该内容在网页上发布的时间等。嵌入向量作为索引，用于查询相似的切片，而元数据则用于访问用来增强提示的信息。</li>
</ol>
<h3 id="检索管道retrieval-pipeline"><a class="markdownIt-Anchor" href="#检索管道retrieval-pipeline"></a> 检索管道（Retrieval Pipeline）</h3>
<p>检索模块接收用户输入（文本、图像、音频等），将其嵌入，并查询向量数据库（DB）以寻找与用户输入相似的向量。</p>
<p>检索步骤的主要功能是<strong>将用户输入投影到与嵌入数据库中作为索引的嵌入相同的向量空间</strong>。这使得我们能够通过比较向量存储中的嵌入<strong>与用户输入的向量来找到最相似的前 K 个条目</strong>。这些条目随后作为增强提示的一部分，传递给 LLM 用于生成答案。</p>
<p>为了比较两个向量，必须使用一种距离度量方法，例如欧几里得距离或曼哈顿距离。但最常用的距离度量是<strong>余弦距离</strong>，计算公式为：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>C</mi><mi>o</mi><mi>s</mi><mi>i</mi><mi>n</mi><mi>e</mi><mi>D</mi><mi>i</mi><mi>s</mi><mi>t</mi><mi>a</mi><mi>n</mi><mi>c</mi><mi>e</mi><mo>=</mo><mn>1</mn><mo>−</mo><mi>cos</mi><mo>⁡</mo><mo stretchy="false">(</mo><mi>θ</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn><mo>−</mo><mfrac><mrow><mi>A</mi><mo>⋅</mo><mi>B</mi></mrow><mrow><mrow><mo fence="true">∥</mo><mi>A</mi><mo fence="true">∥</mo></mrow><mo>⋅</mo><mrow><mo fence="true">∥</mo><mi>B</mi><mo fence="true">∥</mo></mrow></mrow></mfrac></mrow><annotation encoding="application/x-tex">CosineDistance = 1 - \cos(\theta) = 1 - \frac{A \cdot B}{\left \| A \right \| \cdot \left \| B \right \|}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.07153em;">C</span><span class="mord mathdefault">o</span><span class="mord mathdefault">s</span><span class="mord mathdefault">i</span><span class="mord mathdefault">n</span><span class="mord mathdefault">e</span><span class="mord mathdefault" style="margin-right:0.02778em;">D</span><span class="mord mathdefault">i</span><span class="mord mathdefault">s</span><span class="mord mathdefault">t</span><span class="mord mathdefault">a</span><span class="mord mathdefault">n</span><span class="mord mathdefault">c</span><span class="mord mathdefault">e</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mop">cos</span><span class="mopen">(</span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">1</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:2.29633em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="minner"><span class="mopen delimcenter" style="top:0em;">∥</span><span class="mord mathdefault">A</span><span class="mclose delimcenter" style="top:0em;">∥</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">∥</span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span><span class="mclose delimcenter" style="top:0em;">∥</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord mathdefault">A</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathdefault" style="margin-right:0.05017em;">B</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>其中，<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>θ</mi></mrow><annotation encoding="application/x-tex">\theta</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault" style="margin-right:0.02778em;">θ</span></span></span></span> 是两个向量之间的夹角。余弦距离的值范围从 -1 到 1：</p>
<ul>
<li>当两个向量完全相反时，余弦距离为 -1；</li>
<li>当两个向量正交时，余弦距离为 0；</li>
<li>当两个向量指向相同的方向时，余弦距离为 1。</li>
</ul>
<p>通常，余弦距离在非线性复杂的向量空间中表现良好。然而，需要注意的是，选择合适的向量之间的距离度量方法取决于数据和所使用的嵌入模型。</p>
<p>关键因素需要特别强调的是，用户的输入和嵌入必须<strong>位于相同的向量空间</strong>中。否则，你就无法计算它们之间的距离。为此，必须以与 RAG 数据输入管道中处理原始文档相同的方式对用户输入进行预处理。这意味着必须清理用户输入，必要时进行切分，并使用相同的函数、模型和超参数来嵌入用户输入。这与训练和推理时数据特征的预处理方法相似。如果处理不一致，推理结果可能会不准确，这种现象也被称为“训练-服务偏差”（training-serving skew）。</p>
<h3 id="生成管道generation-pipeline"><a class="markdownIt-Anchor" href="#生成管道generation-pipeline"></a> 生成管道（Generation Pipeline）</h3>
<p>RAG 系统的最后一步是获取用户的输入，检索相关数据，将其传递给大语言模型（LLM），并生成有价值的答案。</p>
<p>在这一步中，最终的提示（prompt）是由系统模板和用户查询以及检索到的上下文填充而成的。根据应用的不同，您可能会使用一个单独的提示模板或多个提示模板。通常，所有的提示工程（prompt engineering）工作都是在提示模板的层面进行的。</p>
<p>以下是一个虚拟示例，展示了一个通用的系统和提示模板，并说明它们如何与检索逻辑和 LLM 一起使用，生成最终的答案：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">system_template = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">You are a helpful assistant who answers all the user&#x27;s questions politely.</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">prompt_template = <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">Answer the user&#x27;s question using only the provided context. If you cannot</span></span><br><span class="line"><span class="string">answer using the context, respond with &quot;I don&#x27;t know.&quot;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Context: &#123;context&#125;</span></span><br><span class="line"><span class="string">User question: &#123;user_question&#125;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">user_question = <span class="string">&quot;&lt;your_question&gt;&quot;</span></span><br><span class="line">retrieved_context = retrieve(user_question)</span><br><span class="line"></span><br><span class="line">prompt = <span class="string">f&quot;<span class="subst">&#123;system_template&#125;</span>\n&quot;</span></span><br><span class="line">prompt += prompt_template.<span class="built_in">format</span>(context=retrieved_context, user_question=user_question)</span><br><span class="line">answer  = llm(prompt)</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>随着提示模板的不断演化，每次修改都应使用机器学习操作（MLOps）的最佳实践进行跟踪和版本控制。这样，在训练或推理时，您始终可以知道给定的答案是由特定版本的 LLM 和提示模板生成的。您可以通过 Git 跟踪版本，或者将提示模板存储在数据库中，或者使用像 LangFuse 这样的专门提示管理工具。</p>
<p>正如我们在检索管道中看到的，直接影响 RAG 系统准确性的一些关键方面是外部数据的嵌入，通常存储在向量数据库中，用户查询的嵌入，以及我们如何使用<strong>余弦距离</strong>等函数来衡量这两者之间的相似性。为了更好地理解 RAG 算法的这一部分，我们将深入探讨嵌入是什么以及它们如何计算。</p>
<h2 id="嵌入embeddings"><a class="markdownIt-Anchor" href="#嵌入embeddings"></a> 嵌入（Embeddings）</h2>
<h3 id="什么是嵌入embeddings"><a class="markdownIt-Anchor" href="#什么是嵌入embeddings"></a> 什么是嵌入（Embeddings）？</h3>
<p>想象一下，我们正在教计算机理解世界。嵌入就像是一个特殊的翻译器，将这些事物转化为数值代码。不过，这些代码并不是随机的，因为相似的单词或物品会被赋予彼此接近的代码。它就像一张地图，其中具有相似含义的单词被聚集在一起。</p>
<p>从更理论的角度来看，嵌入是物体的稠密数值表示，这些物体以向量的形式编码在一个连续的向量空间中，可能是单词、图像，或者推荐系统中的物品。这个转化帮助捕捉物体之间的语义意义和关系。例如，在自然语言处理（NLP）中，嵌入将单词转换为向量，使得<strong>语义相似的单词在向量空间中彼此接近</strong>。</p>
<h4 id="嵌入的可视化"><a class="markdownIt-Anchor" href="#嵌入的可视化"></a> 嵌入的可视化</h4>
<p>一种常见的方法是可视化嵌入，以便理解和评估它们之间的几何关系。由于嵌入通常有超过 2 或 3 维，通常在 64 到 2048 之间，因此需要将其重新投影到 2D 或 3D 空间中。</p>
<p>例如，你可以使用 <strong>UMAP</strong>（<a target="_blank" rel="noopener" href="https://umap-learn.readthedocs.io/en/latest/index.html">UMAP文档</a>），这是一种降维方法，因其能够在将嵌入投影到 2D 或 3D 时保持点之间的几何特性而受到广泛欢迎。另一个常用的降维算法是 <strong>t-SNE</strong>（<a target="_blank" rel="noopener" href="https://scikit-learn.org/stable/modules/generated/sklearn.manifold.TSNE.html">t-SNE文档</a>）。然而，相比 UMAP，t-SNE 更具随机性，并且不总是保持点之间的拓扑关系。</p>
<p>总结来说，嵌入是一个将对象转换为能够捕捉其语义关系的数值向量的技术，广泛应用于自然语言处理、图像处理和推荐系统等领域。</p>
<h4 id="为什么嵌入embeddings如此强大"><a class="markdownIt-Anchor" href="#为什么嵌入embeddings如此强大"></a> 为什么嵌入（Embeddings）如此强大</h4>
<p>首先，机器学习模型只能处理数值型数据。当处理表格数据时，这通常不是问题，因为数据通常是数值型的，或者可以很容易地转换为数字。然而，当我们希望将文字、图像或音频数据输入模型时，嵌入就显得特别有用。</p>
<p>例如，在处理 <code>Transformer</code> 模型时，您需要对所有文本输入进行分词，每个分词都会关联一个嵌入（embedding），神经网络的密集层可以轻松地处理这些嵌入（embedding）。</p>
<p>基于这个例子，您可以使用嵌入来编码任何类别变量，并将其传递给机器学习模型。那么，为什么不使用其他简单的方法，如独热编码（One-hot Encoding）呢？当处理具有高基数的类别变量时，如语言词汇表，使用其他经典方法会遭遇“维度灾难”（curse of dimensionality）。例如，如果您的词汇表有 10,000 个标记，那么应用独热编码后，每个标记的长度就是 10,000。如果输入序列有 N 个标记，那么输入参数将变成 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>×</mo><mn>10</mn><mo separator="true">,</mo><mn>000</mn></mrow><annotation encoding="application/x-tex">N \times 10,000</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span></span></span></span>。若 <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>N</mi><mo>&gt;</mo><mo>=</mo><mn>100</mn></mrow><annotation encoding="application/x-tex">N &gt;= 100</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72243em;vertical-align:-0.0391em;"></span><span class="mord mathdefault" style="margin-right:0.10903em;">N</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span><span class="mord">0</span><span class="mord">0</span></span></span></span>，则文本输入通常会过于庞大，无法使用。另一个经典方法，如哈希编码（Feature Hashing），虽然不受维度灾难的困扰，但它会丢失向量之间的语义关系。</p>
<blockquote>
<p>[!TIP]</p>
<p><strong>独热编码</strong>：</p>
<ul>
<li>是一种将类别变量转换为二进制矩阵表示的技术。每个类别都会被表示为一个唯一的二进制向量。对于每个类别变量，都会创建一个二进制向量，其长度等于唯一类别的数量，除对应类别的索引外，所有值都为零。</li>
<li>优点：保留了类别的所有信息，简单且可解释。</li>
<li>缺点：当类别变量有许多唯一值时，特征空间会变得非常高维，导致该方法在实际应用中不可行。</li>
</ul>
<p><strong>特征哈希</strong>：</p>
<ul>
<li>也称为哈希编码或“哈希技巧”，是一种通过对类别值应用哈希函数将类别变量转换为数值特征的方法。与独热编码相比，这种方法不受唯一类别数的限制，而是通过将类别映射到固定数量的箱或桶中来减少特征空间的维度。</li>
<li>优点：减少了特征空间的维度，这在处理高基数类别变量时特别有用。在内存使用和计算时间方面具有较高的效率。</li>
<li>缺点：哈希可能会发生冲突，即不同的类别可能会映射到同一个桶中，从而导致信息丢失。此外，这种映射使得方法不可解释，并且很难理解原始类别和哈希特征之间的关系。</li>
</ul>
</blockquote>
<h3 id="嵌入的优势"><a class="markdownIt-Anchor" href="#嵌入的优势"></a> 嵌入的优势</h3>
<p>嵌入帮助我们编码类别变量，并且可以控制输出向量的维度。与朴素的哈希技巧不同，嵌入使用巧妙的方法将信息压缩到比哈希技巧更低维的空间中。</p>
<p>其次，通过对输入进行嵌入，我们可以降低它的维度，并将所有语义信息压缩成一个密集的向量。这在处理图像时是一种非常流行的技术，其中卷积神经网络（CNN）编码模块将高维的图像信息映射为嵌入，然后通过CNN解码器对该嵌入进行处理，进行分类或回归操作。</p>
<p><img src="/2025/03/10/llm-engineers-handbook-note/Typical_cnn.png" alt="Typical_cnn"></p>
<p>上图是一个典型的CNN结构的示意图。想象一下每个层中的小方块，它们是“感受区块”。每个小方块将信息传递给前一层的单个神经元。在网络的不同层级中，主要发生了两个关键操作：</p>
<ul>
<li><strong>缩小图像尺寸</strong>：特殊的“采样 <code>subsampling</code>”操作将图像尺寸减小，集中关注图像的关键信息。</li>
<li><strong>学习特征</strong>：另一方面，“卷积 <code>convolution</code>”操作会增加图像特征层的尺寸，以便网络能够从图像中学习更复杂的特征。</li>
</ul>
<p>最终，网络中的完全连接层会将所有这些处理过的信息转化为最终的向量嵌入，即图像的数值表示。</p>
<h3 id="如何创建嵌入embeddings"><a class="markdownIt-Anchor" href="#如何创建嵌入embeddings"></a> 如何创建嵌入（Embeddings）</h3>
<p>嵌入是通过深度学习模型创建的，这些模型能够理解输入的上下文和语义，并将其投影到一个连续的向量空间中。根据数据输入的类型，嵌入的创建方法有所不同。因此，在选择嵌入模型之前，理解你的数据和需求至关重要。</p>
<h4 id="文本数据中的嵌入"><a class="markdownIt-Anchor" href="#文本数据中的嵌入"></a> 文本数据中的嵌入</h4>
<p>例如，当处理文本数据时，<code>Word2Vec</code> 和 <code>GloVe</code> 是早期用于创建词汇嵌入的常见方法，它们在一些简单的应用中仍然广泛使用。另一种流行的方法是使用 <code>encoder-only</code> 的 <code>transformers</code>，例如 <code>BERT</code>，及其系列中的其他方法，例如 <code>RoBERTa</code>。这些模型利用转换器架构的编码器将您的输入智能地投影到密集向量空间中，稍后可将其用作嵌入。</p>
<blockquote>
<p>[!TIP]</p>
<p><strong><code>BERT</code></strong></p>
<p><strong>基于 <code>Transformer</code> 的双向编码器表示技术</strong>（英语：Bidirectional Encoder Representations from Transformers，<strong>BERT</strong>）是用于自然语言处理（NLP）的预训练技术，由 Google 提出。通过在所有层中共同调整左右情境，利用无标记文本预先训练深度双向表示（深度双向、无监督式）。同时考虑句子中单词的左右上下文，BERT 使用双向方法，而不是按顺序分析文本，BERT 同时查看句子中的所有单词。</p>
<p><em>例如：“The bank is situated on the ___ of the river.”</em></p>
<ul>
<li>
<p>在单向模型中，对空白的理解将严重依赖于前面的单词，并且模型可能难以辨别*“bank”*是指银行还是河的一侧。</p>
</li>
<li>
<p><code>BERT</code> 是双向的，它同时考虑左侧（<em>“The bank is situated on the”</em>）和右侧上下文（<em>“of the river”</em>），从而实现更细致的理解。它理解缺失的单词可能与银行的地理位置有关，展示了双向方法带来的语境丰富性。</p>
</li>
</ul>
<p><code>BERT</code> 的创新之处在于借助 Transformer 学习双向表示，Transformer 是一种深度学习组件，不同于递归神经网络 (<code>RNN</code>) 对顺序的依赖性，它能够并行处理整个序列。因此可以分析规模更大的数据集，并加快模型训练速度。Transformer 能够使用注意力机制收集词语相关情境的信息，并以表示该情境的丰富向量进行编码，从而同时处理（而非单独处理）与句中所有其他词语相关的词语。该模型能够学习如何从句段中的每个其他词语衍生出给定词语的含义。</p>
<table>
<thead>
<tr>
<th></th>
<th><code>BERT</code></th>
<th><code>GPT</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>架构</td>
<td>BERT 专为双向表征学习而设计。它使用掩码语言模型目标，根据左右上下文预测句子中缺失的单词。</td>
<td>另一方面，GPT 是为生成式语言建模而设计的。它利用单向自回归方法，根据前面的上下文预测句子中的下一个单词。</td>
</tr>
<tr>
<td>预训练目标</td>
<td>BERT 使用掩码语言模型目标和下一句预测进行预训练。它专注于捕捉双向上下文并理解句子中单词之间的关系。</td>
<td>GPT 经过预先训练，可以预测句子中的下一个单词，这有助于模型学习语言的连贯表示并生成上下文相关的序列。</td>
</tr>
<tr>
<td>上下文理解</td>
<td>BERT 对于需要深入理解句子内的上下文和关系的任务非常有效，例如文本分类、命名实体识别和问答。</td>
<td>GPT 擅长生成连贯且上下文相关的文本。它常用于创意任务、对话系统和需要生成自然语言序列的任务。</td>
</tr>
<tr>
<td>任务类型和用例</td>
<td>常用于文本分类、命名实体识别、情感分析和问答等任务。</td>
<td>应用于文本生成、对话系统、总结和创意写作等任务。</td>
</tr>
<tr>
<td>微调与小样本学习</td>
<td>BERT 通常使用标记数据针对特定的下游任务进行微调，以使其预训练表示适应当前的任务。</td>
<td>GPT 旨在执行小样本学习，它可以用最少的特定任务训练数据推广到新任务。</td>
</tr>
</tbody>
</table>
</blockquote>
<p>下面是一个简单的 Python 代码示例，演示如何使用 <code>SentenceTransformer</code> 来计算句子的嵌入，并计算它们之间的余弦相似度：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> sentence_transformers <span class="keyword">import</span> SentenceTransformer</span><br><span class="line"></span><br><span class="line">model = SentenceTransformer(<span class="string">&quot;all-MiniLM-L6-v2&quot;</span>)</span><br><span class="line">sentences = [</span><br><span class="line">    <span class="string">&quot;The dog sits outside waiting for a treat.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;I am going swimming.&quot;</span>,</span><br><span class="line">    <span class="string">&quot;The dog is swimming.&quot;</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算嵌入</span></span><br><span class="line">embeddings = model.encode(sentences)</span><br><span class="line"><span class="built_in">print</span>(embeddings.shape)  <span class="comment"># 输出: [3, 384]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算余弦相似度</span></span><br><span class="line">similarities = model.similarity(embeddings, embeddings)</span><br><span class="line"><span class="built_in">print</span>(similarities)</span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line"><span class="comment"># tensor([[ 1.0000, -0.0389, 0.2692],</span></span><br><span class="line"><span class="comment">#         [-0.0389, 1.0000, 0.3837],</span></span><br><span class="line"><span class="comment">#         [ 0.2692, 0.3837, 1.0000]])</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们开源看到这三个句子的嵌入向量与它们之间的余弦相似度：</p>
<ul>
<li>第一个句子与其自身的相似度为 1。</li>
<li>第一个和第二个句子的相似度接近 0，说明它们没有什么相似性。</li>
<li>第一个和第三个句子的相似度较高，表明它们有一些共同的上下文。</li>
</ul>
<p>嵌入模型因为使用场景的不同而变化。我们可以在 <a target="_blank" rel="noopener" href="https://huggingface.co/spaces/mteb/leaderboard">Hugging Face 上的 Massive Text Embedding Benchmark (MTEB)</a> 上找到特定的模型。根据需求，可以考虑性能最佳的模型、准确率最高的模型或内存占用最小的模型。同时，使用 <code>Hugging Face</code> 和 <code>SentenceTransformer</code> 使不同模型之间的切换变得简单。因此，您始终可以尝试各种选项。</p>
<p>处理图像时，您可以使用卷积神经网络 (CNN) 嵌入它们。流行的 CNN 网络基于 <code>ResNet</code> 架构。但是，我们不能直接将图像嵌入技术用于录音。相反，我们可以创建音频的视觉表示，例如<strong>频谱图</strong>，然后将图像嵌入模型应用于这些视觉效果。这使我们能够以计算机可以理解的方式捕捉图像和声音的本质。</p>
<p>通过利用 <code>CLIP</code> 之类的模型，您实际上可以将一段文本和一张图片嵌入到同一个向量空间中。这样您就可以使用句子作为输入来查找相似的图像，反之亦然，这证明了 <code>CLIP</code> 的实用性。</p>
<img src="/2025/03/10/llm-engineers-handbook-note/crazy_cat.jpg" alt="crazy_cat" style="zoom:30%;">
<ul>
<li><em>“A crazy cat smiling.”</em></li>
<li><em>“A white and brown cat with a yellow bandana.”</em></li>
<li><em>“A man eating in the garden.”</em></li>
</ul>
<p>在下面的代码片段中，我们使用 <code>CLIP</code> 对一张小猫图像（如上图）和三句话进行编码。最后，我们使用余弦相似度来计算图片和句子之间的相似度：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> io <span class="keyword">import</span> BytesIO</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">from</span> sentence_transformers <span class="keyword">import</span> SentenceTransformer</span><br><span class="line"></span><br><span class="line">image = Image.<span class="built_in">open</span>(image_dir)</span><br><span class="line">model = SentenceTransformer(<span class="string">&quot;clip-ViT-B-32&quot;</span>)</span><br><span class="line">img_emb = model.encode(image)</span><br><span class="line">text_emb = model.encode(</span><br><span class="line">[</span><br><span class="line">  <span class="string">&quot;A crazy cat smiling.&quot;</span>,</span><br><span class="line">  <span class="string">&quot;A white and brown cat with a yellow bandana.&quot;</span>,</span><br><span class="line">  <span class="string">&quot;A man eating in the garden.&quot;</span></span><br><span class="line">])</span><br><span class="line"><span class="built_in">print</span>(text_emb.shape) <span class="comment"># noqa # Output: (3, 512)</span></span><br><span class="line">similarity_scores = model.similarity(img_emb, text_emb) <span class="built_in">print</span>(similarity_scores) <span class="comment"># noqa</span></span><br><span class="line"><span class="comment"># Output: tensor([[0.3068, 0.3300, 0.1719]])</span></span><br></pre></td></tr></table></figure>
<p>至此，我们简要介绍了如何计算嵌入。具体实现的范围很广，大多数数据类别（如单词、句子、文档、图像、视频和图形）都可以计算嵌入。当我们需要计算两个不同数据类别之间的距离（例如句子向量和图像向量之间的距离）时，必须使用专门的模型，这一点至关重要。这些模型旨在将两种数据类型投影到<strong>同一个向量空间</strong>（如 <code>CLIP</code>），以确保准确的距离计算。</p>
<h2 id="向量数据库"><a class="markdownIt-Anchor" href="#向量数据库"></a> 向量数据库</h2>
<p>向量数据库是专门设计用于高效存储、索引和检索向量嵌入的数据库。传统的基于标量的数据库难以应对向量数据的复杂性，因此向量数据库对于实时语义搜索等任务至关重要。</p>
<p>虽然像 FAISS 这样的独立向量索引对于相似性搜索很有效，但它们缺乏向量数据库的全面数据管理功能。向量数据库支持 CRUD 操作、元数据过滤、可扩展性、实时更新、备份、生态系统集成和强大的数据安全性，因此它们比独立索引更适合生产环境。</p>
<h3 id="向量数据库如何工作"><a class="markdownIt-Anchor" href="#向量数据库如何工作"></a> 向量数据库如何工作？</h3>
<p>想想您通常如何搜索数据库。您输入一些特定内容，系统会输出精确匹配。这就是传统数据库的工作方式。向量数据库则不同。我们不是寻找完美匹配，而是寻找查询向量的最近邻居。在底层，向量数据库使用<strong>近似最近邻</strong> （Approximate Nearest Neighbor, ANN） 算法来查找这些近邻。</p>
<p>虽然 <code>ANN</code> 算法不会返回给定搜索的最佳匹配，但标准最近邻算法在实践中太慢了。此外，经验表明，仅使用给定输入查询的最佳匹配的近似值就可以很好地工作。因此，准确性和延迟之间的权衡之下最终选择了 <code>ANN</code> 算法。</p>
<p>这是向量数据库的典型工作流程：</p>
<ol>
<li>
<p><strong>索引向量</strong>：使用针对高维数据优化的数据结构对向量进行索引。常见的索引技术包括分层可导航小世界 (HNSW)、随机投影、乘积量化 (PQ) 和局部敏感哈希 (LSH)。</p>
</li>
<li>
<p><strong>查询相似性</strong>：在搜索过程中，数据库查询索引向量以找到与输入向量最相似的向量。此过程涉及基于相似性度量（例如余弦相似性、欧几里得距离或点积）比较向量。每种方法都有独特的优势，适用于不同的用例。</p>
</li>
<li>
<p><strong>结果的后处理</strong>：在识别潜在匹配后，对结果进行后处理以提高准确性。此步骤可确保将最相关的向量返回给用户。</p>
</li>
</ol>
<p>向量数据库可以在向量搜索之前或之后根据元数据过滤结果。这两种方法在性能和准确性方面都有权衡。查询还依赖于元数据（以及向量索引），因此它包含用于过滤操作的元数据索引用户。</p>
<h3 id="向量索引的算法"><a class="markdownIt-Anchor" href="#向量索引的算法"></a> 向量索引的算法</h3>
<p>向量数据库使用各种算法来创建向量索引并高效地管理搜索数据：</p>
<ul>
<li><strong>随机投影</strong>：随机投影通过使用随机矩阵将向量投影到低维空间来降低向量的维数。该技术保留了向量之间的相对距离，从而有助于更快地进行搜索。</li>
<li><strong>乘积量化（PQ）</strong>：PQ 通过将向量分成更小的子向量，然后将这些子向量量化为代表性代码来压缩向量。这减少了内存使用量并加快了相似性搜索。</li>
<li><strong>局部敏感哈希 （LSH）</strong>：LSH 将相似的向量映射到存储桶中。此方法通过关注数据子集来实现快速近似最近邻搜索，从而降低计算复杂度。在查询时，只查找同一个桶内的近邻，从而提高查询效率。</li>
<li><strong>分层可导航小世界 （HNSW）</strong>：HNSW 构建一个多层图，其中每个节点代表一组向量。相似的节点相互连接，允许算法导航图并有效地找到最近的邻居。</li>
</ul>
<p>这些算法使向量数据库能够有效地处理复杂和大规模数据，使其非常适合各种 AI 和 ML 应用程序。</p>
<h3 id="数据库操作"><a class="markdownIt-Anchor" href="#数据库操作"></a> 数据库操作</h3>
<p>向量数据库还与普通数据库拥有共同的一些特点，以确保高性能、容错性和在生产环境中的易管理性。关键操作包括：</p>
<ul>
<li><strong>分片和复制</strong>：数据会被划分（分片）到多个节点上，以确保可扩展性和高可用性。数据在节点之间的复制有助于维护数据完整性，并在节点失败时确保数据的可用性。</li>
<li><strong>监控</strong>：持续监控数据库性能，包括查询延迟和资源使用情况（RAM、CPU、磁盘），有助于维持最佳操作，并在潜在问题影响系统之前发现它们。</li>
<li><strong>访问控制</strong>：实施强大的访问控制机制，确保只有授权用户可以访问和修改数据。这包括基于角色的访问控制和其他安全协议来保护敏感信息。</li>
<li><strong>备份</strong>：定期的数据库备份对灾难恢复至关重要。自动备份过程确保在数据损坏或丢失的情况下，能够恢复到之前的状态。</li>
</ul>
<h2 id="高级-rag-框架"><a class="markdownIt-Anchor" href="#高级-rag-框架"></a> 高级 RAG 框架</h2>
<p>我们刚刚介绍的基础RAG框架并没有解决许多影响检索和答案生成质量的基本方面，比如：</p>
<ul>
<li>检索到的文档是否与用户的问题相关？</li>
<li>检索到的上下文是否足够回答用户的问题？</li>
<li>是否有冗余信息，只是增加了增强提示的噪音？</li>
<li>检索步骤的延迟是否符合我们的要求？</li>
<li>如果我们无法使用检索到的信息生成有效答案，应该怎么办？</li>
</ul>
<p>从上述问题中，我们可以得出两个结论。第一个结论是，我们需要一个强大的评估模块来<strong>衡量和量化检索数据的质量</strong>，并根据用户的问题生成答案。我们将在第九章详细讨论这个话题。第二个结论是，我们必须改进RAG框架，直接在算法中解决检索的限制。这些改进被称为<strong>高级RAG</strong>。</p>
<p>基础RAG设计可以在三个不同的阶段进行优化：</p>
<ul>
<li><strong>检索前</strong>：这个阶段关注如何构建和预处理数据，以优化数据索引和查询。</li>
<li><strong>检索</strong>：这个阶段主要围绕改进嵌入模型和元数据过滤，以提高向量检索步骤的效果。</li>
<li><strong>检索后</strong>：这个阶段主要聚焦于通过不同方式过滤检索到的文档中的噪音，并在将其输入LLM进行答案生成之前对提示进行压缩。</li>
</ul>
<h3 id="检索前优化"><a class="markdownIt-Anchor" href="#检索前优化"></a> 检索前优化</h3>
<p>检索前的优化步骤有两种不同的方式：</p>
<ul>
<li><strong>数据索引</strong>：这是RAG摄取管道的一部分，主要是在清理或分块模块中实现，目的是对数据进行预处理，以便更好地进行索引。</li>
<li><strong>查询优化</strong>：该算法直接作用于用户的查询，在嵌入查询并从向量数据库中检索数据之前。</li>
</ul>
<h4 id="数据索引"><a class="markdownIt-Anchor" href="#数据索引"></a> 数据索引</h4>
<p>在我们使用嵌入来索引数据时，嵌入语义上代表了分块文档的内容，因此，大部分数据索引技术都专注于通过更好的预处理和数据结构化来提高检索效率，例如：</p>
<ul>
<li>
<p><strong>滑动窗口（Sliding Window）</strong>：滑动窗口技术在文本块之间引入重叠，确保在块边界附近的重要上下文得到保留，从而提高检索的准确性。这在一些领域中尤为有用，如法律文件、科研论文、客户支持日志和医疗记录等，因为关键信息往往跨越多个部分。嵌入是在文本块及其重叠部分上计算的，因此滑动窗口技术通过保持跨越边界的上下文来增强系统检索相关和连贯信息的能力。</p>
</li>
<li>
<p><strong>增强数据粒度</strong>：包括数据清理技术，如删除无关细节、验证事实准确性以及更新过时信息。一个干净且准确的数据集有助于更精确的检索。</p>
</li>
<li>
<p><strong>元数据（Metadata）</strong>：添加如日期、URL、外部ID或章节标记等元数据标签，帮助在检索时有效地过滤结果。</p>
</li>
<li>
<p><strong>优化索引结构</strong>：基于不同的数据索引方法，如不同的块大小和多重索引策略。</p>
</li>
<li>
<p><strong>小到大（Small-to-big）</strong>：该算法将用于检索的文本块与最终生成答案时使用的上下文解耦。该算法使用较小的文本序列来计算嵌入，同时保留该序列本身以及周围较大的窗口作为元数据。因此，使用较小的块可以提高检索的准确性，而更大的上下文则为LLM提供更多的上下文信息。但是，如果我们使用整篇文本来计算嵌入，可能会引入太多噪音，或者文本包含多个主题，这会导致嵌入的整体语义表示较差。</p>
</li>
</ul>
<h4 id="查询优化-query-optimization"><a class="markdownIt-Anchor" href="#查询优化-query-optimization"></a> 查询优化 (Query Optimization)</h4>
<p>在查询优化方面，我们可以利用查询路由、查询重写和查询扩展等技术，进一步优化为LLM检索到的信息：</p>
<ul>
<li>
<p><strong>查询路由 (Query Routing)</strong>：根据用户的输入，可能需要与不同类别的数据交互，并分别查询每个类别。查询路由用于根据用户的输入决定采取何种操作，类似于if/else语句，但决策完全基于自然语言，而不是逻辑语句。</p>
<p><img src="/2025/03/10/llm-engineers-handbook-note/screenshot_2025-03-13_10.28.21.png" alt="screenshot_2025-03-13_10.28.21"></p>
<p>如图所示，假设基于用户的输入，为了执行 RAG，我们可以使用向量搜索查询从向量数据库中检索附加的上下文，或者通过将用户查询转换为 SQL 命令来从标准 SQL 数据库中检索，或者通过利用 REST API 调用从互联网中获取。查询路由器还可以检测是否需要上下文，帮助我们避免对外部数据存储进行冗余调用。此外，查询路由器还可以用来选择最佳的提示模板。例如，在 <code>LLM Twin</code> 用例中，根据用户是想要一段文章、一个帖子还是一段代码片段，需要不同的提示模板来优化创作过程。查询路由通常使用 LLM 来决定采取哪条路径，或者通过选择具有最相似向量的路径来进行嵌入选择。总的来说，查询路由类似于 if/else 语句，但它更具灵活性，因为它直接与自然语言交互。</p>
</li>
<li>
<p><strong>查询重写 (Query Rewriting)</strong>：有时，用户的初始查询可能与数据的结构不完全对齐。查询重写通过重新构造问题，使其更好地匹配已索引的信息来解决这个问题。常见的方法包括：</p>
<ul>
<li><strong>释义 (Paraphrasing)</strong>：在保持原意的基础上重述用户的查询（例如，“气候变化的原因是什么？”可以重写为“导致全球变暖的因素”）。</li>
<li><strong>同义词替换 (Synonym Substitution)</strong>：用同义词替换不常见的词，以扩大搜索范围（例如，“joyful”可以重写为“happy”）。</li>
<li><strong>子查询 (Sub-queries)</strong>：对于较长的查询，可以将其拆分为多个更短且更集中的子查询。这有助于检索阶段更精确地识别相关文档。</li>
</ul>
</li>
<li>
<p><strong>假设文档嵌入 (HyDE)</strong>：该技术通过让 LLM 生成对查询的假设响应。然后，将原始查询和LLM的响应一起送入检索阶段。</p>
</li>
<li>
<p><strong>查询扩展 (Query Expansion)</strong>：该方法通过添加额外的术语或概念来丰富用户的提问，从而提供同一初始问题的不同视角。例如，在搜索“疾病”时，可以利用同义词和与原始查询词相关的术语，甚至包括“疾病”或“病症”。</p>
</li>
<li>
<p><strong>自查询 (Self-query)</strong>：核心思想是将非结构化查询映射到结构化查询。LLM 识别输入文本中的关键实体、事件和关系，并将这些身份作为过滤参数，用于减少向量搜索的空间（例如，识别查询中的城市名，如“巴黎”，并将其添加到过滤器中，以减少向量搜索空间）。</p>
</li>
</ul>
<h3 id="检索优化"><a class="markdownIt-Anchor" href="#检索优化"></a> 检索优化</h3>
<p>检索步骤可以通过两种基本方式进行优化：</p>
<ul>
<li><strong>改进嵌入模型</strong>：在 RAG 摄取管道中使用的嵌入模型，用于编码分块文档，并在推理时转换用户的输入。</li>
<li><strong>利用数据库的过滤和搜索功能</strong>：此步骤仅在推理时使用，当需要基于用户输入检索最相似的文本块时使用。</li>
</ul>
<p>这两种策略的最终目标一致：通过利用查询和已索引数据之间的语义相似性，增强向量检索步骤。</p>
<h4 id="改进嵌入模型"><a class="markdownIt-Anchor" href="#改进嵌入模型"></a> 改进嵌入模型</h4>
<p>在改进嵌入模型时，通常需要对预训练的嵌入模型进行微调，以使其适应特定领域的术语和细微差别，尤其是在术语不断变化或包含稀有词汇的领域。</p>
<p>如果不想对嵌入模型进行微调，可以利用<strong>Instructor模型</strong>（<a target="_blank" rel="noopener" href="https://huggingface.co/hkunlp/instructor-xl">Instructor模型示例</a>）通过针对你领域的指令/提示来引导嵌入生成过程。使用此模型来定制你的嵌入网络以适应数据，可能是一个不错的选择，因为微调模型会消耗更多的计算和人工资源。</p>
<p>以下是一个使用Instructor模型嵌入AI相关文章标题的代码示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> InstructorEmbedding <span class="keyword">import</span> INSTRUCTOR</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化Instructor模型</span></span><br><span class="line">model = INSTRUCTOR(<span class="string">&quot;hkunlp/instructor-base&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义文章标题和指令</span></span><br><span class="line">sentence = <span class="string">&quot;RAG Fundamentals First&quot;</span></span><br><span class="line">instruction = <span class="string">&quot;Represent the title of an article about AI:&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取嵌入向量</span></span><br><span class="line">embeddings = model.encode([[instruction, sentence]])</span><br><span class="line"><span class="built_in">print</span>(embeddings.shape)  <span class="comment"># 输出形状 (1, 768)</span></span><br></pre></td></tr></table></figure>
<p>源代码可以在<a target="_blank" rel="noopener" href="https://github.com/PacktPublishing/LLM-Engineering/blob/main/code_snippets/08_instructor_embeddings.py">这里</a>找到。</p>
<p>在运行Instructor代码之前，你需要创建并激活一个虚拟环境：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python3 -m venv instructor_venv &amp;&amp; <span class="built_in">source</span> instructor_venv/bin/activate</span><br></pre></td></tr></table></figure>
<p>然后安装所需的Python依赖：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install sentence-transformers==2.2.2 InstructorEmbedding==1.0.1</span><br></pre></td></tr></table></figure>
<h4 id="利用经典数据库过滤和搜索功能提高检索"><a class="markdownIt-Anchor" href="#利用经典数据库过滤和搜索功能提高检索"></a> 利用经典数据库过滤和搜索功能提高检索</h4>
<p>在检索优化的另一个方面，你可以通过利用经典的过滤和搜索数据库功能来提高检索效率：</p>
<ul>
<li>
<p><strong>混合搜索 (Hybrid Search)</strong>：这是一种结合向量搜索和关键词搜索的方法。关键词搜索擅长识别包含特定关键词的文档。当任务要求极高的精度，且检索的信息必须包括精确的关键词匹配时，混合搜索表现优秀。虽然向量搜索功能强大，但有时在寻找精确匹配时会遇到困难，但在寻找更广泛的语义相似性时却表现优异。通过将这两种方法结合，你可以利用关键词匹配和语义相似性。通常有一个叫做<code>alpha</code>的参数来控制两者之间的权重。算法会进行两次独立搜索，之后对结果进行标准化和统一。</p>
</li>
<li>
<p><strong>过滤向量搜索 (Filtered Vector Search)</strong>：这种搜索方式利用元数据索引来过滤特定关键词的元数据。与混合搜索不同，你首先仅通过向量索引检索数据，然后在检索前或检索后进行过滤，以减少搜索空间。</p>
</li>
</ul>
<h4 id="实践中的检索优化"><a class="markdownIt-Anchor" href="#实践中的检索优化"></a> 实践中的检索优化</h4>
<p>在实际应用中，通常从<strong>过滤向量搜索</strong>或<strong>混合搜索</strong>开始，因为它们相对容易实现。这种方法让你可以根据性能灵活调整策略。如果结果不如预期，你始终可以微调嵌入模型以提高检索效果。</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="https://lostnfound.top">Guohao</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://lostnfound.top/2025/03/10/llm-engineers-handbook-note/">https://lostnfound.top/2025/03/10/llm-engineers-handbook-note/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://lostnfound.top" target="_blank">Lost N Found</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/LLM/">LLM</a><a class="post-meta__tags" href="/tags/DeepLearning/">DeepLearning</a><a class="post-meta__tags" href="/tags/Engineering/">Engineering</a></div><div class="post_share"><div class="social-share" data-image="/linear-gradient(45deg,%20#8EC3B0,%20#9ED5C5,%20#F8C4B4,%20#FF8787)" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><hr/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="gitalk-container"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Guohao</div><div class="author-info__description">L’existence précède l‘essence</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">42</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">27</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">11</div></a></div><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/Dave0126" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:dave980126@outlook.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E9%9B%B6-%E5%89%8D%E8%A8%80"><span class="toc-text"> 零、前言</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80-%E7%90%86%E8%A7%A3-llm-twin-%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E6%9E%B6%E6%9E%84"><span class="toc-text"> 一、理解 LLM Twin 的概念和架构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-llm-twin"><span class="toc-text"> 什么是 LLM Twin</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E7%94%A8-qwen-%E8%BF%99%E4%BA%9B%E9%80%9A%E7%94%A8%E5%A4%A7%E6%A8%A1%E5%9E%8B"><span class="toc-text"> 为什么不用 Qwen 这些通用大模型？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A7%84%E5%88%92%E4%BA%A7%E5%93%81%E7%9A%84-mvp"><span class="toc-text"> 规划产品的 MVP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF-mvp"><span class="toc-text"> 什么是 MVP?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#llm-twin-%E7%9A%84-mvp-%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD"><span class="toc-text"> LLM Twin 的 MVP 的核心功能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mvp-%E7%9A%84%E5%85%B3%E9%94%AE%E6%8C%91%E6%88%98"><span class="toc-text"> MVP 的关键挑战</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9E%84%E5%BB%BA%E5%85%B7%E6%9C%89%E7%89%B9%E5%BE%81%E8%AE%AD%E7%BB%83%E6%8E%A8%E7%90%86%E6%B5%81%E6%B0%B4%E7%BA%BF%E7%9A%84-ml-%E7%B3%BB%E7%BB%9F"><span class="toc-text"> 构建具有特征&#x2F;训练&#x2F;推理流水线的 ML 系统</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ml-%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%9A%84%E6%8C%91%E6%88%98"><span class="toc-text"> ML 系统开发的挑战</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%9E%84%E5%BB%BA%E4%B8%80%E4%B8%AA%E7%BB%9F%E4%B8%80%E7%9A%84-ml-%E7%B3%BB%E7%BB%9F"><span class="toc-text"> 如何构建一个统一的 ML 系统？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BB%A5%E5%BE%80%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text"> 以往解决方案的问题</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84%E5%9C%A8%E5%AE%9E%E6%97%B6%E6%8E%A8%E7%90%86%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-text"> 单体架构在实时推理系统中的问题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E5%BE%81%E8%AE%AD%E7%BB%83%E6%8E%A8%E7%90%86fti-%E6%9E%B6%E6%9E%84"><span class="toc-text"> 特征&#x2F;训练&#x2F;推理（FTI） 架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E5%BE%81%E7%AE%A1%E9%81%93feature-pipeline"><span class="toc-text"> 特征管道（Feature Pipeline）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%AD%E7%BB%83%E7%AE%A1%E9%81%93training-pipeline"><span class="toc-text"> 训练管道（Training Pipeline）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A8%E7%90%86%E7%AE%A1%E9%81%93inference-pipeline"><span class="toc-text"> 推理管道（Inference Pipeline）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1-llm-twin-%E7%9A%84%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84"><span class="toc-text"> 设计 LLM Twin 的系统结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90"><span class="toc-text"> 需求分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%AD%E7%BB%83training%E9%9C%80%E6%B1%82"><span class="toc-text"> 训练（Training）需求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A8%E7%90%86inference%E9%9C%80%E6%B1%82"><span class="toc-text"> 推理（Inference）需求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#llmops-%E9%9C%80%E6%B1%82"><span class="toc-text"> LLMOps 需求</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-fti-%E7%AE%A1%E9%81%93%E8%AE%BE%E8%AE%A1-llm-twin-%E6%9E%B6%E6%9E%84"><span class="toc-text"> 如何使用 FTI 管道设计 LLM Twin 架构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86%E7%AE%A1%E9%81%93data-collection-pipeline"><span class="toc-text"> 数据收集管道（Data Collection Pipeline）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E5%BE%81%E7%AE%A1%E9%81%93feature-pipeline-2"><span class="toc-text"> 特征管道（Feature Pipeline）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%AE%AD%E7%BB%83%E7%AE%A1%E9%81%93training-pipeline-2"><span class="toc-text"> 训练管道（Training Pipeline）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%A8%E7%90%86%E7%AE%A1%E9%81%93inference-pipeline-2"><span class="toc-text"> 推理管道（Inference Pipeline）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#fti-%E8%AE%BE%E8%AE%A1%E4%B8%8E-llm-twin-%E6%9E%B6%E6%9E%84%E7%9A%84%E6%9C%80%E7%BB%88%E6%80%9D%E8%80%83"><span class="toc-text"> FTI 设计与 LLM Twin 架构的最终思考</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BC%95%E7%94%A8"><span class="toc-text"> 引用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C-%E5%B7%A5%E5%85%B7%E9%93%BE%E4%B8%8E%E5%AE%89%E8%A3%85"><span class="toc-text"> 二、工具链与安装</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#python-%E7%94%9F%E6%80%81%E5%B7%A5%E5%85%B7%E9%93%BE%E5%AE%89%E8%A3%85"><span class="toc-text"> Python 生态工具链安装</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mlops-llmops-%E5%B7%A5%E5%85%B7%E6%A6%82%E8%A7%88"><span class="toc-text"> MLOps &amp; LLMOps 工具概览</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#hugging-face%E6%A8%A1%E5%9E%8B%E6%B3%A8%E5%86%8C%E5%BA%93model-registry"><span class="toc-text"> Hugging Face：模型注册库（Model Registry）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#zenmlmlops-%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%BC%96%E6%8E%92%E5%99%A8"><span class="toc-text"> ZenML：MLOps 工作流编排器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#cometml%E5%8F%AF%E8%A7%86%E5%8C%96%E5%AE%9E%E9%AA%8C%E8%B7%9F%E8%B8%AA"><span class="toc-text"> CometML：可视化实验跟踪</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#opik%E8%AF%84%E4%BC%B0-%E6%B5%8B%E8%AF%95%E5%92%8C%E7%9B%91%E6%8E%A7%E5%A4%A7%E5%9E%8B%E8%AF%AD%E8%A8%80%E6%A8%A1%E5%9E%8B"><span class="toc-text"> Opik：评估、测试和监控大型语言模型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9D%9E%E7%BB%93%E6%9E%84%E5%8C%96%E6%95%B0%E6%8D%AE%E5%BA%93%E4%B8%8E%E5%90%91%E9%87%8F%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text"> 非结构化数据库与向量数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#mongodbnosql"><span class="toc-text"> MongoDB：NoSQL</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#qdrant%E5%90%91%E9%87%8F%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text"> Qdrant：向量数据库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%91%E7%AB%AF%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87aws"><span class="toc-text"> 云端环境准备（AWS）</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89-%E6%95%B0%E6%8D%AE%E5%B7%A5%E7%A8%8B"><span class="toc-text"> 三、数据工程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%BE%E8%AE%A1%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86%E7%AE%A1%E9%81%93"><span class="toc-text"> 设计数据收集管道</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%8E%B0-llm-twin-%E7%9A%84%E6%95%B0%E6%8D%AE%E6%94%B6%E9%9B%86%E6%B5%81%E6%B0%B4%E7%BA%BF"><span class="toc-text"> 实现 LLM Twin 的数据收集流水线</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B5%81%E6%B0%B4%E7%BA%BF%E4%B8%8E%E6%AD%A5%E9%AA%A4"><span class="toc-text"> 流水线与步骤</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%AC%E8%99%AB%E5%88%86%E5%8F%91%E5%99%A8-crawlerdispatcher-%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="toc-text"> 爬虫分发器 CrawlerDispatcher 的实现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%88%AC%E8%99%ABcrawlers"><span class="toc-text"> 爬虫（Crawlers）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9F%BA%E7%B1%BB-basecrawler"><span class="toc-text"> 基类 BaseCrawler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%93%E5%B1%95%E7%88%AC%E8%99%AB%E5%9F%BA%E4%BA%8E-selenium-%E7%9A%84%E7%88%AC%E8%99%AB%E5%9F%BA%E7%B1%BB"><span class="toc-text"> 拓展爬虫：基于 Selenium 的爬虫基类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#github-%E7%88%AC%E8%99%AB%E7%B1%BB-githubcrawler"><span class="toc-text"> Github 爬虫类 GithubCrawler</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#customarticlecrawler-%E7%B1%BB"><span class="toc-text"> CustomArticleCrawler 类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#nosql-%E6%95%B0%E6%8D%AE%E4%BB%93%E5%BA%93%E6%96%87%E6%A1%A3"><span class="toc-text"> NoSQL 数据仓库文档</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#odm-%E4%B8%AD%E9%97%B4%E4%BB%B6"><span class="toc-text"> ODM 中间件</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%88%AB%E5%92%8C%E7%94%A8%E6%88%B7%E6%96%87%E6%A1%A3%E7%B1%BB"><span class="toc-text"> 数据类别和用户文档类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%80%BB%E7%BB%93"><span class="toc-text"> 总结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B-%E6%A3%80%E7%B4%A2%E5%A2%9E%E5%BC%BA%E7%94%9F%E6%88%90rag%E7%AE%A1%E9%81%93"><span class="toc-text"> 四、检索增强生成（RAG）管道</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%90%86%E8%A7%A3-rag"><span class="toc-text"> 理解 RAG</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BB%E8%A7%89hallucinations"><span class="toc-text"> 幻觉（Hallucinations）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%BF%87%E6%97%B6%E4%BF%A1%E6%81%AFold-information"><span class="toc-text"> 过时信息（Old Information）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%80%E5%8D%95-rag-%E6%A1%86%E6%9E%B6"><span class="toc-text"> 简单 RAG 框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E8%BE%93%E5%85%A5%E7%AE%A1%E9%81%93ingestion-pipeline"><span class="toc-text"> 数据输入管道（Ingestion pipeline）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E7%B4%A2%E7%AE%A1%E9%81%93retrieval-pipeline"><span class="toc-text"> 检索管道（Retrieval Pipeline）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E6%88%90%E7%AE%A1%E9%81%93generation-pipeline"><span class="toc-text"> 生成管道（Generation Pipeline）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5embeddings"><span class="toc-text"> 嵌入（Embeddings）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E5%B5%8C%E5%85%A5embeddings"><span class="toc-text"> 什么是嵌入（Embeddings）？</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5%E7%9A%84%E5%8F%AF%E8%A7%86%E5%8C%96"><span class="toc-text"> 嵌入的可视化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E5%B5%8C%E5%85%A5embeddings%E5%A6%82%E6%AD%A4%E5%BC%BA%E5%A4%A7"><span class="toc-text"> 为什么嵌入（Embeddings）如此强大</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B5%8C%E5%85%A5%E7%9A%84%E4%BC%98%E5%8A%BF"><span class="toc-text"> 嵌入的优势</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E5%88%9B%E5%BB%BA%E5%B5%8C%E5%85%A5embeddings"><span class="toc-text"> 如何创建嵌入（Embeddings）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%87%E6%9C%AC%E6%95%B0%E6%8D%AE%E4%B8%AD%E7%9A%84%E5%B5%8C%E5%85%A5"><span class="toc-text"> 文本数据中的嵌入</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%90%91%E9%87%8F%E6%95%B0%E6%8D%AE%E5%BA%93"><span class="toc-text"> 向量数据库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E9%87%8F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C"><span class="toc-text"> 向量数据库如何工作？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%91%E9%87%8F%E7%B4%A2%E5%BC%95%E7%9A%84%E7%AE%97%E6%B3%95"><span class="toc-text"> 向量索引的算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E5%BA%93%E6%93%8D%E4%BD%9C"><span class="toc-text"> 数据库操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%AB%98%E7%BA%A7-rag-%E6%A1%86%E6%9E%B6"><span class="toc-text"> 高级 RAG 框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E7%B4%A2%E5%89%8D%E4%BC%98%E5%8C%96"><span class="toc-text"> 检索前优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B4%A2%E5%BC%95"><span class="toc-text"> 数据索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96-query-optimization"><span class="toc-text"> 查询优化 (Query Optimization)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A3%80%E7%B4%A2%E4%BC%98%E5%8C%96"><span class="toc-text"> 检索优化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%94%B9%E8%BF%9B%E5%B5%8C%E5%85%A5%E6%A8%A1%E5%9E%8B"><span class="toc-text"> 改进嵌入模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A9%E7%94%A8%E7%BB%8F%E5%85%B8%E6%95%B0%E6%8D%AE%E5%BA%93%E8%BF%87%E6%BB%A4%E5%92%8C%E6%90%9C%E7%B4%A2%E5%8A%9F%E8%83%BD%E6%8F%90%E9%AB%98%E6%A3%80%E7%B4%A2"><span class="toc-text"> 利用经典数据库过滤和搜索功能提高检索</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9E%E8%B7%B5%E4%B8%AD%E7%9A%84%E6%A3%80%E7%B4%A2%E4%BC%98%E5%8C%96"><span class="toc-text"> 实践中的检索优化</span></a></li></ol></li></ol></li></ol></li></ol></div></div></div></div></main><footer id="footer" style="background: #8EC3B0"><div id="footer-wrap"><div class="copyright">&copy;2021 - 2025 By Guohao</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><div class="js-pjax"><link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css"><script src="https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js"></script><script>(() => {
  document.querySelectorAll('#article-container span.katex-display').forEach(item => {
    btf.wrap(item, 'div', { class: 'katex-wrap'})
  })
})()</script><script>(() => {
  const $mermaidWrap = document.querySelectorAll('#article-container .mermaid-wrap')
  if ($mermaidWrap.length) {
    window.runMermaid = () => {
      window.loadMermaid = true
      const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

      Array.from($mermaidWrap).forEach((item, index) => {
        const mermaidSrc = item.firstElementChild
        const mermaidThemeConfig = '%%{init:{ \'theme\':\'' + theme + '\'}}%%\n'
        const mermaidID = 'mermaid-' + index
        const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent
        mermaid.mermaidAPI.render(mermaidID, mermaidDefinition, (svgCode) => {
          mermaidSrc.insertAdjacentHTML('afterend', svgCode)
        })
      })
    }

    const loadMermaid = () => {
      window.loadMermaid ? runMermaid() : getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaid)
    }

    window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
  }
})()</script><script>function addGitalkSource () {
  const ele = document.createElement('link')
  ele.rel = 'stylesheet'
  ele.href= 'https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.css'
  document.getElementsByTagName('head')[0].appendChild(ele)
}

function loadGitalk () {
  function initGitalk () {
    var gitalk = new Gitalk(Object.assign({
      clientID: 'ea138c6f176d57705144',
      clientSecret: 'c999d74b366c68c80bc3b704c716a8ff8d67af6d',
      repo: 'Dave0126.github.io',
      owner: 'Dave0126',
      admin: ['Dave0126'],
      id: '07a89b9dbc2537b90e6f494d6bb4dcbf',
      updateCountCallback: commentCount
    },))

    gitalk.render('gitalk-container')
  }

  if (typeof Gitalk === 'function') initGitalk()
  else {
    addGitalkSource()
    getScript('https://cdn.jsdelivr.net/npm/gitalk/dist/gitalk.min.js').then(initGitalk)
  }
}

function commentCount(n){
  let isCommentCount = document.querySelector('#post-meta .gitalk-comment-count')
  if (isCommentCount) {
    isCommentCount.innerHTML= n
  }
}

if ('Gitalk' === 'Gitalk' || !true) {
  if (true) btf.loadComment(document.getElementById('gitalk-container'), loadGitalk)
  else loadGitalk()
} else {
  function loadOtherComment () {
    loadGitalk()
  }
}</script></div></div></body></html>